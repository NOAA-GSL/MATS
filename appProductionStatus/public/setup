#!/usr/bin/env bash
RED='\033[0;31m'
GRN='\033[0;32m'
ORNG='\033[0;33m'
NC='\033[0m' # No Color
tmpfile=$(mktemp /tmp/setp.XXXXXX)
tmpSettingsFile=$(mktemp /tmp/settings.XXXXXX)
tmpDockerFile=$(mktemp /tmp/docker.XXXXXX)
tmpAppList=$(mktemp /tmp/applist.XXXXXX)
function finish {
    echo -e ${NC}
    rm -rf $tmpfile
    rm -rf $tmpSettingsFile
    rm -rf tmpDockerFile
    rm -rf $tmpAppList
}
trap finish EXIT

# are we in an install area (where the tar was unbundled)
if [[ ! -d "./web"  ]]; then
    echo -e "${RED}I don't see a ./web directory - I cannot set up anything, try cd'ing to the container deployment directory - exiting ${NC}"
    exit 1
fi

if [[ ! -d "./bin"  ]]; then
    echo -e "${RED}I don't see a ./bin directory - I cannot set up anything, try cd'ing to the container deployment directory - exiting ${NC}"
    exit 1
fi

if [[ ! -d "./settings"  ]]; then
    echo -e "${RED}Creating a ./settings directory${NC}"
    mkdir settings
fi

if [[ ! -d "${HOME}/mongodata"  ]]; then
    echo -e "${RED}Creating a ${HOME}/mongodata directory${NC}"
    mkdir ${HOME}/mongodata
else
    rm -rf ${HOME}/mongodata/*
fi
DEPLOYDIR=$(pwd)

cat <<%END > ./README
This program will help you configure your MATS tool suite environment based on one of the standard environments.
To do this you must have access to the internet.
This program will ask the GSD server which deployment environments are currently
supported for automatic deployment. It will ask you what environment you wish to deploy. The setup will ask the GSD server what versions
of the apps for your selected deployment are currently up to date and then prompt you for database credentials for each
role required by each app.
Database roles are usually some combination of meta_data - the database that contains app metadata,
sums_data - the database that contains an apps statistical partial sum data, model_data - a database that
contains metadata about data sources, and possibly sites_data - which contains non standard domain data.
The credentials that you provide are stored in a ${DEPLOYDIR}/settings directory with the structure ${DEPLOYDIR}/settings/appreference/settings.json.
If you are familiar with this directory and the settings.json files you can make changes with an editor and the setup program
will use the existing values as defaults.
The program also configures this deployment directory, creating a ${DEPLOYDIR}/docker-compose.yml configuration file,
and a ${DEPLOYDIR}/traefik.toml file, a suitable ${DEPLOYDIR}/web/index.html as a homepage,  and suitable up and down scripts in the
${DEPLOYDIR}/bin directory.
You must have docker, docker-compose and jq installed, and you must be running this script from ${DEPLOYDIR}.
You must be running this program as a user that can run docker - do not run this script as root, in fact do not run any containers as root.
After once configuring an app you will have to confirm overwriting the old configuration if you run setup again.

The reverse proxy has a user/password pre-set to user "admin" and password "adminpassword", you should change this by following the instructions in the traefik.toml file.
This program will create a settings directory here in this directory and a mongodata directory in the $HOME of this user if they do not already exist.

You need to acquire an SSL cert for your domain and put the certificate in /etc/ssl/certs directory of this host. If you have authority over the DNS entry for
your server you can use LetsEncrypt for no cost certs. The instructions for doing this are at https://docs.traefik.io/configuration/acme/.
If you cannot acquire a certificate you can enable the apps temporarily by commenting out
#        [[entryPoints.https.tls.certificates]]
#        certFile = "/etc/ssl/certs/mats-meteor.crt"
#        keyFile = "/etc/ssl/certs/mats-meteor.key"
in the traefik.toml file.

The toolsuite entrypoints are 
https://yourfullyqualifieddomaini/proxy for the reverse proxy dashboard (look at comments in traefik.toml and docker-compose.yml to enable)
https://yourfullyqualifieddomain  for the top level landing page
https://yourfullyqualifieddomain/appref   for an individual app (replace appref with the actual app reference.)

After configuration you can start your toolsuite with.... 
${PWD}/bin/up
and you can stop your toolsuite with..
${PWD}/bin/down

you can rerun this setup with...
cd ${DEPLOYDIR}
bash bin/setup

You may want to occasionally rerun the setup to pick up bug fixes and newly released apps for your deployment. This URL
https://www.esrl.noaa.gov/gsd/mats/appProductionStatus/versions shows the latest versions of the apps available for all the deployments.
By comparing those versions to the versions in your running apps you can determine if an update is necessary. You
can tell the version of a running app by looking at the comments in the docker-compose.yml file. This file is recreated when
you run the setup, with the current version for each app.

%END

cat ./README

# test for jq
jq --version
if [[ ! $? -eq 0  ]]; then
    echo -e ${RED} You do not have jq installed. Exiting ${NC}
    exit 1
fi 
#test for docker
docker --version
if [[ ! $? -eq 0  ]]; then
    echo -e ${RED} You do not have docker installed. Exiting ${NC}
    exit 1
fi 
#test for docker-compose
docker-compose --version
if [[ ! $? -eq 0  ]]; then
    echo -e ${RED} You do not have docker-compose installed. Exiting ${NC}
    exit 1
fi 
echo -e ${NC}

serverUrl="https://www.esrl.noaa.gov/gsd/mats/appProductionStatus"
#get deployment environments - only happens one time
depenvs=$(curl ${serverUrl}/getDeploymentEnvironments 2>/dev/null | jq -r '.[]')
#get applist
echo -e "${ORNG}You must choose an environment to deploy (number [ENTER]) ${NC}"
select depenv in ${depenvs}; do
    echo -e "${GRN}You picked $depenv ($REPLY) deploying for $depenv${NC}"
    break
done
# record a repository name...
# everything that isn't development or integration is production
repository="matsapps/production"
prodRepository="matsapps/production"
if [[ ${depenv} == "integration" ]]; then
    repository="matsapps/integration"
else if [[ ${depenv} == "development" ]]; then
        repository="matsapps/development"
    fi
fi

#record the environment
echo "{\"environment\":\"${depenv}\"}" > web/environment.json

# get the applist just to check if the environment is valid
curl ${serverUrl}/getStableDeploymentAppList/${depenv} 2>/dev/null > $tmpAppList
checkapps=($(cat ${tmpAppList} | jq -r '.[].app'))
if [[ ${#checkapps[@]} < 1 ]]; then
    echo -e "${RED}There are no apps to configure. exiting.${NC}"
        exit 1
else 
    #get the stable deployment and save it to tmpfile
    curl ${serverUrl}/getStableDeployment/${depenv} 2>/dev/null > $tmpfile
    # load the apps from the stable deployment -
    # order is preserved in the array from the tempfile
    apps=($(cat $tmpfile | jq -r '.apps[] | .app'))
    versions=($(cat $tmpfile | jq -r '.apps[] | .version'))
    #set the correct index.html
    homepage=$(jq -r '.homePage' < ${tmpfile})
    echo -e ${ORNG} setting the homepage for $depenv ${NC}
    cp web/${homepage} web/index.html

    echo -e ${ORNG}
    domain=$(hostname)
    read -p "Is '${domain}' the fully qualified hostname for this deployment? y|n" -n 1 -r
    echo -e ${NC}
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${GRN}setting up for ${domain}${NC}"
    else 
        echo -e ${RED}
        read -p "Enter the fully qualified hostname:" domain
        echo -e ${NC}
        echo -e "${GRN}setting up for ${domain}${NC}"
    fi
    htpasswd=$(which htpasswd)
    if [[ $? == 0 ]]; then
        adminPhrase=$($htpasswd -nbB admin adminpassword)
    fi
    unqualifiedHostName=$(echo ${domain} | cut -f1 -d'.')
    #create the traefik.toml file....
cat <<- %ENDTRAEFIK > ./traefik.toml
#To enable the proxy api and dashboard uncomment the '[api]' and '  entrypoint="dashboard"' lines below.
#To set the passwd for the proxy dashboard use
#sudo apt-get install apache2-utils
#htpasswd -nbB admin your_special_password
#replace "admin:$apr1$GZ23gG9v$8slcUumLt29SsZ9MiL.z30" in the "users =" line of the [entryPoints.dashboard.auth.basic]
#entrypoint below. The traefik user challenge will then work for the user admin and your_special_password
defaultEntryPoints = ["http", "https"]
[entryPoints]
  [entryPoints.dashboard]
    address = ":8090"
    [entryPoints.dashboard.auth]
      [entryPoints.dashboard.auth.basic]
        users = ["${adminPhrase}"]
  [entryPoints.http]
    address = ":80"
      [entryPoints.http.redirect]
        entryPoint = "https"
  [entryPoints.https]
    address = ":443"
      [entryPoints.https.tls]
        [[entryPoints.https.tls.certificates]]
        certFile = "/etc/ssl/certs/${unqualifiedHostName}.crt"
        keyFile = "/etc/ssl/certs/${unqualifiedHostName}.key"

# uncomment the following to enable the proxy and the api
[api]
  entrypoint="dashboard"
[docker]
domain = "${domain}"
watch = true
network = "web"
%ENDTRAEFIK

    echo -e ${GRN}configuring applist...  ${apps[@]}${NC}
    # save the stable applist into the web/applist.json
    cp $tmpAppList web/applist.json

    for (( i=0; i<${#apps[@]}; i++ )); do 
        appref=${apps[$i]}
        if [[ ! -d "./settings/${appref}"  ]]; then
            echo -e "${RED}Creating a ./settings/${appref} directory${NC}"
            mkdir settings/${appref}
        fi
        if [[ -f  "./settings/${appref}/settings.json" ]]; then
            read -p "Do you want to keep the existing settings for ${appref}? y|n" -n 1 -r
            echo -e ${NC}
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo -e "${GRN}skipping setting up for ${appref}${NC}"
                continue
            fi
        fi
        dbroles=($(cat $tmpfile | jq -r --arg appref "$appref" '.apps[] | select(.app==$appref) | .dbroles[],""' 2> /dev/null))
        # set the settings files

        lim=$(( ${#dbroles[@]} - 1 ))
        echo -e ${GRN} creating settings file ./settings/${appref}/settings.json with database role ${dbroles[@]}
        echo '{"private":{"databases": [ ' > $tmpSettingsFile
        # need a databse entry for each database role
        for (( ri=0; ri<${#dbroles[@]}; ri++ )); do
            role=${dbroles[$ri]}
            if [[ -f "settings/${appref}/settings.json"  ]]; then
                echo -e ${ORNG}loading existing settings${NC}
                xdhost=$(jq -r --arg r "${role}" '.private.databases[] | select(.role==$r).host' < settings/${appref}/settings.json)
                if [[ "X${xdhost}"  != "X" ]]; then
                    dhost=${xdhost}
                fi
                xdport=$(jq -r --arg r "${role}" '.private.databases[] | select(.role==$r).port' < settings/${appref}/settings.json)
                if [[ "X${xdport}"  != "X" ]]; then
                    dport=${xdport}
                fi
                xduserName=$(jq -r --arg r "${role}" '.private.databases[] | select(.role==$r).user' < settings/${appref}/settings.json)
                if [[ "X${xduserName}"  != "X" ]]; then
                    duserName=${xduserName}
                fi
                xdpassword=$(jq -r --arg r "${role}" '.private.databases[] | select(.role==$r).password' < settings/${appref}/settings.json)
                if [[ "X${xdpassword}"  != "X" ]]; then
                    dpassword=${xdpassword}
                fi
                xddatabase=$(jq -r --arg r "${role}" '.private.databases[] | select(.role==$r).database' < settings/${appref}/settings.json)
                if [[ "X${xddatabase}"  != "X" ]]; then
                    ddatabase=${xddatabase}
                fi
            fi
            good=n
            reset="set"
            while [[ "$good" = "n" ]]; do
                echo -e ${ORNG} Have to ${reset} database server url and database user credentials for ${appref} role ${dbroles[$ri]}
                read -p "What is the host of the database server for ${appref} with role ${role} [$dhost]" host
                host=${host:-$dhost}
                dhost=$host
                read -p "What is the port of the database  server for ${appref} with role ${role} [$dport]" port
                port=${port:-$dport}
                dport=$port
                read -p "What is the database for ${appref} with role ${role} [$ddatabase]" database
                database=${database:-$ddatabase}
                ddatabase=$database
                read -p "What is the username for database ${database} for ${appref} with role ${role} [$duserName]" userName
                userName=${userName:-$duserName}
                duserName=$userName
                cgood="n"
                resetpassword=""
                if [[ "X${dpassword}" != "X" ]]; then
                    read -sp "Keep the existing password for ${database} and ${userName} for ${appref} with role ${role} y|n?" -n 1 -r
                    echo
                 else
                    REPLY="n" # there isn't any password - have to ask for it
                fi
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    password=${dpassword}
                else
                    while [[ "$cgood" = "n" ]]; do
                        echo -e ${ORNG} ${resetpassword}
                        read -sp "What is the password for ${database} and ${userName} for ${appref} and role ${role}" password
                        echo
                        read -sp "Confirm the password for ${database}" cpassword
                        echo -e ${NC}
                        if [[ "$password" = "$cpassword" ]]; then
                            cgood="y"
                        else
                            echo -e "${RED}passwords do not match!!!"${NC}
                            resetpassword="RE-ENTER"
                        fi
                    done
                fi
                echo -e "${GRN}Setting ${appref} database credentials for ${host}:${port} ${database} with user: ${userName}${NC}"
                echo -e ${ORNG}
                read -p "Good with that? y|n?" -n 1 -r
                echo -e ${NC}
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    good="y"
                else
                    echo -e ${RED} redoing ${appref} then... ${NC}
                    reset=RESET
                fi
            done

            # build the list of database entries

            database=${database:-$ddatabase}
            ddatabase=$database
            cat <<- %ENDPOOLS >> $tmpSettingsFile
               {
              "role": "${role}",
              "status": "active",
              "host": "${host}",
              "port": "${port}",
              "user": "${userName}",
              "password": "${password}",
              "database": "${database}",
              "connectionLimit": 10
              } 
%ENDPOOLS
            # add a comma if more than one and not on the last one
            if [[ $ri -lt ${lim} ]] && [[ ${#dbroles[@]} -gt 1 ]]; then
                echo "," >> $tmpSettingsFile
            fi
        done
        #finish up the document
        echo "], \"PYTHON_PATH\":\"/usr/bin/python3\" }, \"public\":{} }" >> $tmpSettingsFile
#        echo ---------
#        cat $tmpSettingsFile
#        echo ---------
         jq '.' < $tmpSettingsFile > ./settings/${appref}/settings.json
#        echo ---------

    done
        #set up the dockerfile
        echo -e ${ORNG} Setting up a dockercompose file for your apps ${NC}

        #NOTE: Spacing is important for compose files!!!! They are yaml!!!!
        cat << %COMPOSEEND > $tmpDockerFile
version: "3.2"

networks:
 web:
  external: true
 backend:
  external: false

services:

 traefik:
  image: ${prodRepository}:mats-traefik
  networks:
   - web
  ports:
   - "80:80"
   - "443:443"
  volumes:
   - /var/run/docker.sock:/var/run/docker.sock
   - ${DEPLOYDIR}/traefik.toml:/traefik.toml
   - /etc/ssl/certs:/etc/ssl/certs
  labels:
   - traefik.frontend.rule=Host:${domain};PathPrefixStrip:/proxy;PathPrefix:/proxy
   - traefik.port=8090

 mats-http:
  image: ${prodRepository}:mats-http
  volumes:
   - ${DEPLOYDIR}/web:/web
  labels:
   - traefik.backend=mats-http/index.html
   - traefik.frontend.rule=Host:${domain}
   - traefik.docker.network=web
   - traefik.port=8080
  networks:
   - web

 mongo:
  image: ${prodRepository}:mats-mongo
  ports:
   - "27017:27017"
  volumes:
   - ${HOME}/mongodata:/data/db
  networks:
   - backend
%COMPOSEEND

    for (( i=0; i<${#apps[@]}; i++ )); do
        appref=${apps[$i]}
        appversion=${versions[$i]}
        apptag="${appref}-${appversion}"
        if [[ ${depenv} == "development" ]]; then
            apptag="${appref}-nightly"
        fi

        cat <<- %COMPOSEAPPEND >> $tmpDockerFile

 ${appref}:
  # app ${appref} version is ${appversion}
  image: ${repository}:${apptag}
  environment:
   - DELAY=6
   - ROOT_URL=https://${domain}/${appref}
  volumes:
   - ${DEPLOYDIR}/settings:/usr/app/settings
  depends_on:
   - mongo
  labels:
   - traefik.backend=${appref}
   - traefik.frontend.rule=Host:${domain};PathPrefix:/${appref}
   - traefik.docker.network=web
   - traefik.port=80
  networks:
   - web
   - backend

%COMPOSEAPPEND
    done
    mv $tmpDockerFile docker-compose.yml
fi

exit 0
