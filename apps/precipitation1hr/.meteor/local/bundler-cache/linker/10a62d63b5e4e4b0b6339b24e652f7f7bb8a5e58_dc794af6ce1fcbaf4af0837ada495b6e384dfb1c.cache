[{"type":"js","data":"/* Imports for global scope */\n\nMongoInternals = Package.mongo.MongoInternals;\nMongo = Package.mongo.Mongo;\nReactiveVar = Package['reactive-var'].ReactiveVar;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nECMAScript = Package.ecmascript.ECMAScript;\nmysql = Package['pcel:mysql'].mysql;\nmoment = Package['momentjs:moment'].moment;\nmatsCollections = Package['randyp:mats-common'].matsCollections;\nmatsTypes = Package['randyp:mats-common'].matsTypes;\nmatsMethods = Package['randyp:mats-common'].matsMethods;\nmatsParamUtils = Package['randyp:mats-common'].matsParamUtils;\nmatsMathUtils = Package['randyp:mats-common'].matsMathUtils;\nmatsPlotUtils = Package['randyp:mats-common'].matsPlotUtils;\nmatsPlotSpecUtils = Package['randyp:mats-common'].matsPlotSpecUtils;\nmatsDataUtils = Package['randyp:mats-common'].matsDataUtils;\nmatsDataQueryUtils = Package['randyp:mats-common'].matsDataQueryUtils;\nmatsDataDiffUtils = Package['randyp:mats-common'].matsDataDiffUtils;\nmatsDataMatchUtils = Package['randyp:mats-common'].matsDataMatchUtils;\nmatsDataCurveOpsUtils = Package['randyp:mats-common'].matsDataCurveOpsUtils;\nmatsDataPlotOpsUtils = Package['randyp:mats-common'].matsDataPlotOpsUtils;\nmatsDataProcessUtils = Package['randyp:mats-common'].matsDataProcessUtils;\nregression = Package['randyp:mats-common'].regression;\nmatsCache = Package['randyp:mats-common'].matsCache;\nAccounts = Package['accounts-base'].Accounts;\n_ = Package.underscore._;\nBlazeLayout = Package['kadira:blaze-layout'].BlazeLayout;\nPicker = Package['meteorhacks:picker'].Picker;\nMeteor = Package.meteor.Meteor;\nglobal = Package.meteor.global;\nmeteorEnv = Package.meteor.meteorEnv;\nWebApp = Package.webapp.WebApp;\nWebAppInternals = Package.webapp.WebAppInternals;\nmain = Package.webapp.main;\nDDP = Package['ddp-client'].DDP;\nDDPServer = Package['ddp-server'].DDPServer;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nBlaze = Package.ui.Blaze;\nUI = Package.ui.UI;\nHandlebars = Package.ui.Handlebars;\nSpacebars = Package.spacebars.Spacebars;\nmeteorInstall = Package.modules.meteorInstall;\nmeteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nPromise = Package.promise.Promise;\nSimpleSchema = Package['aldeed:simple-schema'].SimpleSchema;\nMongoObject = Package['aldeed:simple-schema'].MongoObject;\nGoogle = Package['google-oauth'].Google;\nAutoupdate = Package.autoupdate.Autoupdate;\nHTML = Package.htmljs.HTML;\n\n","servePath":"/global-imports.js"},{"type":"js","data":"var require = meteorInstall({\"server\":{\"dataFunctions\":{\"data_contour.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_contour.js                                                                               //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 4);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 5);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 6);\n\ndataContour = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const plotType = matsTypes.PlotTypes.contour;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n\n  if (curves.length > 1) {\n    throw new Error(\"INFO:  There must only be one added curve.\");\n  }\n\n  var dataset = [];\n  var axisMap = Object.create(null); // initialize variables specific to the curve\n\n  var curve = curves[0];\n  var label = curve['label'];\n  var xAxisParam = curve['x-axis-parameter'];\n  var yAxisParam = curve['y-axis-parameter'];\n  var xValClause = matsCollections.CurveParams.findOne({\n    name: 'x-axis-parameter'\n  }).optionsMap[xAxisParam];\n  var yValClause = matsCollections.CurveParams.findOne({\n    name: 'y-axis-parameter'\n  }).optionsMap[yAxisParam];\n  var dataSourceStr = curve['data-source'];\n  var data_source = matsCollections.CurveParams.findOne({\n    name: 'data-source'\n  }).optionsMap[curve['data-source']][0];\n  var regionStr = curve['region'];\n  var region = Object.keys(matsCollections.CurveParams.findOne({\n    name: 'region'\n  }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n    name: 'region'\n  }).valuesMap[key] === regionStr);\n  var source = curve['truth'];\n  var sourceStr = \"\";\n\n  if (source !== \"All\") {\n    sourceStr = \"_\" + source;\n  }\n\n  var scaleStr = curve['scale'];\n  var scale = Object.keys(matsCollections.CurveParams.findOne({\n    name: 'scale'\n  }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n    name: 'scale'\n  }).valuesMap[key] === scaleStr);\n  var statisticSelect = curve['statistic'];\n  var statisticOptionsMap = matsCollections.CurveParams.findOne({\n    name: 'statistic'\n  }, {\n    optionsMap: 1\n  })['optionsMap'];\n  var statistic = statisticOptionsMap[statisticSelect][0];\n  var validTimeClause = \"\";\n  var thresholdClause = \"\";\n  var forecastLengthClause = \"\";\n  var dateClause = \"\";\n\n  if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n    var forecastLength = curve['forecast-length'];\n    forecastLengthClause = \"and m0.fcst_len = \" + forecastLength + \" \";\n  }\n\n  if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    threshold = threshold * 0.01;\n    thresholdClause = \"and m0.trsh = \" + threshold + \" \";\n  }\n\n  if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n\n    if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n      validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n    }\n  }\n\n  if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date') {\n    dateClause = \"m0.time-m0.fcst_len*3600\";\n  } else {\n    dateClause = \"m0.time\";\n  } // For contours, this functions as the colorbar label.\n\n\n  curve['unitKey'] = statisticOptionsMap[statisticSelect][1];\n  var d; // this is a database driven curve, not a difference curve\n  // prepare the query from the above parameters\n\n  var statement = \"{{xValClause}} \" + \"{{yValClause}} \" + \"count(distinct {{dateClause}}) as N_times, \" + \"min({{dateClause}}) as min_secs, \" + \"max({{dateClause}}) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and {{dateClause}} >= '{{fromSecs}}' \" + \"and {{dateClause}} <= '{{toSecs}}' \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"{{thresholdClause}} \" + \"{{validTimeClause}} \" + \"{{forecastLengthClause}} \" + \"group by xVal,yVal \" + \"order by xVal,yVal\" + \";\";\n  statement = statement.replace('{{xValClause}}', xValClause);\n  statement = statement.replace('{{yValClause}}', yValClause);\n  statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n  statement = statement.replace('{{statistic}}', statistic);\n  statement = statement.replace('{{threshold}}', threshold);\n  statement = statement.replace('{{fromSecs}}', fromSecs);\n  statement = statement.replace('{{toSecs}}', toSecs);\n  statement = statement.replace('{{thresholdClause}}', thresholdClause);\n  statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n  statement = statement.replace('{{validTimeClause}}', validTimeClause);\n  statement = statement.split('{{dateClause}}').join(dateClause);\n  dataRequests[curve.label] = statement; // math is done on forecastLength later on -- set all analyses to 0\n\n  if (forecastLength === \"-99\") {\n    forecastLength = \"0\";\n  }\n\n  var queryResult;\n  var startMoment = moment();\n  var finishMoment;\n\n  try {\n    // send the query statement to the query function\n    queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n    finishMoment = moment();\n    dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n      begin: startMoment.format(),\n      finish: finishMoment.format(),\n      duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n      recordCount: queryResult.data.xTextOutput.length\n    }; // get the data back from the query\n\n    d = queryResult.data;\n  } catch (e) {\n    // this is an error produced by a bug in the query function, not an error returned by the mysql database\n    e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n    throw new Error(e.message);\n  }\n\n  if (queryResult.error !== undefined && queryResult.error !== \"\") {\n    if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n      // this is NOT an error just a no data condition\n      dataFoundForCurve = false;\n    } else {\n      // this is an error returned by the mysql database\n      error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n      throw new Error(error);\n    }\n  }\n\n  var postQueryStartMoment = moment(); // set curve annotation to be the curve mean -- may be recalculated later\n  // also pass previously calculated axis stats to curve options\n\n  const mean = d.glob_stats.mean;\n  const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n  curve['annotation'] = annotation;\n  curve['xmin'] = d.xmin;\n  curve['xmax'] = d.xmax;\n  curve['ymin'] = d.ymin;\n  curve['ymax'] = d.ymax;\n  curve['zmin'] = d.zmin;\n  curve['zmax'] = d.zmax;\n  curve['xAxisKey'] = xAxisParam;\n  curve['yAxisKey'] = yAxisParam;\n  const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n  dataset.push(cOptions);\n  var postQueryFinishMoment = moment();\n  dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n    begin: postQueryStartMoment.format(),\n    finish: postQueryFinishMoment.format(),\n    duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n  }; // process the data returned by the query\n\n  const curveInfoParams = {\n    \"curve\": curves,\n    \"axisMap\": axisMap\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_contour_diff.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_contour_diff.js                                                                          //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataContourDiff = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.contourDiff;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n\n  if (curvesLength !== 2) {\n    throw new Error(\"INFO:  There must be two added curves.\");\n  }\n\n  if (curves[0]['x-axis-parameter'] !== curves[1]['x-axis-parameter'] || curves[0]['y-axis-parameter'] !== curves[1]['y-axis-parameter']) {\n    throw new Error(\"INFO:  The x-axis-parameter and y-axis-parameter must be consistent across both curves.\");\n  }\n\n  var dataset = [];\n  var axisMap = Object.create(null);\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var label = curve['label'];\n    var xAxisParam = curve['x-axis-parameter'];\n    var yAxisParam = curve['y-axis-parameter'];\n    var xValClause = matsCollections.CurveParams.findOne({\n      name: 'x-axis-parameter'\n    }).optionsMap[xAxisParam];\n    var yValClause = matsCollections.CurveParams.findOne({\n      name: 'y-axis-parameter'\n    }).optionsMap[yAxisParam];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimeClause = \"\";\n    var thresholdClause = \"\";\n    var forecastLengthClause = \"\";\n    var dateClause = \"\";\n\n    if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n      var forecastLength = curve['forecast-length'];\n      forecastLengthClause = \"and m0.fcst_len = \" + forecastLength;\n    }\n\n    if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n      var thresholdStr = curve['threshold'];\n      var threshold = Object.keys(matsCollections.CurveParams.findOne({\n        name: 'threshold'\n      }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n        name: 'threshold'\n      }).valuesMap[key] === thresholdStr);\n      threshold = threshold * 0.01;\n      thresholdClause = \"and m0.trsh = \" + threshold;\n    }\n\n    if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n      var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n      }\n    }\n\n    if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date') {\n      dateClause = \"m0.time-m0.fcst_len*3600\";\n    } else {\n      dateClause = \"m0.time\";\n    } // for two contours it's faster to just take care of matching in the query\n\n\n    var matchModel = \"\";\n    var matchDates = \"\";\n    var matchThresholdClause = \"\";\n    var matchValidTimeClause = \"\";\n    var matchForecastLengthClause = \"\";\n    var matchClause = \"\";\n\n    if (matching) {\n      const otherCurveIndex = curveIndex === 0 ? 1 : 0;\n      const otherModel = matsCollections.CurveParams.findOne({\n        name: 'data-source'\n      }).optionsMap[curves[otherCurveIndex]['data-source']][0];\n      const otherRegion = Object.keys(matsCollections.CurveParams.findOne({\n        name: 'region'\n      }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n        name: 'region'\n      }).valuesMap[key] === curves[otherCurveIndex]['region']);\n      matchModel = \", \" + otherModel + \"_\" + otherRegion + \" as a0\";\n      const matchDateClause = dateClause.split('m0').join('a0');\n      matchDates = \"and \" + matchDateClause + \" >= '\" + fromSecs + \"' and \" + matchDateClause + \" <= '\" + toSecs + \"'\";\n      matchClause = \"and m0.time = a0.time\";\n\n      if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n        var matchForecastLength = curves[otherCurveIndex]['forecast-length'];\n        matchForecastLengthClause = \"and a0.fcst_len = \" + matchForecastLength;\n      } else {\n        matchForecastLengthClause = \"and m0.fcst_len = a0.fcst_len\";\n      }\n\n      if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n        var matchThreshold = Object.keys(matsCollections.CurveParams.findOne({\n          name: 'threshold'\n        }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n          name: 'threshold'\n        }).valuesMap[key] === curves[otherCurveIndex]['threshold']);\n        matchThresholdClause = \"and a0.thresh = \" + matchThreshold;\n      } else {\n        matchThresholdClause = \"and m0.thresh = a0.thresh\";\n      }\n\n      if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n        var matchValidTimes = curves[otherCurveIndex]['valid-time'] === undefined ? [] : curves[otherCurveIndex]['valid-time'];\n\n        if (matchValidTimes.length > 0 && matchValidTimes !== matsTypes.InputTypes.unused) {\n          matchValidTimeClause = \" and a0.time%(24*3600)/3600 IN(\" + matchValidTimes + \")\";\n        }\n      }\n    } // For contours, this functions as the colorbar label.\n\n\n    curves[curveIndex]['unitKey'] = statisticOptionsMap[statisticSelect][1];\n    var d; // this is a database driven curve, not a difference curve\n    // prepare the query from the above parameters\n\n    var statement = \"{{xValClause}} \" + \"{{yValClause}} \" + \"count(distinct {{dateClause}}) as N_times, \" + \"min({{dateClause}}) as min_secs, \" + \"max({{dateClause}}) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0{{matchModel}} \" + \"where 1=1 \" + \"{{matchClause}} \" + \"and {{dateClause}} >= '{{fromSecs}}' \" + \"and {{dateClause}} <= '{{toSecs}}' \" + \"{{matchDates}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"{{thresholdClause}} \" + \"{{matchThresholdClause}} \" + \"{{validTimeClause}} \" + \"{{matchValidTimeClause}} \" + \"{{forecastLengthClause}} \" + \"{{matchForecastLengthClause}} \" + \"group by xVal,yVal \" + \"order by xVal,yVal\" + \";\";\n    statement = statement.replace('{{xValClause}}', xValClause);\n    statement = statement.replace('{{yValClause}}', yValClause);\n    statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n    statement = statement.replace('{{matchModel}}', matchModel);\n    statement = statement.replace('{{statistic}}', statistic);\n    statement = statement.replace('{{threshold}}', threshold);\n    statement = statement.replace('{{fromSecs}}', fromSecs);\n    statement = statement.replace('{{toSecs}}', toSecs);\n    statement = statement.replace('{{matchDates}}', matchDates);\n    statement = statement.replace('{{matchClause}}', matchClause);\n    statement = statement.replace('{{thresholdClause}}', thresholdClause);\n    statement = statement.replace('{{matchThresholdClause}}', matchThresholdClause);\n    statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n    statement = statement.replace('{{matchForecastLengthClause}}', matchForecastLengthClause);\n    statement = statement.replace('{{validTimeClause}}', validTimeClause);\n    statement = statement.replace('{{matchValidTimeClause}}', matchValidTimeClause);\n    statement = statement.split('{{dateClause}}').join(dateClause);\n    dataRequests[curve.label] = statement; // math is done on forecastLength later on -- set all analyses to 0\n\n    if (forecastLength === \"-99\") {\n      forecastLength = \"0\";\n    }\n\n    var queryResult;\n    var startMoment = moment();\n    var finishMoment;\n\n    try {\n      // send the query statement to the query function\n      queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n      finishMoment = moment();\n      dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n        begin: startMoment.format(),\n        finish: finishMoment.format(),\n        duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n        recordCount: queryResult.data.xTextOutput.length\n      }; // get the data back from the query\n\n      d = queryResult.data;\n    } catch (e) {\n      // this is an error produced by a bug in the query function, not an error returned by the mysql database\n      e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n      throw new Error(e.message);\n    }\n\n    if (queryResult.error !== undefined && queryResult.error !== \"\") {\n      if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n        // this is NOT an error just a no data condition\n        dataFoundForCurve = false;\n      } else {\n        // this is an error returned by the mysql database\n        error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n        throw new Error(error);\n      }\n    }\n\n    var postQueryStartMoment = moment(); // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n    const mean = d.glob_stats.mean;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['zmin'] = d.zmin;\n    curve['zmax'] = d.zmax;\n    curve['xAxisKey'] = xAxisParam;\n    curve['yAxisKey'] = yAxisParam;\n    const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // turn the two contours into one difference contour\n\n\n  dataset = matsDataDiffUtils.getDataForDiffContour(dataset);\n  plotParams.curves = matsDataUtils.getDiffContourCurveParams(plotParams.curves);\n  curves = plotParams.curves; // process the data returned by the query\n\n  const curveInfoParams = {\n    \"curve\": curves,\n    \"axisMap\": axisMap\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_dailymodelcycle.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_dailymodelcycle.js                                                                       //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataDailyModelCycle = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.dailyModelCycle;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    threshold = threshold * 0.01;\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var utcCycleStart = Number(curve['utc-cycle-start']);\n    utcCycleStarts[curveIndex] = utcCycleStart; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select m0.time as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.time >= {{fromSecs}} \" + \"and m0.time <= {{toSecs}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = {{threshold}} \" + \"and m0.fcst_len < 24 \" + \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN({{utcCycleStart}}) \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{utcCycleStart}}', utcCycleStart);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_dieoff.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_dieoff.js                                                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataDieOff = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.dieoff;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    threshold = threshold * 0.01;\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var forecastLengthStr = curve['dieoff-type'];\n    var forecastLengthOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'dieoff-type'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var forecastLength = forecastLengthOptionsMap[forecastLengthStr][0];\n    var validTimes;\n    var validTimeClause = \"\";\n    var utcCycleStart;\n    var utcCycleStartClause = \"\";\n    var dateRangeClause = \"and m0.time >= \" + fromSecs + \" and m0.time <= \" + toSecs;\n\n    if (forecastLength === matsTypes.ForecastTypes.dieoff) {\n      validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n\n      if (validTimes.length !== 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \"and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n    } else if (forecastLength === matsTypes.ForecastTypes.utcCycle) {\n      utcCycleStart = Number(curve['utc-cycle-start']);\n      utcCycleStartClause = \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN(\" + utcCycleStart + \")\";\n    } else {\n      dateRangeClause = \"and (m0.time - m0.fcst_len*3600) = \" + fromSecs;\n    } // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"SELECT m0.fcst_len AS avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"{{dateRangeClause}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = {{threshold}} \" + \"{{validTimeClause}} \" + \"{{utcCycleStartClause}} \" + \"group by avtime \" + \"order by avtime;\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{dateRangeClause}}', dateRangeClause);\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      statement = statement.replace('{{utcCycleStartClause}}', utcCycleStartClause);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_histogram.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_histogram.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 4);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 5);\n\ndataHistogram = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const plotType = matsTypes.PlotTypes.histogram;\n  const hasLevels = false;\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  var alreadyMatched = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = [];\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var allReturnedSubStats = [];\n  var allReturnedSubSecs = [];\n  var axisMap = Object.create(null); // process user bin customizations\n\n  const binParams = matsDataUtils.setHistogramParameters(plotParams);\n  const yAxisFormat = binParams.yAxisFormat;\n  const binNum = binParams.binNum;\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    dataFoundForCurve[curveIndex] = true;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    threshold = threshold * 0.01;\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = yAxisFormat;\n\n    if (yAxisFormat === 'Relative frequency') {\n      axisKey = axisKey + \" (x100)\";\n    }\n\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    curves[curveIndex].binNum = binNum; // stash the binNum to use it later for bar chart options\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select m0.time as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"{{validTimeClause}} \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = '{{threshold}}' \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      var validTimeClause = \" \";\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n        allReturnedSubStats.push(d.subVals); // save returned data so that we can calculate histogram stats once all the queries are done\n\n        allReturnedSubSecs.push(d.subSecs);\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve[curveIndex] = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      }\n    }\n  }\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"dataFoundForCurve\": dataFoundForCurve,\n    \"axisMap\": axisMap,\n    \"yAxisFormat\": yAxisFormat\n  };\n  const bookkeepingParams = {\n    \"alreadyMatched\": alreadyMatched,\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataHistogram(allReturnedSubStats, allReturnedSubSecs, [], dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_series.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_series.js                                                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataSeries = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.timeSeries;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    threshold = threshold * 0.01;\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n    var averageStr = curve['average'];\n    var averageOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'average'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var average = averageOptionsMap[averageStr][0];\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select {{average}} as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"{{validTimeClause}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = '{{threshold}}' \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{average}}', average);\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      var validTimeClause = \" \";\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      dataRequests[curve.label] = statement; // math is done on forecastLength later on -- set all analyses to 0\n\n      if (forecastLength === \"-99\") {\n        forecastLength = \"0\";\n      }\n\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBTimeSeries(sumPool, statement, data_source, forecastLength, fromSecs, toSecs, averageStr, validTimes, hasLevels, false);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_threshold.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_threshold.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataThreshold = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.threshold;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"SELECT m0.trsh as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"{{validTimeClause}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      var validTimeClause = \" \";\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_validtime.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_validtime.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataValidTime = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.validtime;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    threshold = threshold * 0.01;\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select floor(m0.time%(24*3600)/3600) as hr_of_day, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = '{{threshold}}' \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by hr_of_day \" + \"order by hr_of_day\" + \";\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"main.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/main.js                                                                                                     //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet mysql;\nmodule.link(\"meteor/pcel:mysql\", {\n  mysql(v) {\n    mysql = v;\n  }\n\n}, 1);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 2);\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 3);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 4);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 5);\nlet matsParamUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsParamUtils(v) {\n    matsParamUtils = v;\n  }\n\n}, 6);\n// determined in doCurveParanms\nvar minDate;\nvar maxDate;\nvar dstr;\n\nconst doPlotParams = function () {\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.PlotParams.remove({});\n  }\n\n  if (matsCollections.PlotParams.find().count() == 0) {\n    matsCollections.PlotParams.insert({\n      name: 'dates',\n      type: matsTypes.InputTypes.dateRange,\n      options: [''],\n      startDate: minDate,\n      stopDate: maxDate,\n      superiorNames: ['data-source'],\n      controlButtonCovered: true,\n      default: dstr,\n      controlButtonVisibility: 'block',\n      displayOrder: 1,\n      displayPriority: 1,\n      displayGroup: 1,\n      help: \"dateHelp.html\"\n    });\n    var plotFormats = {};\n    plotFormats[matsTypes.PlotFormats.matching] = 'show matching diffs';\n    plotFormats[matsTypes.PlotFormats.pairwise] = 'pairwise diffs';\n    plotFormats[matsTypes.PlotFormats.none] = 'no diffs';\n    matsCollections.PlotParams.insert({\n      name: 'plotFormat',\n      type: matsTypes.InputTypes.radioGroup,\n      optionsMap: plotFormats,\n      options: [matsTypes.PlotFormats.matching, matsTypes.PlotFormats.pairwise, matsTypes.PlotFormats.none],\n      default: matsTypes.PlotFormats.none,\n      controlButtonCovered: false,\n      controlButtonVisibility: 'block',\n      displayOrder: 1,\n      displayPriority: 1,\n      displayGroup: 3\n    });\n    var yAxisOptionsMap = {\n      \"Number\": [\"number\"],\n      \"Relative frequency\": [\"relFreq\"]\n    };\n    matsCollections.PlotParams.insert({\n      name: 'histogram-yaxis-controls',\n      type: matsTypes.InputTypes.select,\n      optionsMap: yAxisOptionsMap,\n      options: Object.keys(yAxisOptionsMap),\n      default: Object.keys(yAxisOptionsMap)[0],\n      controlButtonCovered: true,\n      controlButtonText: 'Y-axis mode',\n      displayOrder: 1,\n      displayPriority: 1,\n      displayGroup: 2\n    });\n    var binOptionsMap = {\n      \"Default bins\": [\"default\"],\n      \"Set number of bins\": [\"binNumber\"],\n      \"Make zero a bin bound\": [\"zeroBound\"],\n      \"Choose a bin bound\": [\"chooseBound\"],\n      \"Set number of bins and make zero a bin bound\": [\"binNumberWithZero\"],\n      \"Set number of bins and choose a bin bound\": [\"binNumberWithChosen\"],\n      \"Manual bins\": [\"manual\"],\n      \"Manual bin start, number, and stride\": [\"manualStride\"]\n    };\n    matsCollections.PlotParams.insert({\n      name: 'histogram-bin-controls',\n      type: matsTypes.InputTypes.select,\n      optionsMap: binOptionsMap,\n      options: Object.keys(binOptionsMap),\n      hideOtherFor: {\n        'bin-number': [\"Default bins\", \"Make zero a bin bound\", \"Manual bins\", \"Choose a bin bound\"],\n        'bin-pivot': [\"Default bins\", \"Set number of bins\", \"Make zero a bin bound\", \"Set number of bins and make zero a bin bound\", \"Manual bins\", \"Manual bin start, number, and stride\"],\n        'bin-start': [\"Default bins\", \"Set number of bins\", \"Make zero a bin bound\", \"Choose a bin bound\", \"Set number of bins and make zero a bin bound\", \"Set number of bins and choose a bin bound\", \"Manual bins\"],\n        'bin-stride': [\"Default bins\", \"Set number of bins\", \"Make zero a bin bound\", \"Choose a bin bound\", \"Set number of bins and make zero a bin bound\", \"Set number of bins and choose a bin bound\", \"Manual bins\"],\n        'bin-bounds': [\"Default bins\", \"Set number of bins\", \"Make zero a bin bound\", \"Choose a bin bound\", \"Set number of bins and make zero a bin bound\", \"Set number of bins and choose a bin bound\", \"Manual bin start, number, and stride\"]\n      },\n      default: Object.keys(binOptionsMap)[0],\n      controlButtonCovered: true,\n      controlButtonText: 'customize bins',\n      displayOrder: 2,\n      displayPriority: 1,\n      displayGroup: 2\n    });\n    matsCollections.PlotParams.insert({\n      name: 'bin-number',\n      type: matsTypes.InputTypes.numberSpinner,\n      optionsMap: {},\n      options: [],\n      // convenience\n      min: '2',\n      max: '100',\n      step: 'any',\n      default: '12',\n      controlButtonCovered: true,\n      controlButtonText: \"number of bins\",\n      displayOrder: 3,\n      displayPriority: 1,\n      displayGroup: 2\n    });\n    matsCollections.PlotParams.insert({\n      name: 'bin-pivot',\n      type: matsTypes.InputTypes.numberSpinner,\n      optionsMap: {},\n      options: [],\n      // convenience\n      min: '-10000',\n      max: '10000',\n      step: 'any',\n      default: '0',\n      controlButtonCovered: true,\n      controlButtonText: \"bin pivot value\",\n      displayOrder: 4,\n      displayPriority: 1,\n      displayGroup: 2\n    });\n    matsCollections.PlotParams.insert({\n      name: 'bin-start',\n      type: matsTypes.InputTypes.numberSpinner,\n      optionsMap: {},\n      options: [],\n      // convenience\n      min: '-10000',\n      max: '10000',\n      step: 'any',\n      default: '0',\n      controlButtonCovered: true,\n      controlButtonText: \"bin start\",\n      displayOrder: 5,\n      displayPriority: 1,\n      displayGroup: 2\n    });\n    matsCollections.PlotParams.insert({\n      name: 'bin-stride',\n      type: matsTypes.InputTypes.numberSpinner,\n      optionsMap: {},\n      options: [],\n      // convenience\n      min: '-10000',\n      max: '10000',\n      step: 'any',\n      default: '0',\n      controlButtonCovered: true,\n      controlButtonText: \"bin stride\",\n      displayOrder: 6,\n      displayPriority: 1,\n      displayGroup: 2\n    });\n    matsCollections.PlotParams.insert({\n      name: 'bin-bounds',\n      type: matsTypes.InputTypes.textInput,\n      optionsMap: {},\n      options: [],\n      // convenience\n      default: ' ',\n      controlButtonCovered: true,\n      controlButtonText: \"bin bounds (enter numbers separated by commas)\",\n      displayOrder: 7,\n      displayPriority: 1,\n      displayGroup: 2\n    });\n  } else {\n    // need to update the dates selector if the metadata has changed\n    var currentParam = matsCollections.PlotParams.findOne({\n      name: 'dates'\n    });\n\n    if (!matsDataUtils.areObjectsEqual(currentParam.startDate, minDate) || !matsDataUtils.areObjectsEqual(currentParam.stopDate, maxDate) || !matsDataUtils.areObjectsEqual(currentParam.default, dstr)) {\n      // have to reload model data\n      matsCollections.PlotParams.update({\n        name: 'dates'\n      }, {\n        $set: {\n          startDate: minDate,\n          stopDate: maxDate,\n          default: dstr\n        }\n      });\n    }\n  }\n};\n\nconst doCurveParams = function () {\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.CurveParams.remove({});\n  }\n\n  var modelOptionsMap = {};\n  var modelDateRangeMap = {};\n  var regionModelOptionsMap = {};\n  var forecastLengthOptionsMap = {};\n  var thresholdsModelOptionsMap = {};\n  var scaleModelOptionsMap = {};\n  var sourceOptionsMap = {};\n  var masterRegionValuesMap = {};\n  var masterThresholdValuesMap = {};\n  var masterScaleValuesMap = {};\n\n  try {\n    const rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(metadataPool, \"SELECT short_name,description FROM region_descriptions;\");\n    var masterRegDescription;\n    var masterShortName;\n\n    for (var j = 0; j < rows.length; j++) {\n      masterRegDescription = rows[j].description.trim();\n      masterShortName = rows[j].short_name.trim();\n      masterRegionValuesMap[masterShortName] = masterRegDescription;\n    }\n  } catch (err) {\n    console.log(err.message);\n  }\n\n  try {\n    const rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(sumPool, \"SELECT trsh,description FROM threshold_descriptions;\");\n    var masterDescription;\n    var masterTrsh;\n\n    for (var j = 0; j < rows.length; j++) {\n      masterDescription = rows[j].description.trim();\n      masterTrsh = rows[j].trsh.trim();\n      masterThresholdValuesMap[masterTrsh] = masterDescription;\n    }\n  } catch (err) {\n    console.log(err.message);\n  }\n\n  try {\n    const rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(sumPool, \"SELECT scle,description FROM scale_descriptions;\");\n    var masterScaleDescription;\n    var masterScale;\n\n    for (var j = 0; j < rows.length; j++) {\n      masterScaleDescription = rows[j].description.trim();\n      masterScale = rows[j].scle.trim();\n      masterScaleValuesMap[masterScale] = masterScaleDescription;\n    }\n  } catch (err) {\n    console.log(err.message);\n  }\n\n  try {\n    const rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(sumPool, \"select model,regions,sources,display_text,fcst_lens,thresh,scale,mindate,maxdate from regions_per_model_mats_all_categories order by display_category, display_order;\");\n\n    for (var i = 0; i < rows.length; i++) {\n      var model_value = rows[i].model.trim();\n      var model = rows[i].display_text.trim();\n      modelOptionsMap[model] = [model_value];\n      var rowMinDate = moment.utc(rows[i].mindate * 1000).format(\"MM/DD/YYYY HH:mm\");\n      var rowMaxDate = moment.utc(rows[i].maxdate * 1000).format(\"MM/DD/YYYY HH:mm\");\n      modelDateRangeMap[model] = {\n        minDate: rowMinDate,\n        maxDate: rowMaxDate\n      };\n      var sources = rows[i].sources;\n      var sourceArr = sources.split(',').map(Function.prototype.call, String.prototype.trim);\n\n      for (var j = 0; j < sourceArr.length; j++) {\n        sourceArr[j] = sourceArr[j].replace(/'|\\[|\\]/g, \"\");\n      }\n\n      sourceOptionsMap[model] = sourceArr;\n      var forecastLengths = rows[i].fcst_lens;\n      var forecastLengthArr = forecastLengths.split(',').map(Function.prototype.call, String.prototype.trim);\n\n      for (var j = 0; j < forecastLengthArr.length; j++) {\n        forecastLengthArr[j] = forecastLengthArr[j].replace(/'|\\[|\\]/g, \"\");\n      }\n\n      forecastLengthOptionsMap[model] = forecastLengthArr;\n      var thresholds = rows[i].thresh;\n      var thresholdsArrRaw = thresholds.split(',').map(Function.prototype.call, String.prototype.trim);\n      var thresholdsArr = [];\n      var dummyThresh;\n\n      for (var j = 0; j < thresholdsArrRaw.length; j++) {\n        dummyThresh = thresholdsArrRaw[j].replace(/'|\\[|\\]/g, \"\");\n        thresholdsArr.push(masterThresholdValuesMap[dummyThresh]);\n      }\n\n      thresholdsModelOptionsMap[model] = thresholdsArr;\n      var regions = rows[i].regions;\n      var regionsArrRaw = regions.split(',').map(Function.prototype.call, String.prototype.trim);\n      var regionsArr = [];\n      var dummyRegion;\n\n      for (var j = 0; j < regionsArrRaw.length; j++) {\n        dummyRegion = regionsArrRaw[j].replace(/'|\\[|\\]/g, \"\");\n        regionsArr.push(masterRegionValuesMap[dummyRegion]);\n      }\n\n      regionModelOptionsMap[model] = regionsArr;\n      var scales = rows[i].scale;\n      var scalesArrRaw = scales.split(',').map(Function.prototype.call, String.prototype.trim);\n      var scalesArr = [];\n      var dummyScale;\n\n      for (var j = 0; j < scalesArrRaw.length; j++) {\n        dummyScale = scalesArrRaw[j].replace(/'|\\[|\\]/g, \"\");\n        scalesArr.push(masterScaleValuesMap[dummyScale]);\n      }\n\n      scaleModelOptionsMap[model] = scalesArr;\n    }\n  } catch (err) {\n    console.log(err.message);\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'label'\n  }).count() == 0) {\n    matsCollections.CurveParams.insert({\n      name: 'label',\n      type: matsTypes.InputTypes.textInput,\n      optionsMap: {},\n      options: [],\n      // convenience\n      controlButtonCovered: true,\n      default: '',\n      unique: true,\n      controlButtonVisibility: 'block',\n      displayOrder: 1,\n      displayPriority: 1,\n      displayGroup: 1,\n      help: 'label.html'\n    });\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'data-source'\n  }).count() == 0) {\n    matsCollections.CurveParams.insert({\n      name: 'data-source',\n      type: matsTypes.InputTypes.select,\n      optionsMap: modelOptionsMap,\n      dates: modelDateRangeMap,\n      options: Object.keys(modelOptionsMap),\n      // convenience\n      dependentNames: [\"region\", \"forecast-length\", \"threshold\", \"scale\", \"truth\", \"dates\", \"curve-dates\"],\n      controlButtonCovered: true,\n      default: Object.keys(modelOptionsMap)[0],\n      unique: false,\n      controlButtonVisibility: 'block',\n      displayOrder: 2,\n      displayPriority: 1,\n      displayGroup: 1\n    });\n  } else {\n    // it is defined but check for necessary update\n    var currentParam = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    });\n\n    if (!matsDataUtils.areObjectsEqual(currentParam.optionsMap, modelOptionsMap) || !matsDataUtils.areObjectsEqual(currentParam.dates, modelDateRangeMap)) {\n      // have to reload model data\n      matsCollections.CurveParams.update({\n        name: 'data-source'\n      }, {\n        $set: {\n          optionsMap: modelOptionsMap,\n          dates: modelDateRangeMap,\n          options: Object.keys(modelOptionsMap),\n          default: Object.keys(modelOptionsMap)[0]\n        }\n      });\n    }\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'region'\n  }).count() == 0) {\n    matsCollections.CurveParams.insert({\n      name: 'region',\n      type: matsTypes.InputTypes.select,\n      optionsMap: regionModelOptionsMap,\n      options: regionModelOptionsMap[Object.keys(regionModelOptionsMap)[0]],\n      // convenience\n      valuesMap: masterRegionValuesMap,\n      superiorNames: ['data-source'],\n      controlButtonCovered: true,\n      unique: false,\n      default: regionModelOptionsMap[Object.keys(regionModelOptionsMap)[0]][0],\n      controlButtonVisibility: 'block',\n      displayOrder: 3,\n      displayPriority: 1,\n      displayGroup: 1\n    });\n  } else {\n    // it is defined but check for necessary update\n    var currentParam = matsCollections.CurveParams.findOne({\n      name: 'region'\n    });\n\n    if (!matsDataUtils.areObjectsEqual(currentParam.optionsMap, regionModelOptionsMap) || !matsDataUtils.areObjectsEqual(currentParam.valuesMap, masterRegionValuesMap)) {\n      // have to reload model data\n      matsCollections.CurveParams.update({\n        name: 'region'\n      }, {\n        $set: {\n          optionsMap: regionModelOptionsMap,\n          valuesMap: masterRegionValuesMap,\n          options: regionModelOptionsMap[Object.keys(regionModelOptionsMap)[0]],\n          default: regionModelOptionsMap[Object.keys(regionModelOptionsMap)[0]][0]\n        }\n      });\n    }\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'statistic'\n  }).count() == 0) {\n    var optionsMap = {\n      'TSS (True Skill Score)': ['((sum(m0.hit)*sum(m0.cn) - sum(m0.fa)*sum(m0.miss))/((sum(m0.hit)+sum(m0.miss))*(sum(m0.fa)+sum(m0.cn)))) * 100 as stat, group_concat(((m0.hit*m0.cn - m0.fa*m0.miss)/((m0.hit+m0.miss)*(m0.fa+m0.cn))) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n      'PODy (POD of precip > threshold)': ['((sum(m0.hit)+0.00)/sum(m0.hit+m0.miss)) * 100 as stat, group_concat(((m0.hit)/(m0.hit+m0.miss)) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n      'PODn (POD of precip < threshold)': ['((sum(m0.cn)+0.00)/sum(m0.cn+m0.fa)) * 100 as stat, group_concat(((m0.cn)/(m0.cn+m0.fa)) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n      'FAR (False Alarm Ratio)': ['((sum(m0.fa)+0.00)/sum(m0.fa+m0.hit)) * 100 as stat, group_concat(((m0.fa)/(m0.fa+m0.hit)) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 0],\n      'Bias (forecast/actual)': ['((sum(m0.hit+m0.fa)+0.00)/sum(m0.hit+m0.miss)) as stat, group_concat(((m0.hit+m0.fa)/(m0.hit+m0.miss)), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Ratio', 1],\n      'CSI (Critical Success Index)': ['((sum(m0.hit)+0.00)/sum(m0.hit+m0.miss+m0.fa)) * 100 as stat, group_concat(((m0.hit)/(m0.hit+m0.miss+m0.fa)) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n      'HSS (Heidke Skill Score)': ['(2*(sum(m0.cn+0.00)*sum(m0.hit)-sum(m0.miss)*sum(m0.fa))/((sum(m0.cn+0.00)+sum(m0.fa))*(sum(m0.fa)+sum(m0.hit))+(sum(m0.cn+0.00)+sum(m0.miss))*(sum(m0.miss)+sum(m0.hit)))) * 100 as stat, group_concat((2*(m0.cn*m0.hit - m0.miss*m0.fa) / ((m0.cn+m0.fa)*(m0.fa+m0.hit) + (m0.cn+m0.miss)*(m0.miss+m0.hit))) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n      'ETS (Equitable Threat Score)': ['(sum(m0.hit)-(sum(m0.hit+m0.fa)*sum(m0.hit+m0.miss)/sum(m0.hit+m0.fa+m0.miss+m0.cn)))/(sum(m0.hit+m0.fa+m0.miss)-(sum(m0.hit+m0.fa)*sum(m0.hit+m0.miss)/sum(m0.hit+m0.fa+m0.miss+m0.cn))) * 100 as stat, group_concat((m0.hit-((m0.hit+m0.fa)*(m0.hit+m0.miss)/(m0.hit+m0.fa+m0.miss+m0.cn)))/((m0.hit+m0.fa+m0.miss)-((m0.hit+m0.fa)*(m0.hit+m0.miss)/(m0.hit+m0.fa+m0.miss+m0.cn))) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n      'Nlow (obs < threshold, avg per hr)': ['avg(m0.cn+m0.fa+0.000) as stat, group_concat((m0.cn+m0.fa), \";\", m0.time order by m0.time) as sub_data, count(m0.cn) as N0', 'Number', null],\n      'Nhigh (obs > threshold, avg per hr)': ['avg(m0.hit+m0.miss+0.000) as stat, group_concat((m0.hit+m0.miss), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Number', null],\n      'Ntot (total obs, avg per hr)': ['avg(m0.hit+m0.fa+m0.miss+m0.cn+0.000) as stat, group_concat((m0.hit+m0.fa+m0.miss+m0.cn), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Number', null],\n      'Ratio (Nlow / Ntot)': ['(sum(m0.cn+m0.fa+0.000)/sum(m0.hit+m0.fa+m0.miss+m0.cn+0.000)) as stat, group_concat(((m0.cn+m0.fa)/(m0.hit+m0.fa+m0.miss+m0.cn)), \";\", m0.time order by m0.time) as sub_data, count(m0.cn) as N0', 'Ratio', null],\n      'Ratio (Nhigh / Ntot)': ['(sum(m0.hit+m0.miss+0.000)/sum(m0.hit+m0.fa+m0.miss+m0.cn+0.000)) as stat, group_concat(((m0.hit+m0.miss)/(m0.hit+m0.fa+m0.miss+m0.cn)), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Ratio', null],\n      'N in average (to nearest 100)': ['sum(m0.hit+m0.miss+m0.fa+m0.cn+0.000) as stat, group_concat((m0.hit+m0.miss+m0.fa+m0.cn), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Number', null]\n    };\n    matsCollections.CurveParams.insert({\n      name: 'statistic',\n      type: matsTypes.InputTypes.select,\n      optionsMap: optionsMap,\n      options: Object.keys(optionsMap),\n      // convenience\n      controlButtonCovered: true,\n      unique: false,\n      default: Object.keys(optionsMap)[0],\n      controlButtonVisibility: 'block',\n      displayOrder: 1,\n      displayPriority: 1,\n      displayGroup: 2\n    });\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'threshold'\n  }).count() == 0) {\n    matsCollections.CurveParams.insert({\n      name: 'threshold',\n      type: matsTypes.InputTypes.select,\n      optionsMap: thresholdsModelOptionsMap,\n      options: thresholdsModelOptionsMap[Object.keys(thresholdsModelOptionsMap)[0]],\n      // convenience\n      valuesMap: masterThresholdValuesMap,\n      superiorNames: ['data-source'],\n      controlButtonCovered: true,\n      unique: false,\n      default: thresholdsModelOptionsMap[Object.keys(thresholdsModelOptionsMap)[0]][0],\n      controlButtonVisibility: 'block',\n      displayOrder: 2,\n      displayPriority: 1,\n      displayGroup: 2\n    });\n  } else {\n    // it is defined but check for necessary update\n    var currentParam = matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    });\n\n    if (!matsDataUtils.areObjectsEqual(currentParam.optionsMap, thresholdsModelOptionsMap) || !matsDataUtils.areObjectsEqual(currentParam.valuesMap, masterThresholdValuesMap)) {\n      // have to reload model data\n      matsCollections.CurveParams.update({\n        name: 'threshold'\n      }, {\n        $set: {\n          optionsMap: thresholdsModelOptionsMap,\n          valuesMap: masterThresholdValuesMap,\n          options: thresholdsModelOptionsMap[Object.keys(thresholdsModelOptionsMap)[0]],\n          default: thresholdsModelOptionsMap[Object.keys(thresholdsModelOptionsMap)[0]][0]\n        }\n      });\n    }\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'average'\n  }).count() == 0) {\n    optionsMap = {\n      'None': ['m0.time'],\n      '3hr': ['ceil(10800*floor(m0.time/10800)+10800/2)'],\n      '6hr': ['ceil(21600*floor(m0.time/21600)+21600/2)'],\n      '12hr': ['ceil(43200*floor(m0.time/43200)+43200/2)'],\n      '1D': ['ceil(86400*floor(m0.time/86400)+86400/2)'],\n      '3D': ['ceil(259200*floor(m0.time/259200)+259200/2)'],\n      '7D': ['ceil(604800*floor(m0.time/604800)+604800/2)'],\n      '30D': ['ceil(2592000*floor(m0.time/2592000)+2592000/2)'],\n      '60D': ['ceil(5184000*floor(m0.time/5184000)+5184000/2)']\n    };\n    matsCollections.CurveParams.insert({\n      name: 'average',\n      type: matsTypes.InputTypes.select,\n      optionsMap: optionsMap,\n      options: Object.keys(optionsMap),\n      // convenience\n      controlButtonCovered: true,\n      unique: false,\n      selected: 'None',\n      default: 'None',\n      controlButtonVisibility: 'block',\n      displayOrder: 1,\n      displayPriority: 1,\n      displayGroup: 3\n    });\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'forecast-length'\n  }).count() == 0) {\n    matsCollections.CurveParams.insert({\n      name: 'forecast-length',\n      type: matsTypes.InputTypes.select,\n      optionsMap: forecastLengthOptionsMap,\n      options: forecastLengthOptionsMap[Object.keys(forecastLengthOptionsMap)[0]],\n      // convenience\n      superiorNames: ['data-source'],\n      selected: '',\n      controlButtonCovered: true,\n      unique: false,\n      default: 6,\n      controlButtonVisibility: 'block',\n      controlButtonText: \"forecast lead time\",\n      displayOrder: 2,\n      displayPriority: 1,\n      displayGroup: 3\n    });\n  } else {\n    // it is defined but check for necessary update\n    var currentParam = matsCollections.CurveParams.findOne({\n      name: 'forecast-length'\n    });\n\n    if (!matsDataUtils.areObjectsEqual(currentParam.optionsMap, forecastLengthOptionsMap)) {\n      // have to reload model data\n      matsCollections.CurveParams.update({\n        name: 'forecast-length'\n      }, {\n        $set: {\n          optionsMap: forecastLengthOptionsMap,\n          options: forecastLengthOptionsMap[Object.keys(forecastLengthOptionsMap)[0]]\n        }\n      });\n    }\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'dieoff-type'\n  }).count() == 0) {\n    var dieoffOptionsMap = {\n      \"Dieoff\": [matsTypes.ForecastTypes.dieoff],\n      \"Dieoff for a specified UTC cycle init hour\": [matsTypes.ForecastTypes.utcCycle],\n      \"Single cycle forecast (uses first date in range)\": [matsTypes.ForecastTypes.singleCycle]\n    };\n    matsCollections.CurveParams.insert({\n      name: 'dieoff-type',\n      type: matsTypes.InputTypes.select,\n      optionsMap: dieoffOptionsMap,\n      options: Object.keys(dieoffOptionsMap),\n      hideOtherFor: {\n        'valid-time': [\"Dieoff for a specified UTC cycle init hour\", \"Single cycle forecast (uses first date in range)\"],\n        'utc-cycle-start': [\"Dieoff\", \"Single cycle forecast (uses first date in range)\"]\n      },\n      selected: '',\n      controlButtonCovered: true,\n      unique: false,\n      default: Object.keys(dieoffOptionsMap)[0],\n      controlButtonVisibility: 'block',\n      controlButtonText: 'dieoff type',\n      displayOrder: 2,\n      displayPriority: 1,\n      displayGroup: 3\n    });\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'valid-time'\n  }).count() == 0) {\n    matsCollections.CurveParams.insert({\n      name: 'valid-time',\n      type: matsTypes.InputTypes.select,\n      options: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'],\n      selected: [],\n      controlButtonCovered: true,\n      unique: false,\n      default: matsTypes.InputTypes.unused,\n      controlButtonVisibility: 'block',\n      controlButtonText: \"valid utc hour\",\n      displayOrder: 3,\n      displayPriority: 1,\n      displayGroup: 3,\n      multiple: true\n    });\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'utc-cycle-start'\n  }).count() == 0) {\n    const optionsArr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'];\n    matsCollections.CurveParams.insert({\n      name: 'utc-cycle-start',\n      type: matsTypes.InputTypes.select,\n      options: optionsArr,\n      selected: '',\n      controlButtonCovered: true,\n      unique: false,\n      default: optionsArr[12],\n      controlButtonVisibility: 'block',\n      controlButtonText: \"utc cycle init hour\",\n      displayOrder: 3,\n      displayPriority: 1,\n      displayGroup: 3\n    });\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'truth'\n  }).count() == 0) {\n    matsCollections.CurveParams.insert({\n      name: 'truth',\n      type: matsTypes.InputTypes.select,\n      optionsMap: sourceOptionsMap,\n      options: sourceOptionsMap[Object.keys(sourceOptionsMap)[0]],\n      superiorNames: ['data-source'],\n      controlButtonCovered: true,\n      unique: false,\n      default: sourceOptionsMap[Object.keys(sourceOptionsMap)[0]][0],\n      controlButtonVisibility: 'block',\n      displayOrder: 1,\n      displayPriority: 1,\n      displayGroup: 4\n    });\n  } else {\n    // it is defined but check for necessary update\n    var currentParam = matsCollections.CurveParams.findOne({\n      name: 'truth'\n    });\n\n    if (!matsDataUtils.areObjectsEqual(currentParam.optionsMap, sourceOptionsMap)) {\n      // have to reload model data\n      matsCollections.CurveParams.update({\n        name: 'truth'\n      }, {\n        $set: {\n          optionsMap: sourceOptionsMap,\n          options: sourceOptionsMap[Object.keys(sourceOptionsMap)[0]],\n          default: sourceOptionsMap[Object.keys(sourceOptionsMap)[0]][0]\n        }\n      });\n    }\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'scale'\n  }).count() == 0) {\n    matsCollections.CurveParams.insert({\n      // bias and model average are a different formula for wind (element 0 differs from element 1)\n      // but stays the same (element 0 and element 1 are the same) otherwise.\n      // When plotting profiles we append element 2 to whichever element was chosen (for wind variable). For\n      // time series we never append element 2. Element 3 is used to give us error values for error bars.\n      name: 'scale',\n      type: matsTypes.InputTypes.select,\n      optionsMap: scaleModelOptionsMap,\n      options: scaleModelOptionsMap[Object.keys(scaleModelOptionsMap)[0]],\n      // convenience\n      valuesMap: masterScaleValuesMap,\n      superiorNames: ['data-source'],\n      controlButtonCovered: true,\n      unique: false,\n      default: scaleModelOptionsMap[Object.keys(scaleModelOptionsMap)[0]][0],\n      controlButtonVisibility: 'block',\n      displayOrder: 3,\n      displayPriority: 1,\n      displayGroup: 3\n    });\n  } else {\n    // it is defined but check for necessary update\n    var currentParam = matsCollections.CurveParams.findOne({\n      name: 'scale'\n    });\n\n    if (!matsDataUtils.areObjectsEqual(currentParam.optionsMap, scaleModelOptionsMap) || !matsDataUtils.areObjectsEqual(currentParam.valuesMap, masterScaleValuesMap)) {\n      // have to reload model data\n      matsCollections.CurveParams.update({\n        name: 'scale'\n      }, {\n        $set: {\n          optionsMap: scaleModelOptionsMap,\n          valuesMap: masterScaleValuesMap,\n          options: scaleModelOptionsMap[Object.keys(scaleModelOptionsMap)[0]],\n          default: scaleModelOptionsMap[Object.keys(scaleModelOptionsMap)[0]][0]\n        }\n      });\n    }\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'x-axis-parameter'\n  }).count() == 0) {\n    const optionsMap = {\n      'Fcst lead time': \"select m0.fcst_len as xVal, \",\n      'Threshold': \"select m0.thresh/100 as xVal, \",\n      'Valid UTC hour': \"select m0.time%(24*3600)/3600 as xVal, \",\n      'Init UTC hour': \"select (m0.time-m0.fcst_len*3600)%(24*3600)/3600 as xVal, \",\n      'Valid Date': \"select m0.time as xVal, \",\n      'Init Date': \"select m0.time-m0.fcst_len*3600 as xVal, \"\n    };\n    matsCollections.CurveParams.insert({\n      name: 'x-axis-parameter',\n      type: matsTypes.InputTypes.select,\n      options: Object.keys(optionsMap),\n      optionsMap: optionsMap,\n      // hideOtherFor: {\n      //     'forecast-length': [\"Fcst lead time\"],\n      //     'valid-time': [\"Valid UTC hour\"],\n      //     'pres-level': [\"Pressure level\"],\n      // },\n      selected: '',\n      controlButtonCovered: true,\n      unique: false,\n      default: Object.keys(optionsMap)[2],\n      controlButtonVisibility: 'block',\n      displayOrder: 1,\n      displayPriority: 1,\n      displayGroup: 5\n    });\n  }\n\n  if (matsCollections.CurveParams.find({\n    name: 'y-axis-parameter'\n  }).count() == 0) {\n    const optionsMap = {\n      'Fcst lead time': \"m0.fcst_len as yVal, \",\n      'Threshold': \"m0.thresh/100 as yVal, \",\n      'Valid UTC hour': \"m0.time%(24*3600)/3600 as yVal, \",\n      'Init UTC hour': \"(m0.time-m0.fcst_len*3600)%(24*3600)/3600 as yVal, \",\n      'Valid Date': \"m0.time as yVal, \",\n      'Init Date': \"m0.time-m0.fcst_len*3600 as yVal, \"\n    };\n    matsCollections.CurveParams.insert({\n      name: 'y-axis-parameter',\n      type: matsTypes.InputTypes.select,\n      options: Object.keys(optionsMap),\n      optionsMap: optionsMap,\n      // hideOtherFor: {\n      //     'forecast-length': [\"Fcst lead time\"],\n      //     'valid-time': [\"Valid UTC hour\"],\n      //     'pres-level': [\"Pressure level\"],\n      // },\n      selected: '',\n      controlButtonCovered: true,\n      unique: false,\n      default: Object.keys(optionsMap)[0],\n      controlButtonVisibility: 'block',\n      displayOrder: 2,\n      displayPriority: 1,\n      displayGroup: 5\n    });\n  } // determine date defaults for dates and curveDates\n\n\n  var defaultDataSource = matsCollections.CurveParams.findOne({\n    name: \"data-source\"\n  }, {\n    default: 1\n  }).default;\n  modelDateRangeMap = matsCollections.CurveParams.findOne({\n    name: \"data-source\"\n  }, {\n    dates: 1\n  }).dates;\n  minDate = modelDateRangeMap[defaultDataSource].minDate;\n  maxDate = modelDateRangeMap[defaultDataSource].maxDate;\n  var minusMonthMinDate = matsParamUtils.getMinMaxDates(minDate, maxDate).minDate;\n  dstr = minusMonthMinDate + ' - ' + maxDate;\n\n  if (matsCollections.CurveParams.find({\n    name: 'curve-dates'\n  }).count() == 0) {\n    optionsMap = {\n      '1 day': ['1 day'],\n      '3 days': ['3 days'],\n      '7 days': ['7 days'],\n      '31 days': ['31 days'],\n      '90 days': ['90 days'],\n      '180 days': ['180 days'],\n      '365 days': ['365 days']\n    };\n    matsCollections.CurveParams.insert({\n      name: 'curve-dates',\n      type: matsTypes.InputTypes.dateRange,\n      optionsMap: optionsMap,\n      options: Object.keys(optionsMap).sort(),\n      startDate: minDate,\n      stopDate: maxDate,\n      superiorNames: ['data-source'],\n      controlButtonCovered: true,\n      unique: false,\n      default: dstr,\n      controlButtonVisibility: 'block',\n      displayOrder: 1,\n      displayPriority: 1,\n      displayGroup: 6,\n      help: \"dateHelp.html\"\n    });\n  } else {\n    // it is defined but check for necessary update\n    var currentParam = matsCollections.CurveParams.findOne({\n      name: 'curve-dates'\n    });\n\n    if (!matsDataUtils.areObjectsEqual(currentParam.startDate, minDate) || !matsDataUtils.areObjectsEqual(currentParam.stopDate, maxDate) || !matsDataUtils.areObjectsEqual(currentParam.default, dstr)) {\n      // have to reload model data\n      matsCollections.CurveParams.update({\n        name: 'curve-dates'\n      }, {\n        $set: {\n          startDate: minDate,\n          stopDate: maxDate,\n          default: dstr\n        }\n      });\n    }\n  }\n};\n/* The format of a curveTextPattern is an array of arrays, each sub array has\n [labelString, localVariableName, delimiterString]  any of which can be null.\n Each sub array will be joined (the localVariableName is always dereferenced first)\n and then the sub arrays will be joined maintaining order.\n\n The curveTextPattern is found by its name which must match the corresponding PlotGraphFunctions.PlotType value.\n See curve_item.js and standAlone.js.\n */\n\n\nconst doCurveTextPatterns = function () {\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.CurveTextPatterns.remove({});\n  }\n\n  if (matsCollections.CurveTextPatterns.find().count() == 0) {\n    matsCollections.CurveTextPatterns.insert({\n      plotType: matsTypes.PlotTypes.timeSeries,\n      textPattern: [['', 'label', ': '], ['', 'data-source', ' in '], ['', 'region', ', '], ['', 'threshold', ' '], ['', 'scale', ', '], ['', 'statistic', ', '], ['fcst_len: ', 'forecast-length', 'h, '], ['valid-time: ', 'valid-time', ', '], ['avg: ', 'average', ', '], ['', 'truth', ' ']],\n      displayParams: [\"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"average\", \"forecast-length\", \"valid-time\", \"truth\"],\n      groupSize: 6\n    });\n    matsCollections.CurveTextPatterns.insert({\n      plotType: matsTypes.PlotTypes.dieoff,\n      textPattern: [['', 'label', ': '], ['', 'data-source', ' in '], ['', 'region', ', '], ['', 'threshold', ' '], ['', 'scale', ', '], ['', 'statistic', ', '], ['', 'dieoff-type', ', '], ['valid-time: ', 'valid-time', ', '], ['start utc: ', 'utc-cycle-start', ', '], ['', 'truth', ', '], ['', 'curve-dates', '']],\n      displayParams: [\"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"dieoff-type\", \"valid-time\", \"utc-cycle-start\", \"truth\", \"curve-dates\"],\n      groupSize: 6\n    });\n    matsCollections.CurveTextPatterns.insert({\n      plotType: matsTypes.PlotTypes.threshold,\n      textPattern: [['', 'label', ': '], ['', 'data-source', ' in '], ['', 'region', ', '], ['', 'scale', ', '], ['', 'statistic', ', '], ['fcst_len: ', 'forecast-length', 'h, '], ['valid-time: ', 'valid-time', ', '], ['', 'truth', ', '], ['', 'curve-dates', '']],\n      displayParams: [\"label\", \"data-source\", \"region\", \"statistic\", \"scale\", \"forecast-length\", \"valid-time\", \"truth\", \"curve-dates\"],\n      groupSize: 6\n    });\n    matsCollections.CurveTextPatterns.insert({\n      plotType: matsTypes.PlotTypes.validtime,\n      textPattern: [['', 'label', ': '], ['', 'data-source', ' in '], ['', 'region', ', '], ['', 'threshold', ' '], ['', 'scale', ', '], ['', 'statistic', ', '], ['fcst_len: ', 'forecast-length', 'h, '], ['', 'truth', ', '], ['', 'curve-dates', '']],\n      displayParams: [\"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"forecast-length\", \"truth\", \"curve-dates\"],\n      groupSize: 6\n    });\n    matsCollections.CurveTextPatterns.insert({\n      plotType: matsTypes.PlotTypes.dailyModelCycle,\n      textPattern: [['', 'label', ': '], ['', 'data-source', ' in '], ['', 'region', ', '], ['', 'threshold', ' '], ['', 'scale', ', '], ['', 'statistic', ', '], ['start utc: ', 'utc-cycle-start', ', '], ['', 'truth', ' ']],\n      displayParams: [\"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"utc-cycle-start\", \"truth\"],\n      groupSize: 6\n    });\n    matsCollections.CurveTextPatterns.insert({\n      plotType: matsTypes.PlotTypes.histogram,\n      textPattern: [['', 'label', ': '], ['', 'data-source', ' in '], ['', 'region', ', '], ['', 'threshold', ' '], ['', 'scale', ', '], ['', 'statistic', ', '], ['fcst_len: ', 'forecast-length', 'h, '], ['valid-time: ', 'valid-time', ', '], ['', 'truth', ', '], ['', 'curve-dates', '']],\n      displayParams: [\"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"forecast-length\", \"valid-time\", \"truth\", \"curve-dates\"],\n      groupSize: 6\n    });\n    matsCollections.CurveTextPatterns.insert({\n      plotType: matsTypes.PlotTypes.contour,\n      textPattern: [['', 'label', ': '], ['', 'data-source', ' in '], ['', 'region', ', '], ['', 'threshold', ' '], ['', 'scale', ', '], ['', 'statistic', ', '], ['fcst_len: ', 'forecast-length', 'h, '], ['valid-time: ', 'valid-time', ', '], ['', 'truth', ', '], ['x-axis: ', 'x-axis-parameter', ', '], ['y-axis: ', 'y-axis-parameter', '']],\n      displayParams: [\"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"forecast-length\", \"valid-time\", \"truth\", \"x-axis-parameter\", \"y-axis-parameter\"],\n      groupSize: 6\n    });\n    matsCollections.CurveTextPatterns.insert({\n      plotType: matsTypes.PlotTypes.contourDiff,\n      textPattern: [['', 'label', ': '], ['', 'data-source', ' in '], ['', 'region', ', '], ['', 'threshold', ' '], ['', 'scale', ', '], ['', 'statistic', ', '], ['fcst_len: ', 'forecast-length', 'h, '], ['valid-time: ', 'valid-time', ', '], ['', 'truth', ', '], ['x-axis: ', 'x-axis-parameter', ', '], ['y-axis: ', 'y-axis-parameter', '']],\n      displayParams: [\"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"forecast-length\", \"valid-time\", \"truth\", \"x-axis-parameter\", \"y-axis-parameter\"],\n      groupSize: 6\n    });\n  }\n};\n\nconst doSavedCurveParams = function () {\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.SavedCurveParams.remove({});\n  }\n\n  if (matsCollections.SavedCurveParams.find().count() == 0) {\n    matsCollections.SavedCurveParams.insert({\n      clName: 'changeList',\n      changeList: []\n    });\n  }\n};\n\nconst doPlotGraph = function () {\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.PlotGraphFunctions.remove({});\n  }\n\n  if (matsCollections.PlotGraphFunctions.find().count() == 0) {\n    matsCollections.PlotGraphFunctions.insert({\n      plotType: matsTypes.PlotTypes.timeSeries,\n      graphFunction: \"graphPlotly\",\n      dataFunction: \"dataSeries\",\n      checked: true\n    });\n    matsCollections.PlotGraphFunctions.insert({\n      plotType: matsTypes.PlotTypes.dieoff,\n      graphFunction: \"graphPlotly\",\n      dataFunction: \"dataDieOff\",\n      checked: false\n    });\n    matsCollections.PlotGraphFunctions.insert({\n      plotType: matsTypes.PlotTypes.threshold,\n      graphFunction: \"graphPlotly\",\n      dataFunction: \"dataThreshold\",\n      checked: false\n    });\n    matsCollections.PlotGraphFunctions.insert({\n      plotType: matsTypes.PlotTypes.validtime,\n      graphFunction: \"graphPlotly\",\n      dataFunction: \"dataValidTime\",\n      checked: false\n    });\n    matsCollections.PlotGraphFunctions.insert({\n      plotType: matsTypes.PlotTypes.dailyModelCycle,\n      graphFunction: \"graphPlotly\",\n      dataFunction: \"dataDailyModelCycle\",\n      checked: false\n    });\n    matsCollections.PlotGraphFunctions.insert({\n      plotType: matsTypes.PlotTypes.histogram,\n      graphFunction: \"graphPlotly\",\n      dataFunction: \"dataHistogram\",\n      checked: false\n    });\n    matsCollections.PlotGraphFunctions.insert({\n      plotType: matsTypes.PlotTypes.contour,\n      graphFunction: \"graphPlotly\",\n      dataFunction: \"dataContour\",\n      checked: false\n    });\n    matsCollections.PlotGraphFunctions.insert({\n      plotType: matsTypes.PlotTypes.contourDiff,\n      graphFunction: \"graphPlotly\",\n      dataFunction: \"dataContourDiff\",\n      checked: false\n    });\n  }\n};\n\nMeteor.startup(function () {\n  matsCollections.Databases.remove({});\n\n  if (matsCollections.Databases.find().count() == 0) {\n    matsCollections.Databases.insert({\n      role: matsTypes.DatabaseRoles.SUMS_DATA,\n      status: \"active\",\n      host: 'wolphin.fsl.noaa.gov',\n      user: 'readonly',\n      password: 'ReadOnly@2016!',\n      database: 'precip_new',\n      connectionLimit: 10\n    });\n    matsCollections.Databases.insert({\n      role: matsTypes.DatabaseRoles.META_DATA,\n      status: \"active\",\n      host: 'wolphin.fsl.noaa.gov',\n      user: 'readonly',\n      password: 'ReadOnly@2016!',\n      database: 'mats_common',\n      connectionLimit: 10\n    });\n  }\n\n  const sumSettings = matsCollections.Databases.findOne({\n    role: matsTypes.DatabaseRoles.SUMS_DATA,\n    status: \"active\"\n  }, {\n    host: 1,\n    user: 1,\n    password: 1,\n    database: 1,\n    connectionLimit: 1\n  }); // the pool is intended to be global\n\n  sumPool = mysql.createPool(sumSettings);\n  sumPool.on('connection', function (connection) {\n    connection.query('set group_concat_max_len = 4294967295');\n  });\n  const metadataSettings = matsCollections.Databases.findOne({\n    role: matsTypes.DatabaseRoles.META_DATA,\n    status: \"active\"\n  }, {\n    host: 1,\n    user: 1,\n    password: 1,\n    database: 1,\n    connectionLimit: 1\n  }); // the pool is intended to be global\n\n  metadataPool = mysql.createPool(metadataSettings);\n  const mdr = new matsTypes.MetaDataDBRecord(\"sumPool\", \"precip_new\", ['regions_per_model_mats_all_categories', 'threshold_descriptions', 'scale_descriptions']);\n  mdr.addRecord(\"metadataPool\", \"mats_common\", ['region_descriptions']);\n  matsMethods.resetApp({\n    appMdr: mdr,\n    appType: matsTypes.AppTypes.mats,\n    app: 'precipitation1hr'\n  });\n}); // this object is global so that the reset code can get to it\n// These are application specific mongo data - like curve params\n// The appSpecificResetRoutines object is a special name,\n// as is doCurveParams. The refreshMetaData mechanism depends on them being named that way.\n\nappSpecificResetRoutines = [doPlotGraph, doCurveParams, doSavedCurveParams, doPlotParams, doCurveTextPatterns];\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nrequire(\"/server/dataFunctions/data_contour.js\");\nrequire(\"/server/dataFunctions/data_contour_diff.js\");\nrequire(\"/server/dataFunctions/data_dailymodelcycle.js\");\nrequire(\"/server/dataFunctions/data_dieoff.js\");\nrequire(\"/server/dataFunctions/data_histogram.js\");\nrequire(\"/server/dataFunctions/data_series.js\");\nrequire(\"/server/dataFunctions/data_threshold.js\");\nrequire(\"/server/dataFunctions/data_validtime.js\");\nrequire(\"/server/main.js\");","hash":"65bd6918ed87aced0ededcbd6399f784171d9de0","servePath":"/app.js","sourceMap":{"version":3,"sources":["server/dataFunctions/data_contour.js","server/dataFunctions/data_contour_diff.js","server/dataFunctions/data_dailymodelcycle.js","server/dataFunctions/data_dieoff.js","server/dataFunctions/data_histogram.js","server/dataFunctions/data_series.js","server/dataFunctions/data_threshold.js","server/dataFunctions/data_validtime.js","server/main.js"],"names":["matsCollections","module","link","v","matsTypes","matsDataUtils","matsDataQueryUtils","matsDataCurveOpsUtils","matsDataProcessUtils","moment","dataContour","plotParams","plotFunction","plotType","PlotTypes","contour","dataRequests","dataFoundForCurve","totalProcessingStart","dateRange","getDateRange","dates","fromSecs","fromSeconds","toSecs","toSeconds","error","curves","JSON","parse","stringify","length","Error","dataset","axisMap","Object","create","curve","label","xAxisParam","yAxisParam","xValClause","CurveParams","findOne","name","optionsMap","yValClause","dataSourceStr","data_source","regionStr","region","keys","valuesMap","find","key","source","sourceStr","scaleStr","scale","statisticSelect","statisticOptionsMap","statistic","validTimeClause","thresholdClause","forecastLengthClause","dateClause","forecastLength","thresholdStr","threshold","validTimes","undefined","InputTypes","unused","d","statement","replace","split","join","queryResult","startMoment","finishMoment","queryDBContour","sumPool","begin","format","finish","duration","diff","asSeconds","recordCount","data","xTextOutput","e","message","Messages","NO_DATA_FOUND","postQueryStartMoment","mean","glob_stats","annotation","toPrecision","xmin","xmax","ymin","ymax","zmin","zmax","cOptions","generateContourCurveOptions","push","postQueryFinishMoment","curveInfoParams","bookkeepingParams","result","processDataContour","matsDataDiffUtils","dataContourDiff","matching","PlotActions","matched","contourDiff","curvesLength","curveIndex","matchModel","matchDates","matchThresholdClause","matchValidTimeClause","matchForecastLengthClause","matchClause","otherCurveIndex","otherModel","otherRegion","matchDateClause","matchForecastLength","matchThreshold","matchValidTimes","getDataForDiffContour","getDiffContourCurveParams","dataDailyModelCycle","dailyModelCycle","hasLevels","utcCycleStarts","Number","MAX_VALUE","idealValues","diffFrom","utcCycleStart","axisKey","idealVal","indexOf","queryDBSpecialtyCurve","x","diffResult","getDataForDiffCurve","sum","generateSeriesCurveOptions","appParams","processDataXYCurve","dataDieOff","dieoff","forecastLengthStr","forecastLengthOptionsMap","utcCycleStartClause","dateRangeClause","ForecastTypes","utcCycle","dataHistogram","histogram","alreadyMatched","allReturnedSubStats","allReturnedSubSecs","binParams","setHistogramParameters","yAxisFormat","binNum","subVals","subSecs","processDataHistogram","dataSeries","timeSeries","averageStr","averageOptionsMap","average","queryDBTimeSeries","dataThreshold","dataValidTime","validtime","Meteor","mysql","matsParamUtils","minDate","maxDate","dstr","doPlotParams","Settings","resetFromCode","PlotParams","remove","count","insert","type","options","startDate","stopDate","superiorNames","controlButtonCovered","default","controlButtonVisibility","displayOrder","displayPriority","displayGroup","help","plotFormats","PlotFormats","pairwise","none","radioGroup","yAxisOptionsMap","select","controlButtonText","binOptionsMap","hideOtherFor","numberSpinner","min","max","step","textInput","currentParam","areObjectsEqual","update","$set","doCurveParams","modelOptionsMap","modelDateRangeMap","regionModelOptionsMap","thresholdsModelOptionsMap","scaleModelOptionsMap","sourceOptionsMap","masterRegionValuesMap","masterThresholdValuesMap","masterScaleValuesMap","rows","simplePoolQueryWrapSynchronous","metadataPool","masterRegDescription","masterShortName","j","description","trim","short_name","err","console","log","masterDescription","masterTrsh","trsh","masterScaleDescription","masterScale","scle","i","model_value","model","display_text","rowMinDate","utc","mindate","rowMaxDate","maxdate","sources","sourceArr","map","Function","prototype","call","String","forecastLengths","fcst_lens","forecastLengthArr","thresholds","thresh","thresholdsArrRaw","thresholdsArr","dummyThresh","regions","regionsArrRaw","regionsArr","dummyRegion","scales","scalesArrRaw","scalesArr","dummyScale","unique","dependentNames","selected","dieoffOptionsMap","singleCycle","multiple","optionsArr","defaultDataSource","minusMonthMinDate","getMinMaxDates","sort","doCurveTextPatterns","CurveTextPatterns","textPattern","displayParams","groupSize","doSavedCurveParams","SavedCurveParams","clName","changeList","doPlotGraph","PlotGraphFunctions","graphFunction","dataFunction","checked","startup","Databases","role","DatabaseRoles","SUMS_DATA","status","host","user","password","database","connectionLimit","META_DATA","sumSettings","createPool","on","connection","query","metadataSettings","mdr","MetaDataDBRecord","addRecord","matsMethods","resetApp","appMdr","appType","AppTypes","mats","app","appSpecificResetRoutines"],"mappings":"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","file":"/app.js","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataContour = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const plotType = matsTypes.PlotTypes.contour;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    if (curves.length > 1) {\n        throw new Error(\"INFO:  There must only be one added curve.\");\n    }\n    var dataset = [];\n    var axisMap = Object.create(null);\n\n    // initialize variables specific to the curve\n    var curve = curves[0];\n    var label = curve['label'];\n    var xAxisParam = curve['x-axis-parameter'];\n    var yAxisParam = curve['y-axis-parameter'];\n    var xValClause = matsCollections.CurveParams.findOne({name: 'x-axis-parameter'}).optionsMap[xAxisParam];\n    var yValClause = matsCollections.CurveParams.findOne({name: 'y-axis-parameter'}).optionsMap[yAxisParam];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n    if (source !== \"All\") {\n        sourceStr = \"_\" + source;\n    }\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimeClause = \"\";\n    var thresholdClause = \"\";\n    var forecastLengthClause = \"\";\n    var dateClause = \"\";\n    if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n        var forecastLength = curve['forecast-length'];\n        forecastLengthClause = \"and m0.fcst_len = \" + forecastLength + \" \";\n    }\n    if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        threshold = threshold * 0.01;\n        thresholdClause = \"and m0.trsh = \" + threshold + \" \";\n    }\n    if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n            validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n        }\n    }\n    if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && (xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date')) {\n        dateClause = \"m0.time-m0.fcst_len*3600\";\n    } else {\n        dateClause = \"m0.time\";\n    }\n\n    // For contours, this functions as the colorbar label.\n    curve['unitKey'] = statisticOptionsMap[statisticSelect][1];\n\n    var d;\n    // this is a database driven curve, not a difference curve\n    // prepare the query from the above parameters\n    var statement = \"{{xValClause}} \" +\n        \"{{yValClause}} \" +\n        \"count(distinct {{dateClause}}) as N_times, \" +\n        \"min({{dateClause}}) as min_secs, \" +\n        \"max({{dateClause}}) as max_secs, \" +\n        \"{{statistic}} \" +\n        \"from {{data_source}} as m0 \" +\n        \"where 1=1 \" +\n        \"and {{dateClause}} >= '{{fromSecs}}' \" +\n        \"and {{dateClause}} <= '{{toSecs}}' \" +\n        \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n        \"{{thresholdClause}} \" +\n        \"{{validTimeClause}} \" +\n        \"{{forecastLengthClause}} \" +\n        \"group by xVal,yVal \" +\n        \"order by xVal,yVal\" +\n        \";\";\n\n    statement = statement.replace('{{xValClause}}', xValClause);\n    statement = statement.replace('{{yValClause}}', yValClause);\n    statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n    statement = statement.replace('{{statistic}}', statistic);\n    statement = statement.replace('{{threshold}}', threshold);\n    statement = statement.replace('{{fromSecs}}', fromSecs);\n    statement = statement.replace('{{toSecs}}', toSecs);\n    statement = statement.replace('{{thresholdClause}}', thresholdClause);\n    statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n    statement = statement.replace('{{validTimeClause}}', validTimeClause);\n    statement = statement.split('{{dateClause}}').join(dateClause);\n    dataRequests[curve.label] = statement;\n\n    // math is done on forecastLength later on -- set all analyses to 0\n    if (forecastLength === \"-99\") {\n        forecastLength = \"0\";\n    }\n\n    var queryResult;\n    var startMoment = moment();\n    var finishMoment;\n    try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n            begin: startMoment.format(),\n            finish: finishMoment.format(),\n            duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n            recordCount: queryResult.data.xTextOutput.length\n        };\n        // get the data back from the query\n        d = queryResult.data;\n    } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n    }\n    if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n            // this is NOT an error just a no data condition\n            dataFoundForCurve = false;\n        } else {\n            // this is an error returned by the mysql database\n            error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n            throw (new Error(error));\n        }\n    }\n\n    var postQueryStartMoment = moment();\n\n    // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n    const mean = d.glob_stats.mean;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['zmin'] = d.zmin;\n    curve['zmax'] = d.zmax;\n    curve['xAxisKey'] = xAxisParam;\n    curve['yAxisKey'] = yAxisParam;\n    const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n        begin: postQueryStartMoment.format(),\n        finish: postQueryFinishMoment.format(),\n        duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n\n    // process the data returned by the query\n    const curveInfoParams = {\"curve\": curves, \"axisMap\": axisMap};\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataContourDiff = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.contourDiff;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    if (curvesLength !== 2) {\n        throw new Error(\"INFO:  There must be two added curves.\");\n    }\n    if (curves[0]['x-axis-parameter'] !== curves[1]['x-axis-parameter'] || curves[0]['y-axis-parameter'] !== curves[1]['y-axis-parameter']) {\n        throw new Error(\"INFO:  The x-axis-parameter and y-axis-parameter must be consistent across both curves.\");\n    }\n    var dataset = [];\n    var axisMap = Object.create(null);\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var label = curve['label'];\n        var xAxisParam = curve['x-axis-parameter'];\n        var yAxisParam = curve['y-axis-parameter'];\n        var xValClause = matsCollections.CurveParams.findOne({name: 'x-axis-parameter'}).optionsMap[xAxisParam];\n        var yValClause = matsCollections.CurveParams.findOne({name: 'y-axis-parameter'}).optionsMap[yAxisParam];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var validTimeClause = \"\";\n        var thresholdClause = \"\";\n        var forecastLengthClause = \"\";\n        var dateClause = \"\";\n        if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n            var forecastLength = curve['forecast-length'];\n            forecastLengthClause = \"and m0.fcst_len = \" + forecastLength;\n        }\n        if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n            var thresholdStr = curve['threshold'];\n            var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n            threshold = threshold * 0.01;\n            thresholdClause = \"and m0.trsh = \" + threshold;\n        }\n        if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n            var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n            }\n        }\n        if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && (xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date')) {\n            dateClause = \"m0.time-m0.fcst_len*3600\";\n        } else {\n            dateClause = \"m0.time\";\n        }\n\n        // for two contours it's faster to just take care of matching in the query\n        var matchModel = \"\";\n        var matchDates = \"\";\n        var matchThresholdClause = \"\";\n        var matchValidTimeClause = \"\";\n        var matchForecastLengthClause = \"\";\n        var matchClause = \"\";\n        if (matching) {\n            const otherCurveIndex = curveIndex === 0 ? 1 : 0;\n            const otherModel = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curves[otherCurveIndex]['data-source']][0];\n            const otherRegion = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === curves[otherCurveIndex]['region']);\n\n            matchModel = \", \" + otherModel + \"_\" + otherRegion + \" as a0\";\n            const matchDateClause = dateClause.split('m0').join('a0');\n            matchDates = \"and \" + matchDateClause + \" >= '\" + fromSecs + \"' and \" + matchDateClause + \" <= '\" + toSecs + \"'\";\n            matchClause = \"and m0.time = a0.time\";\n\n            if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n                var matchForecastLength = curves[otherCurveIndex]['forecast-length'];\n                matchForecastLengthClause = \"and a0.fcst_len = \" + matchForecastLength;\n            } else {\n                matchForecastLengthClause = \"and m0.fcst_len = a0.fcst_len\";\n            }\n            if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n                var matchThreshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === curves[otherCurveIndex]['threshold']);\n                matchThresholdClause = \"and a0.thresh = \" + matchThreshold;\n            } else {\n                matchThresholdClause = \"and m0.thresh = a0.thresh\";\n            }\n            if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n                var matchValidTimes = curves[otherCurveIndex]['valid-time'] === undefined ? [] : curves[otherCurveIndex]['valid-time'];\n                if (matchValidTimes.length > 0 && matchValidTimes !== matsTypes.InputTypes.unused) {\n                    matchValidTimeClause = \" and a0.time%(24*3600)/3600 IN(\" + matchValidTimes + \")\";\n                }\n            }\n        }\n\n        // For contours, this functions as the colorbar label.\n        curves[curveIndex]['unitKey'] = statisticOptionsMap[statisticSelect][1];\n\n        var d;\n        // this is a database driven curve, not a difference curve\n        // prepare the query from the above parameters\n        var statement = \"{{xValClause}} \" +\n            \"{{yValClause}} \" +\n            \"count(distinct {{dateClause}}) as N_times, \" +\n            \"min({{dateClause}}) as min_secs, \" +\n            \"max({{dateClause}}) as max_secs, \" +\n            \"{{statistic}} \" +\n            \"from {{data_source}} as m0{{matchModel}} \" +\n            \"where 1=1 \" +\n            \"{{matchClause}} \" +\n            \"and {{dateClause}} >= '{{fromSecs}}' \" +\n            \"and {{dateClause}} <= '{{toSecs}}' \" +\n            \"{{matchDates}} \" +\n            \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n            \"{{thresholdClause}} \" +\n            \"{{matchThresholdClause}} \" +\n            \"{{validTimeClause}} \" +\n            \"{{matchValidTimeClause}} \" +\n            \"{{forecastLengthClause}} \" +\n            \"{{matchForecastLengthClause}} \" +\n            \"group by xVal,yVal \" +\n            \"order by xVal,yVal\" +\n            \";\";\n\n        statement = statement.replace('{{xValClause}}', xValClause);\n        statement = statement.replace('{{yValClause}}', yValClause);\n        statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n        statement = statement.replace('{{matchModel}}', matchModel);\n        statement = statement.replace('{{statistic}}', statistic);\n        statement = statement.replace('{{threshold}}', threshold);\n        statement = statement.replace('{{fromSecs}}', fromSecs);\n        statement = statement.replace('{{toSecs}}', toSecs);\n        statement = statement.replace('{{matchDates}}', matchDates);\n        statement = statement.replace('{{matchClause}}', matchClause);\n        statement = statement.replace('{{thresholdClause}}', thresholdClause);\n        statement = statement.replace('{{matchThresholdClause}}', matchThresholdClause);\n        statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n        statement = statement.replace('{{matchForecastLengthClause}}', matchForecastLengthClause);\n        statement = statement.replace('{{validTimeClause}}', validTimeClause);\n        statement = statement.replace('{{matchValidTimeClause}}', matchValidTimeClause);\n        statement = statement.split('{{dateClause}}').join(dateClause);\n        dataRequests[curve.label] = statement;\n\n        // math is done on forecastLength later on -- set all analyses to 0\n        if (forecastLength === \"-99\") {\n            forecastLength = \"0\";\n        }\n\n        var queryResult;\n        var startMoment = moment();\n        var finishMoment;\n        try {\n            // send the query statement to the query function\n            queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n            finishMoment = moment();\n            dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                begin: startMoment.format(),\n                finish: finishMoment.format(),\n                duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                recordCount: queryResult.data.xTextOutput.length\n            };\n            // get the data back from the query\n            d = queryResult.data;\n        } catch (e) {\n            // this is an error produced by a bug in the query function, not an error returned by the mysql database\n            e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n            throw new Error(e.message);\n        }\n        if (queryResult.error !== undefined && queryResult.error !== \"\") {\n            if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                // this is NOT an error just a no data condition\n                dataFoundForCurve = false;\n            } else {\n                // this is an error returned by the mysql database\n                error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                throw (new Error(error));\n            }\n        }\n\n        var postQueryStartMoment = moment();\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.glob_stats.mean;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['zmin'] = d.zmin;\n        curve['zmax'] = d.zmax;\n        curve['xAxisKey'] = xAxisParam;\n        curve['yAxisKey'] = yAxisParam;\n        const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        };\n    }\n\n    // turn the two contours into one difference contour\n    dataset = matsDataDiffUtils.getDataForDiffContour(dataset);\n    plotParams.curves = matsDataUtils.getDiffContourCurveParams(plotParams.curves);\n    curves = plotParams.curves;\n\n    // process the data returned by the query\n    const curveInfoParams = {\"curve\": curves, \"axisMap\": axisMap};\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataDailyModelCycle = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.dailyModelCycle;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        threshold = threshold * 0.01;\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var utcCycleStart = Number(curve['utc-cycle-start']);\n        utcCycleStarts[curveIndex] = utcCycleStart;\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select m0.time as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.time >= {{fromSecs}} \" +\n                \"and m0.time <= {{toSecs}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = {{threshold}} \" +\n                \"and m0.fcst_len < 24 \" +\n                \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN({{utcCycleStart}}) \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{utcCycleStart}}', utcCycleStart);\n\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataDieOff = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.dieoff;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        threshold = threshold * 0.01;\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var forecastLengthStr = curve['dieoff-type'];\n        var forecastLengthOptionsMap = matsCollections.CurveParams.findOne({name: 'dieoff-type'}, {optionsMap: 1})['optionsMap'];\n        var forecastLength = forecastLengthOptionsMap[forecastLengthStr][0];\n        var validTimes;\n        var validTimeClause = \"\";\n        var utcCycleStart;\n        var utcCycleStartClause = \"\";\n        var dateRangeClause = \"and m0.time >= \" + fromSecs + \" and m0.time <= \" + toSecs;\n        if (forecastLength === matsTypes.ForecastTypes.dieoff) {\n            validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n            if (validTimes.length !== 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \"and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n            }\n        } else if (forecastLength === matsTypes.ForecastTypes.utcCycle) {\n            utcCycleStart = Number(curve['utc-cycle-start']);\n            utcCycleStartClause = \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN(\" + utcCycleStart + \")\";\n        } else {\n            dateRangeClause = \"and (m0.time - m0.fcst_len*3600) = \" + fromSecs;\n        }\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"SELECT m0.fcst_len AS avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"{{dateRangeClause}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = {{threshold}} \" +\n                \"{{validTimeClause}} \" +\n                \"{{utcCycleStartClause}} \" +\n                \"group by avtime \" +\n                \"order by avtime;\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{dateRangeClause}}', dateRangeClause);\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n            statement = statement.replace('{{utcCycleStartClause}}', utcCycleStartClause);\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataHistogram = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const plotType = matsTypes.PlotTypes.histogram;\n    const hasLevels = false;\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    var alreadyMatched = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = [];\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var allReturnedSubStats = [];\n    var allReturnedSubSecs = [];\n    var axisMap = Object.create(null);\n\n    // process user bin customizations\n    const binParams = matsDataUtils.setHistogramParameters(plotParams);\n    const yAxisFormat = binParams.yAxisFormat;\n    const binNum = binParams.binNum;\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        dataFoundForCurve[curveIndex] = true;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        threshold = threshold * 0.01;\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = yAxisFormat;\n        if (yAxisFormat === 'Relative frequency') {\n            axisKey = axisKey + \" (x100)\"\n        }\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        curves[curveIndex].binNum = binNum; // stash the binNum to use it later for bar chart options\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select m0.time as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"{{validTimeClause}} \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = '{{threshold}}' \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            var validTimeClause = \" \";\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n            }\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n                allReturnedSubStats.push(d.subVals); // save returned data so that we can calculate histogram stats once all the queries are done\n                allReturnedSubSecs.push(d.subSecs);\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve[curveIndex] = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n        }\n    }\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"dataFoundForCurve\": dataFoundForCurve,\n        \"axisMap\": axisMap,\n        \"yAxisFormat\": yAxisFormat\n    };\n    const bookkeepingParams = {\n        \"alreadyMatched\": alreadyMatched,\n        \"dataRequests\": dataRequests,\n        \"totalProcessingStart\": totalProcessingStart\n    };\n    var result = matsDataProcessUtils.processDataHistogram(allReturnedSubStats, allReturnedSubSecs, [], dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataSeries = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.timeSeries;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        threshold = threshold * 0.01;\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        var averageStr = curve['average'];\n        var averageOptionsMap = matsCollections.CurveParams.findOne({name: 'average'}, {optionsMap: 1})['optionsMap'];\n        var average = averageOptionsMap[averageStr][0];\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select {{average}} as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"{{validTimeClause}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = '{{threshold}}' \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{average}}', average);\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            var validTimeClause = \" \";\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\"\n            }\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n\n            dataRequests[curve.label] = statement;\n\n            // math is done on forecastLength later on -- set all analyses to 0\n            if (forecastLength === \"-99\") {\n                forecastLength = \"0\";\n            }\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBTimeSeries(sumPool, statement, data_source, forecastLength, fromSecs, toSecs, averageStr, validTimes, hasLevels, false);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataThreshold = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.threshold;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"SELECT m0.trsh as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"{{validTimeClause}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            var validTimeClause = \" \";\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\"\n            }\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataValidTime = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.validtime;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        threshold = threshold * 0.01;\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select floor(m0.time%(24*3600)/3600) as hr_of_day, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = '{{threshold}}' \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by hr_of_day \" +\n                \"order by hr_of_day\" +\n                \";\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {Meteor} from 'meteor/meteor';\nimport {mysql} from 'meteor/pcel:mysql';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsParamUtils} from 'meteor/randyp:mats-common';\n\n// determined in doCurveParanms\nvar minDate;\nvar maxDate;\nvar dstr;\n\nconst doPlotParams = function () {\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.PlotParams.remove({});\n    }\n    if (matsCollections.PlotParams.find().count() == 0) {\n        matsCollections.PlotParams.insert(\n            {\n                name: 'dates',\n                type: matsTypes.InputTypes.dateRange,\n                options: [''],\n                startDate: minDate,\n                stopDate: maxDate,\n                superiorNames: ['data-source'],\n                controlButtonCovered: true,\n                default: dstr,\n                controlButtonVisibility: 'block',\n                displayOrder: 1,\n                displayPriority: 1,\n                displayGroup: 1,\n                help: \"dateHelp.html\"\n            });\n\n        var plotFormats = {};\n        plotFormats[matsTypes.PlotFormats.matching] = 'show matching diffs';\n        plotFormats[matsTypes.PlotFormats.pairwise] = 'pairwise diffs';\n        plotFormats[matsTypes.PlotFormats.none] = 'no diffs';\n        matsCollections.PlotParams.insert(\n            {\n                name: 'plotFormat',\n                type: matsTypes.InputTypes.radioGroup,\n                optionsMap: plotFormats,\n                options: [matsTypes.PlotFormats.matching, matsTypes.PlotFormats.pairwise, matsTypes.PlotFormats.none],\n                default: matsTypes.PlotFormats.none,\n                controlButtonCovered: false,\n                controlButtonVisibility: 'block',\n                displayOrder: 1,\n                displayPriority: 1,\n                displayGroup: 3\n            });\n\n        var yAxisOptionsMap = {\n            \"Number\": [\"number\"],\n            \"Relative frequency\": [\"relFreq\"]\n        };\n        matsCollections.PlotParams.insert(\n            {\n                name: 'histogram-yaxis-controls',\n                type: matsTypes.InputTypes.select,\n                optionsMap: yAxisOptionsMap,\n                options: Object.keys(yAxisOptionsMap),\n                default: Object.keys(yAxisOptionsMap)[0],\n                controlButtonCovered: true,\n                controlButtonText: 'Y-axis mode',\n                displayOrder: 1,\n                displayPriority: 1,\n                displayGroup: 2\n            });\n\n        var binOptionsMap = {\n            \"Default bins\": [\"default\"],\n            \"Set number of bins\": [\"binNumber\"],\n            \"Make zero a bin bound\": [\"zeroBound\"],\n            \"Choose a bin bound\": [\"chooseBound\"],\n            \"Set number of bins and make zero a bin bound\": [\"binNumberWithZero\"],\n            \"Set number of bins and choose a bin bound\": [\"binNumberWithChosen\"],\n            \"Manual bins\": [\"manual\"],\n            \"Manual bin start, number, and stride\": [\"manualStride\"]\n        };\n        matsCollections.PlotParams.insert(\n            {\n                name: 'histogram-bin-controls',\n                type: matsTypes.InputTypes.select,\n                optionsMap: binOptionsMap,\n                options: Object.keys(binOptionsMap),\n                hideOtherFor: {\n                    'bin-number': [\"Default bins\", \"Make zero a bin bound\", \"Manual bins\", \"Choose a bin bound\"],\n                    'bin-pivot': [\"Default bins\", \"Set number of bins\", \"Make zero a bin bound\", \"Set number of bins and make zero a bin bound\", \"Manual bins\", \"Manual bin start, number, and stride\"],\n                    'bin-start': [\"Default bins\", \"Set number of bins\", \"Make zero a bin bound\", \"Choose a bin bound\", \"Set number of bins and make zero a bin bound\", \"Set number of bins and choose a bin bound\", \"Manual bins\"],\n                    'bin-stride': [\"Default bins\", \"Set number of bins\", \"Make zero a bin bound\", \"Choose a bin bound\", \"Set number of bins and make zero a bin bound\", \"Set number of bins and choose a bin bound\", \"Manual bins\"],\n                    'bin-bounds': [\"Default bins\", \"Set number of bins\", \"Make zero a bin bound\", \"Choose a bin bound\", \"Set number of bins and make zero a bin bound\", \"Set number of bins and choose a bin bound\", \"Manual bin start, number, and stride\"],\n                },\n                default: Object.keys(binOptionsMap)[0],\n                controlButtonCovered: true,\n                controlButtonText: 'customize bins',\n                displayOrder: 2,\n                displayPriority: 1,\n                displayGroup: 2\n            });\n\n        matsCollections.PlotParams.insert(\n            {\n                name: 'bin-number',\n                type: matsTypes.InputTypes.numberSpinner,\n                optionsMap: {},\n                options: [],   // convenience\n                min: '2',\n                max: '100',\n                step: 'any',\n                default: '12',\n                controlButtonCovered: true,\n                controlButtonText: \"number of bins\",\n                displayOrder: 3,\n                displayPriority: 1,\n                displayGroup: 2\n            });\n\n        matsCollections.PlotParams.insert(\n            {\n                name: 'bin-pivot',\n                type: matsTypes.InputTypes.numberSpinner,\n                optionsMap: {},\n                options: [],   // convenience\n                min: '-10000',\n                max: '10000',\n                step: 'any',\n                default: '0',\n                controlButtonCovered: true,\n                controlButtonText: \"bin pivot value\",\n                displayOrder: 4,\n                displayPriority: 1,\n                displayGroup: 2\n            });\n\n        matsCollections.PlotParams.insert(\n            {\n                name: 'bin-start',\n                type: matsTypes.InputTypes.numberSpinner,\n                optionsMap: {},\n                options: [],   // convenience\n                min: '-10000',\n                max: '10000',\n                step: 'any',\n                default: '0',\n                controlButtonCovered: true,\n                controlButtonText: \"bin start\",\n                displayOrder: 5,\n                displayPriority: 1,\n                displayGroup: 2\n            });\n\n        matsCollections.PlotParams.insert(\n            {\n                name: 'bin-stride',\n                type: matsTypes.InputTypes.numberSpinner,\n                optionsMap: {},\n                options: [],   // convenience\n                min: '-10000',\n                max: '10000',\n                step: 'any',\n                default: '0',\n                controlButtonCovered: true,\n                controlButtonText: \"bin stride\",\n                displayOrder: 6,\n                displayPriority: 1,\n                displayGroup: 2\n            });\n\n        matsCollections.PlotParams.insert(\n            {\n                name: 'bin-bounds',\n                type: matsTypes.InputTypes.textInput,\n                optionsMap: {},\n                options: [],   // convenience\n                default: ' ',\n                controlButtonCovered: true,\n                controlButtonText: \"bin bounds (enter numbers separated by commas)\",\n                displayOrder: 7,\n                displayPriority: 1,\n                displayGroup: 2\n            });\n    } else {\n        // need to update the dates selector if the metadata has changed\n        var currentParam = matsCollections.PlotParams.findOne({name: 'dates'});\n        if ((!matsDataUtils.areObjectsEqual(currentParam.startDate, minDate)) ||\n            (!matsDataUtils.areObjectsEqual(currentParam.stopDate, maxDate)) ||\n            (!matsDataUtils.areObjectsEqual(currentParam.default, dstr))) {\n            // have to reload model data\n            matsCollections.PlotParams.update({name: 'dates'}, {\n                $set: {\n                    startDate: minDate,\n                    stopDate: maxDate,\n                    default: dstr\n                }\n            });\n        }\n    }\n};\n\nconst doCurveParams = function () {\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.CurveParams.remove({});\n    }\n    var modelOptionsMap = {};\n    var modelDateRangeMap = {};\n    var regionModelOptionsMap = {};\n    var forecastLengthOptionsMap = {};\n    var thresholdsModelOptionsMap = {};\n    var scaleModelOptionsMap = {};\n    var sourceOptionsMap = {};\n    var masterRegionValuesMap = {};\n    var masterThresholdValuesMap = {};\n    var masterScaleValuesMap = {};\n\n    try {\n        const rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(metadataPool, \"SELECT short_name,description FROM region_descriptions;\");\n        var masterRegDescription;\n        var masterShortName;\n        for (var j = 0; j < rows.length; j++) {\n            masterRegDescription = rows[j].description.trim();\n            masterShortName = rows[j].short_name.trim();\n            masterRegionValuesMap[masterShortName] = masterRegDescription;\n        }\n    } catch (err) {\n        console.log(err.message);\n    }\n\n    try {\n        const rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(sumPool, \"SELECT trsh,description FROM threshold_descriptions;\");\n        var masterDescription;\n        var masterTrsh;\n        for (var j = 0; j < rows.length; j++) {\n            masterDescription = rows[j].description.trim();\n            masterTrsh = rows[j].trsh.trim();\n            masterThresholdValuesMap[masterTrsh] = masterDescription;\n        }\n    } catch (err) {\n        console.log(err.message);\n    }\n\n    try {\n        const rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(sumPool, \"SELECT scle,description FROM scale_descriptions;\");\n        var masterScaleDescription;\n        var masterScale;\n        for (var j = 0; j < rows.length; j++) {\n            masterScaleDescription = rows[j].description.trim();\n            masterScale = rows[j].scle.trim();\n            masterScaleValuesMap[masterScale] = masterScaleDescription;\n        }\n    } catch (err) {\n        console.log(err.message);\n    }\n\n    try {\n        const rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(sumPool, \"select model,regions,sources,display_text,fcst_lens,thresh,scale,mindate,maxdate from regions_per_model_mats_all_categories order by display_category, display_order;\");\n        for (var i = 0; i < rows.length; i++) {\n\n            var model_value = rows[i].model.trim();\n            var model = rows[i].display_text.trim();\n            modelOptionsMap[model] = [model_value];\n\n            var rowMinDate = moment.utc(rows[i].mindate * 1000).format(\"MM/DD/YYYY HH:mm\");\n            var rowMaxDate = moment.utc(rows[i].maxdate * 1000).format(\"MM/DD/YYYY HH:mm\");\n            modelDateRangeMap[model] = {minDate: rowMinDate, maxDate: rowMaxDate};\n\n            var sources = rows[i].sources;\n            var sourceArr = sources.split(',').map(Function.prototype.call, String.prototype.trim);\n            for (var j = 0; j < sourceArr.length; j++) {\n                sourceArr[j] = sourceArr[j].replace(/'|\\[|\\]/g, \"\");\n            }\n            sourceOptionsMap[model] = sourceArr;\n\n            var forecastLengths = rows[i].fcst_lens;\n            var forecastLengthArr = forecastLengths.split(',').map(Function.prototype.call, String.prototype.trim);\n            for (var j = 0; j < forecastLengthArr.length; j++) {\n                forecastLengthArr[j] = forecastLengthArr[j].replace(/'|\\[|\\]/g, \"\");\n            }\n            forecastLengthOptionsMap[model] = forecastLengthArr;\n\n            var thresholds = rows[i].thresh;\n            var thresholdsArrRaw = thresholds.split(',').map(Function.prototype.call, String.prototype.trim);\n            var thresholdsArr = [];\n            var dummyThresh;\n            for (var j = 0; j < thresholdsArrRaw.length; j++) {\n                dummyThresh = thresholdsArrRaw[j].replace(/'|\\[|\\]/g, \"\");\n                thresholdsArr.push(masterThresholdValuesMap[dummyThresh]);\n            }\n            thresholdsModelOptionsMap[model] = thresholdsArr;\n\n            var regions = rows[i].regions;\n            var regionsArrRaw = regions.split(',').map(Function.prototype.call, String.prototype.trim);\n            var regionsArr = [];\n            var dummyRegion;\n            for (var j = 0; j < regionsArrRaw.length; j++) {\n                dummyRegion = regionsArrRaw[j].replace(/'|\\[|\\]/g, \"\");\n                regionsArr.push(masterRegionValuesMap[dummyRegion]);\n            }\n            regionModelOptionsMap[model] = regionsArr;\n\n            var scales = rows[i].scale;\n            var scalesArrRaw = scales.split(',').map(Function.prototype.call, String.prototype.trim);\n            var scalesArr = [];\n            var dummyScale;\n            for (var j = 0; j < scalesArrRaw.length; j++) {\n                dummyScale = scalesArrRaw[j].replace(/'|\\[|\\]/g, \"\");\n                scalesArr.push(masterScaleValuesMap[dummyScale]);\n            }\n            scaleModelOptionsMap[model] = scalesArr;\n        }\n\n    } catch (err) {\n        console.log(err.message);\n    }\n\n    if (matsCollections.CurveParams.find({name: 'label'}).count() == 0) {\n        matsCollections.CurveParams.insert(\n            {\n                name: 'label',\n                type: matsTypes.InputTypes.textInput,\n                optionsMap: {},\n                options: [],   // convenience\n                controlButtonCovered: true,\n                default: '',\n                unique: true,\n                controlButtonVisibility: 'block',\n                displayOrder: 1,\n                displayPriority: 1,\n                displayGroup: 1,\n                help: 'label.html'\n            }\n        );\n    }\n\n    if (matsCollections.CurveParams.find({name: 'data-source'}).count() == 0) {\n        matsCollections.CurveParams.insert(\n            {\n                name: 'data-source',\n                type: matsTypes.InputTypes.select,\n                optionsMap: modelOptionsMap,\n                dates: modelDateRangeMap,\n                options: Object.keys(modelOptionsMap),   // convenience\n                dependentNames: [\"region\", \"forecast-length\", \"threshold\", \"scale\", \"truth\", \"dates\", \"curve-dates\"],\n                controlButtonCovered: true,\n                default: Object.keys(modelOptionsMap)[0],\n                unique: false,\n                controlButtonVisibility: 'block',\n                displayOrder: 2,\n                displayPriority: 1,\n                displayGroup: 1\n            });\n    } else {\n        // it is defined but check for necessary update\n        var currentParam = matsCollections.CurveParams.findOne({name: 'data-source'});\n        if (!matsDataUtils.areObjectsEqual(currentParam.optionsMap, modelOptionsMap) ||\n            (!matsDataUtils.areObjectsEqual(currentParam.dates, modelDateRangeMap))) {\n            // have to reload model data\n            matsCollections.CurveParams.update({name: 'data-source'}, {\n                $set: {\n                    optionsMap: modelOptionsMap,\n                    dates: modelDateRangeMap,\n                    options: Object.keys(modelOptionsMap),\n                    default: Object.keys(modelOptionsMap)[0]\n                }\n            });\n        }\n    }\n\n    if (matsCollections.CurveParams.find({name: 'region'}).count() == 0) {\n        matsCollections.CurveParams.insert(\n            {\n                name: 'region',\n                type: matsTypes.InputTypes.select,\n                optionsMap: regionModelOptionsMap,\n                options: regionModelOptionsMap[Object.keys(regionModelOptionsMap)[0]],   // convenience\n                valuesMap: masterRegionValuesMap,\n                superiorNames: ['data-source'],\n                controlButtonCovered: true,\n                unique: false,\n                default: regionModelOptionsMap[Object.keys(regionModelOptionsMap)[0]][0],\n                controlButtonVisibility: 'block',\n                displayOrder: 3,\n                displayPriority: 1,\n                displayGroup: 1\n            });\n    } else {\n        // it is defined but check for necessary update\n        var currentParam = matsCollections.CurveParams.findOne({name: 'region'});\n        if ((!matsDataUtils.areObjectsEqual(currentParam.optionsMap, regionModelOptionsMap)) ||\n            (!matsDataUtils.areObjectsEqual(currentParam.valuesMap, masterRegionValuesMap))) {\n            // have to reload model data\n            matsCollections.CurveParams.update({name: 'region'}, {\n                $set: {\n                    optionsMap: regionModelOptionsMap,\n                    valuesMap: masterRegionValuesMap,\n                    options: regionModelOptionsMap[Object.keys(regionModelOptionsMap)[0]],\n                    default: regionModelOptionsMap[Object.keys(regionModelOptionsMap)[0]][0]\n                }\n            });\n        }\n    }\n\n    if (matsCollections.CurveParams.find({name: 'statistic'}).count() == 0) {\n        var optionsMap = {\n            'TSS (True Skill Score)': ['((sum(m0.hit)*sum(m0.cn) - sum(m0.fa)*sum(m0.miss))/((sum(m0.hit)+sum(m0.miss))*(sum(m0.fa)+sum(m0.cn)))) * 100 as stat, group_concat(((m0.hit*m0.cn - m0.fa*m0.miss)/((m0.hit+m0.miss)*(m0.fa+m0.cn))) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n\n            'PODy (POD of precip > threshold)': ['((sum(m0.hit)+0.00)/sum(m0.hit+m0.miss)) * 100 as stat, group_concat(((m0.hit)/(m0.hit+m0.miss)) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n\n            'PODn (POD of precip < threshold)': ['((sum(m0.cn)+0.00)/sum(m0.cn+m0.fa)) * 100 as stat, group_concat(((m0.cn)/(m0.cn+m0.fa)) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n\n            'FAR (False Alarm Ratio)': ['((sum(m0.fa)+0.00)/sum(m0.fa+m0.hit)) * 100 as stat, group_concat(((m0.fa)/(m0.fa+m0.hit)) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 0],\n\n            'Bias (forecast/actual)': ['((sum(m0.hit+m0.fa)+0.00)/sum(m0.hit+m0.miss)) as stat, group_concat(((m0.hit+m0.fa)/(m0.hit+m0.miss)), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Ratio', 1],\n\n            'CSI (Critical Success Index)': ['((sum(m0.hit)+0.00)/sum(m0.hit+m0.miss+m0.fa)) * 100 as stat, group_concat(((m0.hit)/(m0.hit+m0.miss+m0.fa)) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n\n            'HSS (Heidke Skill Score)': ['(2*(sum(m0.cn+0.00)*sum(m0.hit)-sum(m0.miss)*sum(m0.fa))/((sum(m0.cn+0.00)+sum(m0.fa))*(sum(m0.fa)+sum(m0.hit))+(sum(m0.cn+0.00)+sum(m0.miss))*(sum(m0.miss)+sum(m0.hit)))) * 100 as stat, group_concat((2*(m0.cn*m0.hit - m0.miss*m0.fa) / ((m0.cn+m0.fa)*(m0.fa+m0.hit) + (m0.cn+m0.miss)*(m0.miss+m0.hit))) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n\n            'ETS (Equitable Threat Score)': ['(sum(m0.hit)-(sum(m0.hit+m0.fa)*sum(m0.hit+m0.miss)/sum(m0.hit+m0.fa+m0.miss+m0.cn)))/(sum(m0.hit+m0.fa+m0.miss)-(sum(m0.hit+m0.fa)*sum(m0.hit+m0.miss)/sum(m0.hit+m0.fa+m0.miss+m0.cn))) * 100 as stat, group_concat((m0.hit-((m0.hit+m0.fa)*(m0.hit+m0.miss)/(m0.hit+m0.fa+m0.miss+m0.cn)))/((m0.hit+m0.fa+m0.miss)-((m0.hit+m0.fa)*(m0.hit+m0.miss)/(m0.hit+m0.fa+m0.miss+m0.cn))) * 100, \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'x100', 100],\n\n            'Nlow (obs < threshold, avg per hr)': ['avg(m0.cn+m0.fa+0.000) as stat, group_concat((m0.cn+m0.fa), \";\", m0.time order by m0.time) as sub_data, count(m0.cn) as N0', 'Number', null],\n\n            'Nhigh (obs > threshold, avg per hr)': ['avg(m0.hit+m0.miss+0.000) as stat, group_concat((m0.hit+m0.miss), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Number', null],\n\n            'Ntot (total obs, avg per hr)': ['avg(m0.hit+m0.fa+m0.miss+m0.cn+0.000) as stat, group_concat((m0.hit+m0.fa+m0.miss+m0.cn), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Number', null],\n\n            'Ratio (Nlow / Ntot)': ['(sum(m0.cn+m0.fa+0.000)/sum(m0.hit+m0.fa+m0.miss+m0.cn+0.000)) as stat, group_concat(((m0.cn+m0.fa)/(m0.hit+m0.fa+m0.miss+m0.cn)), \";\", m0.time order by m0.time) as sub_data, count(m0.cn) as N0', 'Ratio', null],\n\n            'Ratio (Nhigh / Ntot)': ['(sum(m0.hit+m0.miss+0.000)/sum(m0.hit+m0.fa+m0.miss+m0.cn+0.000)) as stat, group_concat(((m0.hit+m0.miss)/(m0.hit+m0.fa+m0.miss+m0.cn)), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Ratio', null],\n\n            'N in average (to nearest 100)': ['sum(m0.hit+m0.miss+m0.fa+m0.cn+0.000) as stat, group_concat((m0.hit+m0.miss+m0.fa+m0.cn), \";\", m0.time order by m0.time) as sub_data, count(m0.hit) as N0', 'Number', null]\n        };\n        matsCollections.CurveParams.insert(\n            {\n                name: 'statistic',\n                type: matsTypes.InputTypes.select,\n                optionsMap: optionsMap,\n                options: Object.keys(optionsMap),   // convenience\n                controlButtonCovered: true,\n                unique: false,\n                default: Object.keys(optionsMap)[0],\n                controlButtonVisibility: 'block',\n                displayOrder: 1,\n                displayPriority: 1,\n                displayGroup: 2\n            });\n    }\n\n    if (matsCollections.CurveParams.find({name: 'threshold'}).count() == 0) {\n        matsCollections.CurveParams.insert(\n            {\n                name: 'threshold',\n                type: matsTypes.InputTypes.select,\n                optionsMap: thresholdsModelOptionsMap,\n                options: thresholdsModelOptionsMap[Object.keys(thresholdsModelOptionsMap)[0]],   // convenience\n                valuesMap: masterThresholdValuesMap,\n                superiorNames: ['data-source'],\n                controlButtonCovered: true,\n                unique: false,\n                default: thresholdsModelOptionsMap[Object.keys(thresholdsModelOptionsMap)[0]][0],\n                controlButtonVisibility: 'block',\n                displayOrder: 2,\n                displayPriority: 1,\n                displayGroup: 2\n            });\n    } else {\n        // it is defined but check for necessary update\n        var currentParam = matsCollections.CurveParams.findOne({name: 'threshold'});\n        if ((!matsDataUtils.areObjectsEqual(currentParam.optionsMap, thresholdsModelOptionsMap)) ||\n            (!matsDataUtils.areObjectsEqual(currentParam.valuesMap, masterThresholdValuesMap))) {\n            // have to reload model data\n            matsCollections.CurveParams.update({name: 'threshold'}, {\n                $set: {\n                    optionsMap: thresholdsModelOptionsMap,\n                    valuesMap: masterThresholdValuesMap,\n                    options: thresholdsModelOptionsMap[Object.keys(thresholdsModelOptionsMap)[0]],\n                    default: thresholdsModelOptionsMap[Object.keys(thresholdsModelOptionsMap)[0]][0]\n                }\n            });\n        }\n    }\n\n    if (matsCollections.CurveParams.find({name: 'average'}).count() == 0) {\n        optionsMap = {\n            'None': ['m0.time'],\n            '3hr': ['ceil(10800*floor(m0.time/10800)+10800/2)'],\n            '6hr': ['ceil(21600*floor(m0.time/21600)+21600/2)'],\n            '12hr': ['ceil(43200*floor(m0.time/43200)+43200/2)'],\n            '1D': ['ceil(86400*floor(m0.time/86400)+86400/2)'],\n            '3D': ['ceil(259200*floor(m0.time/259200)+259200/2)'],\n            '7D': ['ceil(604800*floor(m0.time/604800)+604800/2)'],\n            '30D': ['ceil(2592000*floor(m0.time/2592000)+2592000/2)'],\n            '60D': ['ceil(5184000*floor(m0.time/5184000)+5184000/2)']\n        };\n\n        matsCollections.CurveParams.insert(\n            {\n                name: 'average',\n                type: matsTypes.InputTypes.select,\n                optionsMap: optionsMap,\n                options: Object.keys(optionsMap),   // convenience\n                controlButtonCovered: true,\n                unique: false,\n                selected: 'None',\n                default: 'None',\n                controlButtonVisibility: 'block',\n                displayOrder: 1,\n                displayPriority: 1,\n                displayGroup: 3\n            });\n    }\n\n    if (matsCollections.CurveParams.find({name: 'forecast-length'}).count() == 0) {\n        matsCollections.CurveParams.insert(\n            {\n                name: 'forecast-length',\n                type: matsTypes.InputTypes.select,\n                optionsMap: forecastLengthOptionsMap,\n                options: forecastLengthOptionsMap[Object.keys(forecastLengthOptionsMap)[0]],   // convenience\n                superiorNames: ['data-source'],\n                selected: '',\n                controlButtonCovered: true,\n                unique: false,\n                default: 6,\n                controlButtonVisibility: 'block',\n                controlButtonText: \"forecast lead time\",\n                displayOrder: 2,\n                displayPriority: 1,\n                displayGroup: 3\n            });\n    } else {\n        // it is defined but check for necessary update\n        var currentParam = matsCollections.CurveParams.findOne({name: 'forecast-length'});\n        if (!matsDataUtils.areObjectsEqual(currentParam.optionsMap, forecastLengthOptionsMap)) {\n            // have to reload model data\n            matsCollections.CurveParams.update({name: 'forecast-length'}, {\n                $set: {\n                    optionsMap: forecastLengthOptionsMap,\n                    options: forecastLengthOptionsMap[Object.keys(forecastLengthOptionsMap)[0]]\n                }\n            });\n        }\n    }\n\n    if (matsCollections.CurveParams.find({name: 'dieoff-type'}).count() == 0) {\n        var dieoffOptionsMap = {\n            \"Dieoff\": [matsTypes.ForecastTypes.dieoff],\n            \"Dieoff for a specified UTC cycle init hour\": [matsTypes.ForecastTypes.utcCycle],\n            \"Single cycle forecast (uses first date in range)\": [matsTypes.ForecastTypes.singleCycle]\n        };\n        matsCollections.CurveParams.insert(\n            {\n                name: 'dieoff-type',\n                type: matsTypes.InputTypes.select,\n                optionsMap: dieoffOptionsMap,\n                options: Object.keys(dieoffOptionsMap),\n                hideOtherFor: {\n                    'valid-time': [\"Dieoff for a specified UTC cycle init hour\", \"Single cycle forecast (uses first date in range)\"],\n                    'utc-cycle-start': [\"Dieoff\", \"Single cycle forecast (uses first date in range)\"],\n                },\n                selected: '',\n                controlButtonCovered: true,\n                unique: false,\n                default: Object.keys(dieoffOptionsMap)[0],\n                controlButtonVisibility: 'block',\n                controlButtonText: 'dieoff type',\n                displayOrder: 2,\n                displayPriority: 1,\n                displayGroup: 3\n            });\n    }\n\n    if (matsCollections.CurveParams.find({name: 'valid-time'}).count() == 0) {\n        matsCollections.CurveParams.insert(\n            {\n                name: 'valid-time',\n                type: matsTypes.InputTypes.select,\n                options: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'],\n                selected: [],\n                controlButtonCovered: true,\n                unique: false,\n                default: matsTypes.InputTypes.unused,\n                controlButtonVisibility: 'block',\n                controlButtonText: \"valid utc hour\",\n                displayOrder: 3,\n                displayPriority: 1,\n                displayGroup: 3,\n                multiple: true\n            });\n    }\n\n    if (matsCollections.CurveParams.find({name: 'utc-cycle-start'}).count() == 0) {\n\n        const optionsArr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'];\n\n        matsCollections.CurveParams.insert(\n            {\n                name: 'utc-cycle-start',\n                type: matsTypes.InputTypes.select,\n                options: optionsArr,\n                selected: '',\n                controlButtonCovered: true,\n                unique: false,\n                default: optionsArr[12],\n                controlButtonVisibility: 'block',\n                controlButtonText: \"utc cycle init hour\",\n                displayOrder: 3,\n                displayPriority: 1,\n                displayGroup: 3,\n            });\n    }\n\n    if (matsCollections.CurveParams.find({name: 'truth'}).count() == 0) {\n        matsCollections.CurveParams.insert(\n            {\n                name: 'truth',\n                type: matsTypes.InputTypes.select,\n                optionsMap: sourceOptionsMap,\n                options: sourceOptionsMap[Object.keys(sourceOptionsMap)[0]],\n                superiorNames: ['data-source'],\n                controlButtonCovered: true,\n                unique: false,\n                default: sourceOptionsMap[Object.keys(sourceOptionsMap)[0]][0],\n                controlButtonVisibility: 'block',\n                displayOrder: 1,\n                displayPriority: 1,\n                displayGroup: 4\n            });\n    } else {\n        // it is defined but check for necessary update\n        var currentParam = matsCollections.CurveParams.findOne({name: 'truth'});\n        if (!matsDataUtils.areObjectsEqual(currentParam.optionsMap, sourceOptionsMap)) {\n            // have to reload model data\n            matsCollections.CurveParams.update({name: 'truth'}, {\n                $set: {\n                    optionsMap: sourceOptionsMap,\n                    options: sourceOptionsMap[Object.keys(sourceOptionsMap)[0]],\n                    default: sourceOptionsMap[Object.keys(sourceOptionsMap)[0]][0]\n                }\n            });\n        }\n    }\n\n    if (matsCollections.CurveParams.find({name: 'scale'}).count() == 0) {\n        matsCollections.CurveParams.insert(\n            {// bias and model average are a different formula for wind (element 0 differs from element 1)\n                // but stays the same (element 0 and element 1 are the same) otherwise.\n                // When plotting profiles we append element 2 to whichever element was chosen (for wind variable). For\n                // time series we never append element 2. Element 3 is used to give us error values for error bars.\n                name: 'scale',\n                type: matsTypes.InputTypes.select,\n                optionsMap: scaleModelOptionsMap,\n                options: scaleModelOptionsMap[Object.keys(scaleModelOptionsMap)[0]],   // convenience\n                valuesMap: masterScaleValuesMap,\n                superiorNames: ['data-source'],\n                controlButtonCovered: true,\n                unique: false,\n                default: scaleModelOptionsMap[Object.keys(scaleModelOptionsMap)[0]][0],\n                controlButtonVisibility: 'block',\n                displayOrder: 3,\n                displayPriority: 1,\n                displayGroup: 3\n            });\n    } else {\n        // it is defined but check for necessary update\n        var currentParam = matsCollections.CurveParams.findOne({name: 'scale'});\n        if ((!matsDataUtils.areObjectsEqual(currentParam.optionsMap, scaleModelOptionsMap)) ||\n            (!matsDataUtils.areObjectsEqual(currentParam.valuesMap, masterScaleValuesMap))) {\n            // have to reload model data\n            matsCollections.CurveParams.update({name: 'scale'}, {\n                $set: {\n                    optionsMap: scaleModelOptionsMap,\n                    valuesMap: masterScaleValuesMap,\n                    options: scaleModelOptionsMap[Object.keys(scaleModelOptionsMap)[0]],\n                    default: scaleModelOptionsMap[Object.keys(scaleModelOptionsMap)[0]][0]\n                }\n            });\n        }\n\n    }\n\n    if (matsCollections.CurveParams.find({name: 'x-axis-parameter'}).count() == 0) {\n\n        const optionsMap = {\n            'Fcst lead time': \"select m0.fcst_len as xVal, \",\n            'Threshold': \"select m0.thresh/100 as xVal, \",\n            'Valid UTC hour': \"select m0.time%(24*3600)/3600 as xVal, \",\n            'Init UTC hour': \"select (m0.time-m0.fcst_len*3600)%(24*3600)/3600 as xVal, \",\n            'Valid Date': \"select m0.time as xVal, \",\n            'Init Date': \"select m0.time-m0.fcst_len*3600 as xVal, \"\n        };\n\n        matsCollections.CurveParams.insert(\n            {\n                name: 'x-axis-parameter',\n                type: matsTypes.InputTypes.select,\n                options: Object.keys(optionsMap),\n                optionsMap: optionsMap,\n                // hideOtherFor: {\n                //     'forecast-length': [\"Fcst lead time\"],\n                //     'valid-time': [\"Valid UTC hour\"],\n                //     'pres-level': [\"Pressure level\"],\n                // },\n                selected: '',\n                controlButtonCovered: true,\n                unique: false,\n                default: Object.keys(optionsMap)[2],\n                controlButtonVisibility: 'block',\n                displayOrder: 1,\n                displayPriority: 1,\n                displayGroup: 5,\n            });\n    }\n\n    if (matsCollections.CurveParams.find({name: 'y-axis-parameter'}).count() == 0) {\n\n        const optionsMap = {\n            'Fcst lead time': \"m0.fcst_len as yVal, \",\n            'Threshold': \"m0.thresh/100 as yVal, \",\n            'Valid UTC hour': \"m0.time%(24*3600)/3600 as yVal, \",\n            'Init UTC hour': \"(m0.time-m0.fcst_len*3600)%(24*3600)/3600 as yVal, \",\n            'Valid Date': \"m0.time as yVal, \",\n            'Init Date': \"m0.time-m0.fcst_len*3600 as yVal, \"\n        };\n\n        matsCollections.CurveParams.insert(\n            {\n                name: 'y-axis-parameter',\n                type: matsTypes.InputTypes.select,\n                options: Object.keys(optionsMap),\n                optionsMap: optionsMap,\n                // hideOtherFor: {\n                //     'forecast-length': [\"Fcst lead time\"],\n                //     'valid-time': [\"Valid UTC hour\"],\n                //     'pres-level': [\"Pressure level\"],\n                // },\n                selected: '',\n                controlButtonCovered: true,\n                unique: false,\n                default: Object.keys(optionsMap)[0],\n                controlButtonVisibility: 'block',\n                displayOrder: 2,\n                displayPriority: 1,\n                displayGroup: 5,\n            });\n    }\n\n    // determine date defaults for dates and curveDates\n    var defaultDataSource = matsCollections.CurveParams.findOne({name:\"data-source\"},{default:1}).default;\n    modelDateRangeMap = matsCollections.CurveParams.findOne({name:\"data-source\"},{dates:1}).dates;\n    minDate = modelDateRangeMap[defaultDataSource].minDate;\n    maxDate = modelDateRangeMap[defaultDataSource].maxDate;\n    var minusMonthMinDate = matsParamUtils.getMinMaxDates(minDate, maxDate).minDate;\n    dstr = minusMonthMinDate + ' - ' + maxDate;\n\n    if (matsCollections.CurveParams.find({name: 'curve-dates'}).count() == 0) {\n        optionsMap = {\n            '1 day': ['1 day'],\n            '3 days': ['3 days'],\n            '7 days': ['7 days'],\n            '31 days': ['31 days'],\n            '90 days': ['90 days'],\n            '180 days': ['180 days'],\n            '365 days': ['365 days']\n        };\n        matsCollections.CurveParams.insert(\n            {\n                name: 'curve-dates',\n                type: matsTypes.InputTypes.dateRange,\n                optionsMap: optionsMap,\n                options: Object.keys(optionsMap).sort(),\n                startDate: minDate,\n                stopDate: maxDate,\n                superiorNames: ['data-source'],\n                controlButtonCovered: true,\n                unique: false,\n                default: dstr,\n                controlButtonVisibility: 'block',\n                displayOrder: 1,\n                displayPriority: 1,\n                displayGroup: 6,\n                help: \"dateHelp.html\"\n            });\n    } else {\n        // it is defined but check for necessary update\n        var currentParam = matsCollections.CurveParams.findOne({name: 'curve-dates'});\n        if ((!matsDataUtils.areObjectsEqual(currentParam.startDate, minDate)) ||\n            (!matsDataUtils.areObjectsEqual(currentParam.stopDate, maxDate)) ||\n            (!matsDataUtils.areObjectsEqual(currentParam.default, dstr))) {\n            // have to reload model data\n            matsCollections.CurveParams.update({name: 'curve-dates'}, {\n                $set: {\n                    startDate: minDate,\n                    stopDate: maxDate,\n                    default: dstr\n                }\n            });\n        }\n    }\n};\n\n/* The format of a curveTextPattern is an array of arrays, each sub array has\n [labelString, localVariableName, delimiterString]  any of which can be null.\n Each sub array will be joined (the localVariableName is always dereferenced first)\n and then the sub arrays will be joined maintaining order.\n\n The curveTextPattern is found by its name which must match the corresponding PlotGraphFunctions.PlotType value.\n See curve_item.js and standAlone.js.\n */\nconst doCurveTextPatterns = function () {\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.CurveTextPatterns.remove({});\n    }\n    if (matsCollections.CurveTextPatterns.find().count() == 0) {\n        matsCollections.CurveTextPatterns.insert({\n            plotType: matsTypes.PlotTypes.timeSeries,\n            textPattern: [\n                ['', 'label', ': '],\n                ['', 'data-source', ' in '],\n                ['', 'region', ', '],\n                ['', 'threshold', ' '],\n                ['', 'scale', ', '],\n                ['', 'statistic', ', '],\n                ['fcst_len: ', 'forecast-length', 'h, '],\n                ['valid-time: ', 'valid-time', ', '],\n                ['avg: ', 'average', ', '],\n                ['', 'truth', ' ']\n            ],\n            displayParams: [\n                \"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"average\", \"forecast-length\", \"valid-time\", \"truth\"\n            ],\n            groupSize: 6\n\n        });\n        matsCollections.CurveTextPatterns.insert({\n            plotType: matsTypes.PlotTypes.dieoff,\n            textPattern: [\n                ['', 'label', ': '],\n                ['', 'data-source', ' in '],\n                ['', 'region', ', '],\n                ['', 'threshold', ' '],\n                ['', 'scale', ', '],\n                ['', 'statistic', ', '],\n                ['', 'dieoff-type', ', '],\n                ['valid-time: ', 'valid-time', ', '],\n                ['start utc: ', 'utc-cycle-start', ', '],\n                ['', 'truth', ', '],\n                ['', 'curve-dates', '']\n            ],\n            displayParams: [\n                \"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"dieoff-type\", \"valid-time\", \"utc-cycle-start\", \"truth\", \"curve-dates\"\n            ],\n            groupSize: 6\n        });\n        matsCollections.CurveTextPatterns.insert({\n            plotType: matsTypes.PlotTypes.threshold,\n            textPattern: [\n                ['', 'label', ': '],\n                ['', 'data-source', ' in '],\n                ['', 'region', ', '],\n                ['', 'scale', ', '],\n                ['', 'statistic', ', '],\n                ['fcst_len: ', 'forecast-length', 'h, '],\n                ['valid-time: ', 'valid-time', ', '],\n                ['', 'truth', ', '],\n                ['', 'curve-dates', '']\n            ],\n            displayParams: [\n                \"label\", \"data-source\", \"region\", \"statistic\", \"scale\", \"forecast-length\", \"valid-time\", \"truth\", \"curve-dates\"\n            ],\n            groupSize: 6\n        });\n        matsCollections.CurveTextPatterns.insert({\n            plotType: matsTypes.PlotTypes.validtime,\n            textPattern: [\n                ['', 'label', ': '],\n                ['', 'data-source', ' in '],\n                ['', 'region', ', '],\n                ['', 'threshold', ' '],\n                ['', 'scale', ', '],\n                ['', 'statistic', ', '],\n                ['fcst_len: ', 'forecast-length', 'h, '],\n                ['', 'truth', ', '],\n                ['', 'curve-dates', '']\n            ],\n            displayParams: [\n                \"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"forecast-length\", \"truth\", \"curve-dates\"\n            ],\n            groupSize: 6\n        });\n        matsCollections.CurveTextPatterns.insert({\n            plotType: matsTypes.PlotTypes.dailyModelCycle,\n            textPattern: [\n                ['', 'label', ': '],\n                ['', 'data-source', ' in '],\n                ['', 'region', ', '],\n                ['', 'threshold', ' '],\n                ['', 'scale', ', '],\n                ['', 'statistic', ', '],\n                ['start utc: ', 'utc-cycle-start', ', '],\n                ['', 'truth', ' ']\n            ],\n            displayParams: [\n                \"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"utc-cycle-start\", \"truth\"\n            ],\n            groupSize: 6\n        });\n        matsCollections.CurveTextPatterns.insert({\n            plotType: matsTypes.PlotTypes.histogram,\n            textPattern: [\n                ['', 'label', ': '],\n                ['', 'data-source', ' in '],\n                ['', 'region', ', '],\n                ['', 'threshold', ' '],\n                ['', 'scale', ', '],\n                ['', 'statistic', ', '],\n                ['fcst_len: ', 'forecast-length', 'h, '],\n                ['valid-time: ', 'valid-time', ', '],\n                ['', 'truth', ', '],\n                ['', 'curve-dates', '']\n            ],\n            displayParams: [\n                \"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"forecast-length\", \"valid-time\", \"truth\", \"curve-dates\"\n            ],\n            groupSize: 6\n        });\n        matsCollections.CurveTextPatterns.insert({\n            plotType: matsTypes.PlotTypes.contour,\n            textPattern: [\n                ['', 'label', ': '],\n                ['', 'data-source', ' in '],\n                ['', 'region', ', '],\n                ['', 'threshold', ' '],\n                ['', 'scale', ', '],\n                ['', 'statistic', ', '],\n                ['fcst_len: ', 'forecast-length', 'h, '],\n                ['valid-time: ', 'valid-time', ', '],\n                ['', 'truth', ', '],\n                ['x-axis: ', 'x-axis-parameter', ', '],\n                ['y-axis: ', 'y-axis-parameter', '']\n\n            ],\n            displayParams: [\n                \"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"forecast-length\", \"valid-time\", \"truth\", \"x-axis-parameter\", \"y-axis-parameter\"\n            ],\n            groupSize: 6\n\n        });\n        matsCollections.CurveTextPatterns.insert({\n            plotType: matsTypes.PlotTypes.contourDiff,\n            textPattern: [\n                ['', 'label', ': '],\n                ['', 'data-source', ' in '],\n                ['', 'region', ', '],\n                ['', 'threshold', ' '],\n                ['', 'scale', ', '],\n                ['', 'statistic', ', '],\n                ['fcst_len: ', 'forecast-length', 'h, '],\n                ['valid-time: ', 'valid-time', ', '],\n                ['', 'truth', ', '],\n                ['x-axis: ', 'x-axis-parameter', ', '],\n                ['y-axis: ', 'y-axis-parameter', '']\n\n            ],\n            displayParams: [\n                \"label\", \"data-source\", \"region\", \"statistic\", \"threshold\", \"scale\", \"forecast-length\", \"valid-time\", \"truth\", \"x-axis-parameter\", \"y-axis-parameter\"\n            ],\n            groupSize: 6\n\n        });\n    }\n};\n\nconst doSavedCurveParams = function () {\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.SavedCurveParams.remove({});\n    }\n    if (matsCollections.SavedCurveParams.find().count() == 0) {\n        matsCollections.SavedCurveParams.insert({clName: 'changeList', changeList: []});\n    }\n};\n\nconst doPlotGraph = function () {\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.PlotGraphFunctions.remove({});\n    }\n    if (matsCollections.PlotGraphFunctions.find().count() == 0) {\n        matsCollections.PlotGraphFunctions.insert({\n            plotType: matsTypes.PlotTypes.timeSeries,\n            graphFunction: \"graphPlotly\",\n            dataFunction: \"dataSeries\",\n            checked: true\n        });\n        matsCollections.PlotGraphFunctions.insert({\n            plotType: matsTypes.PlotTypes.dieoff,\n            graphFunction: \"graphPlotly\",\n            dataFunction: \"dataDieOff\",\n            checked: false\n        });\n        matsCollections.PlotGraphFunctions.insert({\n            plotType: matsTypes.PlotTypes.threshold,\n            graphFunction: \"graphPlotly\",\n            dataFunction: \"dataThreshold\",\n            checked: false\n        });\n        matsCollections.PlotGraphFunctions.insert({\n            plotType: matsTypes.PlotTypes.validtime,\n            graphFunction: \"graphPlotly\",\n            dataFunction: \"dataValidTime\",\n            checked: false\n        });\n        matsCollections.PlotGraphFunctions.insert({\n            plotType: matsTypes.PlotTypes.dailyModelCycle,\n            graphFunction: \"graphPlotly\",\n            dataFunction: \"dataDailyModelCycle\",\n            checked: false\n        });\n        matsCollections.PlotGraphFunctions.insert({\n            plotType: matsTypes.PlotTypes.histogram,\n            graphFunction: \"graphPlotly\",\n            dataFunction: \"dataHistogram\",\n            checked: false\n        });\n        matsCollections.PlotGraphFunctions.insert({\n            plotType: matsTypes.PlotTypes.contour,\n            graphFunction: \"graphPlotly\",\n            dataFunction: \"dataContour\",\n            checked: false\n        });\n        matsCollections.PlotGraphFunctions.insert({\n            plotType: matsTypes.PlotTypes.contourDiff,\n            graphFunction: \"graphPlotly\",\n            dataFunction: \"dataContourDiff\",\n            checked: false\n        });\n    }\n};\n\nMeteor.startup(function () {\n    matsCollections.Databases.remove({});\n    if (matsCollections.Databases.find().count() == 0) {\n        matsCollections.Databases.insert({\n            role: matsTypes.DatabaseRoles.SUMS_DATA,\n            status: \"active\",\n            host: 'wolphin.fsl.noaa.gov',\n            user: 'readonly',\n            password: 'ReadOnly@2016!',\n            database: 'precip_new',\n            connectionLimit: 10\n        });\n\n        matsCollections.Databases.insert({\n            role: matsTypes.DatabaseRoles.META_DATA,\n            status: \"active\",\n            host: 'wolphin.fsl.noaa.gov',\n            user: 'readonly',\n            password: 'ReadOnly@2016!',\n            database: 'mats_common',\n            connectionLimit: 10\n        });\n    }\n\n    const sumSettings = matsCollections.Databases.findOne({role: matsTypes.DatabaseRoles.SUMS_DATA, status: \"active\"}, {\n        host: 1,\n        user: 1,\n        password: 1,\n        database: 1,\n        connectionLimit: 1\n    });\n    // the pool is intended to be global\n    sumPool = mysql.createPool(sumSettings);\n    sumPool.on('connection', function (connection) {\n        connection.query('set group_concat_max_len = 4294967295')\n    });\n\n    const metadataSettings = matsCollections.Databases.findOne({role: matsTypes.DatabaseRoles.META_DATA, status: \"active\"}, {\n        host: 1,\n        user: 1,\n        password: 1,\n        database: 1,\n        connectionLimit: 1\n    });\n// the pool is intended to be global\n    metadataPool = mysql.createPool(metadataSettings);\n\n\n    const mdr = new matsTypes.MetaDataDBRecord(\"sumPool\", \"precip_new\", ['regions_per_model_mats_all_categories', 'threshold_descriptions', 'scale_descriptions']);\n    mdr.addRecord(\"metadataPool\", \"mats_common\", ['region_descriptions']);\n    matsMethods.resetApp({appMdr:mdr, appType:matsTypes.AppTypes.mats, app:'precipitation1hr'});\n});\n\n// this object is global so that the reset code can get to it\n// These are application specific mongo data - like curve params\n// The appSpecificResetRoutines object is a special name,\n// as is doCurveParams. The refreshMetaData mechanism depends on them being named that way.\nappSpecificResetRoutines = [\n    doPlotGraph,\n    doCurveParams,\n    doSavedCurveParams,\n    doPlotParams,\n    doCurveTextPatterns\n];\n"]}}]