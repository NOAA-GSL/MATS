[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"inter-process-messaging\":{\"inter-process-messaging.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/inter-process-messaging/inter-process-messaging.js               //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nconst uuid = require(\"uuid\");\n\nconst { encode, decode } = require(\"arson\");\n\nconst {\n  MESSAGE,\n  RESPONSE,\n  PING,\n  PONG,\n} = require(\"./types.js\");\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nObject.assign(exports, {\n  // Adds onMessage(topic, callback) and sendMessage(topic, payload)\n  // methods to otherProcess. These methods are an improvement over the\n  // native Node interfaces otherProcess.on(\"message\", callback) and\n  // otherProcess.send(message) because they take a topic string as their\n  // first argument, which allows restricting the delivery of messages by\n  // topic; and they permit the receiving process to respond by returning\n  // a value (possibly a Promise) from the onMessage callback.\n  enable(otherProcess) {\n    if (typeof otherProcess.onMessage === \"function\" &&\n        typeof otherProcess.sendMessage === \"function\") {\n      // Calling enable more than once should be safe/idempotent.\n      return otherProcess;\n    }\n\n    const callbacksByTopic = new Map;\n\n    // To receive messages *from* otherProcess, this process should call\n    // otherMessage.onMessage(topic, callback). The callback will receive\n    // the provided payload as its first (and only) parameter. Callbacks\n    // may return a Promise, in which case the response will be delayed\n    // until all results returned by callbacks registered for this topic\n    // have been resolved.\n    otherProcess.onMessage = function onMessage(topic, callback) {\n      if (! callbacksByTopic.has(topic)) {\n        callbacksByTopic.set(topic, new Set);\n      }\n      callbacksByTopic.get(topic).add(callback);\n    };\n\n    const readyResolvers = new Map;\n    const pendingMessages = new Map;\n    const promisesByTopic = new Map;\n    const handlersByType = Object.create(null);\n\n    handlersByType[PING] = function ({ id }) {\n      otherProcess.send({ type: PONG, id });\n    };\n\n    handlersByType[PONG] = function ({ id }) {\n      const resolve = readyResolvers.get(id);\n      if (typeof resolve === \"function\") {\n        readyResolvers.delete(id);\n        // This resolves the child.readyForMessages Promise created above.\n        resolve();\n      }\n    };\n\n    handlersByType[MESSAGE] = function ({\n      responseId,\n      topic,\n      encodedPayload,\n    }) {\n      const newPromise = (\n        promisesByTopic.get(topic) || Promise.resolve()\n      ).then(() => {\n        const results = [];\n        const callbacks = callbacksByTopic.get(topic);\n        if (callbacks && callbacks.size > 0) {\n          // Re-decode the payload for each callback to prevent one\n          // callback from modifying the payload seen by later callbacks.\n          callbacks.forEach(cb => results.push(cb(decode(encodedPayload))));\n          return Promise.all(results);\n        }\n        // Since there were no callbacks, this will be an empty array.\n        return results;\n      }).then(results => {\n        if (responseId) {\n          otherProcess.send({\n            type: RESPONSE,\n            responseId,\n            encodedResults: encode(results),\n          });\n        }\n      }, error => {\n        const serializable = {};\n\n        // Use Reflect.ownKeys to catch non-enumerable properties, since\n        // every Error property (including \"message\") seems to be\n        // non-enumerable by default.\n        Reflect.ownKeys(error).forEach(key => {\n          serializable[key] = error[key];\n        });\n\n        otherProcess.send({\n          type: RESPONSE,\n          responseId,\n          encodedError: encode(serializable),\n        });\n      });\n\n      // Immediately update the latest promise for this topic to the\n      // newPromise that we just created, before any listeners run. This\n      // strategy has the effect of chaining promises by topic and thus\n      // keeping messages and their responses strictly ordered, one after\n      // the last. Because we always register a non-throwing error handler\n      // at the end of newPromise, this queue of promises should never get\n      // stalled by an earlier rejection.\n      promisesByTopic.set(topic, newPromise);\n    };\n\n    handlersByType[RESPONSE] = function (message) {\n      const entry = pendingMessages.get(message.responseId);\n      if (entry) {\n        if (hasOwn.call(message, \"encodedError\")) {\n          entry.reject(decode(message.encodedError));\n        } else {\n          entry.resolve(decode(message.encodedResults));\n        }\n      }\n    };\n\n    otherProcess.on(\"message\", message => {\n      const handler = handlersByType[message.type];\n      if (typeof handler === \"function\") {\n        handler(message);\n      }\n    });\n\n    // Call otherProcess.sendMessage(topic, payload) instead of the native\n    // otherProcess.send(message) to deliver a message based on a specific\n    // topic string, and to receive a reliable response when the other\n    // process has finished handling that message.\n    otherProcess.sendMessage = function sendMessage(topic, payload) {\n      otherProcess.readyForMessages =\n        otherProcess.readyForMessages || makeReadyPromise();\n\n      return otherProcess.readyForMessages.then(() => {\n        const responseId = uuid();\n\n        return new Promise((resolve, reject) => {\n          pendingMessages.set(responseId, { resolve, reject });\n\n          otherProcess.send({\n            type: MESSAGE,\n            responseId,\n            topic,\n            encodedPayload: encode(payload),\n          }, error => {\n            if (error) {\n              reject(error);\n            }\n          });\n\n        }).then(response => {\n          pendingMessages.delete(responseId);\n          return response;\n\n        }, error => {\n          pendingMessages.delete(responseId);\n          throw error;\n        });\n      });\n    };\n\n    function makeReadyPromise() {\n      return new Promise((resolve, reject) => {\n        const pingMessage = { type: PING, id: uuid() };\n        const backoff_factor = 1.1;\n        let delay_ms = 50;\n\n        readyResolvers.set(pingMessage.id, resolve);\n\n        function poll() {\n          if (readyResolvers.has(pingMessage.id)) {\n            otherProcess.send(pingMessage, error => {\n              if (error) {\n                reject(error);\n              } else {\n                setTimeout(poll, delay_ms);\n                delay_ms *= backoff_factor;\n              }\n            });\n          }\n        }\n\n        poll();\n      });\n    }\n\n    otherProcess.on(\"exit\", (code, signal) => {\n      const error = new Error(\"process exited\");\n      Object.assign(error, { code, signal });\n\n      // Terminate any pending messages.\n      pendingMessages.forEach(entry => entry.reject(error));\n\n      // Prevent future messages from being sent.\n      otherProcess.readyForMessages = Promise.reject(error);\n\n      // Silence UnhandledPromiseRejectionWarning\n      otherProcess.readyForMessages.catch(() => {});\n    });\n\n    return otherProcess;\n  },\n\n  // Call this onMessage function to listen for messages *from the parent\n  // process* (if the parent spawned this process with an IPC channel).\n  onMessage(topic, callback) {\n    // Do nothing by default unless exports.enable(process) is called\n    // below, because this process will never receive any messages unless\n    // we have an IPC channel open with the parent process, which is true\n    // only if process.send is a function.\n  }\n});\n\nif (typeof process.send === \"function\") {\n  // The process.send method is defined only when the current process was\n  // spawned with an IPC channel by the parent process. In other words,\n  // given that process.send can be used to send messages to the parent\n  // process, it makes sense to enable process.sendMessage(topic, payload)\n  // in the child-to-parent direction, too.\n  exports.enable(process);\n\n  // Override the default no-op exports.onMessage defined above.\n  exports.onMessage = process.onMessage;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n},\"types.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/inter-process-messaging/types.js                                 //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nexports.MESSAGE = \"METEOR_IPC_MESSAGE\";\nexports.RESPONSE = \"METEOR_IPC_RESPONSE\";\nexports.PING = \"METEOR_IPC_PING\";\nexports.PONG = \"METEOR_IPC_PONG\";\n\n///////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"uuid\":{\"package.json\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// node_modules/meteor/inter-process-messaging/node_modules/uuid/package.jso //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmodule.exports = {\n  \"name\": \"uuid\",\n  \"version\": \"3.3.2\"\n};\n\n///////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// node_modules/meteor/inter-process-messaging/node_modules/uuid/index.js    //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmodule.useNode();\n///////////////////////////////////////////////////////////////////////////////\n\n}},\"arson\":{\"package.json\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// node_modules/meteor/inter-process-messaging/node_modules/arson/package.js //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmodule.exports = {\n  \"name\": \"arson\",\n  \"version\": \"0.2.6\",\n  \"main\": \"index.js\"\n};\n\n///////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// node_modules/meteor/inter-process-messaging/node_modules/arson/index.js   //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmodule.useNode();\n///////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/inter-process-messaging/inter-process-messaging.js\");\n\n/* Exports */\nPackage._define(\"inter-process-messaging\", exports);\n\n})();\n","servePath":"/packages/inter-process-messaging.js"}]