[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package['modules-runtime'].meteorInstall;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modules\":{\"client.js\":function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/modules/client.js                                                           //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nrequire(\"./install-packages.js\");\nrequire(\"./stubs.js\");\nrequire(\"./process.js\");\nrequire(\"./reify.js\");\n\nexports.addStyles = require(\"./css\").addStyles;\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n},\"css.js\":function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/modules/css.js                                                              //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nvar doc = document;\nvar head = doc.getElementsByTagName(\"head\").item(0);\n\nexports.addStyles = function (css) {\n  var style = doc.createElement(\"style\");\n\n  style.setAttribute(\"type\", \"text/css\");\n\n  // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx\n  var internetExplorerSheetObject =\n    style.sheet || // Edge/IE11.\n    style.styleSheet; // Older IEs.\n\n  if (internetExplorerSheetObject) {\n    internetExplorerSheetObject.cssText = css;\n  } else {\n    style.appendChild(doc.createTextNode(css));\n  }\n\n  return head.appendChild(style);\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n},\"install-packages.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/modules/install-packages.js                                                 //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nfunction install(name, mainModule) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n\n  if (typeof mainModule === \"string\") {\n    // Set up an alias from /node_modules/meteor/<package>.js to the main\n    // module, e.g. meteor/<package>/index.js.\n    meteorDir[name + \".js\"] = mainModule;\n  } else {\n    // back compat with old Meteor packages\n    meteorDir[name + \".js\"] = function (r, e, module) {\n      module.exports = Package[name];\n    };\n  }\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"modules-runtime\");\ninstall(\"modules\", \"meteor/modules/client.js\");\ninstall(\"modern-browsers\");\ninstall(\"babel-compiler\");\ninstall(\"ecmascript\");\ninstall(\"ecmascript-runtime\");\ninstall(\"babel-runtime\", \"meteor/babel-runtime/babel-runtime.js\");\ninstall(\"promise\", \"meteor/promise/client.js\");\ninstall(\"fetch\", \"meteor/fetch/modern.js\");\ninstall(\"dynamic-import\", \"meteor/dynamic-import/client.js\");\ninstall(\"es5-shim\");\ninstall(\"ecmascript-runtime-client\", \"meteor/ecmascript-runtime-client/modern.js\");\ninstall(\"base64\", \"meteor/base64/base64.js\");\ninstall(\"ejson\", \"meteor/ejson/ejson.js\");\ninstall(\"diff-sequence\", \"meteor/diff-sequence/diff.js\");\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\ninstall(\"id-map\", \"meteor/id-map/id-map.js\");\ninstall(\"random\");\ninstall(\"mongo-id\", \"meteor/mongo-id/id.js\");\ninstall(\"ordered-dict\", \"meteor/ordered-dict/ordered_dict.js\");\ninstall(\"tracker\");\ninstall(\"minimongo\", \"meteor/minimongo/minimongo_client.js\");\ninstall(\"check\", \"meteor/check/match.js\");\ninstall(\"retry\", \"meteor/retry/retry.js\");\ninstall(\"callback-hook\", \"meteor/callback-hook/hook.js\");\ninstall(\"ddp-common\");\ninstall(\"reload\", \"meteor/reload/reload.js\");\ninstall(\"socket-stream-client\", \"meteor/socket-stream-client/browser.js\");\ninstall(\"ddp-client\", \"meteor/ddp-client/client/client.js\");\ninstall(\"ddp\");\ninstall(\"ddp-server\");\ninstall(\"allow-deny\");\ninstall(\"mongo-dev-server\");\ninstall(\"mongo\");\ninstall(\"blaze-html-templates\");\ninstall(\"reactive-var\");\ninstall(\"jquery\", \"meteor/jquery/main.js\");\ninstall(\"standard-minifier-js\");\ninstall(\"shell-server\");\ninstall(\"pcel:mysql\");\ninstall(\"seba:minifiers-autoprefixer\");\ninstall(\"reactive-dict\", \"meteor/reactive-dict/migration.js\");\ninstall(\"session\", \"meteor/session/session.js\");\ninstall(\"momentjs:moment\");\ninstall(\"natestrauser:select2\");\ninstall(\"underscore\");\ninstall(\"aldeed:simple-schema\");\ninstall(\"mdg:validated-method\", \"meteor/mdg:validated-method/validated-method.js\");\ninstall(\"observe-sequence\");\ninstall(\"deps\");\ninstall(\"htmljs\");\ninstall(\"blaze\");\ninstall(\"spacebars\");\ninstall(\"templating-compiler\");\ninstall(\"templating-runtime\");\ninstall(\"templating\");\ninstall(\"ddp-rate-limiter\");\ninstall(\"localstorage\");\ninstall(\"accounts-base\", \"meteor/accounts-base/client_main.js\");\ninstall(\"url\", \"meteor/url/url_client.js\");\ninstall(\"oauth\");\ninstall(\"accounts-oauth\");\ninstall(\"service-configuration\");\ninstall(\"oauth2\");\ninstall(\"google-oauth\", \"meteor/google-oauth/namespace.js\");\ninstall(\"less\");\ninstall(\"accounts-ui-unstyled\");\ninstall(\"accounts-ui\");\ninstall(\"google-config-ui\");\ninstall(\"accounts-google\");\ninstall(\"yasinuslu:json-view\");\ninstall(\"twbs:bootstrap\");\ninstall(\"dangrossman:bootstrap-daterangepicker\");\ninstall(\"fortawesome:fontawesome\");\ninstall(\"meteortoys:toykit\");\ninstall(\"msavin:mongol\");\ninstall(\"differential:event-hooks\");\ninstall(\"risul:bootstrap-colorpicker\");\ninstall(\"logging\", \"meteor/logging/logging.js\");\ninstall(\"ostrio:flow-router-extra\", \"meteor/ostrio:flow-router-extra/client/_init.js\");\ninstall(\"meteorhacks:picker\");\ninstall(\"randyp:mats-common\", \"meteor/randyp:mats-common/client/main.js\");\ninstall(\"kadira:blaze-layout\");\ninstall(\"webapp\", \"meteor/webapp/webapp_client.js\");\ninstall(\"livedata\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"ui\");\ninstall(\"autoupdate\", \"meteor/autoupdate/autoupdate_client.js\");\ninstall(\"mdg:validation-error\");\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n},\"process.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/modules/process.js                                                          //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nif (! global.process) {\n  try {\n    // The application can run `npm install process` to provide its own\n    // process stub; otherwise this module will provide a partial stub.\n    global.process = require(\"process\");\n  } catch (missing) {\n    global.process = {};\n  }\n}\n\nvar proc = global.process;\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = proc;\n      }\n    }\n  });\n} else {\n  proc.platform = \"browser\";\n  proc.nextTick = proc.nextTick || Meteor._setImmediate;\n}\n\nif (typeof proc.env !== \"object\") {\n  proc.env = {};\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nfor (var key in meteorEnv) {\n  if (hasOwn.call(meteorEnv, key)) {\n    proc.env[key] = meteorEnv[key];\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n},\"reify.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/modules/reify.js                                                            //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nrequire(\"reify/lib/runtime\").enable(\n  module.constructor.prototype\n);\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n},\"stubs.js\":function(require){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/modules/stubs.js                                                            //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nvar haveStubs = false;\ntry {\n  require.resolve(\"meteor-node-stubs\");\n  haveStubs = true;\n} catch (noStubs) {}\n\nif (haveStubs) {\n  // When meteor-node-stubs is installed in the application's root\n  // node_modules directory, requiring it here installs aliases for stubs\n  // for all Node built-in modules, such as fs, util, and http.\n  require(\"meteor-node-stubs\");\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"reify\":{\"lib\":{\"runtime\":{\"index.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// node_modules/meteor/modules/node_modules/reify/lib/runtime/index.js                  //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\n\"use strict\";\n\n// This module should be compatible with PhantomJS v1, just like the other files\n// in reify/lib/runtime. Node 4+ features like const/let and arrow functions are\n// not acceptable here, and importing any npm packages should be contemplated\n// with extreme skepticism.\n\nvar utils = require(\"./utils.js\");\nvar Entry = require(\"./entry.js\");\n\n// The exports.enable method can be used to enable the Reify runtime for\n// specific module objects, or for Module.prototype (where implemented),\n// to make the runtime available throughout the entire module system.\nexports.enable = function (mod) {\n  if (mod.link !== moduleLink) {\n    mod.link = moduleLink;\n    mod.watch = moduleWatch;\n    mod[\"export\"] = moduleExport;\n    mod.exportDefault = moduleExportDefault;\n    mod.exportAs = moduleExportAs;\n    mod.runSetters = runSetters;\n\n    // Legacy shorthand for mod.exportAs(\"*\").\n    mod.makeNsSetter = moduleMakeNsSetter;\n\n    return true;\n  }\n\n  return false;\n};\n\n// Shorthand for module.watch(require(id), setters) that accepts just a\n// string module identifier `id` rather than the exports object for the\n// required module. In the future, this API will replace module.watch, and\n// will allow for creating Entry objects before module evaluation, which\n// will solve some problems with import cycles and hoisted declarations.\nfunction moduleLink(id, setters, key) {\n  return moduleWatch.call(this, this.require(id), setters, key);\n}\n\n// If key is provided, it will be used to identify the given setters so\n// that they can be replaced if module.watch is called again with the same\n// key. This avoids potential memory leaks from import declarations inside\n// loops. The compiler generates these keys automatically (and\n// deterministically) when compiling nested import declarations.\nfunction moduleWatch(exported, setters, key) {\n  utils.setESModule(this.exports);\n  Entry.getOrCreate(this.exports, this);\n\n  if (utils.isObject(setters)) {\n    Entry.getOrCreate(exported).addSetters(this, setters, key);\n  }\n}\n\n// Register getter functions for local variables in the scope of an export\n// statement. Pass true as the second argument to indicate that the getter\n// functions always return the same values.\nfunction moduleExport(getters, constant) {\n  utils.setESModule(this.exports);\n  var entry = Entry.getOrCreate(this.exports, this);\n  entry.addGetters(getters, constant);\n  if (this.loaded) {\n    // If the module has already been evaluated, then we need to trigger\n    // another round of entry.runSetters calls, which begins by calling\n    // entry.runModuleGetters(module).\n    entry.runSetters();\n  }\n}\n\n// Register a getter function that always returns the given value.\nfunction moduleExportDefault(value) {\n  return this[\"export\"]({\n    \"default\": function () {\n      return value;\n    }\n  }, true);\n}\n\n// Returns a function suitable for passing as a setter callback to\n// module.watch or module.link. If name is an identifier, calling the\n// function will set the export of that name to the given value. If the\n// name is \"*\", all properties of the value object will be exported by\n// name, except for \"default\" (use \"*+\" instead of \"*\" to include it).\n// Discussion of why the \"default\" property is skipped:\n// https://github.com/tc39/ecma262/issues/948\nfunction moduleExportAs(name) {\n  var entry = this;\n  var includeDefault = name === \"*+\";\n  return function (value) {\n    if (name === \"*\" || name === \"*+\") {\n      Object.keys(value).forEach(function (key) {\n        if (includeDefault || key !== \"default\") {\n          utils.copyKey(key, entry.exports, value);\n        }\n      });\n    } else {\n      entry.exports[name] = value;\n    }\n  };\n}\n\n// Platform-specific code should find a way to call this method whenever\n// the module system is about to return module.exports from require. This\n// might happen more than once per module, in case of dependency cycles,\n// so we want Module.prototype.runSetters to run each time.\nfunction runSetters(valueToPassThrough) {\n  var entry = Entry.get(this.exports);\n  if (entry !== null) {\n    entry.runSetters();\n  }\n\n  if (this.loaded) {\n    // If this module has finished loading, then we must create an Entry\n    // object here, so that we can add this module to entry.ownerModules\n    // by passing it as the second argument to Entry.getOrCreate.\n    Entry.getOrCreate(this.exports, this);\n  }\n\n  // Assignments to exported local variables get wrapped with calls to\n  // module.runSetters, so module.runSetters returns the\n  // valueToPassThrough parameter to allow the value of the original\n  // expression to pass through. For example,\n  //\n  //   export var a = 1;\n  //   console.log(a += 3);\n  //\n  // becomes\n  //\n  //   module.export(\"a\", () => a);\n  //   var a = 1;\n  //   console.log(module.runSetters(a += 3));\n  //\n  // This ensures module.runSetters runs immediately after the assignment,\n  // and does not interfere with the larger computation.\n  return valueToPassThrough;\n}\n\n// Legacy helper that returns a function that takes a namespace object and\n// copies the properties of the namespace to module.exports, excluding any\n// \"default\" property (unless includeDefault is true), which is useful for\n// implementing `export * from \"module\"`.\n//\n// Instead of using this helper like so:\n//\n//   module.link(id, { \"*\": module.makeNsSetter() });\n//\n// non-legacy code should simply use a string-valued setter:\n//\n//   module.link(id, { \"*\": \"*\" });\n//\n// or, to include the \"default\" property:\n//\n//   module.link(id, { \"*\": \"*+\" });\n//\n// This helper may be removed in a future version of Reify.\nfunction moduleMakeNsSetter(includeDefault) {\n  return this.exportAs(includeDefault ? \"*+\" : \"*\");\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n},\"utils.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// node_modules/meteor/modules/node_modules/reify/lib/runtime/utils.js                  //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\n\"use strict\";\n\n// This module should be compatible with PhantomJS v1, just like the other files\n// in reify/lib/runtime. Node 4+ features like const/let and arrow functions are\n// not acceptable here, and importing any npm packages should be contemplated\n// with extreme skepticism.\n\nvar useSetPrototypeOf = typeof Object.setPrototypeOf === \"function\";\nvar useSymbol = typeof Symbol === \"function\";\n\nvar esStrKey = \"__esModule\";\nvar esSymKey = useSymbol ? Symbol.for(esStrKey) : null;\nvar useToStringTag = useSymbol && typeof Symbol.toStringTag === \"symbol\";\nvar useGetOwnPropDesc =\n  typeof Object.getOwnPropertyDescriptor === \"function\";\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction copyKey(key, target, source) {\n  if (useGetOwnPropDesc) {\n    var desc = Object.getOwnPropertyDescriptor(source, key);\n    desc.configurable = true; // Allow redefinition.\n    Object.defineProperty(target, key, desc);\n  } else {\n    target[key] = source[key];\n  }\n}\n\nexports.copyKey = copyKey;\n\n// Returns obj[key] unless that property is defined by a getter function,\n// in which case the getter function is returned.\nexports.valueOrGetter = function (obj, key) {\n  if (useGetOwnPropDesc && hasOwn.call(obj, key)) {\n    var desc = Object.getOwnPropertyDescriptor(obj, key);\n    if (typeof desc.get === \"function\") {\n      return desc.get;\n    }\n  }\n\n  return obj[key];\n};\n\nfunction getESModule(exported) {\n  if (isObjectLike(exported)) {\n    if (useSymbol && hasOwn.call(exported, esSymKey)) {\n      return !! exported[esSymKey];\n    }\n\n    if (hasOwn.call(exported, esStrKey)) {\n      return !! exported[esStrKey];\n    }\n  }\n\n  return false;\n}\n\nexports.getESModule = getESModule;\n\nfunction setESModule(exported) {\n  if (isObjectLike(exported)) {\n    if (useSymbol) {\n      exported[esSymKey] = true;\n    } else if (! exported[esStrKey]) {\n      // Other module runtime systems may set exported.__esModule such\n      // that it can't be redefined, so we call Object.defineProperty only\n      // when exported.__esModule is not already true.\n      Object.defineProperty(exported, esStrKey, {\n        configurable: true,\n        enumerable: false,\n        value: true,\n        writable: false\n      });\n    }\n  }\n}\n\nexports.setESModule = setESModule;\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\nexports.isObject = isObject;\n\nfunction isObjectLike(value) {\n  var type = typeof value;\n  return type === \"function\" || (type === \"object\" && value !== null);\n}\n\nexports.isObjectLike = isObjectLike;\n\nfunction createNamespace() {\n  var namespace = Object.create(null);\n\n  if (useToStringTag) {\n    Object.defineProperty(namespace, Symbol.toStringTag, {\n      value: \"Module\",\n      configurable: false,\n      enumerable: false,\n      writable: false\n    });\n  }\n\n  setESModule(namespace);\n\n  return namespace;\n}\n\nexports.createNamespace = createNamespace;\n\nfunction setPrototypeOf(object, proto) {\n  if (useSetPrototypeOf) {\n    Object.setPrototypeOf(object, proto);\n  } else {\n    object.__proto__ = proto;\n  }\n  return object;\n}\n\nexports.setPrototypeOf = setPrototypeOf;\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n},\"entry.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// node_modules/meteor/modules/node_modules/reify/lib/runtime/entry.js                  //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\n\"use strict\";\n\n// This module should be compatible with PhantomJS v1, just like the other files\n// in reify/lib/runtime. Node 4+ features like const/let and arrow functions are\n// not acceptable here, and importing any npm packages should be contemplated\n// with extreme skepticism.\n\nvar utils = require(\"./utils.js\");\n\nvar GETTER_ERROR = {};\nvar NAN = {};\nvar UNDEFINED = {};\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar keySalt = 0;\n\nfunction Entry(exported) {\n  // The module.exports of the module this Entry is managing.\n  this.exports = exported;\n  // Getters for local variables exported from the managed module.\n  this.getters = Object.create(null);\n  // Setters for assigning to local variables in parent modules.\n  this.setters = Object.create(null);\n  // The normalized namespace object that importers receive when they use\n  // `import * as namespace from \"...\"` syntax.\n  this.namespace = utils.createNamespace();\n}\n\nvar Ep = utils.setPrototypeOf(Entry.prototype, null);\n\nvar weakEntryMap = typeof WeakMap === \"function\"\n  ? new WeakMap\n  : new (function FakeWeakMap() {\n    // A barely functional WeakMap polyfill, just in case. This\n    // implementation needs to be logically correct only in the specific\n    // ways that the Entry class uses it. It isn't even \"weak\" in the\n    // garbage-collection sense of the word, but that's fine.\n    var keys = [];\n    var values = [];\n\n    this.get = function (obj) {\n      var index = keys.indexOf(obj);\n      if (index >= 0) {\n        return values[index];\n      }\n    };\n\n    this.set = function (obj, value) {\n      var index = keys.indexOf(obj);\n      if (index >= 0) {\n        values[index] = value;\n      } else {\n        keys.push(obj);\n        values.push(value);\n      }\n    };\n  });\n\nEntry.get = function (exported) {\n  if (utils.isObjectLike(exported)) {\n    var entry = weakEntryMap.get(exported);\n    if (entry !== void 0) {\n      return entry;\n    }\n  }\n  return null;\n};\n\nEntry.getOrCreate = function (exported, mod) {\n  if (! utils.isObjectLike(exported)) {\n    // In case the child module modified module.exports, create a\n    // temporary Entry object so that we can call the entry.addSetters\n    // method once, which will trigger entry.runSetters(names).\n    return new Entry(exported);\n  }\n\n  var entry = weakEntryMap.get(exported);\n  if (entry !== void 0) {\n    return entry;\n  }\n\n  var entry = new Entry(exported);\n  weakEntryMap.set(exported, entry);\n  return entry;\n};\n\nfunction safeKeys(obj) {\n  var keys = Object.keys(obj);\n  var esModuleIndex = keys.indexOf(\"__esModule\");\n  if (esModuleIndex >= 0) {\n    keys.splice(esModuleIndex, 1);\n  }\n  return keys;\n}\n\nEp.addGetters = function (getters, constant) {\n  var names = safeKeys(getters);\n  var nameCount = names.length;\n  constant = !! constant;\n\n  for (var i = 0; i < nameCount; ++i) {\n    var name = names[i];\n    var getter = getters[name];\n\n    if (typeof getter === \"function\" &&\n        // Should this throw if this.getters[name] exists?\n        ! (name in this.getters)) {\n      this.getters[name] = getter;\n      getter.constant = constant;\n      getter.runCount = 0;\n    }\n  }\n};\n\nEp.addSetters = function (parent, setters, key) {\n  var names = safeKeys(setters);\n  var nameCount = names.length;\n\n  if (! nameCount) {\n    return;\n  }\n\n  // If no key is provided, make a unique key. Otherwise, make sure the key is\n  // distinct from keys provided by other parent modules.\n  key = key === void 0\n    ? makeUniqueKey()\n    : parent.id + \":\" + key;\n\n  var entry = this;\n\n  for (var i = 0; i < nameCount; ++i) {\n    var name = names[i];\n    var setter = normalizeSetterValue(parent, setters[name]);\n\n    if (typeof setter === \"function\") {\n      setter.parent = parent;\n      if (! (name in entry.setters)) {\n        entry.setters[name] = Object.create(null);\n      }\n      entry.setters[name][key] = setter;\n    }\n  }\n\n  entry.runSetters(names);\n};\n\nfunction normalizeSetterValue(module, setter) {\n  if (typeof setter === \"function\") {\n    return setter;\n  }\n\n  if (typeof setter === \"string\") {\n    // If the value of the setter property is a string, the setter will\n    // re-export the imported value using that string as the name of the\n    // exported value. If the string is \"*\", all properties of the value\n    // object will be re-exported as individual exports, except for the\n    // \"default\" property (use \"*+\" instead of \"*\" to include it).\n    return module.exportAs(setter);\n  }\n\n  if (Array.isArray(setter)) {\n    switch (setter.length) {\n    case 0: return null;\n    case 1: return normalizeSetterValue(module, setter[0]);\n    default:\n      var setterFns = setter.map(function (elem) {\n        return normalizeSetterValue(module, elem);\n      });\n\n      // Return a combined function that calls all of the nested setter\n      // functions with the same value.\n      return function (value) {\n        setterFns.forEach(function (fn) {\n          fn(value);\n        });\n      };\n    }\n  }\n\n  return null;\n}\n\nEp.runGetters = function (names) {\n  // Before running getters, copy anything added to the exports object\n  // over to the namespace. Values returned by getters take precedence\n  // over these values, but we don't want to miss anything.\n  syncExportsToNamespace(this, names);\n\n  if (names === void 0 ||\n      names.indexOf(\"*\") >= 0) {\n    names = Object.keys(this.getters);\n  }\n\n  var nameCount = names.length;\n\n  for (var i = 0; i < nameCount; ++i) {\n    var name = names[i];\n    var value = runGetter(this, name);\n\n    // If the getter is run without error, update both entry.namespace and\n    // module.exports with the current value so that CommonJS require\n    // calls remain consistent with module.watch.\n    if (value !== GETTER_ERROR) {\n      this.namespace[name] = value;\n      this.exports[name] = value;\n    }\n  }\n};\n\nfunction syncExportsToNamespace(entry, names) {\n  var setDefault = false;\n\n  if (! utils.getESModule(entry.exports)) {\n    // If the module entry is managing overrides module.exports, that\n    // value should be exposed as the .default property of the namespace,\n    // unless module.exports is marked as an ECMASCript module.\n    entry.namespace.default = entry.exports;\n    setDefault = true;\n  }\n\n  if (! utils.isObjectLike(entry.exports)) {\n    return;\n  }\n\n  if (names === void 0 ||\n      names.indexOf(\"*\") >= 0) {\n    names = Object.keys(entry.exports);\n  }\n\n  names.forEach(function (key) {\n    // Don't set any properties for which a getter function exists in\n    // entry.getters, don't accidentally override entry.namespace.default,\n    // and only copy own properties from entry.exports.\n    if (! hasOwn.call(entry.getters, key) &&\n        ! (setDefault && key === \"default\") &&\n        hasOwn.call(entry.exports, key)) {\n      utils.copyKey(key, entry.namespace, entry.exports);\n    }\n  });\n}\n\n// Called whenever module.exports might have changed, to trigger any\n// setters associated with the newly exported values. The names parameter\n// is optional; without it, all getters and setters will run.\nEp.runSetters = function (names) {\n  // Make sure entry.namespace and module.exports are up to date before we\n  // call getExportByName(entry, name).\n  this.runGetters(names);\n\n  // Lazily-initialized object mapping parent module identifiers to parent\n  // module objects whose setters we might need to run.\n  var parents;\n\n  forEachSetter(this, names, function (setter, name, value) {\n    if (parents === void 0) {\n      parents = Object.create(null);\n    }\n    parents[setter.parent.id] = setter.parent;\n\n    // The param order for setters is `value` then `name` because the `name`\n    // param is only used by namespace exports.\n    setter(value, name);\n  });\n\n  if (! parents) {\n    return;\n  }\n\n  // If any of the setters updated the module.exports of a parent module,\n  // or updated local variables that are exported by that parent module,\n  // then we must re-run any setters registered by that parent module.\n  var parentIDs = Object.keys(parents);\n  var parentIDCount = parentIDs.length;\n\n  for (var i = 0; i < parentIDCount; ++i) {\n    // What happens if parents[parentIDs[id]] === module, or if\n    // longer cycles exist in the parent chain? Thanks to our setter.last\n    // bookkeeping above, the runSetters broadcast will only proceed\n    // as far as there are any actual changes to report.\n    var parent = parents[parentIDs[i]];\n    var parentEntry = Entry.get(parent.exports);\n    if (parentEntry) {\n      parentEntry.runSetters();\n    }\n  }\n};\n\nfunction callSetterIfNecessary(setter, name, value, callback) {\n  if (name === \"__esModule\") {\n    // Ignore setters asking for module.exports.__esModule.\n    return;\n  }\n\n  var shouldCall = false;\n\n  if (setter.last === void 0) {\n    setter.last = Object.create(null);\n    // Always call the setter if it has never been called before.\n    shouldCall = true;\n  }\n\n  function changed(name, value) {\n    var valueToCompare = value;\n    if (valueToCompare !== valueToCompare) {\n      valueToCompare = NAN;\n    } else if (valueToCompare === void 0) {\n      valueToCompare = UNDEFINED;\n    }\n\n    if (setter.last[name] === valueToCompare) {\n      return false;\n    }\n\n    setter.last[name] = valueToCompare;\n    return true;\n  }\n\n  if (name === \"*\") {\n    var keys = safeKeys(value);\n    var keyCount = keys.length;\n    for (var i = 0; i < keyCount; ++i) {\n      var key = keys[i];\n      // Evaluating value[key] is risky because the property might be\n      // defined by a getter function that logs a deprecation warning (or\n      // worse) when evaluated. For example, Node uses this trick to\n      // display a deprecation warning whenever crypto.createCredentials\n      // is accessed. Fortunately, when value[key] is defined by a getter\n      // function, it's enough to check whether the getter function itself\n      // has changed, since we are careful elsewhere to preserve getters\n      // rather than prematurely evaluating them.\n      if (changed(key, utils.valueOrGetter(value, key))) {\n        shouldCall = true;\n      }\n    }\n  } else if (changed(name, value)) {\n    shouldCall = true;\n  }\n\n  if (shouldCall) {\n    // Only invoke the callback if we have not called this setter\n    // (with a value of this name) before, or the current value is\n    // different from the last value we passed to this setter.\n    return callback(setter, name, value);\n  }\n}\n\n// Invoke the given callback once for every (setter, name, value) that needs to\n// be called. Note that forEachSetter does not call any setters itself, only the\n// given callback.\nfunction forEachSetter(entry, names, callback) {\n  var needToCheckNames = true;\n\n  if (names === void 0) {\n    names = Object.keys(entry.setters);\n    needToCheckNames = false;\n  }\n\n  var nameCount = names.length;\n\n  for (var i = 0; i < nameCount; ++i) {\n    var name = names[i];\n\n    if (needToCheckNames &&\n        ! hasOwn.call(entry.setters, name)) {\n      continue;\n    }\n\n    var setters = entry.setters[name];\n    var keys = Object.keys(setters);\n    var keyCount = keys.length;\n\n    for (var j = 0; j < keyCount; ++j) {\n      var key = keys[j];\n      var value = getExportByName(entry, name);\n\n      callSetterIfNecessary(setters[key], name, value, callback);\n\n      var getter = entry.getters[name];\n      if (typeof getter === \"function\" &&\n          // Sometimes a getter function will throw because it's called\n          // before the variable it's supposed to return has been\n          // initialized, so we need to know that the getter function has\n          // run to completion at least once.\n          getter.runCount > 0 &&\n          getter.constant) {\n        // If we happen to know that this getter function has run\n        // successfully, and will never return a different value, then we\n        // can forget the corresponding setter, because we've already\n        // reported that constant value. Note that we can't forget the\n        // getter, because we need to remember the original value in case\n        // anyone tampers with entry.exports[name].\n        delete setters[key];\n      }\n    }\n  }\n}\n\nfunction getExportByName(entry, name) {\n  if (name === \"*\") {\n    return entry.namespace;\n  }\n\n  if (hasOwn.call(entry.namespace, name)) {\n    return entry.namespace[name];\n  }\n\n  var exported = entry.exports;\n\n  if (name === \"default\" &&\n      ! (utils.getESModule(exported) &&\n         \"default\" in exported)) {\n    return exported;\n  }\n\n  if (exported == null) {\n    return;\n  }\n\n  return exported[name];\n}\n\nfunction makeUniqueKey() {\n  return Math.random()\n    .toString(36)\n    // Add an incrementing salt to help track key ordering and also\n    // absolutely guarantee we never return the same key twice.\n    .replace(\"0.\", ++keySalt + \"$\");\n}\n\nfunction runGetter(entry, name) {\n  var getter = entry.getters[name];\n  try {\n    var result = getter();\n    ++getter.runCount;\n    return result;\n  } catch (e) {}\n  return GETTER_ERROR;\n}\n\nmodule.exports = Entry;\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/modules/client.js\");\n\n/* Exports */\nPackage._define(\"modules\", exports, {\n  meteorInstall: meteorInstall\n});\n\n})();\n","servePath":"/packages/modules.js"}]