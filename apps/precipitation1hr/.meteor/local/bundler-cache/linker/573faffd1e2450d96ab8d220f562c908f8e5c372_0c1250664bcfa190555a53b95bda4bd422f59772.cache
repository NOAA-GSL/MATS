[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar URL = Package.url.URL;\nvar meteorInstall = Package.modules.meteorInstall;\n\n/* Package-scope variables */\nvar HTTP, HTTPInternals;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"http\":{\"httpcall_server.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/http/httpcall_server.js                                                                                 //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nvar path = require('path');\nvar request = require('request');\nvar url_util = require('url');\nvar URL = require(\"meteor/url\").URL;\nvar common = require(\"./httpcall_common.js\");\nvar HTTP = exports.HTTP = common.HTTP;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nexports.HTTPInternals = {\n  NpmModules: {\n    request: {\n      version: Npm.require('request/package.json').version,\n      module: request\n    }\n  }\n};\n\n// _call always runs asynchronously; HTTP.call, defined below,\n// wraps _call and runs synchronously when no callback is provided.\nfunction _call(method, url, options, callback) {\n  ////////// Process arguments //////////\n\n  if (! callback && typeof options === \"function\") {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  if (hasOwn.call(options, 'beforeSend')) {\n    throw new Error(\"Option beforeSend not supported on server.\");\n  }\n\n  method = (method || \"\").toUpperCase();\n\n  if (! /^https?:\\/\\//.test(url))\n    throw new Error(\"url must be absolute and start with http:// or https://\");\n\n  var headers = {};\n\n  var content = options.content;\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n\n  var paramsForUrl, paramsForBody;\n  if (content || method === \"GET\" || method === \"HEAD\")\n    paramsForUrl = options.params;\n  else\n    paramsForBody = options.params;\n\n  var newUrl = URL._constructUrl(url, options.query, paramsForUrl);\n\n  if (options.auth) {\n    if (options.auth.indexOf(':') < 0)\n      throw new Error('auth option should be of the form \"username:password\"');\n    headers['Authorization'] = \"Basic \"+\n      Buffer.from(options.auth, \"ascii\").toString(\"base64\");\n  }\n\n  if (paramsForBody) {\n    content = URL._encodeParams(paramsForBody);\n    headers['Content-Type'] = \"application/x-www-form-urlencoded\";\n  }\n\n  if (options.headers) {\n    Object.keys(options.headers).forEach(function (key) {\n      headers[key] = options.headers[key];\n    });\n  }\n\n  // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n  callback = (function(callback) {\n    var called = false;\n    return function(error, response) {\n      if (! called) {\n        called = true;\n        if (error && response) {\n          error.response = response;\n        }\n        callback(error, response);\n      }\n    };\n  })(callback);\n\n  ////////// Kickoff! //////////\n\n  // Allow users to override any request option with the npmRequestOptions\n  // option.\n  var reqOptions = Object.assign({\n    url: newUrl,\n    method: method,\n    encoding: \"utf8\",\n    jar: false,\n    timeout: options.timeout,\n    body: content,\n    followRedirect: options.followRedirects,\n    // Follow redirects on non-GET requests\n    // also. (https://github.com/meteor/meteor/issues/2808)\n    followAllRedirects: options.followRedirects,\n    headers: headers\n  }, options.npmRequestOptions || null);\n\n  request(reqOptions, function(error, res, body) {\n    var response = null;\n\n    if (! error) {\n      response = {};\n      response.statusCode = res.statusCode;\n      response.content = body;\n      response.headers = res.headers;\n\n      common.populateData(response);\n\n      if (response.statusCode >= 400) {\n        error = common.makeErrorByStatus(\n          response.statusCode,\n          response.content\n        );\n      }\n    }\n\n    callback(error, response);\n  });\n}\n\nHTTP.call = Meteor.wrapAsync(_call);\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"httpcall_common.js\":function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/http/httpcall_common.js                                                                                 //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nvar MAX_LENGTH = 500; // if you change this, also change the appropriate test\nvar slice = Array.prototype.slice;\n\nexports.makeErrorByStatus = function(statusCode, content) {\n  var message = \"failed [\" + statusCode + \"]\";\n\n  if (content) {\n    var stringContent = typeof content == \"string\" ?\n      content : content.toString();\n\n    message += ' ' + truncate(stringContent.replace(/\\n/g, ' '), MAX_LENGTH);\n  }\n\n  return new Error(message);\n};\n\nfunction truncate(str, length) {\n  return str.length > length ? str.slice(0, length) + '...' : str;\n}\n\n// Fill in `response.data` if the content-type is JSON.\nexports.populateData = function(response) {\n  // Read Content-Type header, up to a ';' if there is one.\n  // A typical header might be \"application/json; charset=utf-8\"\n  // or just \"application/json\".\n  var contentType = (response.headers['content-type'] || ';').split(';')[0];\n\n  // Only try to parse data as JSON if server sets correct content type.\n  if (['application/json',\n       'text/javascript',\n       'application/javascript',\n       'application/x-javascript',\n      ].indexOf(contentType) >= 0) {\n    try {\n      response.data = JSON.parse(response.content);\n    } catch (err) {\n      response.data = null;\n    }\n  } else {\n    response.data = null;\n  }\n};\n\nvar HTTP = exports.HTTP = {};\n\n/**\n * @summary Send an HTTP `GET` request. Equivalent to calling [`HTTP.call`](#http_call) with \"GET\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n */\nHTTP.get = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"GET\"].concat(slice.call(arguments)));\n};\n\n/**\n * @summary Send an HTTP `POST` request. Equivalent to calling [`HTTP.call`](#http_call) with \"POST\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n */\nHTTP.post = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"POST\"].concat(slice.call(arguments)));\n};\n\n/**\n * @summary Send an HTTP `PUT` request. Equivalent to calling [`HTTP.call`](#http_call) with \"PUT\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n */\nHTTP.put = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"PUT\"].concat(slice.call(arguments)));\n};\n\n/**\n * @summary Send an HTTP `DELETE` request. Equivalent to calling [`HTTP.call`](#http_call) with \"DELETE\" as the first argument. (Named `del` to avoid conflict with the Javascript keyword `delete`)\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n */\nHTTP.del = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"DELETE\"].concat(slice.call(arguments)));\n};\n\n/**\n * @summary Send an HTTP `PATCH` request. Equivalent to calling [`HTTP.call`](#http_call) with \"PATCH\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n */\nHTTP.patch = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"PATCH\"].concat(slice.call(arguments)));\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"request\":{\"package.json\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/http/node_modules/request/package.json                                                       //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nmodule.exports = {\n  \"name\": \"request\",\n  \"version\": \"2.88.0\",\n  \"main\": \"index.js\"\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/http/node_modules/request/index.js                                                           //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nmodule.useNode();\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/http/httpcall_server.js\");\n\n/* Exports */\nPackage._define(\"http\", exports, {\n  HTTP: HTTP,\n  HTTPInternals: HTTPInternals\n});\n\n})();\n","servePath":"/packages/http.js"}]