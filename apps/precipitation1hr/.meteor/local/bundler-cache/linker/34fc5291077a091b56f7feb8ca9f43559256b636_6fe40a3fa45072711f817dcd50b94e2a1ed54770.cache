[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modern-browsers\":{\"modern.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/modern-browsers/modern.js                                            //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\nconst minimumVersions = Object.create(null);\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// This map defines aliasing behavior in a generic way which still permits\n// minimum versions to be specified for a specific browser family.\nconst browserAliases = {\n  chrome: [\n    // chromeMobile*, per https://github.com/meteor/meteor/pull/9793,\n    \"chromeMobile\",\n    \"chromeMobileIOS\",\n\n    // The major version number of Chromium and Headless Chrome track with the\n    // releases of Chrome Dev, Canary and Stable, so we should be okay to\n    // alias them to Chrome in a generic sense.\n    // https://www.chromium.org/developers/version-numbers\n    //\n    // Chromium is particularly important to list here since, unlike macOS\n    // builds, Linux builds list Chromium in the userAgent along with Chrome:\n    //   e.g. Chromium/70.0.3538.77 Chrome/70.0.3538.77\n    \"chromium\",\n    \"headlesschrome\",\n  ],\n\n  // If a call to setMinimumBrowserVersions specifies Edge 12 as a minimum\n  // version, that means no version of Internet Explorer pre-Edge should\n  // be classified as modern. This edge:[\"ie\"] alias effectively enforces\n  // that logic, because there is no IE12. #9818 #9839\n  edge: [\"ie\"],\n\n  // The webapp package converts browser names to camel case, so\n  // mobile_safari and mobileSafari should be synonymous.\n  mobile_safari: [\"mobileSafari\"],\n};\n\n// Expand the given minimum versions by reusing chrome versions for\n// chromeMobile (according to browserAliases above).\nfunction applyAliases(versions) {\n  const lowerCaseVersions = Object.create(null);\n\n  Object.keys(versions).forEach(browser => {\n    lowerCaseVersions[browser.toLowerCase()] = versions[browser];\n  });\n\n  Object.keys(browserAliases).forEach(original => {\n    const aliases = browserAliases[original];\n    original = original.toLowerCase();\n\n    if (hasOwn.call(lowerCaseVersions, original)) {\n      aliases.forEach(alias => {\n        alias = alias.toLowerCase();\n        if (! hasOwn.call(lowerCaseVersions, alias)) {\n          lowerCaseVersions[alias] = lowerCaseVersions[original];\n        }\n      });\n    }\n  });\n\n  return lowerCaseVersions;\n}\n\n// TODO Should it be possible for callers to setMinimumBrowserVersions to\n// forbid any version of a particular browser?\n\n// Given a { name, major, minor, patch } object like the one provided by\n// webapp via request.browser, return true if that browser qualifies as\n// \"modern\" according to all requested version constraints.\nfunction isModern(browser) {\n  const lowerCaseName = browser &&\n    typeof browser.name === \"string\" &&\n    browser.name.toLowerCase();\n\n  return !!lowerCaseName &&\n    hasOwn.call(minimumVersions, lowerCaseName) &&\n    greaterThanOrEqualTo([\n      ~~browser.major,\n      ~~browser.minor,\n      ~~browser.patch,\n    ], minimumVersions[lowerCaseName].version);\n}\n\n// Any package that depends on the modern-browsers package can call this\n// function to communicate its expectations for the minimum browser\n// versions that qualify as \"modern.\" The final decision between\n// web.browser.legacy and web.browser will be based on the maximum of all\n// requested minimum versions for each browser.\nfunction setMinimumBrowserVersions(versions, source) {\n  const lowerCaseVersions = applyAliases(versions);\n\n  Object.keys(lowerCaseVersions).forEach(lowerCaseName => {\n    const version = lowerCaseVersions[lowerCaseName];\n\n    if (hasOwn.call(minimumVersions, lowerCaseName) &&\n        ! greaterThan(version, minimumVersions[lowerCaseName].version)) {\n      return;\n    }\n\n    minimumVersions[lowerCaseName] = {\n      version: copy(version),\n      source: source || getCaller(\"setMinimumBrowserVersions\")\n    };\n  });\n}\n\nfunction getCaller(calleeName) {\n  const error = new Error;\n  Error.captureStackTrace(error);\n  const lines = error.stack.split(\"\\n\");\n  let caller;\n  lines.some((line, i) => {\n    if (line.indexOf(calleeName) >= 0) {\n      caller = lines[i + 1].trim();\n      return true;\n    }\n  });\n  return caller;\n}\n\nObject.assign(exports, {\n  isModern,\n  setMinimumBrowserVersions,\n  calculateHashOfMinimumVersions() {\n    const { createHash } = require(\"crypto\");\n    return createHash(\"sha1\").update(\n      JSON.stringify(minimumVersions)\n    ).digest(\"hex\");\n  }\n});\n\n// For making defensive copies of [major, minor, ...] version arrays, so\n// they don't change unexpectedly.\nfunction copy(version) {\n  if (typeof version === \"number\") {\n    return version;\n  }\n\n  if (Array.isArray(version)) {\n    return version.map(copy);\n  }\n\n  return version;\n}\n\nfunction greaterThanOrEqualTo(a, b) {\n  return ! greaterThan(b, a);\n}\n\nfunction greaterThan(a, b) {\n  const as = (typeof a === \"number\") ? [a] : a;\n  const bs = (typeof b === \"number\") ? [b] : b;\n  const maxLen = Math.max(as.length, bs.length);\n\n  for (let i = 0; i < maxLen; ++i) {\n    a = (i < as.length) ? as[i] : 0;\n    b = (i < bs.length) ? bs[i] : 0;\n\n    if (a > b) {\n      return true;\n    }\n\n    if (a < b) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction makeSource(feature) {\n  return module.id + \" (\" + feature + \")\"\n}\n\nsetMinimumBrowserVersions({\n  chrome: 49,\n  edge: 12,\n  firefox: 45,\n  mobileSafari: [9, 2],\n  opera: 36,\n  safari: 9,\n  // Electron 1.0.0+ matches Chromium 49, per\n  // https://github.com/Kilian/electron-to-chromium/blob/master/full-versions.js\n  electron: 1,\n}, makeSource(\"classes\"));\n\nsetMinimumBrowserVersions({\n  chrome: 39,\n  edge: 13,\n  firefox: 26,\n  mobileSafari: 10,\n  opera: 26,\n  safari: 10,\n  // Disallow any version of PhantomJS.\n  phantomjs: Infinity,\n  electron: [0, 20],\n}, makeSource(\"generator functions\"));\n\nsetMinimumBrowserVersions({\n  chrome: 41,\n  edge: 13,\n  firefox: 34,\n  mobileSafari: [9, 2],\n  opera: 29,\n  safari: [9, 1],\n  electron: [0, 24],\n}, makeSource(\"template literals\"));\n\nsetMinimumBrowserVersions({\n  chrome: 38,\n  edge: 12,\n  firefox: 36,\n  mobileSafari: 9,\n  opera: 25,\n  safari: 9,\n  electron: [0, 20],\n}, makeSource(\"symbols\"));\n\n///////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/modern-browsers/modern.js\");\n\n/* Exports */\nPackage._define(\"modern-browsers\", exports);\n\n})();\n","servePath":"/packages/modern-browsers.js"}]