[{"type":"js","data":"/* Imports for global scope */\n\nMongoInternals = Package.mongo.MongoInternals;\nMongo = Package.mongo.Mongo;\nReactiveVar = Package['reactive-var'].ReactiveVar;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nECMAScript = Package.ecmascript.ECMAScript;\nmysql = Package['pcel:mysql'].mysql;\nmoment = Package['momentjs:moment'].moment;\nmatsCollections = Package['randyp:mats-common'].matsCollections;\nmatsTypes = Package['randyp:mats-common'].matsTypes;\nmatsMethods = Package['randyp:mats-common'].matsMethods;\nmatsParamUtils = Package['randyp:mats-common'].matsParamUtils;\nmatsMathUtils = Package['randyp:mats-common'].matsMathUtils;\nmatsPlotUtils = Package['randyp:mats-common'].matsPlotUtils;\nmatsPlotSpecUtils = Package['randyp:mats-common'].matsPlotSpecUtils;\nmatsDataUtils = Package['randyp:mats-common'].matsDataUtils;\nmatsDataQueryUtils = Package['randyp:mats-common'].matsDataQueryUtils;\nmatsDataDiffUtils = Package['randyp:mats-common'].matsDataDiffUtils;\nmatsDataMatchUtils = Package['randyp:mats-common'].matsDataMatchUtils;\nmatsDataCurveOpsUtils = Package['randyp:mats-common'].matsDataCurveOpsUtils;\nmatsDataPlotOpsUtils = Package['randyp:mats-common'].matsDataPlotOpsUtils;\nmatsDataProcessUtils = Package['randyp:mats-common'].matsDataProcessUtils;\nregression = Package['randyp:mats-common'].regression;\nmatsCache = Package['randyp:mats-common'].matsCache;\nAccounts = Package['accounts-base'].Accounts;\n_ = Package.underscore._;\nBlazeLayout = Package['kadira:blaze-layout'].BlazeLayout;\nPicker = Package['meteorhacks:picker'].Picker;\nMeteor = Package.meteor.Meteor;\nglobal = Package.meteor.global;\nmeteorEnv = Package.meteor.meteorEnv;\nWebApp = Package.webapp.WebApp;\nWebAppInternals = Package.webapp.WebAppInternals;\nmain = Package.webapp.main;\nDDP = Package['ddp-client'].DDP;\nDDPServer = Package['ddp-server'].DDPServer;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nBlaze = Package.ui.Blaze;\nUI = Package.ui.UI;\nHandlebars = Package.ui.Handlebars;\nSpacebars = Package.spacebars.Spacebars;\nmeteorInstall = Package.modules.meteorInstall;\nmeteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nPromise = Package.promise.Promise;\nSimpleSchema = Package['aldeed:simple-schema'].SimpleSchema;\nMongoObject = Package['aldeed:simple-schema'].MongoObject;\nGoogle = Package['google-oauth'].Google;\nAutoupdate = Package.autoupdate.Autoupdate;\nHTML = Package.htmljs.HTML;\n\n","servePath":"/global-imports.js"},{"type":"js","data":"var require = meteorInstall({\"server\":{\"dataFunctions\":{\"data_contour.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_contour.js                                                                               //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 4);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 5);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 6);\n\ndataContour = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const plotType = matsTypes.PlotTypes.contour;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n\n  if (curves.length > 1) {\n    throw new Error(\"INFO:  There must only be one added curve.\");\n  }\n\n  var dataset = [];\n  var axisMap = Object.create(null); // initialize variables specific to the curve\n\n  var curve = curves[0];\n  var label = curve['label'];\n  var xAxisParam = curve['x-axis-parameter'];\n  var yAxisParam = curve['y-axis-parameter'];\n  var xValClause = matsCollections.CurveParams.findOne({\n    name: 'x-axis-parameter'\n  }).optionsMap[xAxisParam];\n  var yValClause = matsCollections.CurveParams.findOne({\n    name: 'y-axis-parameter'\n  }).optionsMap[yAxisParam];\n  var dataSourceStr = curve['data-source'];\n  var data_source = matsCollections.CurveParams.findOne({\n    name: 'data-source'\n  }).optionsMap[curve['data-source']][0];\n  var regionStr = curve['region'];\n  var region = Object.keys(matsCollections.CurveParams.findOne({\n    name: 'region'\n  }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n    name: 'region'\n  }).valuesMap[key] === regionStr);\n  var source = curve['truth'];\n  var sourceStr = \"\";\n\n  if (source !== \"All\") {\n    sourceStr = \"_\" + source;\n  }\n\n  var scaleStr = curve['scale'];\n  var scale = Object.keys(matsCollections.CurveParams.findOne({\n    name: 'scale'\n  }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n    name: 'scale'\n  }).valuesMap[key] === scaleStr);\n  var statisticSelect = curve['statistic'];\n  var statisticOptionsMap = matsCollections.CurveParams.findOne({\n    name: 'statistic'\n  }, {\n    optionsMap: 1\n  })['optionsMap'];\n  var statistic = statisticOptionsMap[statisticSelect][0];\n  var validTimeClause = \"\";\n  var thresholdClause = \"\";\n  var forecastLengthClause = \"\";\n  var dateClause = \"\";\n\n  if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n    var forecastLength = curve['forecast-length'];\n    forecastLengthClause = \"and m0.fcst_len = \" + forecastLength + \" \";\n  }\n\n  if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    thresholdClause = \"and m0.trsh = \" + threshold + \" \";\n  }\n\n  if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n\n    if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n      validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n    }\n  }\n\n  if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date') {\n    dateClause = \"m0.time-m0.fcst_len*3600\";\n  } else {\n    dateClause = \"m0.time\";\n  } // For contours, this functions as the colorbar label.\n\n\n  curve['unitKey'] = statisticOptionsMap[statisticSelect][1];\n  var d; // this is a database driven curve, not a difference curve\n  // prepare the query from the above parameters\n\n  var statement = \"{{xValClause}} \" + \"{{yValClause}} \" + \"count(distinct {{dateClause}}) as N_times, \" + \"min({{dateClause}}) as min_secs, \" + \"max({{dateClause}}) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and {{dateClause}} >= '{{fromSecs}}' \" + \"and {{dateClause}} <= '{{toSecs}}' \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"{{thresholdClause}} \" + \"{{validTimeClause}} \" + \"{{forecastLengthClause}} \" + \"group by xVal,yVal \" + \"order by xVal,yVal\" + \";\";\n  statement = statement.replace('{{xValClause}}', xValClause);\n  statement = statement.replace('{{yValClause}}', yValClause);\n  statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n  statement = statement.replace('{{statistic}}', statistic);\n  statement = statement.replace('{{threshold}}', threshold);\n  statement = statement.replace('{{fromSecs}}', fromSecs);\n  statement = statement.replace('{{toSecs}}', toSecs);\n  statement = statement.replace('{{thresholdClause}}', thresholdClause);\n  statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n  statement = statement.replace('{{validTimeClause}}', validTimeClause);\n  statement = statement.split('{{dateClause}}').join(dateClause);\n  dataRequests[curve.label] = statement; // math is done on forecastLength later on -- set all analyses to 0\n\n  if (forecastLength === \"-99\") {\n    forecastLength = \"0\";\n  }\n\n  var queryResult;\n  var startMoment = moment();\n  var finishMoment;\n\n  try {\n    // send the query statement to the query function\n    queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n    finishMoment = moment();\n    dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n      begin: startMoment.format(),\n      finish: finishMoment.format(),\n      duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n      recordCount: queryResult.data.xTextOutput.length\n    }; // get the data back from the query\n\n    d = queryResult.data;\n  } catch (e) {\n    // this is an error produced by a bug in the query function, not an error returned by the mysql database\n    e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n    throw new Error(e.message);\n  }\n\n  if (queryResult.error !== undefined && queryResult.error !== \"\") {\n    if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n      // this is NOT an error just a no data condition\n      dataFoundForCurve = false;\n    } else {\n      // this is an error returned by the mysql database\n      error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n      throw new Error(error);\n    }\n  }\n\n  var postQueryStartMoment = moment(); // set curve annotation to be the curve mean -- may be recalculated later\n  // also pass previously calculated axis stats to curve options\n\n  const mean = d.glob_stats.mean;\n  const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n  curve['annotation'] = annotation;\n  curve['xmin'] = d.xmin;\n  curve['xmax'] = d.xmax;\n  curve['ymin'] = d.ymin;\n  curve['ymax'] = d.ymax;\n  curve['zmin'] = d.zmin;\n  curve['zmax'] = d.zmax;\n  curve['xAxisKey'] = xAxisParam;\n  curve['yAxisKey'] = yAxisParam;\n  const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n  dataset.push(cOptions);\n  var postQueryFinishMoment = moment();\n  dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n    begin: postQueryStartMoment.format(),\n    finish: postQueryFinishMoment.format(),\n    duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n  }; // process the data returned by the query\n\n  const curveInfoParams = {\n    \"curve\": curves,\n    \"axisMap\": axisMap\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_contour_diff.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_contour_diff.js                                                                          //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataContourDiff = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.contourDiff;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n\n  if (curvesLength !== 2) {\n    throw new Error(\"INFO:  There must be two added curves.\");\n  }\n\n  if (curves[0]['x-axis-parameter'] !== curves[1]['x-axis-parameter'] || curves[0]['y-axis-parameter'] !== curves[1]['y-axis-parameter']) {\n    throw new Error(\"INFO:  The x-axis-parameter and y-axis-parameter must be consistent across both curves.\");\n  }\n\n  var dataset = [];\n  var axisMap = Object.create(null);\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var label = curve['label'];\n    var xAxisParam = curve['x-axis-parameter'];\n    var yAxisParam = curve['y-axis-parameter'];\n    var xValClause = matsCollections.CurveParams.findOne({\n      name: 'x-axis-parameter'\n    }).optionsMap[xAxisParam];\n    var yValClause = matsCollections.CurveParams.findOne({\n      name: 'y-axis-parameter'\n    }).optionsMap[yAxisParam];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimeClause = \"\";\n    var thresholdClause = \"\";\n    var forecastLengthClause = \"\";\n    var dateClause = \"\";\n\n    if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n      var forecastLength = curve['forecast-length'];\n      forecastLengthClause = \"and m0.fcst_len = \" + forecastLength;\n    }\n\n    if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n      var thresholdStr = curve['threshold'];\n      var threshold = Object.keys(matsCollections.CurveParams.findOne({\n        name: 'threshold'\n      }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n        name: 'threshold'\n      }).valuesMap[key] === thresholdStr);\n      thresholdClause = \"and m0.trsh = \" + threshold;\n    }\n\n    if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n      var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n      }\n    }\n\n    if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date') {\n      dateClause = \"m0.time-m0.fcst_len*3600\";\n    } else {\n      dateClause = \"m0.time\";\n    } // for two contours it's faster to just take care of matching in the query\n\n\n    var matchModel = \"\";\n    var matchDates = \"\";\n    var matchThresholdClause = \"\";\n    var matchValidTimeClause = \"\";\n    var matchForecastLengthClause = \"\";\n    var matchClause = \"\";\n\n    if (matching) {\n      const otherCurveIndex = curveIndex === 0 ? 1 : 0;\n      const otherModel = matsCollections.CurveParams.findOne({\n        name: 'data-source'\n      }).optionsMap[curves[otherCurveIndex]['data-source']][0];\n      const otherRegion = Object.keys(matsCollections.CurveParams.findOne({\n        name: 'region'\n      }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n        name: 'region'\n      }).valuesMap[key] === curves[otherCurveIndex]['region']);\n      matchModel = \", \" + otherModel + \"_\" + otherRegion + \" as a0\";\n      const matchDateClause = dateClause.split('m0').join('a0');\n      matchDates = \"and \" + matchDateClause + \" >= '\" + fromSecs + \"' and \" + matchDateClause + \" <= '\" + toSecs + \"'\";\n      matchClause = \"and m0.time = a0.time\";\n\n      if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n        var matchForecastLength = curves[otherCurveIndex]['forecast-length'];\n        matchForecastLengthClause = \"and a0.fcst_len = \" + matchForecastLength;\n      } else {\n        matchForecastLengthClause = \"and m0.fcst_len = a0.fcst_len\";\n      }\n\n      if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n        var matchThreshold = Object.keys(matsCollections.CurveParams.findOne({\n          name: 'threshold'\n        }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n          name: 'threshold'\n        }).valuesMap[key] === curves[otherCurveIndex]['threshold']);\n        matchThresholdClause = \"and a0.thresh = \" + matchThreshold;\n      } else {\n        matchThresholdClause = \"and m0.thresh = a0.thresh\";\n      }\n\n      if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n        var matchValidTimes = curves[otherCurveIndex]['valid-time'] === undefined ? [] : curves[otherCurveIndex]['valid-time'];\n\n        if (matchValidTimes.length > 0 && matchValidTimes !== matsTypes.InputTypes.unused) {\n          matchValidTimeClause = \" and a0.time%(24*3600)/3600 IN(\" + matchValidTimes + \")\";\n        }\n      }\n    } // For contours, this functions as the colorbar label.\n\n\n    curves[curveIndex]['unitKey'] = statisticOptionsMap[statisticSelect][1];\n    var d; // this is a database driven curve, not a difference curve\n    // prepare the query from the above parameters\n\n    var statement = \"{{xValClause}} \" + \"{{yValClause}} \" + \"count(distinct {{dateClause}}) as N_times, \" + \"min({{dateClause}}) as min_secs, \" + \"max({{dateClause}}) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0{{matchModel}} \" + \"where 1=1 \" + \"{{matchClause}} \" + \"and {{dateClause}} >= '{{fromSecs}}' \" + \"and {{dateClause}} <= '{{toSecs}}' \" + \"{{matchDates}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"{{thresholdClause}} \" + \"{{matchThresholdClause}} \" + \"{{validTimeClause}} \" + \"{{matchValidTimeClause}} \" + \"{{forecastLengthClause}} \" + \"{{matchForecastLengthClause}} \" + \"group by xVal,yVal \" + \"order by xVal,yVal\" + \";\";\n    statement = statement.replace('{{xValClause}}', xValClause);\n    statement = statement.replace('{{yValClause}}', yValClause);\n    statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n    statement = statement.replace('{{matchModel}}', matchModel);\n    statement = statement.replace('{{statistic}}', statistic);\n    statement = statement.replace('{{threshold}}', threshold);\n    statement = statement.replace('{{fromSecs}}', fromSecs);\n    statement = statement.replace('{{toSecs}}', toSecs);\n    statement = statement.replace('{{matchDates}}', matchDates);\n    statement = statement.replace('{{matchClause}}', matchClause);\n    statement = statement.replace('{{thresholdClause}}', thresholdClause);\n    statement = statement.replace('{{matchThresholdClause}}', matchThresholdClause);\n    statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n    statement = statement.replace('{{matchForecastLengthClause}}', matchForecastLengthClause);\n    statement = statement.replace('{{validTimeClause}}', validTimeClause);\n    statement = statement.replace('{{matchValidTimeClause}}', matchValidTimeClause);\n    statement = statement.split('{{dateClause}}').join(dateClause);\n    dataRequests[curve.label] = statement; // math is done on forecastLength later on -- set all analyses to 0\n\n    if (forecastLength === \"-99\") {\n      forecastLength = \"0\";\n    }\n\n    var queryResult;\n    var startMoment = moment();\n    var finishMoment;\n\n    try {\n      // send the query statement to the query function\n      queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n      finishMoment = moment();\n      dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n        begin: startMoment.format(),\n        finish: finishMoment.format(),\n        duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n        recordCount: queryResult.data.xTextOutput.length\n      }; // get the data back from the query\n\n      d = queryResult.data;\n    } catch (e) {\n      // this is an error produced by a bug in the query function, not an error returned by the mysql database\n      e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n      throw new Error(e.message);\n    }\n\n    if (queryResult.error !== undefined && queryResult.error !== \"\") {\n      if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n        // this is NOT an error just a no data condition\n        dataFoundForCurve = false;\n      } else {\n        // this is an error returned by the mysql database\n        error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n        throw new Error(error);\n      }\n    }\n\n    var postQueryStartMoment = moment(); // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n    const mean = d.glob_stats.mean;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['zmin'] = d.zmin;\n    curve['zmax'] = d.zmax;\n    curve['xAxisKey'] = xAxisParam;\n    curve['yAxisKey'] = yAxisParam;\n    const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // turn the two contours into one difference contour\n\n\n  dataset = matsDataDiffUtils.getDataForDiffContour(dataset);\n  plotParams.curves = matsDataUtils.getDiffContourCurveParams(plotParams.curves);\n  curves = plotParams.curves; // process the data returned by the query\n\n  const curveInfoParams = {\n    \"curve\": curves,\n    \"axisMap\": axisMap\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_dailymodelcycle.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_dailymodelcycle.js                                                                       //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataDailyModelCycle = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.dailyModelCycle;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var utcCycleStart = Number(curve['utc-cycle-start']);\n    utcCycleStarts[curveIndex] = utcCycleStart; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select m0.time as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.time >= {{fromSecs}} \" + \"and m0.time <= {{toSecs}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = {{threshold}} \" + \"and m0.fcst_len < 24 \" + \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN({{utcCycleStart}}) \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{utcCycleStart}}', utcCycleStart);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_dieoff.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_dieoff.js                                                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataDieOff = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.dieoff;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var forecastLengthStr = curve['dieoff-type'];\n    var forecastLengthOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'dieoff-type'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var forecastLength = forecastLengthOptionsMap[forecastLengthStr][0];\n    var validTimes;\n    var validTimeClause = \"\";\n    var utcCycleStart;\n    var utcCycleStartClause = \"\";\n    var dateRangeClause = \"and m0.time >= \" + fromSecs + \" and m0.time <= \" + toSecs;\n\n    if (forecastLength === matsTypes.ForecastTypes.dieoff) {\n      validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n\n      if (validTimes.length !== 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \"and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n    } else if (forecastLength === matsTypes.ForecastTypes.utcCycle) {\n      utcCycleStart = Number(curve['utc-cycle-start']);\n      utcCycleStartClause = \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN(\" + utcCycleStart + \")\";\n    } else {\n      dateRangeClause = \"and (m0.time - m0.fcst_len*3600) = \" + fromSecs;\n    } // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"SELECT m0.fcst_len AS avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"{{dateRangeClause}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = {{threshold}} \" + \"{{validTimeClause}} \" + \"{{utcCycleStartClause}} \" + \"group by avtime \" + \"order by avtime;\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{dateRangeClause}}', dateRangeClause);\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      statement = statement.replace('{{utcCycleStartClause}}', utcCycleStartClause);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_histogram.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_histogram.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 4);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 5);\n\ndataHistogram = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const plotType = matsTypes.PlotTypes.histogram;\n  const hasLevels = false;\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  var alreadyMatched = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = [];\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var allReturnedSubStats = [];\n  var allReturnedSubSecs = [];\n  var axisMap = Object.create(null); // process user bin customizations\n\n  const binParams = matsDataUtils.setHistogramParameters(plotParams);\n  const yAxisFormat = binParams.yAxisFormat;\n  const binNum = binParams.binNum;\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    dataFoundForCurve[curveIndex] = true;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = yAxisFormat;\n\n    if (yAxisFormat === 'Relative frequency') {\n      axisKey = axisKey + \" (x100)\";\n    }\n\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    curves[curveIndex].binNum = binNum; // stash the binNum to use it later for bar chart options\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select m0.time as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"{{validTimeClause}} \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = '{{threshold}}' \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      var validTimeClause = \" \";\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n        allReturnedSubStats.push(d.subVals); // save returned data so that we can calculate histogram stats once all the queries are done\n\n        allReturnedSubSecs.push(d.subSecs);\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve[curveIndex] = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      }\n    }\n  }\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"dataFoundForCurve\": dataFoundForCurve,\n    \"axisMap\": axisMap,\n    \"yAxisFormat\": yAxisFormat\n  };\n  const bookkeepingParams = {\n    \"alreadyMatched\": alreadyMatched,\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataHistogram(allReturnedSubStats, allReturnedSubSecs, [], dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_series.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_series.js                                                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataSeries = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.timeSeries;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n    var averageStr = curve['average'];\n    var averageOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'average'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var average = averageOptionsMap[averageStr][0];\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select {{average}} as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"{{validTimeClause}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = '{{threshold}}' \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{average}}', average);\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      var validTimeClause = \" \";\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      dataRequests[curve.label] = statement; // math is done on forecastLength later on -- set all analyses to 0\n\n      if (forecastLength === \"-99\") {\n        forecastLength = \"0\";\n      }\n\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBTimeSeries(sumPool, statement, data_source, forecastLength, fromSecs, toSecs, averageStr, validTimes, hasLevels, false);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_threshold.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_threshold.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataThreshold = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.threshold;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"SELECT m0.trsh/100 as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"{{validTimeClause}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      var validTimeClause = \" \";\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"data_validtime.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/dataFunctions/data_validtime.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataValidTime = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.validtime;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select floor(m0.time%(24*3600)/3600) as hr_of_day, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = '{{threshold}}' \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by hr_of_day \" + \"order by hr_of_day\" + \";\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nrequire(\"/server/dataFunctions/data_contour.js\");\nrequire(\"/server/dataFunctions/data_contour_diff.js\");\nrequire(\"/server/dataFunctions/data_dailymodelcycle.js\");\nrequire(\"/server/dataFunctions/data_dieoff.js\");\nrequire(\"/server/dataFunctions/data_histogram.js\");\nrequire(\"/server/dataFunctions/data_series.js\");\nrequire(\"/server/dataFunctions/data_threshold.js\");\nrequire(\"/server/dataFunctions/data_validtime.js\");","hash":"ee9c2503cc53bffb9774131a742b8d4012960551","servePath":"/app.js","sourceMap":{"version":3,"sources":["server/dataFunctions/data_contour.js","server/dataFunctions/data_contour_diff.js","server/dataFunctions/data_dailymodelcycle.js","server/dataFunctions/data_dieoff.js","server/dataFunctions/data_histogram.js","server/dataFunctions/data_series.js","server/dataFunctions/data_threshold.js","server/dataFunctions/data_validtime.js"],"names":["matsCollections","module","link","v","matsTypes","matsDataUtils","matsDataQueryUtils","matsDataCurveOpsUtils","matsDataProcessUtils","moment","dataContour","plotParams","plotFunction","plotType","PlotTypes","contour","dataRequests","dataFoundForCurve","totalProcessingStart","dateRange","getDateRange","dates","fromSecs","fromSeconds","toSecs","toSeconds","error","curves","JSON","parse","stringify","length","Error","dataset","axisMap","Object","create","curve","label","xAxisParam","yAxisParam","xValClause","CurveParams","findOne","name","optionsMap","yValClause","dataSourceStr","data_source","regionStr","region","keys","valuesMap","find","key","source","sourceStr","scaleStr","scale","statisticSelect","statisticOptionsMap","statistic","validTimeClause","thresholdClause","forecastLengthClause","dateClause","forecastLength","thresholdStr","threshold","validTimes","undefined","InputTypes","unused","d","statement","replace","split","join","queryResult","startMoment","finishMoment","queryDBContour","sumPool","begin","format","finish","duration","diff","asSeconds","recordCount","data","xTextOutput","e","message","Messages","NO_DATA_FOUND","postQueryStartMoment","mean","glob_stats","annotation","toPrecision","xmin","xmax","ymin","ymax","zmin","zmax","cOptions","generateContourCurveOptions","push","postQueryFinishMoment","curveInfoParams","bookkeepingParams","result","processDataContour","matsDataDiffUtils","dataContourDiff","matching","PlotActions","matched","contourDiff","curvesLength","curveIndex","matchModel","matchDates","matchThresholdClause","matchValidTimeClause","matchForecastLengthClause","matchClause","otherCurveIndex","otherModel","otherRegion","matchDateClause","matchForecastLength","matchThreshold","matchValidTimes","getDataForDiffContour","getDiffContourCurveParams","dataDailyModelCycle","dailyModelCycle","hasLevels","utcCycleStarts","Number","MAX_VALUE","idealValues","diffFrom","utcCycleStart","axisKey","idealVal","indexOf","queryDBSpecialtyCurve","x","diffResult","getDataForDiffCurve","sum","generateSeriesCurveOptions","appParams","processDataXYCurve","dataDieOff","dieoff","forecastLengthStr","forecastLengthOptionsMap","utcCycleStartClause","dateRangeClause","ForecastTypes","utcCycle","dataHistogram","histogram","alreadyMatched","allReturnedSubStats","allReturnedSubSecs","binParams","setHistogramParameters","yAxisFormat","binNum","subVals","subSecs","processDataHistogram","dataSeries","timeSeries","averageStr","averageOptionsMap","average","queryDBTimeSeries","dataThreshold","dataValidTime","validtime"],"mappings":";;;;;;;;AAAA,IAAIA,eAAJ;AAAoBC,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACF,iBAAe,CAACG,CAAD,EAAG;AAACH,mBAAe,GAACG,CAAhB;AAAkB;;AAAtC,CAAxC,EAAgF,CAAhF;AAAmF,IAAIC,SAAJ;AAAcH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACE,WAAS,CAACD,CAAD,EAAG;AAACC,aAAS,GAACD,CAAV;AAAY;;AAA1B,CAAxC,EAAoE,CAApE;AAAuE,IAAIE,aAAJ;AAAkBJ,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACG,eAAa,CAACF,CAAD,EAAG;AAACE,iBAAa,GAACF,CAAd;AAAgB;;AAAlC,CAAxC,EAA4E,CAA5E;AAA+E,IAAIG,kBAAJ;AAAuBL,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACI,oBAAkB,CAACH,CAAD,EAAG;AAACG,sBAAkB,GAACH,CAAnB;AAAqB;;AAA5C,CAAxC,EAAsF,CAAtF;AAAyF,IAAII,qBAAJ;AAA0BN,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACK,uBAAqB,CAACJ,CAAD,EAAG;AAACI,yBAAqB,GAACJ,CAAtB;AAAwB;;AAAlD,CAAxC,EAA4F,CAA5F;AAA+F,IAAIK,oBAAJ;AAAyBP,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACM,sBAAoB,CAACL,CAAD,EAAG;AAACK,wBAAoB,GAACL,CAArB;AAAuB;;AAAhD,CAAxC,EAA0F,CAA1F;AAA6F,IAAIM,MAAJ;AAAWR,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACO,QAAM,CAACN,CAAD,EAAG;AAACM,UAAM,GAACN,CAAP;AAAS;;AAApB,CAArC,EAA2D,CAA3D;;AAYvoBO,WAAW,GAAG,UAAUC,UAAV,EAAsBC,YAAtB,EAAoC;AAC9C;AACA,QAAMC,QAAQ,GAAGT,SAAS,CAACU,SAAV,CAAoBC,OAArC;AACA,MAAIC,YAAY,GAAG,EAAnB,CAH8C,CAGvB;;AACvB,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,oBAAoB,GAAGT,MAAM,EAAjC;AACA,MAAIU,SAAS,GAAGd,aAAa,CAACe,YAAd,CAA2BT,UAAU,CAACU,KAAtC,CAAhB;AACA,MAAIC,QAAQ,GAAGH,SAAS,CAACI,WAAzB;AACA,MAAIC,MAAM,GAAGL,SAAS,CAACM,SAAvB;AACA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,UAAU,CAACgB,MAA1B,CAAX,CAAb;;AACA,MAAIA,MAAM,CAACI,MAAP,GAAgB,CAApB,EAAuB;AACnB,UAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN;AACH;;AACD,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd,CAf8C,CAiB9C;;AACA,MAAIC,KAAK,GAAGV,MAAM,CAAC,CAAD,CAAlB;AACA,MAAIW,KAAK,GAAGD,KAAK,CAAC,OAAD,CAAjB;AACA,MAAIE,UAAU,GAAGF,KAAK,CAAC,kBAAD,CAAtB;AACA,MAAIG,UAAU,GAAGH,KAAK,CAAC,kBAAD,CAAtB;AACA,MAAII,UAAU,GAAGzC,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,QAAI,EAAE;AAAP,GAApC,EAAgEC,UAAhE,CAA2EN,UAA3E,CAAjB;AACA,MAAIO,UAAU,GAAG9C,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,QAAI,EAAE;AAAP,GAApC,EAAgEC,UAAhE,CAA2EL,UAA3E,CAAjB;AACA,MAAIO,aAAa,GAAGV,KAAK,CAAC,aAAD,CAAzB;AACA,MAAIW,WAAW,GAAGhD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,QAAI,EAAE;AAAP,GAApC,EAA2DC,UAA3D,CAAsER,KAAK,CAAC,aAAD,CAA3E,EAA4F,CAA5F,CAAlB;AACA,MAAIY,SAAS,GAAGZ,KAAK,CAAC,QAAD,CAArB;AACA,MAAIa,MAAM,GAAGf,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,QAAI,EAAE;AAAP,GAApC,EAAsDQ,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,QAAI,EAAE;AAAP,GAApC,EAAsDQ,SAAtD,CAAgEE,GAAhE,MAAyEL,SAAlK,CAAb;AACA,MAAIM,MAAM,GAAGlB,KAAK,CAAC,OAAD,CAAlB;AACA,MAAImB,SAAS,GAAG,EAAhB;;AACA,MAAID,MAAM,KAAK,KAAf,EAAsB;AAClBC,aAAS,GAAG,MAAMD,MAAlB;AACH;;AACD,MAAIE,QAAQ,GAAGpB,KAAK,CAAC,OAAD,CAApB;AACA,MAAIqB,KAAK,GAAGvB,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,QAAI,EAAE;AAAP,GAApC,EAAqDQ,SAAjE,EAA4EC,IAA5E,CAAiFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,QAAI,EAAE;AAAP,GAApC,EAAqDQ,SAArD,CAA+DE,GAA/D,MAAwEG,QAAhK,CAAZ;AACA,MAAIE,eAAe,GAAGtB,KAAK,CAAC,WAAD,CAA3B;AACA,MAAIuB,mBAAmB,GAAG5D,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,QAAI,EAAE;AAAP,GAApC,EAAyD;AAACC,cAAU,EAAE;AAAb,GAAzD,EAA0E,YAA1E,CAA1B;AACA,MAAIgB,SAAS,GAAGD,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhB;AACA,MAAIG,eAAe,GAAG,EAAtB;AACA,MAAIC,eAAe,GAAG,EAAtB;AACA,MAAIC,oBAAoB,GAAG,EAA3B;AACA,MAAIC,UAAU,GAAG,EAAjB;;AACA,MAAI1B,UAAU,KAAK,gBAAf,IAAmCC,UAAU,KAAK,gBAAtD,EAAwE;AACpE,QAAI0B,cAAc,GAAG7B,KAAK,CAAC,iBAAD,CAA1B;AACA2B,wBAAoB,GAAG,uBAAuBE,cAAvB,GAAwC,GAA/D;AACH;;AACD,MAAI3B,UAAU,KAAK,WAAf,IAA8BC,UAAU,KAAK,WAAjD,EAA8D;AAC1D,QAAI2B,YAAY,GAAG9B,KAAK,CAAC,WAAD,CAAxB;AACA,QAAI+B,SAAS,GAAGjC,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAArE,EAAgFC,IAAhF,CAAqFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAAzD,CAAmEE,GAAnE,MAA4Ea,YAAxK,CAAhB;AACAJ,mBAAe,GAAG,mBAAmBK,SAAnB,GAA+B,GAAjD;AACH;;AACD,MAAI7B,UAAU,KAAK,gBAAf,IAAmCC,UAAU,KAAK,gBAAtD,EAAwE;AACpE,QAAI6B,UAAU,GAAGhC,KAAK,CAAC,YAAD,CAAL,KAAwBiC,SAAxB,GAAoC,EAApC,GAAyCjC,KAAK,CAAC,YAAD,CAA/D;;AACA,QAAIgC,UAAU,CAACtC,MAAX,GAAoB,CAApB,IAAyBsC,UAAU,KAAKjE,SAAS,CAACmE,UAAV,CAAqBC,MAAjE,EAAyE;AACrEV,qBAAe,GAAG,qCAAqCO,UAArC,GAAkD,GAApE;AACH;AACJ;;AACD,MAAI,CAAC9B,UAAU,KAAK,WAAf,IAA8BC,UAAU,KAAK,WAA9C,KAA+DD,UAAU,KAAK,YAAf,IAA+BC,UAAU,KAAK,YAAjH,EAAgI;AAC5HyB,cAAU,GAAG,0BAAb;AACH,GAFD,MAEO;AACHA,cAAU,GAAG,SAAb;AACH,GA7D6C,CA+D9C;;;AACA5B,OAAK,CAAC,SAAD,CAAL,GAAmBuB,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAnB;AAEA,MAAIc,CAAJ,CAlE8C,CAmE9C;AACA;;AACA,MAAIC,SAAS,GAAG,oBACZ,iBADY,GAEZ,6CAFY,GAGZ,mCAHY,GAIZ,mCAJY,GAKZ,gBALY,GAMZ,6BANY,GAOZ,YAPY,GAQZ,uCARY,GASZ,qCATY,GAUZ,qCAVY,GAWZ,sBAXY,GAYZ,sBAZY,GAaZ,2BAbY,GAcZ,qBAdY,GAeZ,oBAfY,GAgBZ,GAhBJ;AAkBAA,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,gBAAlB,EAAoClC,UAApC,CAAZ;AACAiC,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,gBAAlB,EAAoC7B,UAApC,CAAZ;AACA4B,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqC3B,WAAW,GAAG,GAAd,GAAoBU,KAApB,GAA4BF,SAA5B,GAAwC,GAAxC,GAA8CN,MAAnF,CAAZ;AACAwB,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCd,SAAnC,CAAZ;AACAa,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCP,SAAnC,CAAZ;AACAM,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,cAAlB,EAAkCrD,QAAlC,CAAZ;AACAoD,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,YAAlB,EAAgCnD,MAAhC,CAAZ;AACAkD,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCZ,eAAzC,CAAZ;AACAW,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,0BAAlB,EAA8CX,oBAA9C,CAAZ;AACAU,WAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCb,eAAzC,CAAZ;AACAY,WAAS,GAAGA,SAAS,CAACE,KAAV,CAAgB,gBAAhB,EAAkCC,IAAlC,CAAuCZ,UAAvC,CAAZ;AACAjD,cAAY,CAACqB,KAAK,CAACC,KAAP,CAAZ,GAA4BoC,SAA5B,CAlG8C,CAoG9C;;AACA,MAAIR,cAAc,KAAK,KAAvB,EAA8B;AAC1BA,kBAAc,GAAG,GAAjB;AACH;;AAED,MAAIY,WAAJ;AACA,MAAIC,WAAW,GAAGtE,MAAM,EAAxB;AACA,MAAIuE,YAAJ;;AACA,MAAI;AACA;AACAF,eAAW,GAAGxE,kBAAkB,CAAC2E,cAAnB,CAAkCC,OAAlC,EAA2CR,SAA3C,CAAd;AACAM,gBAAY,GAAGvE,MAAM,EAArB;AACAO,gBAAY,CAAC,mCAAmCqB,KAAK,CAACC,KAA1C,CAAZ,GAA+D;AAC3D6C,WAAK,EAAEJ,WAAW,CAACK,MAAZ,EADoD;AAE3DC,YAAM,EAAEL,YAAY,CAACI,MAAb,EAFmD;AAG3DE,cAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBN,YAAY,CAACO,IAAb,CAAkBR,WAAlB,CAAhB,EAAgDS,SAAhD,KAA8D,UAHb;AAI3DC,iBAAW,EAAEX,WAAW,CAACY,IAAZ,CAAiBC,WAAjB,CAA6B5D;AAJiB,KAA/D,CAJA,CAUA;;AACA0C,KAAC,GAAGK,WAAW,CAACY,IAAhB;AACH,GAZD,CAYE,OAAOE,CAAP,EAAU;AACR;AACAA,KAAC,CAACC,OAAF,GAAY,uBAAuBD,CAAC,CAACC,OAAzB,GAAmC,kBAAnC,GAAwDnB,SAApE;AACA,UAAM,IAAI1C,KAAJ,CAAU4D,CAAC,CAACC,OAAZ,CAAN;AACH;;AACD,MAAIf,WAAW,CAACpD,KAAZ,KAAsB4C,SAAtB,IAAmCQ,WAAW,CAACpD,KAAZ,KAAsB,EAA7D,EAAiE;AAC7D,QAAIoD,WAAW,CAACpD,KAAZ,KAAsBtB,SAAS,CAAC0F,QAAV,CAAmBC,aAA7C,EAA4D;AACxD;AACA9E,uBAAiB,GAAG,KAApB;AACH,KAHD,MAGO;AACH;AACAS,WAAK,IAAI,wCAAwCoD,WAAW,CAACpD,KAApD,GAA4D,kBAA5D,GAAiFgD,SAAjF,GAA6F,MAAtG;AACA,YAAO,IAAI1C,KAAJ,CAAUN,KAAV,CAAP;AACH;AACJ;;AAED,MAAIsE,oBAAoB,GAAGvF,MAAM,EAAjC,CAxI8C,CA0I9C;AACA;;AACA,QAAMwF,IAAI,GAAGxB,CAAC,CAACyB,UAAF,CAAaD,IAA1B;AACA,QAAME,UAAU,GAAGF,IAAI,KAAK3B,SAAT,GAAqBhC,KAAK,GAAG,cAA7B,GAA8CA,KAAK,GAAG,WAAR,GAAsB2D,IAAI,CAACG,WAAL,CAAiB,CAAjB,CAAvF;AACA/D,OAAK,CAAC,YAAD,CAAL,GAAsB8D,UAAtB;AACA9D,OAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC4B,IAAlB;AACAhE,OAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC6B,IAAlB;AACAjE,OAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC8B,IAAlB;AACAlE,OAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC+B,IAAlB;AACAnE,OAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAACgC,IAAlB;AACApE,OAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAACiC,IAAlB;AACArE,OAAK,CAAC,UAAD,CAAL,GAAoBE,UAApB;AACAF,OAAK,CAAC,UAAD,CAAL,GAAoBG,UAApB;AACA,QAAMmE,QAAQ,GAAGpG,qBAAqB,CAACqG,2BAAtB,CAAkDvE,KAAlD,EAAyDH,OAAzD,EAAkEuC,CAAlE,CAAjB,CAvJ8C,CAuJ0C;;AACxFxC,SAAO,CAAC4E,IAAR,CAAaF,QAAb;AACA,MAAIG,qBAAqB,GAAGrG,MAAM,EAAlC;AACAO,cAAY,CAAC,gDAAgDqB,KAAK,CAACC,KAAvD,CAAZ,GAA4E;AACxE6C,SAAK,EAAEa,oBAAoB,CAACZ,MAArB,EADiE;AAExEC,UAAM,EAAEyB,qBAAqB,CAAC1B,MAAtB,EAFgE;AAGxEE,YAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBwB,qBAAqB,CAACvB,IAAtB,CAA2BS,oBAA3B,CAAhB,EAAkER,SAAlE,KAAgF;AAHlB,GAA5E,CA1J8C,CAgK9C;;AACA,QAAMuB,eAAe,GAAG;AAAC,aAASpF,MAAV;AAAkB,eAAWO;AAA7B,GAAxB;AACA,QAAM8E,iBAAiB,GAAG;AAAC,oBAAgBhG,YAAjB;AAA+B,4BAAwBE;AAAvD,GAA1B;AACA,MAAI+F,MAAM,GAAGzG,oBAAoB,CAAC0G,kBAArB,CAAwCjF,OAAxC,EAAiD8E,eAAjD,EAAkEpG,UAAlE,EAA8EqG,iBAA9E,CAAb;AACApG,cAAY,CAACqG,MAAD,CAAZ;AACH,CArKD,C;;;;;;;;;;;ACZA,IAAIjH,eAAJ;AAAoBC,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACF,iBAAe,CAACG,CAAD,EAAG;AAACH,mBAAe,GAACG,CAAhB;AAAkB;;AAAtC,CAAxC,EAAgF,CAAhF;AAAmF,IAAIC,SAAJ;AAAcH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACE,WAAS,CAACD,CAAD,EAAG;AAACC,aAAS,GAACD,CAAV;AAAY;;AAA1B,CAAxC,EAAoE,CAApE;AAAuE,IAAIE,aAAJ;AAAkBJ,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACG,eAAa,CAACF,CAAD,EAAG;AAACE,iBAAa,GAACF,CAAd;AAAgB;;AAAlC,CAAxC,EAA4E,CAA5E;AAA+E,IAAIG,kBAAJ;AAAuBL,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACI,oBAAkB,CAACH,CAAD,EAAG;AAACG,sBAAkB,GAACH,CAAnB;AAAqB;;AAA5C,CAAxC,EAAsF,CAAtF;AAAyF,IAAIgH,iBAAJ;AAAsBlH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACiH,mBAAiB,CAAChH,CAAD,EAAG;AAACgH,qBAAiB,GAAChH,CAAlB;AAAoB;;AAA1C,CAAxC,EAAoF,CAApF;AAAuF,IAAII,qBAAJ;AAA0BN,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACK,uBAAqB,CAACJ,CAAD,EAAG;AAACI,yBAAqB,GAACJ,CAAtB;AAAwB;;AAAlD,CAAxC,EAA4F,CAA5F;AAA+F,IAAIK,oBAAJ;AAAyBP,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACM,sBAAoB,CAACL,CAAD,EAAG;AAACK,wBAAoB,GAACL,CAArB;AAAuB;;AAAhD,CAAxC,EAA0F,CAA1F;AAA6F,IAAIM,MAAJ;AAAWR,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACO,QAAM,CAACN,CAAD,EAAG;AAACM,UAAM,GAACN,CAAP;AAAS;;AAApB,CAArC,EAA2D,CAA3D;;AAapvBiH,eAAe,GAAG,UAAUzG,UAAV,EAAsBC,YAAtB,EAAoC;AAClD;AACA,QAAMyG,QAAQ,GAAG1G,UAAU,CAAC,YAAD,CAAV,KAA6BP,SAAS,CAACkH,WAAV,CAAsBC,OAApE;AACA,QAAM1G,QAAQ,GAAGT,SAAS,CAACU,SAAV,CAAoB0G,WAArC;AACA,MAAIxG,YAAY,GAAG,EAAnB,CAJkD,CAI3B;;AACvB,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,oBAAoB,GAAGT,MAAM,EAAjC;AACA,MAAIU,SAAS,GAAGd,aAAa,CAACe,YAAd,CAA2BT,UAAU,CAACU,KAAtC,CAAhB;AACA,MAAIC,QAAQ,GAAGH,SAAS,CAACI,WAAzB;AACA,MAAIC,MAAM,GAAGL,SAAS,CAACM,SAAvB;AACA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,UAAU,CAACgB,MAA1B,CAAX,CAAb;AACA,MAAI8F,YAAY,GAAG9F,MAAM,CAACI,MAA1B;;AACA,MAAI0F,YAAY,KAAK,CAArB,EAAwB;AACpB,UAAM,IAAIzF,KAAJ,CAAU,wCAAV,CAAN;AACH;;AACD,MAAIL,MAAM,CAAC,CAAD,CAAN,CAAU,kBAAV,MAAkCA,MAAM,CAAC,CAAD,CAAN,CAAU,kBAAV,CAAlC,IAAmEA,MAAM,CAAC,CAAD,CAAN,CAAU,kBAAV,MAAkCA,MAAM,CAAC,CAAD,CAAN,CAAU,kBAAV,CAAzG,EAAwI;AACpI,UAAM,IAAIK,KAAJ,CAAU,yFAAV,CAAN;AACH;;AACD,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;;AAEA,OAAK,IAAIsF,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGD,YAAtC,EAAoDC,UAAU,EAA9D,EAAkE;AAC9D;AACA,QAAIrF,KAAK,GAAGV,MAAM,CAAC+F,UAAD,CAAlB;AACA,QAAIpF,KAAK,GAAGD,KAAK,CAAC,OAAD,CAAjB;AACA,QAAIE,UAAU,GAAGF,KAAK,CAAC,kBAAD,CAAtB;AACA,QAAIG,UAAU,GAAGH,KAAK,CAAC,kBAAD,CAAtB;AACA,QAAII,UAAU,GAAGzC,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAgEC,UAAhE,CAA2EN,UAA3E,CAAjB;AACA,QAAIO,UAAU,GAAG9C,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAgEC,UAAhE,CAA2EL,UAA3E,CAAjB;AACA,QAAIO,aAAa,GAAGV,KAAK,CAAC,aAAD,CAAzB;AACA,QAAIW,WAAW,GAAGhD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAA2DC,UAA3D,CAAsER,KAAK,CAAC,aAAD,CAA3E,EAA4F,CAA5F,CAAlB;AACA,QAAIY,SAAS,GAAGZ,KAAK,CAAC,QAAD,CAArB;AACA,QAAIa,MAAM,GAAGf,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAtD,CAAgEE,GAAhE,MAAyEL,SAAlK,CAAb;AACA,QAAIM,MAAM,GAAGlB,KAAK,CAAC,OAAD,CAAlB;AACA,QAAImB,SAAS,GAAG,EAAhB;;AACA,QAAID,MAAM,KAAK,KAAf,EAAsB;AAClBC,eAAS,GAAG,MAAMD,MAAlB;AACH;;AACD,QAAIE,QAAQ,GAAGpB,KAAK,CAAC,OAAD,CAApB;AACA,QAAIqB,KAAK,GAAGvB,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAAjE,EAA4EC,IAA5E,CAAiFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAArD,CAA+DE,GAA/D,MAAwEG,QAAhK,CAAZ;AACA,QAAIE,eAAe,GAAGtB,KAAK,CAAC,WAAD,CAA3B;AACA,QAAIuB,mBAAmB,GAAG5D,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyD;AAACC,gBAAU,EAAE;AAAb,KAAzD,EAA0E,YAA1E,CAA1B;AACA,QAAIgB,SAAS,GAAGD,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhB;AACA,QAAIG,eAAe,GAAG,EAAtB;AACA,QAAIC,eAAe,GAAG,EAAtB;AACA,QAAIC,oBAAoB,GAAG,EAA3B;AACA,QAAIC,UAAU,GAAG,EAAjB;;AACA,QAAI1B,UAAU,KAAK,gBAAf,IAAmCC,UAAU,KAAK,gBAAtD,EAAwE;AACpE,UAAI0B,cAAc,GAAG7B,KAAK,CAAC,iBAAD,CAA1B;AACA2B,0BAAoB,GAAG,uBAAuBE,cAA9C;AACH;;AACD,QAAI3B,UAAU,KAAK,WAAf,IAA8BC,UAAU,KAAK,WAAjD,EAA8D;AAC1D,UAAI2B,YAAY,GAAG9B,KAAK,CAAC,WAAD,CAAxB;AACA,UAAI+B,SAAS,GAAGjC,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,YAAI,EAAE;AAAP,OAApC,EAAyDQ,SAArE,EAAgFC,IAAhF,CAAqFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,YAAI,EAAE;AAAP,OAApC,EAAyDQ,SAAzD,CAAmEE,GAAnE,MAA4Ea,YAAxK,CAAhB;AACAJ,qBAAe,GAAG,mBAAmBK,SAArC;AACH;;AACD,QAAI7B,UAAU,KAAK,gBAAf,IAAmCC,UAAU,KAAK,gBAAtD,EAAwE;AACpE,UAAI6B,UAAU,GAAGhC,KAAK,CAAC,YAAD,CAAL,KAAwBiC,SAAxB,GAAoC,EAApC,GAAyCjC,KAAK,CAAC,YAAD,CAA/D;;AACA,UAAIgC,UAAU,CAACtC,MAAX,GAAoB,CAApB,IAAyBsC,UAAU,KAAKjE,SAAS,CAACmE,UAAV,CAAqBC,MAAjE,EAAyE;AACrEV,uBAAe,GAAG,qCAAqCO,UAArC,GAAkD,GAApE;AACH;AACJ;;AACD,QAAI,CAAC9B,UAAU,KAAK,WAAf,IAA8BC,UAAU,KAAK,WAA9C,KAA+DD,UAAU,KAAK,YAAf,IAA+BC,UAAU,KAAK,YAAjH,EAAgI;AAC5HyB,gBAAU,GAAG,0BAAb;AACH,KAFD,MAEO;AACHA,gBAAU,GAAG,SAAb;AACH,KA7C6D,CA+C9D;;;AACA,QAAI0D,UAAU,GAAG,EAAjB;AACA,QAAIC,UAAU,GAAG,EAAjB;AACA,QAAIC,oBAAoB,GAAG,EAA3B;AACA,QAAIC,oBAAoB,GAAG,EAA3B;AACA,QAAIC,yBAAyB,GAAG,EAAhC;AACA,QAAIC,WAAW,GAAG,EAAlB;;AACA,QAAIX,QAAJ,EAAc;AACV,YAAMY,eAAe,GAAGP,UAAU,KAAK,CAAf,GAAmB,CAAnB,GAAuB,CAA/C;AACA,YAAMQ,UAAU,GAAGlI,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,YAAI,EAAE;AAAP,OAApC,EAA2DC,UAA3D,CAAsElB,MAAM,CAACsG,eAAD,CAAN,CAAwB,aAAxB,CAAtE,EAA8G,CAA9G,CAAnB;AACA,YAAME,WAAW,GAAGhG,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,YAAI,EAAE;AAAP,OAApC,EAAsDQ,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,YAAI,EAAE;AAAP,OAApC,EAAsDQ,SAAtD,CAAgEE,GAAhE,MAAyE3B,MAAM,CAACsG,eAAD,CAAN,CAAwB,QAAxB,CAAlK,CAApB;AAEAN,gBAAU,GAAG,OAAOO,UAAP,GAAoB,GAApB,GAA0BC,WAA1B,GAAwC,QAArD;AACA,YAAMC,eAAe,GAAGnE,UAAU,CAACW,KAAX,CAAiB,IAAjB,EAAuBC,IAAvB,CAA4B,IAA5B,CAAxB;AACA+C,gBAAU,GAAG,SAASQ,eAAT,GAA2B,OAA3B,GAAqC9G,QAArC,GAAgD,QAAhD,GAA2D8G,eAA3D,GAA6E,OAA7E,GAAuF5G,MAAvF,GAAgG,GAA7G;AACAwG,iBAAW,GAAG,uBAAd;;AAEA,UAAIzF,UAAU,KAAK,gBAAf,IAAmCC,UAAU,KAAK,gBAAtD,EAAwE;AACpE,YAAI6F,mBAAmB,GAAG1G,MAAM,CAACsG,eAAD,CAAN,CAAwB,iBAAxB,CAA1B;AACAF,iCAAyB,GAAG,uBAAuBM,mBAAnD;AACH,OAHD,MAGO;AACHN,iCAAyB,GAAG,+BAA5B;AACH;;AACD,UAAIxF,UAAU,KAAK,WAAf,IAA8BC,UAAU,KAAK,WAAjD,EAA8D;AAC1D,YAAI8F,cAAc,GAAGnG,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,cAAI,EAAE;AAAP,SAApC,EAAyDQ,SAArE,EAAgFC,IAAhF,CAAqFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,cAAI,EAAE;AAAP,SAApC,EAAyDQ,SAAzD,CAAmEE,GAAnE,MAA4E3B,MAAM,CAACsG,eAAD,CAAN,CAAwB,WAAxB,CAAxK,CAArB;AACAJ,4BAAoB,GAAG,qBAAqBS,cAA5C;AACH,OAHD,MAGO;AACHT,4BAAoB,GAAG,2BAAvB;AACH;;AACD,UAAItF,UAAU,KAAK,gBAAf,IAAmCC,UAAU,KAAK,gBAAtD,EAAwE;AACpE,YAAI+F,eAAe,GAAG5G,MAAM,CAACsG,eAAD,CAAN,CAAwB,YAAxB,MAA0C3D,SAA1C,GAAsD,EAAtD,GAA2D3C,MAAM,CAACsG,eAAD,CAAN,CAAwB,YAAxB,CAAjF;;AACA,YAAIM,eAAe,CAACxG,MAAhB,GAAyB,CAAzB,IAA8BwG,eAAe,KAAKnI,SAAS,CAACmE,UAAV,CAAqBC,MAA3E,EAAmF;AAC/EsD,8BAAoB,GAAG,oCAAoCS,eAApC,GAAsD,GAA7E;AACH;AACJ;AACJ,KAlF6D,CAoF9D;;;AACA5G,UAAM,CAAC+F,UAAD,CAAN,CAAmB,SAAnB,IAAgC9D,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhC;AAEA,QAAIc,CAAJ,CAvF8D,CAwF9D;AACA;;AACA,QAAIC,SAAS,GAAG,oBACZ,iBADY,GAEZ,6CAFY,GAGZ,mCAHY,GAIZ,mCAJY,GAKZ,gBALY,GAMZ,2CANY,GAOZ,YAPY,GAQZ,kBARY,GASZ,uCATY,GAUZ,qCAVY,GAWZ,iBAXY,GAYZ,qCAZY,GAaZ,sBAbY,GAcZ,2BAdY,GAeZ,sBAfY,GAgBZ,2BAhBY,GAiBZ,2BAjBY,GAkBZ,gCAlBY,GAmBZ,qBAnBY,GAoBZ,oBApBY,GAqBZ,GArBJ;AAuBAA,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,gBAAlB,EAAoClC,UAApC,CAAZ;AACAiC,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,gBAAlB,EAAoC7B,UAApC,CAAZ;AACA4B,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqC3B,WAAW,GAAG,GAAd,GAAoBU,KAApB,GAA4BF,SAA5B,GAAwC,GAAxC,GAA8CN,MAAnF,CAAZ;AACAwB,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,gBAAlB,EAAoCgD,UAApC,CAAZ;AACAjD,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCd,SAAnC,CAAZ;AACAa,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCP,SAAnC,CAAZ;AACAM,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,cAAlB,EAAkCrD,QAAlC,CAAZ;AACAoD,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,YAAlB,EAAgCnD,MAAhC,CAAZ;AACAkD,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,gBAAlB,EAAoCiD,UAApC,CAAZ;AACAlD,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqCqD,WAArC,CAAZ;AACAtD,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCZ,eAAzC,CAAZ;AACAW,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,0BAAlB,EAA8CkD,oBAA9C,CAAZ;AACAnD,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,0BAAlB,EAA8CX,oBAA9C,CAAZ;AACAU,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,+BAAlB,EAAmDoD,yBAAnD,CAAZ;AACArD,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCb,eAAzC,CAAZ;AACAY,aAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,0BAAlB,EAA8CmD,oBAA9C,CAAZ;AACApD,aAAS,GAAGA,SAAS,CAACE,KAAV,CAAgB,gBAAhB,EAAkCC,IAAlC,CAAuCZ,UAAvC,CAAZ;AACAjD,gBAAY,CAACqB,KAAK,CAACC,KAAP,CAAZ,GAA4BoC,SAA5B,CAlI8D,CAoI9D;;AACA,QAAIR,cAAc,KAAK,KAAvB,EAA8B;AAC1BA,oBAAc,GAAG,GAAjB;AACH;;AAED,QAAIY,WAAJ;AACA,QAAIC,WAAW,GAAGtE,MAAM,EAAxB;AACA,QAAIuE,YAAJ;;AACA,QAAI;AACA;AACAF,iBAAW,GAAGxE,kBAAkB,CAAC2E,cAAnB,CAAkCC,OAAlC,EAA2CR,SAA3C,CAAd;AACAM,kBAAY,GAAGvE,MAAM,EAArB;AACAO,kBAAY,CAAC,mCAAmCqB,KAAK,CAACC,KAA1C,CAAZ,GAA+D;AAC3D6C,aAAK,EAAEJ,WAAW,CAACK,MAAZ,EADoD;AAE3DC,cAAM,EAAEL,YAAY,CAACI,MAAb,EAFmD;AAG3DE,gBAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBN,YAAY,CAACO,IAAb,CAAkBR,WAAlB,CAAhB,EAAgDS,SAAhD,KAA8D,UAHb;AAI3DC,mBAAW,EAAEX,WAAW,CAACY,IAAZ,CAAiBC,WAAjB,CAA6B5D;AAJiB,OAA/D,CAJA,CAUA;;AACA0C,OAAC,GAAGK,WAAW,CAACY,IAAhB;AACH,KAZD,CAYE,OAAOE,CAAP,EAAU;AACR;AACAA,OAAC,CAACC,OAAF,GAAY,uBAAuBD,CAAC,CAACC,OAAzB,GAAmC,kBAAnC,GAAwDnB,SAApE;AACA,YAAM,IAAI1C,KAAJ,CAAU4D,CAAC,CAACC,OAAZ,CAAN;AACH;;AACD,QAAIf,WAAW,CAACpD,KAAZ,KAAsB4C,SAAtB,IAAmCQ,WAAW,CAACpD,KAAZ,KAAsB,EAA7D,EAAiE;AAC7D,UAAIoD,WAAW,CAACpD,KAAZ,KAAsBtB,SAAS,CAAC0F,QAAV,CAAmBC,aAA7C,EAA4D;AACxD;AACA9E,yBAAiB,GAAG,KAApB;AACH,OAHD,MAGO;AACH;AACAS,aAAK,IAAI,wCAAwCoD,WAAW,CAACpD,KAApD,GAA4D,kBAA5D,GAAiFgD,SAAjF,GAA6F,MAAtG;AACA,cAAO,IAAI1C,KAAJ,CAAUN,KAAV,CAAP;AACH;AACJ;;AAED,QAAIsE,oBAAoB,GAAGvF,MAAM,EAAjC,CAxK8D,CA0K9D;AACA;;AACA,UAAMwF,IAAI,GAAGxB,CAAC,CAACyB,UAAF,CAAaD,IAA1B;AACA,UAAME,UAAU,GAAGF,IAAI,KAAK3B,SAAT,GAAqBhC,KAAK,GAAG,cAA7B,GAA8CA,KAAK,GAAG,WAAR,GAAsB2D,IAAI,CAACG,WAAL,CAAiB,CAAjB,CAAvF;AACA/D,SAAK,CAAC,YAAD,CAAL,GAAsB8D,UAAtB;AACA9D,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC4B,IAAlB;AACAhE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC6B,IAAlB;AACAjE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC8B,IAAlB;AACAlE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC+B,IAAlB;AACAnE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAACgC,IAAlB;AACApE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAACiC,IAAlB;AACArE,SAAK,CAAC,UAAD,CAAL,GAAoBE,UAApB;AACAF,SAAK,CAAC,UAAD,CAAL,GAAoBG,UAApB;AACA,UAAMmE,QAAQ,GAAGpG,qBAAqB,CAACqG,2BAAtB,CAAkDvE,KAAlD,EAAyDH,OAAzD,EAAkEuC,CAAlE,CAAjB,CAvL8D,CAuL0B;;AACxFxC,WAAO,CAAC4E,IAAR,CAAaF,QAAb;AACA,QAAIG,qBAAqB,GAAGrG,MAAM,EAAlC;AACAO,gBAAY,CAAC,gDAAgDqB,KAAK,CAACC,KAAvD,CAAZ,GAA4E;AACxE6C,WAAK,EAAEa,oBAAoB,CAACZ,MAArB,EADiE;AAExEC,YAAM,EAAEyB,qBAAqB,CAAC1B,MAAtB,EAFgE;AAGxEE,cAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBwB,qBAAqB,CAACvB,IAAtB,CAA2BS,oBAA3B,CAAhB,EAAkER,SAAlE,KAAgF;AAHlB,KAA5E;AAKH,GArNiD,CAuNlD;;;AACAvD,SAAO,GAAGkF,iBAAiB,CAACqB,qBAAlB,CAAwCvG,OAAxC,CAAV;AACAtB,YAAU,CAACgB,MAAX,GAAoBtB,aAAa,CAACoI,yBAAd,CAAwC9H,UAAU,CAACgB,MAAnD,CAApB;AACAA,QAAM,GAAGhB,UAAU,CAACgB,MAApB,CA1NkD,CA4NlD;;AACA,QAAMoF,eAAe,GAAG;AAAC,aAASpF,MAAV;AAAkB,eAAWO;AAA7B,GAAxB;AACA,QAAM8E,iBAAiB,GAAG;AAAC,oBAAgBhG,YAAjB;AAA+B,4BAAwBE;AAAvD,GAA1B;AACA,MAAI+F,MAAM,GAAGzG,oBAAoB,CAAC0G,kBAArB,CAAwCjF,OAAxC,EAAiD8E,eAAjD,EAAkEpG,UAAlE,EAA8EqG,iBAA9E,CAAb;AACApG,cAAY,CAACqG,MAAD,CAAZ;AACH,CAjOD,C;;;;;;;;;;;ACbA,IAAIjH,eAAJ;AAAoBC,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACF,iBAAe,CAACG,CAAD,EAAG;AAACH,mBAAe,GAACG,CAAhB;AAAkB;;AAAtC,CAAxC,EAAgF,CAAhF;AAAmF,IAAIC,SAAJ;AAAcH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACE,WAAS,CAACD,CAAD,EAAG;AAACC,aAAS,GAACD,CAAV;AAAY;;AAA1B,CAAxC,EAAoE,CAApE;AAAuE,IAAIE,aAAJ;AAAkBJ,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACG,eAAa,CAACF,CAAD,EAAG;AAACE,iBAAa,GAACF,CAAd;AAAgB;;AAAlC,CAAxC,EAA4E,CAA5E;AAA+E,IAAIG,kBAAJ;AAAuBL,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACI,oBAAkB,CAACH,CAAD,EAAG;AAACG,sBAAkB,GAACH,CAAnB;AAAqB;;AAA5C,CAAxC,EAAsF,CAAtF;AAAyF,IAAIgH,iBAAJ;AAAsBlH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACiH,mBAAiB,CAAChH,CAAD,EAAG;AAACgH,qBAAiB,GAAChH,CAAlB;AAAoB;;AAA1C,CAAxC,EAAoF,CAApF;AAAuF,IAAII,qBAAJ;AAA0BN,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACK,uBAAqB,CAACJ,CAAD,EAAG;AAACI,yBAAqB,GAACJ,CAAtB;AAAwB;;AAAlD,CAAxC,EAA4F,CAA5F;AAA+F,IAAIK,oBAAJ;AAAyBP,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACM,sBAAoB,CAACL,CAAD,EAAG;AAACK,wBAAoB,GAACL,CAArB;AAAuB;;AAAhD,CAAxC,EAA0F,CAA1F;AAA6F,IAAIM,MAAJ;AAAWR,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACO,QAAM,CAACN,CAAD,EAAG;AAACM,UAAM,GAACN,CAAP;AAAS;;AAApB,CAArC,EAA2D,CAA3D;;AAapvBuI,mBAAmB,GAAG,UAAU/H,UAAV,EAAsBC,YAAtB,EAAoC;AACtD;AACA,QAAMyG,QAAQ,GAAG1G,UAAU,CAAC,YAAD,CAAV,KAA6BP,SAAS,CAACkH,WAAV,CAAsBC,OAApE;AACA,QAAM1G,QAAQ,GAAGT,SAAS,CAACU,SAAV,CAAoB6H,eAArC;AACA,QAAMC,SAAS,GAAG,KAAlB;AACA,MAAI5H,YAAY,GAAG,EAAnB,CALsD,CAK/B;;AACvB,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,oBAAoB,GAAGT,MAAM,EAAjC;AACA,MAAIU,SAAS,GAAGd,aAAa,CAACe,YAAd,CAA2BT,UAAU,CAACU,KAAtC,CAAhB;AACA,MAAIC,QAAQ,GAAGH,SAAS,CAACI,WAAzB;AACA,MAAIC,MAAM,GAAGL,SAAS,CAACM,SAAvB;AACA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,UAAU,CAACgB,MAA1B,CAAX,CAAb;AACA,MAAI8F,YAAY,GAAG9F,MAAM,CAACI,MAA1B;AACA,MAAIE,OAAO,GAAG,EAAd;AACA,MAAI4G,cAAc,GAAG,EAArB;AACA,MAAI3G,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;AACA,MAAIkE,IAAI,GAAG,CAAC,CAAD,GAAKwC,MAAM,CAACC,SAAvB;AACA,MAAIvC,IAAI,GAAG,CAAC,CAAD,GAAKsC,MAAM,CAACC,SAAvB;AACA,MAAI1C,IAAI,GAAGyC,MAAM,CAACC,SAAlB;AACA,MAAIxC,IAAI,GAAGuC,MAAM,CAACC,SAAlB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAItB,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGD,YAAtC,EAAoDC,UAAU,EAA9D,EAAkE;AAC9D;AACA,QAAIrF,KAAK,GAAGV,MAAM,CAAC+F,UAAD,CAAlB;AACA,QAAIuB,QAAQ,GAAG5G,KAAK,CAAC4G,QAArB;AACA,QAAI3G,KAAK,GAAGD,KAAK,CAAC,OAAD,CAAjB;AACA,QAAIU,aAAa,GAAGV,KAAK,CAAC,aAAD,CAAzB;AACA,QAAIW,WAAW,GAAGhD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAA2DC,UAA3D,CAAsER,KAAK,CAAC,aAAD,CAA3E,EAA4F,CAA5F,CAAlB;AACA,QAAIY,SAAS,GAAGZ,KAAK,CAAC,QAAD,CAArB;AACA,QAAIa,MAAM,GAAGf,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAtD,CAAgEE,GAAhE,MAAyEL,SAAlK,CAAb;AACA,QAAIM,MAAM,GAAGlB,KAAK,CAAC,OAAD,CAAlB;AACA,QAAImB,SAAS,GAAG,EAAhB;;AACA,QAAID,MAAM,KAAK,KAAf,EAAsB;AAClBC,eAAS,GAAG,MAAMD,MAAlB;AACH;;AACD,QAAIE,QAAQ,GAAGpB,KAAK,CAAC,OAAD,CAApB;AACA,QAAIqB,KAAK,GAAGvB,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAAjE,EAA4EC,IAA5E,CAAiFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAArD,CAA+DE,GAA/D,MAAwEG,QAAhK,CAAZ;AACA,QAAIU,YAAY,GAAG9B,KAAK,CAAC,WAAD,CAAxB;AACA,QAAI+B,SAAS,GAAGjC,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAArE,EAAgFC,IAAhF,CAAqFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAAzD,CAAmEE,GAAnE,MAA4Ea,YAAxK,CAAhB;AACA,QAAIR,eAAe,GAAGtB,KAAK,CAAC,WAAD,CAA3B;AACA,QAAIuB,mBAAmB,GAAG5D,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyD;AAACC,gBAAU,EAAE;AAAb,KAAzD,EAA0E,YAA1E,CAA1B;AACA,QAAIgB,SAAS,GAAGD,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhB;AACA,QAAIuF,aAAa,GAAGJ,MAAM,CAACzG,KAAK,CAAC,iBAAD,CAAN,CAA1B;AACAwG,kBAAc,CAACnB,UAAD,CAAd,GAA6BwB,aAA7B,CAtB8D,CAuB9D;AACA;AACA;AACA;;AACA,QAAIC,OAAO,GAAGvF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAd;AACAhC,UAAM,CAAC+F,UAAD,CAAN,CAAmByB,OAAnB,GAA6BA,OAA7B,CA5B8D,CA4BxB;;AACtC,QAAIC,QAAQ,GAAGxF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAf;;AACA,QAAIyF,QAAQ,KAAK,IAAb,IAAqBJ,WAAW,CAACK,OAAZ,CAAoBD,QAApB,MAAkC,CAAC,CAA5D,EAA+D;AAC3DJ,iBAAW,CAACnC,IAAZ,CAAiBuC,QAAjB;AACH;;AAED,QAAI3E,CAAJ;;AACA,QAAIwE,QAAQ,IAAI,IAAhB,EAAsB;AAClB;AACA;AACA,UAAIvE,SAAS,GAAG,+BACZ,sCADY,GAEZ,4BAFY,GAGZ,4BAHY,GAIZ,gBAJY,GAKZ,6BALY,GAMZ,YANY,GAOZ,8BAPY,GAQZ,4BARY,GASZ,qCATY,GAUZ,8BAVY,GAWZ,uBAXY,GAYZ,wEAZY,GAaZ,kBAbY,GAcZ,iBAdY,GAeZ,GAfJ;AAiBAA,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCP,SAAnC,CAAZ;AACAM,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,cAAlB,EAAkCrD,QAAlC,CAAZ;AACAoD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,YAAlB,EAAgCnD,MAAhC,CAAZ;AACAkD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqC3B,WAAW,GAAG,GAAd,GAAoBU,KAApB,GAA4BF,SAA5B,GAAwC,GAAxC,GAA8CN,MAAnF,CAAZ;AACAwB,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCd,SAAnC,CAAZ;AACAa,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,mBAAlB,EAAuCuE,aAAvC,CAAZ;AAEAlI,kBAAY,CAACqB,KAAK,CAACC,KAAP,CAAZ,GAA4BoC,SAA5B;AAEA,UAAII,WAAJ;AACA,UAAIC,WAAW,GAAGtE,MAAM,EAAxB;AACA,UAAIuE,YAAJ;;AACA,UAAI;AACA;AACAF,mBAAW,GAAGxE,kBAAkB,CAACgJ,qBAAnB,CAAyCpE,OAAzC,EAAkDR,SAAlD,EAA6D7D,QAA7D,EAAuE+H,SAAvE,CAAd;AACA5D,oBAAY,GAAGvE,MAAM,EAArB;AACAO,oBAAY,CAAC,mCAAmCqB,KAAK,CAACC,KAA1C,CAAZ,GAA+D;AAC3D6C,eAAK,EAAEJ,WAAW,CAACK,MAAZ,EADoD;AAE3DC,gBAAM,EAAEL,YAAY,CAACI,MAAb,EAFmD;AAG3DE,kBAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBN,YAAY,CAACO,IAAb,CAAkBR,WAAlB,CAAhB,EAAgDS,SAAhD,KAA8D,UAHb;AAI3DC,qBAAW,EAAEX,WAAW,CAACY,IAAZ,CAAiB6D,CAAjB,CAAmBxH;AAJ2B,SAA/D,CAJA,CAUA;;AACA0C,SAAC,GAAGK,WAAW,CAACY,IAAhB;AACH,OAZD,CAYE,OAAOE,CAAP,EAAU;AACR;AACAA,SAAC,CAACC,OAAF,GAAY,uBAAuBD,CAAC,CAACC,OAAzB,GAAmC,kBAAnC,GAAwDnB,SAApE;AACA,cAAM,IAAI1C,KAAJ,CAAU4D,CAAC,CAACC,OAAZ,CAAN;AACH;;AACD,UAAIf,WAAW,CAACpD,KAAZ,KAAsB4C,SAAtB,IAAmCQ,WAAW,CAACpD,KAAZ,KAAsB,EAA7D,EAAiE;AAC7D,YAAIoD,WAAW,CAACpD,KAAZ,KAAsBtB,SAAS,CAAC0F,QAAV,CAAmBC,aAA7C,EAA4D;AACxD;AACA9E,2BAAiB,GAAG,KAApB;AACH,SAHD,MAGO;AACH;AACAS,eAAK,IAAI,wCAAwCoD,WAAW,CAACpD,KAApD,GAA4D,kBAA5D,GAAiFgD,SAAjF,GAA6F,MAAtG;AACA,gBAAO,IAAI1C,KAAJ,CAAUN,KAAV,CAAP;AACH;AACJ,OA1DiB,CA4DlB;;;AACA,UAAIsE,oBAAoB,GAAGvF,MAAM,EAAjC;;AACA,UAAIQ,iBAAJ,EAAuB;AACnBoF,YAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH;AACJ,KApED,MAoEO;AACH;AACA,YAAMgD,UAAU,GAAGrC,iBAAiB,CAACsC,mBAAlB,CAAsCxH,OAAtC,EAA+CgH,QAA/C,EAAyDpI,QAAzD,EAAmE+H,SAAnE,CAAnB;AACAnE,OAAC,GAAG+E,UAAU,CAACvH,OAAf;AACAoE,UAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH,KA/G6D,CAiH9D;AACA;;;AACA,UAAMP,IAAI,GAAGxB,CAAC,CAACiF,GAAF,GAAQjF,CAAC,CAAC8E,CAAF,CAAIxH,MAAzB;AACA,UAAMoE,UAAU,GAAGF,IAAI,KAAK3B,SAAT,GAAqBhC,KAAK,GAAG,cAA7B,GAA8CA,KAAK,GAAG,WAAR,GAAsB2D,IAAI,CAACG,WAAL,CAAiB,CAAjB,CAAvF;AACA/D,SAAK,CAAC,YAAD,CAAL,GAAsB8D,UAAtB;AACA9D,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC4B,IAAlB;AACAhE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC6B,IAAlB;AACAjE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC8B,IAAlB;AACAlE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC+B,IAAlB;AACAnE,SAAK,CAAC,SAAD,CAAL,GAAmB8G,OAAnB;AACA,UAAMxC,QAAQ,GAAGpG,qBAAqB,CAACoJ,0BAAtB,CAAiDtH,KAAjD,EAAwDqF,UAAxD,EAAoExF,OAApE,EAA6EuC,CAA7E,CAAjB,CA3H8D,CA2HqC;;AACnGxC,WAAO,CAAC4E,IAAR,CAAaF,QAAb;AACA,QAAIG,qBAAqB,GAAGrG,MAAM,EAAlC;AACAO,gBAAY,CAAC,gDAAgDqB,KAAK,CAACC,KAAvD,CAAZ,GAA4E;AACxE6C,WAAK,EAAEa,oBAAoB,CAACZ,MAArB,EADiE;AAExEC,YAAM,EAAEyB,qBAAqB,CAAC1B,MAAtB,EAFgE;AAGxEE,cAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBwB,qBAAqB,CAACvB,IAAtB,CAA2BS,oBAA3B,CAAhB,EAAkER,SAAlE,KAAgF;AAHlB,KAA5E;AAKH,GA1JqD,CA0JnD;AAEH;;;AACA,QAAMoE,SAAS,GAAG;AAAC,gBAAY/I,QAAb;AAAuB,iBAAa+H,SAApC;AAA+C,gBAAYvB;AAA3D,GAAlB;AACA,QAAMN,eAAe,GAAG;AACpB,cAAUpF,MADU;AAEpB,oBAAgB8F,YAFI;AAGpB,mBAAeuB,WAHK;AAIpB,sBAAkBH,cAJE;AAKpB,eAAW3G,OALS;AAMpB,YAAQoE,IANY;AAOpB,YAAQD;AAPY,GAAxB;AASA,QAAMW,iBAAiB,GAAG;AAAC,oBAAgBhG,YAAjB;AAA+B,4BAAwBE;AAAvD,GAA1B;AACA,MAAI+F,MAAM,GAAGzG,oBAAoB,CAACqJ,kBAArB,CAAwC5H,OAAxC,EAAiD2H,SAAjD,EAA4D7C,eAA5D,EAA6EpG,UAA7E,EAAyFqG,iBAAzF,CAAb;AACApG,cAAY,CAACqG,MAAD,CAAZ;AACH,CA1KD,C;;;;;;;;;;;ACbA,IAAIjH,eAAJ;AAAoBC,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACF,iBAAe,CAACG,CAAD,EAAG;AAACH,mBAAe,GAACG,CAAhB;AAAkB;;AAAtC,CAAxC,EAAgF,CAAhF;AAAmF,IAAIC,SAAJ;AAAcH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACE,WAAS,CAACD,CAAD,EAAG;AAACC,aAAS,GAACD,CAAV;AAAY;;AAA1B,CAAxC,EAAoE,CAApE;AAAuE,IAAIE,aAAJ;AAAkBJ,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACG,eAAa,CAACF,CAAD,EAAG;AAACE,iBAAa,GAACF,CAAd;AAAgB;;AAAlC,CAAxC,EAA4E,CAA5E;AAA+E,IAAIG,kBAAJ;AAAuBL,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACI,oBAAkB,CAACH,CAAD,EAAG;AAACG,sBAAkB,GAACH,CAAnB;AAAqB;;AAA5C,CAAxC,EAAsF,CAAtF;AAAyF,IAAIgH,iBAAJ;AAAsBlH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACiH,mBAAiB,CAAChH,CAAD,EAAG;AAACgH,qBAAiB,GAAChH,CAAlB;AAAoB;;AAA1C,CAAxC,EAAoF,CAApF;AAAuF,IAAII,qBAAJ;AAA0BN,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACK,uBAAqB,CAACJ,CAAD,EAAG;AAACI,yBAAqB,GAACJ,CAAtB;AAAwB;;AAAlD,CAAxC,EAA4F,CAA5F;AAA+F,IAAIK,oBAAJ;AAAyBP,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACM,sBAAoB,CAACL,CAAD,EAAG;AAACK,wBAAoB,GAACL,CAArB;AAAuB;;AAAhD,CAAxC,EAA0F,CAA1F;AAA6F,IAAIM,MAAJ;AAAWR,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACO,QAAM,CAACN,CAAD,EAAG;AAACM,UAAM,GAACN,CAAP;AAAS;;AAApB,CAArC,EAA2D,CAA3D;;AAapvB2J,UAAU,GAAG,UAAUnJ,UAAV,EAAsBC,YAAtB,EAAoC;AAC7C;AACA,QAAMyG,QAAQ,GAAG1G,UAAU,CAAC,YAAD,CAAV,KAA6BP,SAAS,CAACkH,WAAV,CAAsBC,OAApE;AACA,QAAM1G,QAAQ,GAAGT,SAAS,CAACU,SAAV,CAAoBiJ,MAArC;AACA,QAAMnB,SAAS,GAAG,KAAlB;AACA,MAAI5H,YAAY,GAAG,EAAnB,CAL6C,CAKtB;;AACvB,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,oBAAoB,GAAGT,MAAM,EAAjC;AACA,MAAIiB,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,UAAU,CAACgB,MAA1B,CAAX,CAAb;AACA,MAAI8F,YAAY,GAAG9F,MAAM,CAACI,MAA1B;AACA,MAAIE,OAAO,GAAG,EAAd;AACA,MAAI4G,cAAc,GAAG,EAArB;AACA,MAAI3G,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;AACA,MAAIkE,IAAI,GAAG,CAAC,CAAD,GAAKwC,MAAM,CAACC,SAAvB;AACA,MAAIvC,IAAI,GAAG,CAAC,CAAD,GAAKsC,MAAM,CAACC,SAAvB;AACA,MAAI1C,IAAI,GAAGyC,MAAM,CAACC,SAAlB;AACA,MAAIxC,IAAI,GAAGuC,MAAM,CAACC,SAAlB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAItB,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGD,YAAtC,EAAoDC,UAAU,EAA9D,EAAkE;AAC9D;AACA,QAAIrF,KAAK,GAAGV,MAAM,CAAC+F,UAAD,CAAlB;AACA,QAAIuB,QAAQ,GAAG5G,KAAK,CAAC4G,QAArB;AACA,QAAI3G,KAAK,GAAGD,KAAK,CAAC,OAAD,CAAjB;AACA,QAAIW,WAAW,GAAGhD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAA2DC,UAA3D,CAAsER,KAAK,CAAC,aAAD,CAA3E,EAA4F,CAA5F,CAAlB;AACA,QAAIY,SAAS,GAAGZ,KAAK,CAAC,QAAD,CAArB;AACA,QAAIa,MAAM,GAAGf,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAtD,CAAgEE,GAAhE,MAAyEL,SAAlK,CAAb;AACA,QAAIM,MAAM,GAAGlB,KAAK,CAAC,OAAD,CAAlB;AACA,QAAImB,SAAS,GAAG,EAAhB;;AACA,QAAID,MAAM,KAAK,KAAf,EAAsB;AAClBC,eAAS,GAAG,MAAMD,MAAlB;AACH;;AACD,QAAIY,YAAY,GAAG9B,KAAK,CAAC,WAAD,CAAxB;AACA,QAAI+B,SAAS,GAAGjC,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAArE,EAAgFC,IAAhF,CAAqFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAAzD,CAAmEE,GAAnE,MAA4Ea,YAAxK,CAAhB;AACA,QAAIR,eAAe,GAAGtB,KAAK,CAAC,WAAD,CAA3B;AACA,QAAIuB,mBAAmB,GAAG5D,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyD;AAACC,gBAAU,EAAE;AAAb,KAAzD,EAA0E,YAA1E,CAA1B;AACA,QAAIgB,SAAS,GAAGD,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhB;AACA,QAAIF,QAAQ,GAAGpB,KAAK,CAAC,OAAD,CAApB;AACA,QAAIqB,KAAK,GAAGvB,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAAjE,EAA4EC,IAA5E,CAAiFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAArD,CAA+DE,GAA/D,MAAwEG,QAAhK,CAAZ;AACA,QAAItC,SAAS,GAAGd,aAAa,CAACe,YAAd,CAA2BiB,KAAK,CAAC,aAAD,CAAhC,CAAhB;AACA,QAAIf,QAAQ,GAAGH,SAAS,CAACI,WAAzB;AACA,QAAIC,MAAM,GAAGL,SAAS,CAACM,SAAvB;AACA,QAAIuI,iBAAiB,GAAG3H,KAAK,CAAC,aAAD,CAA7B;AACA,QAAI4H,wBAAwB,GAAGjK,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAA2D;AAACC,gBAAU,EAAE;AAAb,KAA3D,EAA4E,YAA5E,CAA/B;AACA,QAAIqB,cAAc,GAAG+F,wBAAwB,CAACD,iBAAD,CAAxB,CAA4C,CAA5C,CAArB;AACA,QAAI3F,UAAJ;AACA,QAAIP,eAAe,GAAG,EAAtB;AACA,QAAIoF,aAAJ;AACA,QAAIgB,mBAAmB,GAAG,EAA1B;AACA,QAAIC,eAAe,GAAG,oBAAoB7I,QAApB,GAA+B,kBAA/B,GAAoDE,MAA1E;;AACA,QAAI0C,cAAc,KAAK9D,SAAS,CAACgK,aAAV,CAAwBL,MAA/C,EAAuD;AACnD1F,gBAAU,GAAGhC,KAAK,CAAC,YAAD,CAAL,KAAwBiC,SAAxB,GAAoC,EAApC,GAAyCjC,KAAK,CAAC,YAAD,CAA3D;;AACA,UAAIgC,UAAU,CAACtC,MAAX,KAAsB,CAAtB,IAA2BsC,UAAU,KAAKjE,SAAS,CAACmE,UAAV,CAAqBC,MAAnE,EAA2E;AACvEV,uBAAe,GAAG,4CAA4CO,UAA5C,GAAyD,GAA3E;AACH;AACJ,KALD,MAKO,IAAIH,cAAc,KAAK9D,SAAS,CAACgK,aAAV,CAAwBC,QAA/C,EAAyD;AAC5DnB,mBAAa,GAAGJ,MAAM,CAACzG,KAAK,CAAC,iBAAD,CAAN,CAAtB;AACA6H,yBAAmB,GAAG,wDAAwDhB,aAAxD,GAAwE,GAA9F;AACH,KAHM,MAGA;AACHiB,qBAAe,GAAG,wCAAwC7I,QAA1D;AACH,KAzC6D,CA0C9D;AACA;AACA;AACA;;;AACA,QAAI6H,OAAO,GAAGvF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAd;AACAhC,UAAM,CAAC+F,UAAD,CAAN,CAAmByB,OAAnB,GAA6BA,OAA7B,CA/C8D,CA+CxB;;AACtC,QAAIC,QAAQ,GAAGxF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAf;;AACA,QAAIyF,QAAQ,KAAK,IAAb,IAAqBJ,WAAW,CAACK,OAAZ,CAAoBD,QAApB,MAAkC,CAAC,CAA5D,EAA+D;AAC3DJ,iBAAW,CAACnC,IAAZ,CAAiBuC,QAAjB;AACH;;AAED,QAAI3E,CAAJ;;AACA,QAAIwE,QAAQ,IAAI,IAAhB,EAAsB;AAClB;AACA;AACA,UAAIvE,SAAS,GAAG,mCACZ,sCADY,GAEZ,4BAFY,GAGZ,4BAHY,GAIZ,gBAJY,GAKZ,6BALY,GAMZ,YANY,GAOZ,sBAPY,GAQZ,qCARY,GASZ,8BATY,GAUZ,sBAVY,GAWZ,0BAXY,GAYZ,kBAZY,GAaZ,kBAbJ;AAeAA,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,cAAlB,EAAkCrD,QAAlC,CAAZ;AACAoD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,YAAlB,EAAgCnD,MAAhC,CAAZ;AACAkD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqC3B,WAAW,GAAG,GAAd,GAAoBU,KAApB,GAA4BF,SAA5B,GAAwC,GAAxC,GAA8CN,MAAnF,CAAZ;AACAwB,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCd,SAAnC,CAAZ;AACAa,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCP,SAAnC,CAAZ;AACAM,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCwF,eAAzC,CAAZ;AACAzF,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCb,eAAzC,CAAZ;AACAY,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,yBAAlB,EAA6CuF,mBAA7C,CAAZ;AACAlJ,kBAAY,CAACqB,KAAK,CAACC,KAAP,CAAZ,GAA4BoC,SAA5B;AAEA,UAAII,WAAJ;AACA,UAAIC,WAAW,GAAGtE,MAAM,EAAxB;AACA,UAAIuE,YAAJ;;AACA,UAAI;AACA;AACAF,mBAAW,GAAGxE,kBAAkB,CAACgJ,qBAAnB,CAAyCpE,OAAzC,EAAkDR,SAAlD,EAA6D7D,QAA7D,EAAuE+H,SAAvE,CAAd;AACA5D,oBAAY,GAAGvE,MAAM,EAArB;AACAO,oBAAY,CAAC,mCAAmCqB,KAAK,CAACC,KAA1C,CAAZ,GAA+D;AAC3D6C,eAAK,EAAEJ,WAAW,CAACK,MAAZ,EADoD;AAE3DC,gBAAM,EAAEL,YAAY,CAACI,MAAb,EAFmD;AAG3DE,kBAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBN,YAAY,CAACO,IAAb,CAAkBR,WAAlB,CAAhB,EAAgDS,SAAhD,KAA8D,UAHb;AAI3DC,qBAAW,EAAEX,WAAW,CAACY,IAAZ,CAAiB6D,CAAjB,CAAmBxH;AAJ2B,SAA/D,CAJA,CAUA;;AACA0C,SAAC,GAAGK,WAAW,CAACY,IAAhB;AACH,OAZD,CAYE,OAAOE,CAAP,EAAU;AACR;AACAA,SAAC,CAACC,OAAF,GAAY,uBAAuBD,CAAC,CAACC,OAAzB,GAAmC,kBAAnC,GAAwDnB,SAApE;AACA,cAAM,IAAI1C,KAAJ,CAAU4D,CAAC,CAACC,OAAZ,CAAN;AACH;;AACD,UAAIf,WAAW,CAACpD,KAAZ,KAAsB4C,SAAtB,IAAmCQ,WAAW,CAACpD,KAAZ,KAAsB,EAA7D,EAAiE;AAC7D,YAAIoD,WAAW,CAACpD,KAAZ,KAAsBtB,SAAS,CAAC0F,QAAV,CAAmBC,aAA7C,EAA4D;AACxD;AACA9E,2BAAiB,GAAG,KAApB;AACH,SAHD,MAGO;AACH;AACAS,eAAK,IAAI,wCAAwCoD,WAAW,CAACpD,KAApD,GAA4D,kBAA5D,GAAiFgD,SAAjF,GAA6F,MAAtG;AACA,gBAAO,IAAI1C,KAAJ,CAAUN,KAAV,CAAP;AACH;AACJ,OAzDiB,CA2DlB;;;AACA,UAAIsE,oBAAoB,GAAGvF,MAAM,EAAjC;;AACA,UAAIQ,iBAAJ,EAAuB;AACnBoF,YAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH;AACJ,KAnED,MAmEO;AACH;AACA,YAAMgD,UAAU,GAAGrC,iBAAiB,CAACsC,mBAAlB,CAAsCxH,OAAtC,EAA+CgH,QAA/C,EAAyDpI,QAAzD,EAAmE+H,SAAnE,CAAnB;AACAnE,OAAC,GAAG+E,UAAU,CAACvH,OAAf;AACAoE,UAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH,KAjI6D,CAmI9D;AACA;;;AACA,UAAMP,IAAI,GAAGxB,CAAC,CAACiF,GAAF,GAAQjF,CAAC,CAAC8E,CAAF,CAAIxH,MAAzB;AACA,UAAMoE,UAAU,GAAGF,IAAI,KAAK3B,SAAT,GAAqBhC,KAAK,GAAG,cAA7B,GAA8CA,KAAK,GAAG,WAAR,GAAsB2D,IAAI,CAACG,WAAL,CAAiB,CAAjB,CAAvF;AACA/D,SAAK,CAAC,YAAD,CAAL,GAAsB8D,UAAtB;AACA9D,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC4B,IAAlB;AACAhE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC6B,IAAlB;AACAjE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC8B,IAAlB;AACAlE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC+B,IAAlB;AACAnE,SAAK,CAAC,SAAD,CAAL,GAAmB8G,OAAnB;AACA,UAAMxC,QAAQ,GAAGpG,qBAAqB,CAACoJ,0BAAtB,CAAiDtH,KAAjD,EAAwDqF,UAAxD,EAAoExF,OAApE,EAA6EuC,CAA7E,CAAjB,CA7I8D,CA6IqC;;AACnGxC,WAAO,CAAC4E,IAAR,CAAaF,QAAb;AACA,QAAIG,qBAAqB,GAAGrG,MAAM,EAAlC;AACAO,gBAAY,CAAC,gDAAgDqB,KAAK,CAACC,KAAvD,CAAZ,GAA4E;AACxE6C,WAAK,EAAEa,oBAAoB,CAACZ,MAArB,EADiE;AAExEC,YAAM,EAAEyB,qBAAqB,CAAC1B,MAAtB,EAFgE;AAGxEE,cAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBwB,qBAAqB,CAACvB,IAAtB,CAA2BS,oBAA3B,CAAhB,EAAkER,SAAlE,KAAgF;AAHlB,KAA5E;AAKH,GAzK4C,CAyK1C;AAEH;;;AACA,QAAMoE,SAAS,GAAG;AAAC,gBAAY/I,QAAb;AAAuB,iBAAa+H,SAApC;AAA+C,gBAAYvB;AAA3D,GAAlB;AACA,QAAMN,eAAe,GAAG;AACpB,cAAUpF,MADU;AAEpB,oBAAgB8F,YAFI;AAGpB,mBAAeuB,WAHK;AAIpB,sBAAkBH,cAJE;AAKpB,eAAW3G,OALS;AAMpB,YAAQoE,IANY;AAOpB,YAAQD;AAPY,GAAxB;AASA,QAAMW,iBAAiB,GAAG;AAAC,oBAAgBhG,YAAjB;AAA+B,4BAAwBE;AAAvD,GAA1B;AACA,MAAI+F,MAAM,GAAGzG,oBAAoB,CAACqJ,kBAArB,CAAwC5H,OAAxC,EAAiD2H,SAAjD,EAA4D7C,eAA5D,EAA6EpG,UAA7E,EAAyFqG,iBAAzF,CAAb;AACApG,cAAY,CAACqG,MAAD,CAAZ;AACH,CAzLD,C;;;;;;;;;;;ACbA,IAAIjH,eAAJ;AAAoBC,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACF,iBAAe,CAACG,CAAD,EAAG;AAACH,mBAAe,GAACG,CAAhB;AAAkB;;AAAtC,CAAxC,EAAgF,CAAhF;AAAmF,IAAIC,SAAJ;AAAcH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACE,WAAS,CAACD,CAAD,EAAG;AAACC,aAAS,GAACD,CAAV;AAAY;;AAA1B,CAAxC,EAAoE,CAApE;AAAuE,IAAIE,aAAJ;AAAkBJ,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACG,eAAa,CAACF,CAAD,EAAG;AAACE,iBAAa,GAACF,CAAd;AAAgB;;AAAlC,CAAxC,EAA4E,CAA5E;AAA+E,IAAIG,kBAAJ;AAAuBL,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACI,oBAAkB,CAACH,CAAD,EAAG;AAACG,sBAAkB,GAACH,CAAnB;AAAqB;;AAA5C,CAAxC,EAAsF,CAAtF;AAAyF,IAAIK,oBAAJ;AAAyBP,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACM,sBAAoB,CAACL,CAAD,EAAG;AAACK,wBAAoB,GAACL,CAArB;AAAuB;;AAAhD,CAAxC,EAA0F,CAA1F;AAA6F,IAAIM,MAAJ;AAAWR,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACO,QAAM,CAACN,CAAD,EAAG;AAACM,UAAM,GAACN,CAAP;AAAS;;AAApB,CAArC,EAA2D,CAA3D;;AAW9gBmK,aAAa,GAAG,UAAU3J,UAAV,EAAsBC,YAAtB,EAAoC;AAChD;AACA,QAAMC,QAAQ,GAAGT,SAAS,CAACU,SAAV,CAAoByJ,SAArC;AACA,QAAM3B,SAAS,GAAG,KAAlB;AACA,QAAMvB,QAAQ,GAAG1G,UAAU,CAAC,YAAD,CAAV,KAA6BP,SAAS,CAACkH,WAAV,CAAsBC,OAApE;AACA,MAAIiD,cAAc,GAAG,KAArB;AACA,MAAIxJ,YAAY,GAAG,EAAnB,CANgD,CAMzB;;AACvB,MAAIC,iBAAiB,GAAG,EAAxB;AACA,MAAIC,oBAAoB,GAAGT,MAAM,EAAjC;AACA,MAAIiB,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,UAAU,CAACgB,MAA1B,CAAX,CAAb;AACA,MAAI8F,YAAY,GAAG9F,MAAM,CAACI,MAA1B;AACA,MAAIE,OAAO,GAAG,EAAd;AACA,MAAIwI,mBAAmB,GAAG,EAA1B;AACA,MAAIC,kBAAkB,GAAG,EAAzB;AACA,MAAIxI,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd,CAfgD,CAiBhD;;AACA,QAAMuI,SAAS,GAAGtK,aAAa,CAACuK,sBAAd,CAAqCjK,UAArC,CAAlB;AACA,QAAMkK,WAAW,GAAGF,SAAS,CAACE,WAA9B;AACA,QAAMC,MAAM,GAAGH,SAAS,CAACG,MAAzB;;AAEA,OAAK,IAAIpD,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGD,YAAtC,EAAoDC,UAAU,EAA9D,EAAkE;AAC9D;AACA,QAAIrF,KAAK,GAAGV,MAAM,CAAC+F,UAAD,CAAlB;AACA,QAAIuB,QAAQ,GAAG5G,KAAK,CAAC4G,QAArB;AACAhI,qBAAiB,CAACyG,UAAD,CAAjB,GAAgC,IAAhC;AACA,QAAIpF,KAAK,GAAGD,KAAK,CAAC,OAAD,CAAjB;AACA,QAAIU,aAAa,GAAGV,KAAK,CAAC,aAAD,CAAzB;AACA,QAAIW,WAAW,GAAGhD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAA2DC,UAA3D,CAAsER,KAAK,CAAC,aAAD,CAA3E,EAA4F,CAA5F,CAAlB;AACA,QAAIY,SAAS,GAAGZ,KAAK,CAAC,QAAD,CAArB;AACA,QAAIa,MAAM,GAAGf,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAtD,CAAgEE,GAAhE,MAAyEL,SAAlK,CAAb;AACA,QAAIM,MAAM,GAAGlB,KAAK,CAAC,OAAD,CAAlB;AACA,QAAImB,SAAS,GAAG,EAAhB;;AACA,QAAID,MAAM,KAAK,KAAf,EAAsB;AAClBC,eAAS,GAAG,MAAMD,MAAlB;AACH;;AACD,QAAIE,QAAQ,GAAGpB,KAAK,CAAC,OAAD,CAApB;AACA,QAAIqB,KAAK,GAAGvB,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAAjE,EAA4EC,IAA5E,CAAiFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAArD,CAA+DE,GAA/D,MAAwEG,QAAhK,CAAZ;AACA,QAAIU,YAAY,GAAG9B,KAAK,CAAC,WAAD,CAAxB;AACA,QAAI+B,SAAS,GAAGjC,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAArE,EAAgFC,IAAhF,CAAqFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAAzD,CAAmEE,GAAnE,MAA4Ea,YAAxK,CAAhB;AACA,QAAIR,eAAe,GAAGtB,KAAK,CAAC,WAAD,CAA3B;AACA,QAAIuB,mBAAmB,GAAG5D,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyD;AAACC,gBAAU,EAAE;AAAb,KAAzD,EAA0E,YAA1E,CAA1B;AACA,QAAIgB,SAAS,GAAGD,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhB;AACA,QAAIU,UAAU,GAAGhC,KAAK,CAAC,YAAD,CAAL,KAAwBiC,SAAxB,GAAoC,EAApC,GAAyCjC,KAAK,CAAC,YAAD,CAA/D;AACA,QAAIlB,SAAS,GAAGd,aAAa,CAACe,YAAd,CAA2BiB,KAAK,CAAC,aAAD,CAAhC,CAAhB;AACA,QAAIf,QAAQ,GAAGH,SAAS,CAACI,WAAzB;AACA,QAAIC,MAAM,GAAGL,SAAS,CAACM,SAAvB;AACA,QAAIyC,cAAc,GAAG7B,KAAK,CAAC,iBAAD,CAA1B,CA1B8D,CA2B9D;AACA;AACA;AACA;;AACA,QAAI8G,OAAO,GAAG0B,WAAd;;AACA,QAAIA,WAAW,KAAK,oBAApB,EAA0C;AACtC1B,aAAO,GAAGA,OAAO,GAAG,SAApB;AACH;;AACDxH,UAAM,CAAC+F,UAAD,CAAN,CAAmByB,OAAnB,GAA6BA,OAA7B,CAnC8D,CAmCxB;;AACtCxH,UAAM,CAAC+F,UAAD,CAAN,CAAmBoD,MAAnB,GAA4BA,MAA5B,CApC8D,CAoC1B;;AAEpC,QAAIrG,CAAJ;;AACA,QAAIwE,QAAQ,IAAI,IAAhB,EAAsB;AAClB;AACA;AACA,UAAIvE,SAAS,GAAG,+BACZ,sCADY,GAEZ,4BAFY,GAGZ,4BAHY,GAIZ,gBAJY,GAKZ,6BALY,GAMZ,YANY,GAOZ,sBAPY,GAQZ,gCARY,GASZ,8BATY,GAUZ,qCAVY,GAWZ,gCAXY,GAYZ,yCAZY,GAaZ,kBAbY,GAcZ,iBAdY,GAeZ,GAfJ;AAiBAA,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,cAAlB,EAAkCrD,QAAlC,CAAZ;AACAoD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,YAAlB,EAAgCnD,MAAhC,CAAZ;AACAkD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqC3B,WAAW,GAAG,GAAd,GAAoBU,KAApB,GAA4BF,SAA5B,GAAwC,GAAxC,GAA8CN,MAAnF,CAAZ;AACAwB,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCd,SAAnC,CAAZ;AACAa,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCP,SAAnC,CAAZ;AACAM,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,oBAAlB,EAAwCT,cAAxC,CAAZ;AACA,UAAIJ,eAAe,GAAG,GAAtB;;AACA,UAAIO,UAAU,CAACtC,MAAX,GAAoB,CAApB,IAAyBsC,UAAU,KAAKjE,SAAS,CAACmE,UAAV,CAAqBC,MAAjE,EAAyE;AACrEV,uBAAe,GAAG,6CAA6CO,UAA7C,GAA0D,GAA5E;AACH;;AACDK,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCb,eAAzC,CAAZ;AAEA9C,kBAAY,CAACqB,KAAK,CAACC,KAAP,CAAZ,GAA4BoC,SAA5B;AAEA,UAAII,WAAJ;AACA,UAAIC,WAAW,GAAGtE,MAAM,EAAxB;AACA,UAAIuE,YAAJ;;AACA,UAAI;AACA;AACAF,mBAAW,GAAGxE,kBAAkB,CAACgJ,qBAAnB,CAAyCpE,OAAzC,EAAkDR,SAAlD,EAA6D7D,QAA7D,EAAuE+H,SAAvE,CAAd;AACA5D,oBAAY,GAAGvE,MAAM,EAArB;AACAO,oBAAY,CAAC,mCAAmCqB,KAAK,CAACC,KAA1C,CAAZ,GAA+D;AAC3D6C,eAAK,EAAEJ,WAAW,CAACK,MAAZ,EADoD;AAE3DC,gBAAM,EAAEL,YAAY,CAACI,MAAb,EAFmD;AAG3DE,kBAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBN,YAAY,CAACO,IAAb,CAAkBR,WAAlB,CAAhB,EAAgDS,SAAhD,KAA8D,UAHb;AAI3DC,qBAAW,EAAEX,WAAW,CAACY,IAAZ,CAAiB6D,CAAjB,CAAmBxH;AAJ2B,SAA/D,CAJA,CAUA;;AACA0C,SAAC,GAAGK,WAAW,CAACY,IAAhB;AACA+E,2BAAmB,CAAC5D,IAApB,CAAyBpC,CAAC,CAACsG,OAA3B,EAZA,CAYqC;;AACrCL,0BAAkB,CAAC7D,IAAnB,CAAwBpC,CAAC,CAACuG,OAA1B;AACH,OAdD,CAcE,OAAOpF,CAAP,EAAU;AACR;AACAA,SAAC,CAACC,OAAF,GAAY,uBAAuBD,CAAC,CAACC,OAAzB,GAAmC,kBAAnC,GAAwDnB,SAApE;AACA,cAAM,IAAI1C,KAAJ,CAAU4D,CAAC,CAACC,OAAZ,CAAN;AACH;;AACD,UAAIf,WAAW,CAACpD,KAAZ,KAAsB4C,SAAtB,IAAmCQ,WAAW,CAACpD,KAAZ,KAAsB,EAA7D,EAAiE;AAC7D,YAAIoD,WAAW,CAACpD,KAAZ,KAAsBtB,SAAS,CAAC0F,QAAV,CAAmBC,aAA7C,EAA4D;AACxD;AACA9E,2BAAiB,CAACyG,UAAD,CAAjB,GAAgC,KAAhC;AACH,SAHD,MAGO;AACH;AACAhG,eAAK,IAAI,wCAAwCoD,WAAW,CAACpD,KAApD,GAA4D,kBAA5D,GAAiFgD,SAAjF,GAA6F,MAAtG;AACA,gBAAO,IAAI1C,KAAJ,CAAUN,KAAV,CAAP;AACH;AACJ;AACJ;AACJ;;AACD,QAAMkI,SAAS,GAAG;AAAC,gBAAY/I,QAAb;AAAuB,iBAAa+H,SAApC;AAA+C,gBAAYvB;AAA3D,GAAlB;AACA,QAAMN,eAAe,GAAG;AACpB,cAAUpF,MADU;AAEpB,oBAAgB8F,YAFI;AAGpB,yBAAqBxG,iBAHD;AAIpB,eAAWiB,OAJS;AAKpB,mBAAe2I;AALK,GAAxB;AAOA,QAAM7D,iBAAiB,GAAG;AACtB,sBAAkBwD,cADI;AAEtB,oBAAgBxJ,YAFM;AAGtB,4BAAwBE;AAHF,GAA1B;AAKA,MAAI+F,MAAM,GAAGzG,oBAAoB,CAACyK,oBAArB,CAA0CR,mBAA1C,EAA+DC,kBAA/D,EAAmF,EAAnF,EAAuFzI,OAAvF,EAAgG2H,SAAhG,EAA2G7C,eAA3G,EAA4HpG,UAA5H,EAAwIgK,SAAxI,EAAmJ3D,iBAAnJ,CAAb;AACApG,cAAY,CAACqG,MAAD,CAAZ;AACH,CAhJD,C;;;;;;;;;;;ACXA,IAAIjH,eAAJ;AAAoBC,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACF,iBAAe,CAACG,CAAD,EAAG;AAACH,mBAAe,GAACG,CAAhB;AAAkB;;AAAtC,CAAxC,EAAgF,CAAhF;AAAmF,IAAIC,SAAJ;AAAcH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACE,WAAS,CAACD,CAAD,EAAG;AAACC,aAAS,GAACD,CAAV;AAAY;;AAA1B,CAAxC,EAAoE,CAApE;AAAuE,IAAIE,aAAJ;AAAkBJ,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACG,eAAa,CAACF,CAAD,EAAG;AAACE,iBAAa,GAACF,CAAd;AAAgB;;AAAlC,CAAxC,EAA4E,CAA5E;AAA+E,IAAIG,kBAAJ;AAAuBL,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACI,oBAAkB,CAACH,CAAD,EAAG;AAACG,sBAAkB,GAACH,CAAnB;AAAqB;;AAA5C,CAAxC,EAAsF,CAAtF;AAAyF,IAAIgH,iBAAJ;AAAsBlH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACiH,mBAAiB,CAAChH,CAAD,EAAG;AAACgH,qBAAiB,GAAChH,CAAlB;AAAoB;;AAA1C,CAAxC,EAAoF,CAApF;AAAuF,IAAII,qBAAJ;AAA0BN,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACK,uBAAqB,CAACJ,CAAD,EAAG;AAACI,yBAAqB,GAACJ,CAAtB;AAAwB;;AAAlD,CAAxC,EAA4F,CAA5F;AAA+F,IAAIK,oBAAJ;AAAyBP,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACM,sBAAoB,CAACL,CAAD,EAAG;AAACK,wBAAoB,GAACL,CAArB;AAAuB;;AAAhD,CAAxC,EAA0F,CAA1F;AAA6F,IAAIM,MAAJ;AAAWR,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACO,QAAM,CAACN,CAAD,EAAG;AAACM,UAAM,GAACN,CAAP;AAAS;;AAApB,CAArC,EAA2D,CAA3D;;AAapvB+K,UAAU,GAAG,UAAUvK,UAAV,EAAsBC,YAAtB,EAAoC;AAC7C;AACA,QAAMyG,QAAQ,GAAG1G,UAAU,CAAC,YAAD,CAAV,KAA6BP,SAAS,CAACkH,WAAV,CAAsBC,OAApE;AACA,QAAM1G,QAAQ,GAAGT,SAAS,CAACU,SAAV,CAAoBqK,UAArC;AACA,QAAMvC,SAAS,GAAG,KAAlB;AACA,MAAI5H,YAAY,GAAG,EAAnB,CAL6C,CAKtB;;AACvB,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,oBAAoB,GAAGT,MAAM,EAAjC;AACA,MAAIU,SAAS,GAAGd,aAAa,CAACe,YAAd,CAA2BT,UAAU,CAACU,KAAtC,CAAhB;AACA,MAAIC,QAAQ,GAAGH,SAAS,CAACI,WAAzB;AACA,MAAIC,MAAM,GAAGL,SAAS,CAACM,SAAvB;AACA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,UAAU,CAACgB,MAA1B,CAAX,CAAb;AACA,MAAI8F,YAAY,GAAG9F,MAAM,CAACI,MAA1B;AACA,MAAIE,OAAO,GAAG,EAAd;AACA,MAAI4G,cAAc,GAAG,EAArB;AACA,MAAI3G,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;AACA,MAAIkE,IAAI,GAAG,CAAC,CAAD,GAAKwC,MAAM,CAACC,SAAvB;AACA,MAAIvC,IAAI,GAAG,CAAC,CAAD,GAAKsC,MAAM,CAACC,SAAvB;AACA,MAAI1C,IAAI,GAAGyC,MAAM,CAACC,SAAlB;AACA,MAAIxC,IAAI,GAAGuC,MAAM,CAACC,SAAlB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAItB,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGD,YAAtC,EAAoDC,UAAU,EAA9D,EAAkE;AAC9D;AACA,QAAIrF,KAAK,GAAGV,MAAM,CAAC+F,UAAD,CAAlB;AACA,QAAIuB,QAAQ,GAAG5G,KAAK,CAAC4G,QAArB;AACA,QAAI3G,KAAK,GAAGD,KAAK,CAAC,OAAD,CAAjB;AACA,QAAIU,aAAa,GAAGV,KAAK,CAAC,aAAD,CAAzB;AACA,QAAIW,WAAW,GAAGhD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAA2DC,UAA3D,CAAsER,KAAK,CAAC,aAAD,CAA3E,EAA4F,CAA5F,CAAlB;AACA,QAAIY,SAAS,GAAGZ,KAAK,CAAC,QAAD,CAArB;AACA,QAAIa,MAAM,GAAGf,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAtD,CAAgEE,GAAhE,MAAyEL,SAAlK,CAAb;AACA,QAAIM,MAAM,GAAGlB,KAAK,CAAC,OAAD,CAAlB;AACA,QAAImB,SAAS,GAAG,EAAhB;;AACA,QAAID,MAAM,KAAK,KAAf,EAAsB;AAClBC,eAAS,GAAG,MAAMD,MAAlB;AACH;;AACD,QAAIY,YAAY,GAAG9B,KAAK,CAAC,WAAD,CAAxB;AACA,QAAI+B,SAAS,GAAGjC,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAArE,EAAgFC,IAAhF,CAAqFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAAzD,CAAmEE,GAAnE,MAA4Ea,YAAxK,CAAhB;AACA,QAAIR,eAAe,GAAGtB,KAAK,CAAC,WAAD,CAA3B;AACA,QAAIuB,mBAAmB,GAAG5D,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyD;AAACC,gBAAU,EAAE;AAAb,KAAzD,EAA0E,YAA1E,CAA1B;AACA,QAAIgB,SAAS,GAAGD,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhB;AACA,QAAIU,UAAU,GAAGhC,KAAK,CAAC,YAAD,CAAL,KAAwBiC,SAAxB,GAAoC,EAApC,GAAyCjC,KAAK,CAAC,YAAD,CAA/D;AACA,QAAI+I,UAAU,GAAG/I,KAAK,CAAC,SAAD,CAAtB;AACA,QAAIgJ,iBAAiB,GAAGrL,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAuD;AAACC,gBAAU,EAAE;AAAb,KAAvD,EAAwE,YAAxE,CAAxB;AACA,QAAIyI,OAAO,GAAGD,iBAAiB,CAACD,UAAD,CAAjB,CAA8B,CAA9B,CAAd;AACA,QAAI3H,QAAQ,GAAGpB,KAAK,CAAC,OAAD,CAApB;AACA,QAAIqB,KAAK,GAAGvB,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAAjE,EAA4EC,IAA5E,CAAiFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAArD,CAA+DE,GAA/D,MAAwEG,QAAhK,CAAZ;AACA,QAAIS,cAAc,GAAG7B,KAAK,CAAC,iBAAD,CAA1B,CAzB8D,CA0B9D;AACA;AACA;AACA;;AACA,QAAI8G,OAAO,GAAGvF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAd;AACAhC,UAAM,CAAC+F,UAAD,CAAN,CAAmByB,OAAnB,GAA6BA,OAA7B,CA/B8D,CA+BxB;;AACtC,QAAIC,QAAQ,GAAGxF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAf;;AACA,QAAIyF,QAAQ,KAAK,IAAb,IAAqBJ,WAAW,CAACK,OAAZ,CAAoBD,QAApB,MAAkC,CAAC,CAA5D,EAA+D;AAC3DJ,iBAAW,CAACnC,IAAZ,CAAiBuC,QAAjB;AACH;;AAED,QAAI3E,CAAJ;;AACA,QAAIwE,QAAQ,IAAI,IAAhB,EAAsB;AAClB;AACA;AACA,UAAIvE,SAAS,GAAG,mCACZ,sCADY,GAEZ,4BAFY,GAGZ,4BAHY,GAIZ,gBAJY,GAKZ,6BALY,GAMZ,YANY,GAOZ,gCAPY,GAQZ,8BARY,GASZ,sBATY,GAUZ,qCAVY,GAWZ,gCAXY,GAYZ,yCAZY,GAaZ,kBAbY,GAcZ,iBAdY,GAeZ,GAfJ;AAiBAA,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,aAAlB,EAAiC2G,OAAjC,CAAZ;AACA5G,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,cAAlB,EAAkCrD,QAAlC,CAAZ;AACAoD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,YAAlB,EAAgCnD,MAAhC,CAAZ;AACAkD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqC3B,WAAW,GAAG,GAAd,GAAoBU,KAApB,GAA4BF,SAA5B,GAAwC,GAAxC,GAA8CN,MAAnF,CAAZ;AACAwB,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCd,SAAnC,CAAZ;AACAa,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCP,SAAnC,CAAZ;AACAM,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,oBAAlB,EAAwCT,cAAxC,CAAZ;AACA,UAAIJ,eAAe,GAAG,GAAtB;;AACA,UAAIO,UAAU,CAACtC,MAAX,GAAoB,CAApB,IAAyBsC,UAAU,KAAKjE,SAAS,CAACmE,UAAV,CAAqBC,MAAjE,EAAyE;AACrEV,uBAAe,GAAG,6CAA6CO,UAA7C,GAA0D,GAA5E;AACH;;AACDK,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCb,eAAzC,CAAZ;AAEA9C,kBAAY,CAACqB,KAAK,CAACC,KAAP,CAAZ,GAA4BoC,SAA5B,CAjCkB,CAmClB;;AACA,UAAIR,cAAc,KAAK,KAAvB,EAA8B;AAC1BA,sBAAc,GAAG,GAAjB;AACH;;AAED,UAAIY,WAAJ;AACA,UAAIC,WAAW,GAAGtE,MAAM,EAAxB;AACA,UAAIuE,YAAJ;;AACA,UAAI;AACA;AACAF,mBAAW,GAAGxE,kBAAkB,CAACiL,iBAAnB,CAAqCrG,OAArC,EAA8CR,SAA9C,EAAyD1B,WAAzD,EAAsEkB,cAAtE,EAAsF5C,QAAtF,EAAgGE,MAAhG,EAAwG4J,UAAxG,EAAoH/G,UAApH,EAAgIuE,SAAhI,EAA2I,KAA3I,CAAd;AACA5D,oBAAY,GAAGvE,MAAM,EAArB;AACAO,oBAAY,CAAC,mCAAmCqB,KAAK,CAACC,KAA1C,CAAZ,GAA+D;AAC3D6C,eAAK,EAAEJ,WAAW,CAACK,MAAZ,EADoD;AAE3DC,gBAAM,EAAEL,YAAY,CAACI,MAAb,EAFmD;AAG3DE,kBAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBN,YAAY,CAACO,IAAb,CAAkBR,WAAlB,CAAhB,EAAgDS,SAAhD,KAA8D,UAHb;AAI3DC,qBAAW,EAAEX,WAAW,CAACY,IAAZ,CAAiB6D,CAAjB,CAAmBxH;AAJ2B,SAA/D,CAJA,CAUA;;AACA0C,SAAC,GAAGK,WAAW,CAACY,IAAhB;AACH,OAZD,CAYE,OAAOE,CAAP,EAAU;AACR;AACAA,SAAC,CAACC,OAAF,GAAY,uBAAuBD,CAAC,CAACC,OAAzB,GAAmC,kBAAnC,GAAwDnB,SAApE;AACA,cAAM,IAAI1C,KAAJ,CAAU4D,CAAC,CAACC,OAAZ,CAAN;AACH;;AACD,UAAIf,WAAW,CAACpD,KAAZ,KAAsB4C,SAAtB,IAAmCQ,WAAW,CAACpD,KAAZ,KAAsB,EAA7D,EAAiE;AAC7D,YAAIoD,WAAW,CAACpD,KAAZ,KAAsBtB,SAAS,CAAC0F,QAAV,CAAmBC,aAA7C,EAA4D;AACxD;AACA9E,2BAAiB,GAAG,KAApB;AACH,SAHD,MAGO;AACH;AACAS,eAAK,IAAI,wCAAwCoD,WAAW,CAACpD,KAApD,GAA4D,kBAA5D,GAAiFgD,SAAjF,GAA6F,MAAtG;AACA,gBAAO,IAAI1C,KAAJ,CAAUN,KAAV,CAAP;AACH;AACJ,OArEiB,CAuElB;;;AACA,UAAIsE,oBAAoB,GAAGvF,MAAM,EAAjC;;AACA,UAAIQ,iBAAJ,EAAuB;AACnBoF,YAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH;AACJ,KA/ED,MA+EO;AACH;AACA,YAAMgD,UAAU,GAAGrC,iBAAiB,CAACsC,mBAAlB,CAAsCxH,OAAtC,EAA+CgH,QAA/C,EAAyDpI,QAAzD,EAAmE+H,SAAnE,CAAnB;AACAnE,OAAC,GAAG+E,UAAU,CAACvH,OAAf;AACAoE,UAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH,KA7H6D,CA+H9D;AACA;;;AACA,UAAMP,IAAI,GAAGxB,CAAC,CAACiF,GAAF,GAAQjF,CAAC,CAAC8E,CAAF,CAAIxH,MAAzB;AACA,UAAMoE,UAAU,GAAGF,IAAI,KAAK3B,SAAT,GAAqBhC,KAAK,GAAG,cAA7B,GAA8CA,KAAK,GAAG,WAAR,GAAsB2D,IAAI,CAACG,WAAL,CAAiB,CAAjB,CAAvF;AACA/D,SAAK,CAAC,YAAD,CAAL,GAAsB8D,UAAtB;AACA9D,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC4B,IAAlB;AACAhE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC6B,IAAlB;AACAjE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC8B,IAAlB;AACAlE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC+B,IAAlB;AACAnE,SAAK,CAAC,SAAD,CAAL,GAAmB8G,OAAnB;AACA,UAAMxC,QAAQ,GAAGpG,qBAAqB,CAACoJ,0BAAtB,CAAiDtH,KAAjD,EAAwDqF,UAAxD,EAAoExF,OAApE,EAA6EuC,CAA7E,CAAjB,CAzI8D,CAyIqC;;AACnGxC,WAAO,CAAC4E,IAAR,CAAaF,QAAb;AACA,QAAIG,qBAAqB,GAAGrG,MAAM,EAAlC;AACAO,gBAAY,CAAC,gDAAgDqB,KAAK,CAACC,KAAvD,CAAZ,GAA4E;AACxE6C,WAAK,EAAEa,oBAAoB,CAACZ,MAArB,EADiE;AAExEC,YAAM,EAAEyB,qBAAqB,CAAC1B,MAAtB,EAFgE;AAGxEE,cAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBwB,qBAAqB,CAACvB,IAAtB,CAA2BS,oBAA3B,CAAhB,EAAkER,SAAlE,KAAgF;AAHlB,KAA5E;AAKH,GAxK4C,CAwK1C;AAEH;;;AACA,QAAMoE,SAAS,GAAG;AAAC,gBAAY/I,QAAb;AAAuB,iBAAa+H,SAApC;AAA+C,gBAAYvB;AAA3D,GAAlB;AACA,QAAMN,eAAe,GAAG;AACpB,cAAUpF,MADU;AAEpB,oBAAgB8F,YAFI;AAGpB,mBAAeuB,WAHK;AAIpB,sBAAkBH,cAJE;AAKpB,eAAW3G,OALS;AAMpB,YAAQoE,IANY;AAOpB,YAAQD;AAPY,GAAxB;AASA,QAAMW,iBAAiB,GAAG;AAAC,oBAAgBhG,YAAjB;AAA+B,4BAAwBE;AAAvD,GAA1B;AACA,MAAI+F,MAAM,GAAGzG,oBAAoB,CAACqJ,kBAArB,CAAwC5H,OAAxC,EAAiD2H,SAAjD,EAA4D7C,eAA5D,EAA6EpG,UAA7E,EAAyFqG,iBAAzF,CAAb;AACApG,cAAY,CAACqG,MAAD,CAAZ;AACH,CAxLD,C;;;;;;;;;;;ACbA,IAAIjH,eAAJ;AAAoBC,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACF,iBAAe,CAACG,CAAD,EAAG;AAACH,mBAAe,GAACG,CAAhB;AAAkB;;AAAtC,CAAxC,EAAgF,CAAhF;AAAmF,IAAIC,SAAJ;AAAcH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACE,WAAS,CAACD,CAAD,EAAG;AAACC,aAAS,GAACD,CAAV;AAAY;;AAA1B,CAAxC,EAAoE,CAApE;AAAuE,IAAIE,aAAJ;AAAkBJ,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACG,eAAa,CAACF,CAAD,EAAG;AAACE,iBAAa,GAACF,CAAd;AAAgB;;AAAlC,CAAxC,EAA4E,CAA5E;AAA+E,IAAIG,kBAAJ;AAAuBL,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACI,oBAAkB,CAACH,CAAD,EAAG;AAACG,sBAAkB,GAACH,CAAnB;AAAqB;;AAA5C,CAAxC,EAAsF,CAAtF;AAAyF,IAAIgH,iBAAJ;AAAsBlH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACiH,mBAAiB,CAAChH,CAAD,EAAG;AAACgH,qBAAiB,GAAChH,CAAlB;AAAoB;;AAA1C,CAAxC,EAAoF,CAApF;AAAuF,IAAII,qBAAJ;AAA0BN,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACK,uBAAqB,CAACJ,CAAD,EAAG;AAACI,yBAAqB,GAACJ,CAAtB;AAAwB;;AAAlD,CAAxC,EAA4F,CAA5F;AAA+F,IAAIK,oBAAJ;AAAyBP,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACM,sBAAoB,CAACL,CAAD,EAAG;AAACK,wBAAoB,GAACL,CAArB;AAAuB;;AAAhD,CAAxC,EAA0F,CAA1F;AAA6F,IAAIM,MAAJ;AAAWR,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACO,QAAM,CAACN,CAAD,EAAG;AAACM,UAAM,GAACN,CAAP;AAAS;;AAApB,CAArC,EAA2D,CAA3D;;AAapvBqL,aAAa,GAAG,UAAU7K,UAAV,EAAsBC,YAAtB,EAAoC;AAChD;AACA,QAAMyG,QAAQ,GAAG1G,UAAU,CAAC,YAAD,CAAV,KAA6BP,SAAS,CAACkH,WAAV,CAAsBC,OAApE;AACA,QAAM1G,QAAQ,GAAGT,SAAS,CAACU,SAAV,CAAoBsD,SAArC;AACA,QAAMwE,SAAS,GAAG,KAAlB;AACA,MAAI5H,YAAY,GAAG,EAAnB,CALgD,CAKzB;;AACvB,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,oBAAoB,GAAGT,MAAM,EAAjC;AACA,MAAIiB,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,UAAU,CAACgB,MAA1B,CAAX,CAAb;AACA,MAAI8F,YAAY,GAAG9F,MAAM,CAACI,MAA1B;AACA,MAAIE,OAAO,GAAG,EAAd;AACA,MAAI4G,cAAc,GAAG,EAArB;AACA,MAAI3G,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;AACA,MAAIkE,IAAI,GAAG,CAAC,CAAD,GAAKwC,MAAM,CAACC,SAAvB;AACA,MAAIvC,IAAI,GAAG,CAAC,CAAD,GAAKsC,MAAM,CAACC,SAAvB;AACA,MAAI1C,IAAI,GAAGyC,MAAM,CAACC,SAAlB;AACA,MAAIxC,IAAI,GAAGuC,MAAM,CAACC,SAAlB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAItB,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGD,YAAtC,EAAoDC,UAAU,EAA9D,EAAkE;AAC9D;AACA,QAAIrF,KAAK,GAAGV,MAAM,CAAC+F,UAAD,CAAlB;AACA,QAAIuB,QAAQ,GAAG5G,KAAK,CAAC4G,QAArB;AACA,QAAI3G,KAAK,GAAGD,KAAK,CAAC,OAAD,CAAjB;AACA,QAAIU,aAAa,GAAGV,KAAK,CAAC,aAAD,CAAzB;AACA,QAAIW,WAAW,GAAGhD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAA2DC,UAA3D,CAAsER,KAAK,CAAC,aAAD,CAA3E,EAA4F,CAA5F,CAAlB;AACA,QAAIY,SAAS,GAAGZ,KAAK,CAAC,QAAD,CAArB;AACA,QAAIa,MAAM,GAAGf,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAtD,CAAgEE,GAAhE,MAAyEL,SAAlK,CAAb;AACA,QAAIM,MAAM,GAAGlB,KAAK,CAAC,OAAD,CAAlB;AACA,QAAImB,SAAS,GAAG,EAAhB;;AACA,QAAID,MAAM,KAAK,KAAf,EAAsB;AAClBC,eAAS,GAAG,MAAMD,MAAlB;AACH;;AACD,QAAIE,QAAQ,GAAGpB,KAAK,CAAC,OAAD,CAApB;AACA,QAAIqB,KAAK,GAAGvB,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAAjE,EAA4EC,IAA5E,CAAiFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAArD,CAA+DE,GAA/D,MAAwEG,QAAhK,CAAZ;AACA,QAAIE,eAAe,GAAGtB,KAAK,CAAC,WAAD,CAA3B;AACA,QAAIuB,mBAAmB,GAAG5D,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyD;AAACC,gBAAU,EAAE;AAAb,KAAzD,EAA0E,YAA1E,CAA1B;AACA,QAAIgB,SAAS,GAAGD,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhB;AACA,QAAIxC,SAAS,GAAGd,aAAa,CAACe,YAAd,CAA2BiB,KAAK,CAAC,aAAD,CAAhC,CAAhB;AACA,QAAIf,QAAQ,GAAGH,SAAS,CAACI,WAAzB;AACA,QAAIC,MAAM,GAAGL,SAAS,CAACM,SAAvB;AACA,QAAI4C,UAAU,GAAGhC,KAAK,CAAC,YAAD,CAAL,KAAwBiC,SAAxB,GAAoC,EAApC,GAAyCjC,KAAK,CAAC,YAAD,CAA/D;AACA,QAAI6B,cAAc,GAAG7B,KAAK,CAAC,iBAAD,CAA1B,CAvB8D,CAwB9D;AACA;AACA;AACA;;AACA,QAAI8G,OAAO,GAAGvF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAd;AACAhC,UAAM,CAAC+F,UAAD,CAAN,CAAmByB,OAAnB,GAA6BA,OAA7B,CA7B8D,CA6BxB;;AACtC,QAAIC,QAAQ,GAAGxF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAf;;AACA,QAAIyF,QAAQ,KAAK,IAAb,IAAqBJ,WAAW,CAACK,OAAZ,CAAoBD,QAApB,MAAkC,CAAC,CAA5D,EAA+D;AAC3DJ,iBAAW,CAACnC,IAAZ,CAAiBuC,QAAjB;AACH;;AAED,QAAI3E,CAAJ;;AACA,QAAIwE,QAAQ,IAAI,IAAhB,EAAsB;AAClB;AACA;AACA,UAAIvE,SAAS,GAAG,mCACZ,sCADY,GAEZ,4BAFY,GAGZ,4BAHY,GAIZ,gBAJY,GAKZ,6BALY,GAMZ,YANY,GAOZ,gCAPY,GAQZ,8BARY,GASZ,sBATY,GAUZ,qCAVY,GAWZ,yCAXY,GAYZ,kBAZY,GAaZ,iBAbY,GAcZ,GAdJ;AAgBAA,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,cAAlB,EAAkCrD,QAAlC,CAAZ;AACAoD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,YAAlB,EAAgCnD,MAAhC,CAAZ;AACAkD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqC3B,WAAW,GAAG,GAAd,GAAoBU,KAApB,GAA4BF,SAA5B,GAAwC,GAAxC,GAA8CN,MAAnF,CAAZ;AACAwB,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCd,SAAnC,CAAZ;AACAa,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,oBAAlB,EAAwCT,cAAxC,CAAZ;AACA,UAAIJ,eAAe,GAAG,GAAtB;;AACA,UAAIO,UAAU,CAACtC,MAAX,GAAoB,CAApB,IAAyBsC,UAAU,KAAKjE,SAAS,CAACmE,UAAV,CAAqBC,MAAjE,EAAyE;AACrEV,uBAAe,GAAG,6CAA6CO,UAA7C,GAA0D,GAA5E;AACH;;AACDK,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCb,eAAzC,CAAZ;AAEA9C,kBAAY,CAACqB,KAAK,CAACC,KAAP,CAAZ,GAA4BoC,SAA5B;AAEA,UAAII,WAAJ;AACA,UAAIC,WAAW,GAAGtE,MAAM,EAAxB;AACA,UAAIuE,YAAJ;;AACA,UAAI;AACA;AACAF,mBAAW,GAAGxE,kBAAkB,CAACgJ,qBAAnB,CAAyCpE,OAAzC,EAAkDR,SAAlD,EAA6D7D,QAA7D,EAAuE+H,SAAvE,CAAd;AACA5D,oBAAY,GAAGvE,MAAM,EAArB;AACAO,oBAAY,CAAC,mCAAmCqB,KAAK,CAACC,KAA1C,CAAZ,GAA+D;AAC3D6C,eAAK,EAAEJ,WAAW,CAACK,MAAZ,EADoD;AAE3DC,gBAAM,EAAEL,YAAY,CAACI,MAAb,EAFmD;AAG3DE,kBAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBN,YAAY,CAACO,IAAb,CAAkBR,WAAlB,CAAhB,EAAgDS,SAAhD,KAA8D,UAHb;AAI3DC,qBAAW,EAAEX,WAAW,CAACY,IAAZ,CAAiB6D,CAAjB,CAAmBxH;AAJ2B,SAA/D,CAJA,CAUA;;AACA0C,SAAC,GAAGK,WAAW,CAACY,IAAhB;AACH,OAZD,CAYE,OAAOE,CAAP,EAAU;AACR;AACAA,SAAC,CAACC,OAAF,GAAY,uBAAuBD,CAAC,CAACC,OAAzB,GAAmC,kBAAnC,GAAwDnB,SAApE;AACA,cAAM,IAAI1C,KAAJ,CAAU4D,CAAC,CAACC,OAAZ,CAAN;AACH;;AACD,UAAIf,WAAW,CAACpD,KAAZ,KAAsB4C,SAAtB,IAAmCQ,WAAW,CAACpD,KAAZ,KAAsB,EAA7D,EAAiE;AAC7D,YAAIoD,WAAW,CAACpD,KAAZ,KAAsBtB,SAAS,CAAC0F,QAAV,CAAmBC,aAA7C,EAA4D;AACxD;AACA9E,2BAAiB,GAAG,KAApB;AACH,SAHD,MAGO;AACH;AACAS,eAAK,IAAI,wCAAwCoD,WAAW,CAACpD,KAApD,GAA4D,kBAA5D,GAAiFgD,SAAjF,GAA6F,MAAtG;AACA,gBAAO,IAAI1C,KAAJ,CAAUN,KAAV,CAAP;AACH;AACJ,OA7DiB,CA+DlB;;;AACA,UAAIsE,oBAAoB,GAAGvF,MAAM,EAAjC;;AACA,UAAIQ,iBAAJ,EAAuB;AACnBoF,YAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH;AACJ,KAvED,MAuEO;AACH;AACA,YAAMgD,UAAU,GAAGrC,iBAAiB,CAACsC,mBAAlB,CAAsCxH,OAAtC,EAA+CgH,QAA/C,EAAyDpI,QAAzD,EAAmE+H,SAAnE,CAAnB;AACAnE,OAAC,GAAG+E,UAAU,CAACvH,OAAf;AACAoE,UAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH,KAnH6D,CAqH9D;AACA;;;AACA,UAAMP,IAAI,GAAGxB,CAAC,CAACiF,GAAF,GAAQjF,CAAC,CAAC8E,CAAF,CAAIxH,MAAzB;AACA,UAAMoE,UAAU,GAAGF,IAAI,KAAK3B,SAAT,GAAqBhC,KAAK,GAAG,cAA7B,GAA8CA,KAAK,GAAG,WAAR,GAAsB2D,IAAI,CAACG,WAAL,CAAiB,CAAjB,CAAvF;AACA/D,SAAK,CAAC,YAAD,CAAL,GAAsB8D,UAAtB;AACA9D,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC4B,IAAlB;AACAhE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC6B,IAAlB;AACAjE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC8B,IAAlB;AACAlE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC+B,IAAlB;AACAnE,SAAK,CAAC,SAAD,CAAL,GAAmB8G,OAAnB;AACA,UAAMxC,QAAQ,GAAGpG,qBAAqB,CAACoJ,0BAAtB,CAAiDtH,KAAjD,EAAwDqF,UAAxD,EAAoExF,OAApE,EAA6EuC,CAA7E,CAAjB,CA/H8D,CA+HqC;;AACnGxC,WAAO,CAAC4E,IAAR,CAAaF,QAAb;AACA,QAAIG,qBAAqB,GAAGrG,MAAM,EAAlC;AACAO,gBAAY,CAAC,gDAAgDqB,KAAK,CAACC,KAAvD,CAAZ,GAA4E;AACxE6C,WAAK,EAAEa,oBAAoB,CAACZ,MAArB,EADiE;AAExEC,YAAM,EAAEyB,qBAAqB,CAAC1B,MAAtB,EAFgE;AAGxEE,cAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBwB,qBAAqB,CAACvB,IAAtB,CAA2BS,oBAA3B,CAAhB,EAAkER,SAAlE,KAAgF;AAHlB,KAA5E;AAKH,GA3J+C,CA2J7C;AAEH;;;AACA,QAAMoE,SAAS,GAAG;AAAC,gBAAY/I,QAAb;AAAuB,iBAAa+H,SAApC;AAA+C,gBAAYvB;AAA3D,GAAlB;AACA,QAAMN,eAAe,GAAG;AACpB,cAAUpF,MADU;AAEpB,oBAAgB8F,YAFI;AAGpB,mBAAeuB,WAHK;AAIpB,sBAAkBH,cAJE;AAKpB,eAAW3G,OALS;AAMpB,YAAQoE,IANY;AAOpB,YAAQD;AAPY,GAAxB;AASA,QAAMW,iBAAiB,GAAG;AAAC,oBAAgBhG,YAAjB;AAA+B,4BAAwBE;AAAvD,GAA1B;AACA,MAAI+F,MAAM,GAAGzG,oBAAoB,CAACqJ,kBAArB,CAAwC5H,OAAxC,EAAiD2H,SAAjD,EAA4D7C,eAA5D,EAA6EpG,UAA7E,EAAyFqG,iBAAzF,CAAb;AACApG,cAAY,CAACqG,MAAD,CAAZ;AACH,CA3KD,C;;;;;;;;;;;ACbA,IAAIjH,eAAJ;AAAoBC,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACF,iBAAe,CAACG,CAAD,EAAG;AAACH,mBAAe,GAACG,CAAhB;AAAkB;;AAAtC,CAAxC,EAAgF,CAAhF;AAAmF,IAAIC,SAAJ;AAAcH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACE,WAAS,CAACD,CAAD,EAAG;AAACC,aAAS,GAACD,CAAV;AAAY;;AAA1B,CAAxC,EAAoE,CAApE;AAAuE,IAAIE,aAAJ;AAAkBJ,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACG,eAAa,CAACF,CAAD,EAAG;AAACE,iBAAa,GAACF,CAAd;AAAgB;;AAAlC,CAAxC,EAA4E,CAA5E;AAA+E,IAAIG,kBAAJ;AAAuBL,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACI,oBAAkB,CAACH,CAAD,EAAG;AAACG,sBAAkB,GAACH,CAAnB;AAAqB;;AAA5C,CAAxC,EAAsF,CAAtF;AAAyF,IAAIgH,iBAAJ;AAAsBlH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACiH,mBAAiB,CAAChH,CAAD,EAAG;AAACgH,qBAAiB,GAAChH,CAAlB;AAAoB;;AAA1C,CAAxC,EAAoF,CAApF;AAAuF,IAAII,qBAAJ;AAA0BN,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACK,uBAAqB,CAACJ,CAAD,EAAG;AAACI,yBAAqB,GAACJ,CAAtB;AAAwB;;AAAlD,CAAxC,EAA4F,CAA5F;AAA+F,IAAIK,oBAAJ;AAAyBP,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACM,sBAAoB,CAACL,CAAD,EAAG;AAACK,wBAAoB,GAACL,CAArB;AAAuB;;AAAhD,CAAxC,EAA0F,CAA1F;AAA6F,IAAIM,MAAJ;AAAWR,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACO,QAAM,CAACN,CAAD,EAAG;AAACM,UAAM,GAACN,CAAP;AAAS;;AAApB,CAArC,EAA2D,CAA3D;;AAapvBsL,aAAa,GAAG,UAAU9K,UAAV,EAAsBC,YAAtB,EAAoC;AAChD;AACA,QAAMyG,QAAQ,GAAG1G,UAAU,CAAC,YAAD,CAAV,KAA6BP,SAAS,CAACkH,WAAV,CAAsBC,OAApE;AACA,QAAM1G,QAAQ,GAAGT,SAAS,CAACU,SAAV,CAAoB4K,SAArC;AACA,QAAM9C,SAAS,GAAG,KAAlB;AACA,MAAI5H,YAAY,GAAG,EAAnB,CALgD,CAKzB;;AACvB,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,oBAAoB,GAAGT,MAAM,EAAjC;AACA,MAAIiB,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,UAAU,CAACgB,MAA1B,CAAX,CAAb;AACA,MAAI8F,YAAY,GAAG9F,MAAM,CAACI,MAA1B;AACA,MAAIE,OAAO,GAAG,EAAd;AACA,MAAI4G,cAAc,GAAG,EAArB;AACA,MAAI3G,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;AACA,MAAIkE,IAAI,GAAG,CAAC,CAAD,GAAKwC,MAAM,CAACC,SAAvB;AACA,MAAIvC,IAAI,GAAG,CAAC,CAAD,GAAKsC,MAAM,CAACC,SAAvB;AACA,MAAI1C,IAAI,GAAGyC,MAAM,CAACC,SAAlB;AACA,MAAIxC,IAAI,GAAGuC,MAAM,CAACC,SAAlB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAItB,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGD,YAAtC,EAAoDC,UAAU,EAA9D,EAAkE;AAC9D;AACA,QAAIrF,KAAK,GAAGV,MAAM,CAAC+F,UAAD,CAAlB;AACA,QAAIuB,QAAQ,GAAG5G,KAAK,CAAC4G,QAArB;AACA,QAAI3G,KAAK,GAAGD,KAAK,CAAC,OAAD,CAAjB;AACA,QAAIU,aAAa,GAAGV,KAAK,CAAC,aAAD,CAAzB;AACA,QAAIW,WAAW,GAAGhD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAA2DC,UAA3D,CAAsER,KAAK,CAAC,aAAD,CAA3E,EAA4F,CAA5F,CAAlB;AACA,QAAIY,SAAS,GAAGZ,KAAK,CAAC,QAAD,CAArB;AACA,QAAIa,MAAM,GAAGf,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAsDQ,SAAtD,CAAgEE,GAAhE,MAAyEL,SAAlK,CAAb;AACA,QAAIM,MAAM,GAAGlB,KAAK,CAAC,OAAD,CAAlB;AACA,QAAImB,SAAS,GAAG,EAAhB;;AACA,QAAID,MAAM,KAAK,KAAf,EAAsB;AAClBC,eAAS,GAAG,MAAMD,MAAlB;AACH;;AACD,QAAIE,QAAQ,GAAGpB,KAAK,CAAC,OAAD,CAApB;AACA,QAAIqB,KAAK,GAAGvB,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAAjE,EAA4EC,IAA5E,CAAiFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAqDQ,SAArD,CAA+DE,GAA/D,MAAwEG,QAAhK,CAAZ;AACA,QAAIU,YAAY,GAAG9B,KAAK,CAAC,WAAD,CAAxB;AACA,QAAI+B,SAAS,GAAGjC,MAAM,CAACgB,IAAP,CAAYnD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAArE,EAAgFC,IAAhF,CAAqFC,GAAG,IAAItD,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyDQ,SAAzD,CAAmEE,GAAnE,MAA4Ea,YAAxK,CAAhB;AACA,QAAIR,eAAe,GAAGtB,KAAK,CAAC,WAAD,CAA3B;AACA,QAAIuB,mBAAmB,GAAG5D,eAAe,CAAC0C,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,UAAI,EAAE;AAAP,KAApC,EAAyD;AAACC,gBAAU,EAAE;AAAb,KAAzD,EAA0E,YAA1E,CAA1B;AACA,QAAIgB,SAAS,GAAGD,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhB;AACA,QAAIxC,SAAS,GAAGd,aAAa,CAACe,YAAd,CAA2BiB,KAAK,CAAC,aAAD,CAAhC,CAAhB;AACA,QAAIf,QAAQ,GAAGH,SAAS,CAACI,WAAzB;AACA,QAAIC,MAAM,GAAGL,SAAS,CAACM,SAAvB;AACA,QAAIyC,cAAc,GAAG7B,KAAK,CAAC,iBAAD,CAA1B,CAxB8D,CAyB9D;AACA;AACA;AACA;;AACA,QAAI8G,OAAO,GAAGvF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAd;AACAhC,UAAM,CAAC+F,UAAD,CAAN,CAAmByB,OAAnB,GAA6BA,OAA7B,CA9B8D,CA8BxB;;AACtC,QAAIC,QAAQ,GAAGxF,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAf;;AACA,QAAIyF,QAAQ,KAAK,IAAb,IAAqBJ,WAAW,CAACK,OAAZ,CAAoBD,QAApB,MAAkC,CAAC,CAA5D,EAA+D;AAC3DJ,iBAAW,CAACnC,IAAZ,CAAiBuC,QAAjB;AACH;;AAED,QAAI3E,CAAJ;;AACA,QAAIwE,QAAQ,IAAI,IAAhB,EAAsB;AAClB;AACA;AACA,UAAIvE,SAAS,GAAG,wDACZ,sCADY,GAEZ,4BAFY,GAGZ,4BAHY,GAIZ,gBAJY,GAKZ,6BALY,GAMZ,YANY,GAOZ,gCAPY,GAQZ,8BARY,GASZ,qCATY,GAUZ,gCAVY,GAWZ,yCAXY,GAYZ,qBAZY,GAaZ,oBAbY,GAcZ,GAdJ;AAgBAA,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,cAAlB,EAAkCrD,QAAlC,CAAZ;AACAoD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,YAAlB,EAAgCnD,MAAhC,CAAZ;AACAkD,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqC3B,WAAW,GAAG,GAAd,GAAoBU,KAApB,GAA4BF,SAA5B,GAAwC,GAAxC,GAA8CN,MAAnF,CAAZ;AACAwB,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCd,SAAnC,CAAZ;AACAa,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmCP,SAAnC,CAAZ;AACAM,eAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,oBAAlB,EAAwCT,cAAxC,CAAZ;AACAlD,kBAAY,CAACqB,KAAK,CAACC,KAAP,CAAZ,GAA4BoC,SAA5B;AAEA,UAAII,WAAJ;AACA,UAAIC,WAAW,GAAGtE,MAAM,EAAxB;AACA,UAAIuE,YAAJ;;AACA,UAAI;AACA;AACAF,mBAAW,GAAGxE,kBAAkB,CAACgJ,qBAAnB,CAAyCpE,OAAzC,EAAkDR,SAAlD,EAA6D7D,QAA7D,EAAuE+H,SAAvE,CAAd;AACA5D,oBAAY,GAAGvE,MAAM,EAArB;AACAO,oBAAY,CAAC,mCAAmCqB,KAAK,CAACC,KAA1C,CAAZ,GAA+D;AAC3D6C,eAAK,EAAEJ,WAAW,CAACK,MAAZ,EADoD;AAE3DC,gBAAM,EAAEL,YAAY,CAACI,MAAb,EAFmD;AAG3DE,kBAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBN,YAAY,CAACO,IAAb,CAAkBR,WAAlB,CAAhB,EAAgDS,SAAhD,KAA8D,UAHb;AAI3DC,qBAAW,EAAEX,WAAW,CAACY,IAAZ,CAAiB6D,CAAjB,CAAmBxH;AAJ2B,SAA/D,CAJA,CAUA;;AACA0C,SAAC,GAAGK,WAAW,CAACY,IAAhB;AACH,OAZD,CAYE,OAAOE,CAAP,EAAU;AACR;AACAA,SAAC,CAACC,OAAF,GAAY,uBAAuBD,CAAC,CAACC,OAAzB,GAAmC,kBAAnC,GAAwDnB,SAApE;AACA,cAAM,IAAI1C,KAAJ,CAAU4D,CAAC,CAACC,OAAZ,CAAN;AACH;;AACD,UAAIf,WAAW,CAACpD,KAAZ,KAAsB4C,SAAtB,IAAmCQ,WAAW,CAACpD,KAAZ,KAAsB,EAA7D,EAAiE;AAC7D,YAAIoD,WAAW,CAACpD,KAAZ,KAAsBtB,SAAS,CAAC0F,QAAV,CAAmBC,aAA7C,EAA4D;AACxD;AACA9E,2BAAiB,GAAG,KAApB;AACH,SAHD,MAGO;AACH;AACAS,eAAK,IAAI,wCAAwCoD,WAAW,CAACpD,KAApD,GAA4D,kBAA5D,GAAiFgD,SAAjF,GAA6F,MAAtG;AACA,gBAAO,IAAI1C,KAAJ,CAAUN,KAAV,CAAP;AACH;AACJ,OAxDiB,CA0DlB;;;AACA,UAAIsE,oBAAoB,GAAGvF,MAAM,EAAjC;;AACA,UAAIQ,iBAAJ,EAAuB;AACnBoF,YAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,YAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH;AACJ,KAlED,MAkEO;AACH;AACA,YAAMgD,UAAU,GAAGrC,iBAAiB,CAACsC,mBAAlB,CAAsCxH,OAAtC,EAA+CgH,QAA/C,EAAyDpI,QAAzD,EAAmE+H,SAAnE,CAAnB;AACAnE,OAAC,GAAG+E,UAAU,CAACvH,OAAf;AACAoE,UAAI,GAAGA,IAAI,GAAG5B,CAAC,CAAC4B,IAAT,GAAgBA,IAAhB,GAAuB5B,CAAC,CAAC4B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG7B,CAAC,CAAC6B,IAAT,GAAgBA,IAAhB,GAAuB7B,CAAC,CAAC6B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG9B,CAAC,CAAC8B,IAAT,GAAgBA,IAAhB,GAAuB9B,CAAC,CAAC8B,IAAhC;AACAC,UAAI,GAAGA,IAAI,GAAG/B,CAAC,CAAC+B,IAAT,GAAgBA,IAAhB,GAAuB/B,CAAC,CAAC+B,IAAhC;AACH,KA/G6D,CAiH9D;AACA;;;AACA,UAAMP,IAAI,GAAGxB,CAAC,CAACiF,GAAF,GAAQjF,CAAC,CAAC8E,CAAF,CAAIxH,MAAzB;AACA,UAAMoE,UAAU,GAAGF,IAAI,KAAK3B,SAAT,GAAqBhC,KAAK,GAAG,cAA7B,GAA8CA,KAAK,GAAG,WAAR,GAAsB2D,IAAI,CAACG,WAAL,CAAiB,CAAjB,CAAvF;AACA/D,SAAK,CAAC,YAAD,CAAL,GAAsB8D,UAAtB;AACA9D,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC4B,IAAlB;AACAhE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC6B,IAAlB;AACAjE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC8B,IAAlB;AACAlE,SAAK,CAAC,MAAD,CAAL,GAAgBoC,CAAC,CAAC+B,IAAlB;AACAnE,SAAK,CAAC,SAAD,CAAL,GAAmB8G,OAAnB;AACA,UAAMxC,QAAQ,GAAGpG,qBAAqB,CAACoJ,0BAAtB,CAAiDtH,KAAjD,EAAwDqF,UAAxD,EAAoExF,OAApE,EAA6EuC,CAA7E,CAAjB,CA3H8D,CA2HqC;;AACnGxC,WAAO,CAAC4E,IAAR,CAAaF,QAAb;AACA,QAAIG,qBAAqB,GAAGrG,MAAM,EAAlC;AACAO,gBAAY,CAAC,gDAAgDqB,KAAK,CAACC,KAAvD,CAAZ,GAA4E;AACxE6C,WAAK,EAAEa,oBAAoB,CAACZ,MAArB,EADiE;AAExEC,YAAM,EAAEyB,qBAAqB,CAAC1B,MAAtB,EAFgE;AAGxEE,cAAQ,EAAE7E,MAAM,CAAC6E,QAAP,CAAgBwB,qBAAqB,CAACvB,IAAtB,CAA2BS,oBAA3B,CAAhB,EAAkER,SAAlE,KAAgF;AAHlB,KAA5E;AAKH,GAvJ+C,CAuJ7C;AAEH;;;AACA,QAAMoE,SAAS,GAAG;AAAC,gBAAY/I,QAAb;AAAuB,iBAAa+H,SAApC;AAA+C,gBAAYvB;AAA3D,GAAlB;AACA,QAAMN,eAAe,GAAG;AACpB,cAAUpF,MADU;AAEpB,oBAAgB8F,YAFI;AAGpB,mBAAeuB,WAHK;AAIpB,sBAAkBH,cAJE;AAKpB,eAAW3G,OALS;AAMpB,YAAQoE,IANY;AAOpB,YAAQD;AAPY,GAAxB;AASA,QAAMW,iBAAiB,GAAG;AAAC,oBAAgBhG,YAAjB;AAA+B,4BAAwBE;AAAvD,GAA1B;AACA,MAAI+F,MAAM,GAAGzG,oBAAoB,CAACqJ,kBAArB,CAAwC5H,OAAxC,EAAiD2H,SAAjD,EAA4D7C,eAA5D,EAA6EpG,UAA7E,EAAyFqG,iBAAzF,CAAb;AACApG,cAAY,CAACqG,MAAD,CAAZ;AACH,CAvKD,C","file":"/app.js","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataContour = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const plotType = matsTypes.PlotTypes.contour;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    if (curves.length > 1) {\n        throw new Error(\"INFO:  There must only be one added curve.\");\n    }\n    var dataset = [];\n    var axisMap = Object.create(null);\n\n    // initialize variables specific to the curve\n    var curve = curves[0];\n    var label = curve['label'];\n    var xAxisParam = curve['x-axis-parameter'];\n    var yAxisParam = curve['y-axis-parameter'];\n    var xValClause = matsCollections.CurveParams.findOne({name: 'x-axis-parameter'}).optionsMap[xAxisParam];\n    var yValClause = matsCollections.CurveParams.findOne({name: 'y-axis-parameter'}).optionsMap[yAxisParam];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n    if (source !== \"All\") {\n        sourceStr = \"_\" + source;\n    }\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimeClause = \"\";\n    var thresholdClause = \"\";\n    var forecastLengthClause = \"\";\n    var dateClause = \"\";\n    if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n        var forecastLength = curve['forecast-length'];\n        forecastLengthClause = \"and m0.fcst_len = \" + forecastLength + \" \";\n    }\n    if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        thresholdClause = \"and m0.trsh = \" + threshold + \" \";\n    }\n    if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n            validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n        }\n    }\n    if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && (xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date')) {\n        dateClause = \"m0.time-m0.fcst_len*3600\";\n    } else {\n        dateClause = \"m0.time\";\n    }\n\n    // For contours, this functions as the colorbar label.\n    curve['unitKey'] = statisticOptionsMap[statisticSelect][1];\n\n    var d;\n    // this is a database driven curve, not a difference curve\n    // prepare the query from the above parameters\n    var statement = \"{{xValClause}} \" +\n        \"{{yValClause}} \" +\n        \"count(distinct {{dateClause}}) as N_times, \" +\n        \"min({{dateClause}}) as min_secs, \" +\n        \"max({{dateClause}}) as max_secs, \" +\n        \"{{statistic}} \" +\n        \"from {{data_source}} as m0 \" +\n        \"where 1=1 \" +\n        \"and {{dateClause}} >= '{{fromSecs}}' \" +\n        \"and {{dateClause}} <= '{{toSecs}}' \" +\n        \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n        \"{{thresholdClause}} \" +\n        \"{{validTimeClause}} \" +\n        \"{{forecastLengthClause}} \" +\n        \"group by xVal,yVal \" +\n        \"order by xVal,yVal\" +\n        \";\";\n\n    statement = statement.replace('{{xValClause}}', xValClause);\n    statement = statement.replace('{{yValClause}}', yValClause);\n    statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n    statement = statement.replace('{{statistic}}', statistic);\n    statement = statement.replace('{{threshold}}', threshold);\n    statement = statement.replace('{{fromSecs}}', fromSecs);\n    statement = statement.replace('{{toSecs}}', toSecs);\n    statement = statement.replace('{{thresholdClause}}', thresholdClause);\n    statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n    statement = statement.replace('{{validTimeClause}}', validTimeClause);\n    statement = statement.split('{{dateClause}}').join(dateClause);\n    dataRequests[curve.label] = statement;\n\n    // math is done on forecastLength later on -- set all analyses to 0\n    if (forecastLength === \"-99\") {\n        forecastLength = \"0\";\n    }\n\n    var queryResult;\n    var startMoment = moment();\n    var finishMoment;\n    try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n            begin: startMoment.format(),\n            finish: finishMoment.format(),\n            duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n            recordCount: queryResult.data.xTextOutput.length\n        };\n        // get the data back from the query\n        d = queryResult.data;\n    } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n    }\n    if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n            // this is NOT an error just a no data condition\n            dataFoundForCurve = false;\n        } else {\n            // this is an error returned by the mysql database\n            error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n            throw (new Error(error));\n        }\n    }\n\n    var postQueryStartMoment = moment();\n\n    // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n    const mean = d.glob_stats.mean;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['zmin'] = d.zmin;\n    curve['zmax'] = d.zmax;\n    curve['xAxisKey'] = xAxisParam;\n    curve['yAxisKey'] = yAxisParam;\n    const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n        begin: postQueryStartMoment.format(),\n        finish: postQueryFinishMoment.format(),\n        duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n\n    // process the data returned by the query\n    const curveInfoParams = {\"curve\": curves, \"axisMap\": axisMap};\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataContourDiff = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.contourDiff;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    if (curvesLength !== 2) {\n        throw new Error(\"INFO:  There must be two added curves.\");\n    }\n    if (curves[0]['x-axis-parameter'] !== curves[1]['x-axis-parameter'] || curves[0]['y-axis-parameter'] !== curves[1]['y-axis-parameter']) {\n        throw new Error(\"INFO:  The x-axis-parameter and y-axis-parameter must be consistent across both curves.\");\n    }\n    var dataset = [];\n    var axisMap = Object.create(null);\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var label = curve['label'];\n        var xAxisParam = curve['x-axis-parameter'];\n        var yAxisParam = curve['y-axis-parameter'];\n        var xValClause = matsCollections.CurveParams.findOne({name: 'x-axis-parameter'}).optionsMap[xAxisParam];\n        var yValClause = matsCollections.CurveParams.findOne({name: 'y-axis-parameter'}).optionsMap[yAxisParam];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var validTimeClause = \"\";\n        var thresholdClause = \"\";\n        var forecastLengthClause = \"\";\n        var dateClause = \"\";\n        if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n            var forecastLength = curve['forecast-length'];\n            forecastLengthClause = \"and m0.fcst_len = \" + forecastLength;\n        }\n        if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n            var thresholdStr = curve['threshold'];\n            var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n            thresholdClause = \"and m0.trsh = \" + threshold;\n        }\n        if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n            var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n            }\n        }\n        if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && (xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date')) {\n            dateClause = \"m0.time-m0.fcst_len*3600\";\n        } else {\n            dateClause = \"m0.time\";\n        }\n\n        // for two contours it's faster to just take care of matching in the query\n        var matchModel = \"\";\n        var matchDates = \"\";\n        var matchThresholdClause = \"\";\n        var matchValidTimeClause = \"\";\n        var matchForecastLengthClause = \"\";\n        var matchClause = \"\";\n        if (matching) {\n            const otherCurveIndex = curveIndex === 0 ? 1 : 0;\n            const otherModel = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curves[otherCurveIndex]['data-source']][0];\n            const otherRegion = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === curves[otherCurveIndex]['region']);\n\n            matchModel = \", \" + otherModel + \"_\" + otherRegion + \" as a0\";\n            const matchDateClause = dateClause.split('m0').join('a0');\n            matchDates = \"and \" + matchDateClause + \" >= '\" + fromSecs + \"' and \" + matchDateClause + \" <= '\" + toSecs + \"'\";\n            matchClause = \"and m0.time = a0.time\";\n\n            if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n                var matchForecastLength = curves[otherCurveIndex]['forecast-length'];\n                matchForecastLengthClause = \"and a0.fcst_len = \" + matchForecastLength;\n            } else {\n                matchForecastLengthClause = \"and m0.fcst_len = a0.fcst_len\";\n            }\n            if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n                var matchThreshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === curves[otherCurveIndex]['threshold']);\n                matchThresholdClause = \"and a0.thresh = \" + matchThreshold;\n            } else {\n                matchThresholdClause = \"and m0.thresh = a0.thresh\";\n            }\n            if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n                var matchValidTimes = curves[otherCurveIndex]['valid-time'] === undefined ? [] : curves[otherCurveIndex]['valid-time'];\n                if (matchValidTimes.length > 0 && matchValidTimes !== matsTypes.InputTypes.unused) {\n                    matchValidTimeClause = \" and a0.time%(24*3600)/3600 IN(\" + matchValidTimes + \")\";\n                }\n            }\n        }\n\n        // For contours, this functions as the colorbar label.\n        curves[curveIndex]['unitKey'] = statisticOptionsMap[statisticSelect][1];\n\n        var d;\n        // this is a database driven curve, not a difference curve\n        // prepare the query from the above parameters\n        var statement = \"{{xValClause}} \" +\n            \"{{yValClause}} \" +\n            \"count(distinct {{dateClause}}) as N_times, \" +\n            \"min({{dateClause}}) as min_secs, \" +\n            \"max({{dateClause}}) as max_secs, \" +\n            \"{{statistic}} \" +\n            \"from {{data_source}} as m0{{matchModel}} \" +\n            \"where 1=1 \" +\n            \"{{matchClause}} \" +\n            \"and {{dateClause}} >= '{{fromSecs}}' \" +\n            \"and {{dateClause}} <= '{{toSecs}}' \" +\n            \"{{matchDates}} \" +\n            \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n            \"{{thresholdClause}} \" +\n            \"{{matchThresholdClause}} \" +\n            \"{{validTimeClause}} \" +\n            \"{{matchValidTimeClause}} \" +\n            \"{{forecastLengthClause}} \" +\n            \"{{matchForecastLengthClause}} \" +\n            \"group by xVal,yVal \" +\n            \"order by xVal,yVal\" +\n            \";\";\n\n        statement = statement.replace('{{xValClause}}', xValClause);\n        statement = statement.replace('{{yValClause}}', yValClause);\n        statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n        statement = statement.replace('{{matchModel}}', matchModel);\n        statement = statement.replace('{{statistic}}', statistic);\n        statement = statement.replace('{{threshold}}', threshold);\n        statement = statement.replace('{{fromSecs}}', fromSecs);\n        statement = statement.replace('{{toSecs}}', toSecs);\n        statement = statement.replace('{{matchDates}}', matchDates);\n        statement = statement.replace('{{matchClause}}', matchClause);\n        statement = statement.replace('{{thresholdClause}}', thresholdClause);\n        statement = statement.replace('{{matchThresholdClause}}', matchThresholdClause);\n        statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n        statement = statement.replace('{{matchForecastLengthClause}}', matchForecastLengthClause);\n        statement = statement.replace('{{validTimeClause}}', validTimeClause);\n        statement = statement.replace('{{matchValidTimeClause}}', matchValidTimeClause);\n        statement = statement.split('{{dateClause}}').join(dateClause);\n        dataRequests[curve.label] = statement;\n\n        // math is done on forecastLength later on -- set all analyses to 0\n        if (forecastLength === \"-99\") {\n            forecastLength = \"0\";\n        }\n\n        var queryResult;\n        var startMoment = moment();\n        var finishMoment;\n        try {\n            // send the query statement to the query function\n            queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n            finishMoment = moment();\n            dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                begin: startMoment.format(),\n                finish: finishMoment.format(),\n                duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                recordCount: queryResult.data.xTextOutput.length\n            };\n            // get the data back from the query\n            d = queryResult.data;\n        } catch (e) {\n            // this is an error produced by a bug in the query function, not an error returned by the mysql database\n            e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n            throw new Error(e.message);\n        }\n        if (queryResult.error !== undefined && queryResult.error !== \"\") {\n            if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                // this is NOT an error just a no data condition\n                dataFoundForCurve = false;\n            } else {\n                // this is an error returned by the mysql database\n                error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                throw (new Error(error));\n            }\n        }\n\n        var postQueryStartMoment = moment();\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.glob_stats.mean;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['zmin'] = d.zmin;\n        curve['zmax'] = d.zmax;\n        curve['xAxisKey'] = xAxisParam;\n        curve['yAxisKey'] = yAxisParam;\n        const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        };\n    }\n\n    // turn the two contours into one difference contour\n    dataset = matsDataDiffUtils.getDataForDiffContour(dataset);\n    plotParams.curves = matsDataUtils.getDiffContourCurveParams(plotParams.curves);\n    curves = plotParams.curves;\n\n    // process the data returned by the query\n    const curveInfoParams = {\"curve\": curves, \"axisMap\": axisMap};\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataDailyModelCycle = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.dailyModelCycle;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var utcCycleStart = Number(curve['utc-cycle-start']);\n        utcCycleStarts[curveIndex] = utcCycleStart;\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select m0.time as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.time >= {{fromSecs}} \" +\n                \"and m0.time <= {{toSecs}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = {{threshold}} \" +\n                \"and m0.fcst_len < 24 \" +\n                \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN({{utcCycleStart}}) \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{utcCycleStart}}', utcCycleStart);\n\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataDieOff = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.dieoff;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var forecastLengthStr = curve['dieoff-type'];\n        var forecastLengthOptionsMap = matsCollections.CurveParams.findOne({name: 'dieoff-type'}, {optionsMap: 1})['optionsMap'];\n        var forecastLength = forecastLengthOptionsMap[forecastLengthStr][0];\n        var validTimes;\n        var validTimeClause = \"\";\n        var utcCycleStart;\n        var utcCycleStartClause = \"\";\n        var dateRangeClause = \"and m0.time >= \" + fromSecs + \" and m0.time <= \" + toSecs;\n        if (forecastLength === matsTypes.ForecastTypes.dieoff) {\n            validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n            if (validTimes.length !== 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \"and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n            }\n        } else if (forecastLength === matsTypes.ForecastTypes.utcCycle) {\n            utcCycleStart = Number(curve['utc-cycle-start']);\n            utcCycleStartClause = \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN(\" + utcCycleStart + \")\";\n        } else {\n            dateRangeClause = \"and (m0.time - m0.fcst_len*3600) = \" + fromSecs;\n        }\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"SELECT m0.fcst_len AS avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"{{dateRangeClause}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = {{threshold}} \" +\n                \"{{validTimeClause}} \" +\n                \"{{utcCycleStartClause}} \" +\n                \"group by avtime \" +\n                \"order by avtime;\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{dateRangeClause}}', dateRangeClause);\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n            statement = statement.replace('{{utcCycleStartClause}}', utcCycleStartClause);\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataHistogram = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const plotType = matsTypes.PlotTypes.histogram;\n    const hasLevels = false;\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    var alreadyMatched = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = [];\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var allReturnedSubStats = [];\n    var allReturnedSubSecs = [];\n    var axisMap = Object.create(null);\n\n    // process user bin customizations\n    const binParams = matsDataUtils.setHistogramParameters(plotParams);\n    const yAxisFormat = binParams.yAxisFormat;\n    const binNum = binParams.binNum;\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        dataFoundForCurve[curveIndex] = true;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = yAxisFormat;\n        if (yAxisFormat === 'Relative frequency') {\n            axisKey = axisKey + \" (x100)\"\n        }\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        curves[curveIndex].binNum = binNum; // stash the binNum to use it later for bar chart options\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select m0.time as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"{{validTimeClause}} \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = '{{threshold}}' \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            var validTimeClause = \" \";\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n            }\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n                allReturnedSubStats.push(d.subVals); // save returned data so that we can calculate histogram stats once all the queries are done\n                allReturnedSubSecs.push(d.subSecs);\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve[curveIndex] = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n        }\n    }\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"dataFoundForCurve\": dataFoundForCurve,\n        \"axisMap\": axisMap,\n        \"yAxisFormat\": yAxisFormat\n    };\n    const bookkeepingParams = {\n        \"alreadyMatched\": alreadyMatched,\n        \"dataRequests\": dataRequests,\n        \"totalProcessingStart\": totalProcessingStart\n    };\n    var result = matsDataProcessUtils.processDataHistogram(allReturnedSubStats, allReturnedSubSecs, [], dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataSeries = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.timeSeries;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        var averageStr = curve['average'];\n        var averageOptionsMap = matsCollections.CurveParams.findOne({name: 'average'}, {optionsMap: 1})['optionsMap'];\n        var average = averageOptionsMap[averageStr][0];\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select {{average}} as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"{{validTimeClause}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = '{{threshold}}' \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{average}}', average);\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            var validTimeClause = \" \";\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\"\n            }\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n\n            dataRequests[curve.label] = statement;\n\n            // math is done on forecastLength later on -- set all analyses to 0\n            if (forecastLength === \"-99\") {\n                forecastLength = \"0\";\n            }\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBTimeSeries(sumPool, statement, data_source, forecastLength, fromSecs, toSecs, averageStr, validTimes, hasLevels, false);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataThreshold = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.threshold;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"SELECT m0.trsh/100 as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"{{validTimeClause}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            var validTimeClause = \" \";\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\"\n            }\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};","/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataValidTime = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.validtime;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select floor(m0.time%(24*3600)/3600) as hr_of_day, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = '{{threshold}}' \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by hr_of_day \" +\n                \"order by hr_of_day\" +\n                \";\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};"]}}]