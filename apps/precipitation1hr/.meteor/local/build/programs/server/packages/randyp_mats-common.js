(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var global = Package.meteor.global;
var meteorEnv = Package.meteor.meteorEnv;
var SimpleSchema = Package['aldeed:simple-schema'].SimpleSchema;
var MongoObject = Package['aldeed:simple-schema'].MongoObject;
var ValidatedMethod = Package['mdg:validated-method'].ValidatedMethod;
var ECMAScript = Package.ecmascript.ECMAScript;
var meteorInstall = Package.modules.meteorInstall;
var ServiceConfiguration = Package['service-configuration'].ServiceConfiguration;
var Hooks = Package['differential:event-hooks'].Hooks;
var EventHooksMonitoringCollection = Package['differential:event-hooks'].EventHooksMonitoringCollection;
var Log = Package.logging.Log;
var Random = Package.random.Random;
var EJSON = Package.ejson.EJSON;
var Spacebars = Package.spacebars.Spacebars;
var check = Package.check.check;
var Match = Package.check.Match;
var Picker = Package['meteorhacks:picker'].Picker;
var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;
var Promise = Package.promise.Promise;

/* Package-scope variables */
var matsTypes, matsCollections, matsMethods, plotResultData, matsCurveUtils, matsGraphUtils, matsSelectUtils, si, matsDataUtils, matsDataQueryUtils, matsDataDiffUtils, data, matsDataMatchUtils, matsDataCurveOpsUtils, matsDataPlotOpsUtils, matsDataProcessUtils, databases, databasesStr, matsPlotSpecUtils, matsCache, regression, matsParamUtils, matsPlotUtils, matsMathUtils;

var require = meteorInstall({"node_modules":{"meteor":{"randyp:mats-common":{"server":{"main.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/server/main.js                                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("../imports/startup/server/index.js");
module.link("../imports/startup/both/index.js");
let ServiceConfiguration;
module.link("meteor/service-configuration", {
  ServiceConfiguration(v) {
    ServiceConfiguration = v;
  }

}, 0);

var setGoogleCred = function () {
  /*
   from developer console:
   console.developers.google.apis
   */
  if (Meteor.isServer) {
    var os = Npm.require('os');

    var hostname = os.hostname();
    var cid = "";
    var cSecret = "";
    var gid = "";
    var gSecret = "";
    var _id = "";
    var cred;

    try {
      cred = ServiceConfiguration.configurations.findOne({
        service: 'google'
      });

      if (cred) {
        cid = cred.clientId;
        cSecret = cred.secret;
        _id = cred._id;
      }
    } catch (ignore) {}

    switch (hostname.split('.')[0]) {
      case "mats":
        gid = "499180266722-d4rn615s4s8tenra4tdisbl1i34uvu82.apps.googleusercontent.com";
        gSecret = "U0QuFoFkMnZwNck1nJfPK1Uv";
        break;

      case "mats-dev":
        gid = "499180266722-m8qusll2n5sc57u0hdefans35noqkt13.apps.googleusercontent.com";
        gSecret = "Ra1xCSDnr-ZZX1wgyAHHSbIU";
        break;

      case "mats-int":
        gid = "499180266722-31eikjprn2lek2jmv8q31adhdbi5cc4b.apps.googleusercontent.com";
        gSecret = "WLaPaYq4MdU4nEUSh_Pw3MDJ";
        break;

      case "localhost":
        gid = "499180266722-b4j64bso7ncfick2cgku7iib516tkhsh.apps.googleusercontent.com";
        gSecret = "j4EZvOdAgOrDH_Lkg82uebpu";
        break;

      default:
        gid = "499180266722-mu5h3she61fgicuro1kjrlv0m4rd7brt.apps.googleusercontent.com";
        gSecret = "oVViBi9TgLrLPWt6ZTv7M95k";
        break;
    }

    if (gid != cid || gSecret != cSecret) {
      // reset gid and gSecret
      if (cred) {
        ServiceConfiguration.configurations.update(_id, {
          $set: {
            secret: gSecret,
            clientId: gid
          }
        });
      } else {
        ServiceConfiguration.configurations.insert({
          service: "google",
          loginStyle: "popup",
          secret: gSecret,
          clientId: gid
        });
      }
    }
  }
};

setGoogleCred();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"imports":{"startup":{"both":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/both/index.js                                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("./mats-collections.js");
module.link("./mats-types.js");
module.link("../api/matsMethods.js");
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"mats-types.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/both/mats-types.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */

/**
 * Created by pierce on 8/31/16.
 */
var DatabaseRoles = {
  MODEL_DATA: 'model_data',
  META_DATA: 'meta_data',
  SUMS_DATA: 'sums_data',
  SITE_DATA: 'site_data'
};
var AppTypes = {
  mats: 'mats',
  metexpress: 'metexpress',
  mats4met: 'mats4met'
};
var InputTypes = {
  textInput: 'textInput',
  select: 'select',
  selectOrderEnforced: 'selectOrderEnforced',
  numberSpinner: 'numberSpinner',
  dateRange: 'dateRange',
  radioGroup: 'radioGroup',
  checkBoxGroup: 'checkBoxGroup',
  resetButton: 'resetButton',
  controlButton: 'controlButton',
  element: 'element',
  selectMap: 'selectMap',
  custom: 'custom',
  unused: "unused",
  forecastSingleCycle: 'forecasts single cycle',
  forecastMultiCycle: 'forecasts multi cycle'
};
var PlotTypes = {
  timeSeries: "TimeSeries",
  profile: "Profile",
  dieoff: "DieOff",
  threshold: "Threshold",
  validtime: "ValidTime",
  dailyModelCycle: "DailyModelCycle",
  reliability: "Reliability",
  map: "Map",
  histogram: "Histogram",
  contour: "Contour",
  contourDiff: "ContourDiff",
  scatter2d: "Scatter2d"
};
var ForecastTypes = {
  dieoff: "dieoff",
  utcCycle: "utc cycle",
  singleCycle: "single cycle"
};
var PlotFormats = {
  none: "none",
  matching: "matching",
  pairwise: "pairwise",
  absolute: "absolute"
};
var PlotActions = {
  matched: "matched",
  unmatched: "unmatched"
};
var BestFits = {
  none: 'none',
  linear: 'linear',
  linearThroughOrigin: 'linearThroughOrigin',
  exponential: 'exponential',
  logarithmic: 'logarithmic',
  power: 'power'
};
var MatchFormats = {
  none: "none",
  time: "time",
  level: "level",
  site: "site"
};
var PlotAxisFilters = {
  none: "none",
  level: "level",
  site: "site"
};
var PlotView = {
  graph: "graph",
  textSeries: "text"
};
var ReservedWords = {
  Zero: "Zero",
  zero: "zero",
  ideal0: "ideal0",
  ideal1: "ideal1",
  ideal2: "ideal2",
  ideal3: "ideal3",
  ideal4: "ideal4",
  ideal5: "ideal5",
  ideal6: "ideal6",
  ideal7: "ideal7",
  ideal8: "ideal8",
  ideal9: "ideal9",
  perfectReliability: "Perfect Reliability",
  noSkill: "No Skill",
  blueCurveText: "blueCurveText",
  blackCurveText: "blackCurveText",
  redCurveText: "redCurveText"
};
var Messages = {
  NO_DATA_FOUND: "INFO:0 data records found"
}; //hide non-timeseries selectors at startup

var selectorsToHide = ['dieoff-type', 'utc-cycle-start', 'histogram-bin-controls', 'histogram-yaxis-controls', 'bin-number', 'bin-pivot', 'bin-start', 'bin-stride', 'bin-bounds', 'x-axis-parameter', 'y-axis-parameter'];
/*
Class for holding metaData records. These are stored in an array. An app can have multiple metadata databases and each database has a pool for connections.
These pools are global (although for future reference the access might be from this collection.). They are refenced in this script via the pool name.
This class enforces the types of the poolName (in case someone accidentally tries to store the whole pool object), and the database name and a list
of table names. The internal list can be appended. The getRecords returns the internal list.
 */

class MetaDataDBRecord {
  constructor(poolName, dbName, tables) {
    if (!typeof poolName === "string") {
      throw new Error("MetaDataDBRecord.constructor : poolName is not a string");
    }

    if (!typeof dbName === "string") {
      throw new Error("MetaDataDBRecord.constructor : dbName is not a string");
    }

    if (!tables instanceof Array) {
      throw new Error("MetaDataDBRecord.constructor : tables is not an array");
    }

    this._records = [];
    var record = {
      'pool': poolName,
      'name': dbName,
      'tables': tables
    };

    this._records.push(record);
  }

  addRecord(poolName, dbName, tables) {
    if (!typeof poolName === "string") {
      throw new Error("MetaDataDBRecord.constructor : poolName is not a string");
    }

    if (!typeof dbName === "string") {
      throw new Error("MetaDataDBRecord.constructor : dbName is not a string");
    }

    if (!tables instanceof Array) {
      throw new Error("MetaDataDBRecord.constructor : tables is not an array");
    }

    var record = {
      'pool': poolName,
      'name': dbName,
      'tables': tables
    };

    this._records.push(record);
  }

  getRecords() {
    return this._records;
  }

}

module.exportDefault(matsTypes = {
  InputTypes: InputTypes,
  PlotTypes: PlotTypes,
  PlotFormats: PlotFormats,
  PlotActions: PlotActions,
  BestFits: BestFits,
  MatchFormats: MatchFormats,
  PlotAxisFilters: PlotAxisFilters,
  PlotView: PlotView,
  Messages: Messages,
  ForecastTypes: ForecastTypes,
  ReservedWords: ReservedWords,
  selectorsToHide: selectorsToHide,
  MetaDataDBRecord: MetaDataDBRecord,
  AppTypes: AppTypes,
  DatabaseRoles: DatabaseRoles
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"mats-collections.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/both/mats-collections.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let Mongo;
module.link("meteor/mongo", {
  Mongo(v) {
    Mongo = v;
  }

}, 0);
var CurveParams = new Mongo.Collection("CurveParams");
var Scatter2dParams = new Mongo.Collection("Scatter2dParams");
var CurveTextPatterns = new Mongo.Collection("CurveTextPatterns");
var ScatterAxisTextPattern = new Mongo.Collection("ScatterAxisTextPattern");
var SavedCurveParams = new Mongo.Collection("SavedCurveParams");
var PlotParams = new Mongo.Collection("PlotParams");
var SavedPlotParams = new Mongo.Collection("SavedPlotParams");
var PlotGraphFunctions = new Mongo.Collection("PlotGraphFunctions");
var SavedPlotGraphFunctions = new Mongo.Collection("SavedPlotGraphFunctions");
var RegionsPerModel = new Mongo.Collection("RegionsPerModel");
var SitesPerModel = new Mongo.Collection("SitesPerModel");
var RegionDescriptions = new Mongo.Collection("RegionDescriptions");
var Models = new Mongo.Collection("Models");
var Instruments = new Mongo.Collection("Instruments");
var FcstLensPerModel = new Mongo.Collection("FcstLensPerModel");
var CurveSettings = new Mongo.Collection("CurveSettings");
var Settings = new Mongo.Collection("Settings");
var ColorScheme = new Mongo.Collection("ColorScheme");
var SentAddresses = new Mongo.Collection("SentAddresses");
var Authorization = new Mongo.Collection("Authorization");
var Roles = new Mongo.Collection("Roles");
var SavedRoles = new Mongo.Collection("SavedRoles");
var Databases = new Mongo.Collection("Databases");
var SavedDatabases = new Mongo.Collection("SavedDatabases");
var Credentials = new Mongo.Collection("Credentials");
var SavedCredentials = new Mongo.Collection("SavedCredentials");
var SiteMap = new Mongo.Collection("SiteMap");
var StationMap = new Mongo.Collection("StationMap");
var appName = new Mongo.Collection("appName");
module.exportDefault(matsCollections = {
  CurveParams: CurveParams,
  Scatter2dParams: Scatter2dParams,
  CurveTextPatterns: CurveTextPatterns,
  ScatterAxisTextPattern: ScatterAxisTextPattern,
  SavedCurveParams: SavedCurveParams,
  PlotParams: PlotParams,
  SavedPlotParams: SavedPlotParams,
  PlotGraphFunctions: PlotGraphFunctions,
  SavedPlotGraphFunctions: SavedPlotGraphFunctions,
  RegionsPerModel: RegionsPerModel,
  SitesPerModel: SitesPerModel,
  RegionDescriptions: RegionDescriptions,
  Models: Models,
  Instruments: Instruments,
  FcstLensPerModel: FcstLensPerModel,
  CurveSettings: CurveSettings,
  Settings: Settings,
  ColorScheme: ColorScheme,
  SentAddresses: SentAddresses,
  Authorization: Authorization,
  Roles: Roles,
  SavedRoles: SavedRoles,
  Databases: Databases,
  SavedDatabases: SavedDatabases,
  Credentials: Credentials,
  SavedCredentials: SavedCredentials,
  SiteMap: SiteMap,
  StationMap: StationMap,
  appName: appName
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"api":{"matsMethods.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/api/matsMethods.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let Meteor;
module.link("meteor/meteor", {
  Meteor(v) {
    Meteor = v;
  }

}, 0);
let ValidatedMethod;
module.link("meteor/mdg:validated-method", {
  ValidatedMethod(v) {
    ValidatedMethod = v;
  }

}, 1);
let SimpleSchema;
module.link("meteor/aldeed:simple-schema", {
  SimpleSchema(v) {
    SimpleSchema = v;
  }

}, 2);
let matsCache, matsCollections, matsDataQueryUtils, matsDataUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCache(v) {
    matsCache = v;
  },

  matsCollections(v) {
    matsCollections = v;
  },

  matsDataQueryUtils(v) {
    matsDataQueryUtils = v;
  },

  matsDataUtils(v) {
    matsDataUtils = v;
  },

  matsTypes(v) {
    matsTypes = v;
  }

}, 3);
let mysql;
module.link("meteor/pcel:mysql", {
  mysql(v) {
    mysql = v;
  }

}, 4);
let url;
module.link("url", {
  url(v) {
    url = v;
  }

}, 5);
let Mongo;
module.link("meteor/mongo", {
  Mongo(v) {
    Mongo = v;
  }

}, 6);
// PRIVATE
// local collection used to keep the table update times for refresh - won't ever be synchronized or persisted.
const metaDataTableUpdates = new Mongo.Collection(null);
const LayoutStoreCollection = new Mongo.Collection("LayoutStoreCollection"); // initialize collection used for pop-out window functionality

const DownSampleResults = new Mongo.Collection("DownSampleResults");
var MV_DIRS = {}; // Define routes for server

if (Meteor.isServer) {
  if (Meteor.settings.private !== undefined && Meteor.settings.private !== null) {
    const _MV_OUT = Meteor.settings.private.MV_OUTPUT;
    const _MV_HOME = Meteor.settings.private.MV_HOME;

    const _MV_LOGDIR = _MV_OUT + "/xml/";

    const _MV_ERRDIR = _MV_OUT + "/xml/";

    const _MV_DATADIR = _MV_OUT + "/data/";

    const _MV_SQLDIR = _MV_OUT + "/xml/"; // sql output goes with the xml output


    const _MV_XMLDIR = _MV_OUT + "/xml/";

    const _MV_SCRIPTSDIR = _MV_OUT + "/scripts/";

    const _MV_PLOTSSDIR = _MV_OUT + "/plots/";

    process.env.JAVA_HOME = Meteor.settings.private.JAVA_HOME;
    process.env.MV_HOME = Meteor.settings.private.MV_HOME;
    MV_DIRS = {
      LOGDIR: _MV_LOGDIR,
      ERRDIR: _MV_ERRDIR,
      DATADIR: _MV_DATADIR,
      SQLDIR: _MV_SQLDIR,
      XMLDIR: _MV_XMLDIR,
      SCRIPTSDIR: _MV_SCRIPTSDIR,
      PLOTSDIR: _MV_PLOTSSDIR,
      HOME: _MV_HOME
    };
  } // add indexes to result and axes collections


  DownSampleResults.rawCollection().createIndex({
    "createdAt": 1
  }, {
    expireAfterSeconds: 3600 * 8
  }); // 8 hour expiration

  LayoutStoreCollection.rawCollection().createIndex({
    "createdAt": 1
  }, {
    expireAfterSeconds: 900
  }); // 15 min expiration
  // set the default proxy prefix path to ""

  if (Meteor.settings.public != null && Meteor.settings.public.proxy_prefix_path == null) {
    Meteor.settings.public.proxy_prefix_path = "";
  }

  Picker.route('/_getCSV/:key', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/_getCSV/:key', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/app:/_getCSV/:key', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route('/CSV/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/CSV/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/CSV/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route('/_getJSON/:key', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/_getJSON/:key', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/app:/_getJSON/:key', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route('/JSON/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/JSON/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/JSON/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route('/clearCache', function (params, req, res, next) {
    Picker.middleware(_clearCache(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/clearCache', function (params, req, res, next) {
    Picker.middleware(_clearCache(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/clearCache', function (params, req, res, next) {
    Picker.middleware(_clearCache(params, req, res, next));
  });
  Picker.route('/refreshMetadata', function (params, req, res, next) {
    Picker.middleware(_refreshMetadataMWltData(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/refreshMetadata', function (params, req, res, next) {
    Picker.middleware(_refreshMetadataMWltData(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/refreshMetadata', function (params, req, res, next) {
    Picker.middleware(_refreshMetadataMWltData(params, req, res, next));
  }); // create picker routes for metviewer middleware static files

  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvdata/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetData(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvpoints1/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetPoints1(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvpoints2/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetPoints2(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvxml/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetXml(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvplot/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetPlot(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvscript/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetScript(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvsql/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetSql(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvlog/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetLog(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mverr/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetErr(params, req, res, next));
  });
} // private - used to see if the main page needs to update its selectors


const _checkMetaDataRefresh = function () {
  // This routine compares the current last modified time of the tables used for curveParameter metadata
  // with the last update time to determine if an update is necessary. We really only do this for Curveparams

  /*
      metaDataTableUpdates:
      {
          name: dataBaseName,
          tables: [tableName1, tableName2 ..],
          lastRefreshed : timestamp
      }
   */
  var refresh = false;
  const tableUpdates = metaDataTableUpdates.find({}).fetch();

  for (var tui = 0; tui < tableUpdates.length; tui++) {
    var id = tableUpdates[tui]._id;
    var poolName = tableUpdates[tui].pool;
    var dbName = tableUpdates[tui].name;
    var tableNames = tableUpdates[tui].tables;
    var lastRefreshed = tableUpdates[tui]['lastRefreshed'];
    var updatedEpoch = Number.MAX_VALUE;

    for (var ti = 0; ti < tableNames.length; ti++) {
      var tName = tableNames[ti];
      var rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(global[poolName], "SELECT UNIX_TIMESTAMP(UPDATE_TIME)" + "    FROM   information_schema.tables" + "    WHERE  TABLE_SCHEMA = '" + dbName + "'" + "    AND TABLE_NAME = '" + tName + "'");

      for (var i = 0; i < rows.length; i++) {
        try {
          updatedEpoch = rows[i]['UNIX_TIMESTAMP(UPDATE_TIME)'];
          break;
        } catch (e) {
          throw new Error("_checkMetaDataRefresh - cannot find last update time for database: " + dbName + " and table: " + tName + " ERROR:" + e.message);
        }

        if (updatedEpoch === Number.MAX_VALUE) {
          throw new Error("_checkMetaDataRefresh - cannot find last update time for database: " + dbName + " and table: " + tName);
        }
      }

      const lastRefreshedEpoch = moment(lastRefreshed).valueOf() / 1000;

      if (lastRefreshedEpoch < updatedEpoch) {
        refresh = true;
        console.log("Refreshing the metadata in the app selectors because table " + dbName + "." + tName + " was updated at " + moment.utc(updatedEpoch * 1000).format("YYYY-MM-DD HH:mm:ss") + " while the metadata was last refreshed at " + moment.utc(lastRefreshedEpoch * 1000).format("YYYY-MM-DD HH:mm:ss"));
        break;
      }
    }

    if (refresh === true) {
      // refresh the app metadata
      // app specific routines
      //const asrKeys = Object.keys(appSpecificResetRoutines);
      const asrKeys = appSpecificResetRoutines;

      for (var ai = 0; ai < asrKeys.length; ai++) {
        global.appSpecificResetRoutines[ai]();
      } // remember that we updated ALL the metadata tables just now


      metaDataTableUpdates.update({
        _id: id
      }, {
        $set: {
          lastRefreshed: moment().format()
        }
      });
    }
  }

  return true;
}; // private middleware for clearing the cache


const _clearCache = function (params, req, res, next) {
  if (Meteor.isServer) {
    matsCache.clear();
    res.end("<body><h1>clearCache Done!</h1></body>");
  }
}; // private middleware for _getCSV route


const _getCSV = function (params, req, res, next) {
  if (Meteor.isServer) {
    var stringify = require('csv-stringify');

    var csv = "";

    try {
      var result = _getFlattenedResultData(params.key, 0, -1000);

      var statArray = Object.values(result.stats);
      var dataArray = Object.values(result.data);
      var statResultArray = [];
      var dataResultArray = [];

      for (var si = 0; si < statArray.length; si++) {
        statResultArray.push(Object.keys(statArray[si])); // push the stat header for this curve(keys)

        statResultArray.push(statArray[si]['n'] === 0 ? [statArray[si].label] : Object.values(statArray[si])); // push the stats for this curve
      }

      for (var di = 0; di < dataArray.length; di++) {
        var dataSubArray = Object.values(dataArray[di]);
        var dataHeader = dataSubArray[0] === undefined ? statArray[di].label : Object.keys(dataSubArray[0]); //dataHeader[0] = 'label';

        dataHeader[0] = dataSubArray[0] === undefined ? "NO DATA" : Object.keys(dataSubArray[0]).filter(key => key.indexOf('Curve') != -1)[0];
        dataResultArray.push(dataHeader); // push this curve data header (keys)

        if (dataSubArray[0] === undefined) {
          continue;
        }

        for (var dsi = 0; dsi < dataSubArray.length; dsi++) {
          // push this curves data
          dataResultArray.push(Object.values(dataSubArray[dsi]));
        }
      }

      var fileName = "matsplot-" + moment.utc().format('YYYYMMDD-HH.mm.ss') + ".csv";
      res.setHeader('Content-disposition', 'attachment; filename=' + fileName);
      res.setHeader('Content-Type', 'attachment.ContentType');
      stringify(statResultArray, {
        header: true
      }, function (err, output) {
        if (err) {
          console.log("error in _getCSV:", err);
          res.write("error," + err.toLocaleString());
          res.end("<body><h1>_getCSV Error! " + err.toLocaleString() + "</h1></body>");
          return;
        }

        res.write(output);
        stringify(dataResultArray, {
          header: true
        }, function (err, output) {
          if (err) {
            console.log("error in _getCSV:", err);
            res.write("error," + err.toLocaleString());
            res.end("<body><h1>_getCSV Error! " + err.toLocaleString() + "</h1></body>");
            return;
          }

          res.write(output);
          res.end();
        });
        delete result;
        delete statResultArray;
        delete dataResultArray;
      });
    } catch (e) {
      console.log('error retrieving data: ', e);
      csv = "error," + e.toLocaleString();
      res.setHeader('Content-disposition', 'attachment; filename=matsplot.csv');
      res.setHeader('Content-Type', 'attachment.ContentType');
      res.end("<body><h1>_getCSV Error! " + csv + "</h1></body>");
    }
  }
}; // private middleware for _getJSON route


const _getJSON = function (params, req, res, next) {
  if (Meteor.isServer) {
    var flatJSON = "";

    try {
      var result = _getPagenatedData(params.key, 0, -1000);

      flatJSON = JSON.stringify(result);
    } catch (e) {
      console.log('error retrieving data: ', e);
      flatJSON = JSON.stringify({
        error: e
      });
      delete flatJSON.dsiRealPageIndex;
      delete flatJSON.dsiTextDirection;
    }

    res.setHeader('Content-Type', 'application/json');
    res.write(flatJSON);
    res.end();
    delete flatJSON;
    delete result;
  }
}; // private method for getting pagenated results and flattening them in order to be appropriate for text display.


const _getFlattenedResultData = function (rk, p, np) {
  if (Meteor.isServer) {
    var resp;

    try {
      var r = rk;
      var p = p;
      var np = np; // get the pagenated data

      var result = _getPagenatedData(r, p, np); // find the type


      var plotTypes = result.basis.plotParams.plotTypes;

      var plotType = _.invert(plotTypes)[true]; // extract data


      var data = result.data;
      var dsiRealPageIndex = result.dsiRealPageIndex;
      var dsiTextDirection = result.dsiTextDirection;

      switch (plotType) {
        case matsTypes.PlotTypes.timeSeries:
        case matsTypes.PlotTypes.dailyModelCycle:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          /*
          returnData is
          {
              stats: {
                          curve0: {label:someLabel, mean:someMean,sd:someSd....}
                          curve1: {label:someLabel, mean:someMean,sd:someSd....}
                          ...
                      }
              data: {
                          curve0: [
                                      {time:someTime, stat: someStat, sd: someSd,....},
                                      {time:someTime, stat: someStat, sd: someSd,....},
                                      ....
                                  ],
                          curve1: [
                                      {time:someTime, stat: someStat, sd: someSd,....},
                                      {time:someTime, stat: someStat, sd: someSd,....},
                                      ....
                                  ],
                                  ...
                    }
          }
           */

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            // if the curve label is a reserved word do not process the curve (its a zero or max curve)
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['mean'] = data[ci].glob_stats.d_mean;
            stats['standard deviation'] = data[ci].glob_stats.sd;
            stats['n'] = data[ci].glob_stats.n_good;
            stats['standard error'] = data[ci].glob_stats.stde_betsy;
            stats['lag1'] = data[ci].glob_stats.lag1;
            stats['minimum'] = data[ci].glob_stats.minVal;
            stats['maximum'] = data[ci].glob_stats.maxVal;
            returnData.stats[data[ci].label] = stats;
            var curveData = []; // map of maps

            for (var cdi = 0; cdi < data[ci].x.length; cdi++) {
              //for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + ' time'] = data[ci].x[cdi];
              curveDataElement['raw stat from query'] = data[ci].stats[cdi].raw_stat;
              curveDataElement['plotted stat'] = data[ci].y[cdi];
              curveDataElement['std dev'] = data[ci].stats[cdi].sd;
              curveDataElement['std error'] = data[ci].stats[cdi].stde_betsy;
              curveDataElement['lag1'] = data[ci].stats[cdi].lag1;
              curveDataElement['n'] = data[ci].stats[cdi].n_good;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.profile:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of map

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['mean'] = data[ci].glob_stats.d_mean;
            stats['standard deviation'] = data[ci].glob_stats.sd;
            stats['n'] = data[ci].glob_stats.n_good;
            stats['standard error'] = data[ci].glob_stats.stde_betsy;
            stats['lag1'] = data[ci].glob_stats.lag1;
            stats['minimum'] = data[ci].glob_stats.minVal;
            stats['maximum'] = data[ci].glob_stats.maxVal;
            returnData.stats[data[ci].label] = stats;
            var cdata = data[ci].data;
            var curveData = []; // array of maps

            for (var cdi = 0; cdi < data[ci].x.length; cdi++) {
              // for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + ' level'] = data[ci].y[cdi];
              curveDataElement['raw stat from query'] = data[ci].stats[cdi].raw_stat;
              curveDataElement['plotted stat'] = data[ci].x[cdi];
              curveDataElement['std dev'] = data[ci].stats[cdi].sd;
              curveDataElement['std error'] = data[ci].stats[cdi].stde_betsy;
              curveDataElement['lag1'] = data[ci].stats[cdi].lag1;
              curveDataElement['n'] = data[ci].stats[cdi].n_good;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.dieoff:
        case matsTypes.PlotTypes.threshold:
        case matsTypes.PlotTypes.validtime:
          var labelSuffix;

          switch (plotType) {
            case matsTypes.PlotTypes.dieoff:
              labelSuffix = " forecast lead time";
              break;

            case matsTypes.PlotTypes.validtime:
              labelSuffix = " hour of day";
              break;

            case matsTypes.PlotTypes.threshold:
              labelSuffix = " threshold (in)";
              break;
          }

          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['mean'] = data[ci].glob_stats.d_mean;
            stats['standard deviation'] = data[ci].glob_stats.sd;
            stats['n'] = data[ci].glob_stats.n_good;
            stats['minimum'] = data[ci].glob_stats.minVal;
            stats['maximum'] = data[ci].glob_stats.maxVal;
            returnData.stats[data[ci].label] = stats;
            var curveData = []; // map of maps

            for (var cdi = 0; cdi < data[ci].x.length; cdi++) {
              // for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + labelSuffix] = data[ci].x[cdi];
              curveDataElement['raw stat from query'] = data[ci].stats[cdi].raw_stat;
              curveDataElement['plotted stat'] = data[ci].y[cdi];
              curveDataElement['std dev'] = data[ci].stats[cdi].sd;
              curveDataElement['n'] = data[ci].stats[cdi].n_good;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.reliability:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of map

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['sample climo'] = data[ci].glob_stats.sample_climo;
            returnData.stats[data[ci].label] = stats;
            var cdata = data[ci].data;
            var curveData = []; // array of maps

            for (var cdi = 0; cdi < data[ci].y.length; cdi++) {
              // for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + ' probability bin'] = data[ci].stats[cdi].prob_bin;
              curveDataElement['hit rate'] = data[ci].stats[cdi].hit_rate;
              curveDataElement['oy'] = data[ci].stats[cdi].obs_y;
              curveDataElement['on'] = data[ci].stats[cdi].obs_n;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.map:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          var stats = {};
          stats['label'] = data[0].label;
          stats['total number of obs'] = data[0].stats.reduce(function (prev, curr) {
            return prev + curr.N_times;
          }, 0);
          stats['mean difference'] = matsDataUtils.average(data[0].queryVal);
          stats['standard deviation'] = matsDataUtils.stdev(data[0].queryVal);
          stats['minimum time'] = data[0].stats.reduce(function (prev, curr) {
            return prev < curr.min_time ? prev : curr.min_time;
          });
          stats['minimum time'] = moment.utc(stats['minimum time'] * 1000).format('YYYY-MM-DD HH:mm');
          stats['maximum time'] = data[0].stats.reduce(function (prev, curr) {
            return prev > curr.max_time ? prev : curr.max_time;
          });
          stats['maximum time'] = moment.utc(stats['maximum time'] * 1000).format('YYYY-MM-DD HH:mm');
          returnData.stats[data[0].label] = stats;
          var curveData = []; // map of maps

          for (var si = 0; si < data[0].siteName.length; si++) {
            var curveDataElement = {};
            curveDataElement['Site Name'] = data[0].siteName[si];
            curveDataElement['Number of Times'] = data[0].stats[si].N_times;
            curveDataElement['Start Date'] = moment.utc(data[0].stats[si].min_time * 1000).format('YYYY-MM-DD HH:mm');
            curveDataElement['End Date'] = moment.utc(data[0].stats[si].max_time * 1000).format('YYYY-MM-DD HH:mm');
            curveDataElement['Average Difference'] = data[0].queryVal[si];
            curveData.push(curveDataElement);
          }

          returnData.data[data[0].label] = curveData;
          break;

        case matsTypes.PlotTypes.histogram:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['mean'] = data[ci].glob_stats.glob_mean;
            stats['standard deviation'] = data[ci].glob_stats.glob_sd;
            stats['n'] = data[ci].glob_stats.glob_n;
            stats['minimum'] = data[ci].glob_stats.glob_min;
            stats['maximum'] = data[ci].glob_stats.glob_max;
            returnData.stats[data[ci].label] = stats;
            var curveData = []; // map of maps

            for (var cdi = 0; cdi < data[ci].x.length; cdi++) {
              // for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + ' bin range'] = data[ci].bin_stats[cdi]['binLabel'];
              curveDataElement['n'] = data[ci].bin_stats[cdi].bin_n;
              curveDataElement['bin rel freq'] = data[ci].bin_stats[cdi].bin_rf;
              curveDataElement['bin lower bound'] = data[ci].bin_stats[cdi].binLowBound;
              curveDataElement['bin upper bound'] = data[ci].bin_stats[cdi].binUpBound;
              curveDataElement['bin mean'] = data[ci].bin_stats[cdi].bin_mean;
              curveDataElement['bin std dev'] = data[ci].bin_stats[cdi].bin_sd;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.contour:
        case matsTypes.PlotTypes.contourDiff:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          var stats = {};
          stats['label'] = data[0].label;
          stats['total number of points'] = data[0].glob_stats.n;
          stats['mean stat'] = data[0].glob_stats.mean;
          stats['minimum time'] = data[0].glob_stats.minDate;
          stats['minimum time'] = moment.utc(stats['minimum time'] * 1000).format('YYYY-MM-DD HH:mm');
          stats['maximum time'] = data[0].glob_stats.maxDate;
          stats['maximum time'] = moment.utc(stats['maximum time'] * 1000).format('YYYY-MM-DD HH:mm');
          returnData.stats[data[0].label] = stats;
          var curveData = []; // map of maps

          for (var si = 0; si < data[0].xTextOutput.length; si++) {
            var curveDataElement = {};
            curveDataElement['xVal'] = data[0].xTextOutput[si];
            curveDataElement['yVal'] = data[0].yTextOutput[si];
            curveDataElement['stat'] = data[0].zTextOutput[si];
            curveDataElement['N'] = data[0].nTextOutput[si];
            curveDataElement['Start Date'] = moment.utc(data[0].minDateTextOutput[si] * 1000).format('YYYY-MM-DD HH:mm');
            curveDataElement['End Date'] = moment.utc(data[0].maxDateTextOutput[si] * 1000).format('YYYY-MM-DD HH:mm');
            curveData.push(curveDataElement);
          }

          returnData.data[data[0].label] = curveData;
          break;

        case matsTypes.PlotTypes.scatter2d:
          var returnData = {}; // returns a map of arrays of maps

          /*
          returnData = {
                          curve0: [
                                      {
                                      xval: number,
                                      yval: number,
                                      bestfit: number || none
                                      },
                                      {
                                      xval: number,
                                      yval: number,
                                      bestfit: number || none
                                      },
                                     .....
                                  ],
                           curve1: [
                                      {
                                      xval: number,
                                      yval: number,
                                      bestfit: number || none
                                      },
                                      {
                                      xval: number,
                                      yval: number,
                                      bestfit: number || none
                                      },
                                     .....
                                  ],
                                  ....
                      }
           */

          var firstBestFitIndex = -1;
          var bestFitIndexes = {};

          for (var ci = 0; ci < data.length; ci++) {
            if (ci == firstBestFitIndex) {
              break; // best fit curves are at the end so do not do further processing
            }

            var curveData = data[ci]; // look for a best fit curve - only have to look at curves with higher index than this one

            var bestFitIndex = -1;

            for (var cbi = ci + 1; cbi < data.length; cbi++) {
              if (data[cbi].label.indexOf(curveData.label) !== -1 && data[cbi].label.indexOf("-best fit") != -1) {
                bestFitIndexes[ci] = cbi;

                if (firstBestFitIndex == -1) {
                  firstBestFitIndex = cbi;
                }

                break;
              }
            }

            var curveTextData = [];

            for (var cdi = 0; cdi < curveData.data.length; cdi++) {
              var element = {};
              element['xAxis'] = curveData.data[cdi][0];
              element['yAxis'] = curveData.data[cdi][1];

              if (bestFitIndexes[ci] === undefined) {
                element['best fit'] = "none;";
              } else {
                element['best fit'] = data[bestFitIndexes[ci]].data[cdi][1];
              }

              curveTextData.push(element);
            }

            returnData[curveData.label] = curveTextData;
          }

          break;

        default:
          return undefined;
      }

      returnData.dsiRealPageIndex = dsiRealPageIndex;
      returnData.dsiTextDirection = dsiTextDirection;
      return returnData;
    } catch (error) {
      throw new Meteor.Error("Error in _getFlattenedResultData function: " + error.message);
    }
  }
}; // private method for getting pagenated data
// a newPageIndex of -1000 means get all the data (used for export)
// a newPageIndex of -2000 means get just the last page


const _getPagenatedData = function (rky, p, np) {
  if (Meteor.isServer) {
    var key = rky;
    var myPageIndex = p;
    var newPageIndex = np;
    var ret;
    var rawReturn;

    try {
      var result = matsCache.getResult(key);
      rawReturn = result === undefined ? undefined : result.result; // getResult structure is {key:something, result:resultObject}
    } catch (e) {
      console.log("_getPagenatedData: Error - ", e);
      return undefined;
    }

    ret = rawReturn === undefined ? undefined : JSON.parse(JSON.stringify(rawReturn));
    var start;
    var end;
    var direction = 1;

    if (newPageIndex === -1000) {
      // all the data
      start = 0;
      end = Number.MAX_VALUE;
    } else if (newPageIndex === -2000) {
      // just the last page
      start = -2000;
      direction = -1;
    } else if (myPageIndex <= newPageIndex) {
      // proceed forward
      start = (newPageIndex - 1) * 100;
      end = newPageIndex * 100;
    } else {
      // move back
      direction = -1;
      start = newPageIndex * 100;
      end = (newPageIndex + 1) * 100;
    }

    var dsiStart;
    var dsiEnd;

    for (var csi = 0; csi < ret.data.length; csi++) {
      if (ret.data[csi].x == null || ret.data[csi].x.length <= 100) {
        continue; // don't bother pagenating datasets less than or equal to a page - ret is rawReturn
      }

      dsiStart = start;
      dsiEnd = end;

      if (dsiStart > ret.data[csi].x.length || dsiStart === -2000) {
        // show the last page if we either requested it specifically or are trying to navigate past it
        dsiStart = Math.floor(rawReturn.data[csi].x.length / 100) * 100;
        dsiEnd = rawReturn.data[csi].x.length;

        if (dsiEnd === dsiStart) {
          // make sure the last page isn't empty--if rawReturn.data[csi].data.length/100 produces a whole number,
          // dsiStart and dsiEnd would be the same. This makes sure that the last full page is indeed the last page, without a phantom empty page afterwards
          dsiStart = dsiEnd - 100;
        }
      }

      if (dsiStart < 0) {
        // show the first page if we are trying to navigate before it
        dsiStart = 0;
        dsiEnd = 100;
      }

      if (dsiEnd < dsiStart) {
        // make sure that the end is after the start
        dsiEnd = dsiStart + 100;
      }

      if (dsiEnd > ret.data[csi].x.length) {
        // make sure we don't request past the end -- if results are one page, this should convert the
        // start and end from 0 and 100 to 0 and whatever the end is.
        dsiEnd = ret.data[csi].x.length;
      }

      ret.data[csi].x = rawReturn.data[csi].x.slice(dsiStart, dsiEnd);
      ret.data[csi].y = rawReturn.data[csi].y.slice(dsiStart, dsiEnd);
      ret.data[csi].stats = rawReturn.data[csi].stats.slice(dsiStart, dsiEnd);
      ret.data[csi].glob_stats = rawReturn.data[csi].glob_stats;
    }

    delete rawReturn;

    if (direction === 1) {
      ret.dsiRealPageIndex = Math.floor(dsiEnd / 100);
    } else {
      ret.dsiRealPageIndex = Math.floor(dsiStart / 100);
    }

    ret.dsiTextDirection = direction;
    return ret;
  }
}; //private middleware for getting metviewer data file


const _mvGetData = function (params, req, res, next) {
  const fse = require("fs-extra");

  const filePath = MV_DIRS.DATADIR;
  const baseName = params.key + ".data";
  const fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting data file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer points1 file


const _mvGetPoints1 = function (params, req, res, next) {
  const fse = require("fs-extra");

  const filePath = MV_DIRS.DATADIR;
  const baseName = params.key + ".points1";
  const fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting data file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer points1 file


const _mvGetPoints2 = function (params, req, res, next) {
  const fse = require("fs-extra");

  const filePath = MV_DIRS.DATADIR;
  const baseName = params.key + ".points2";
  const fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting data file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer xml file


const _mvGetXml = function (params, req, res, next) {
  const fse = require("fs-extra");

  const filePath = MV_DIRS.XMLDIR;
  const baseName = params.key + ".xml";
  const fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting xml file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer plot file


const _mvGetPlot = function (params, req, res, next) {
  const fse = require("fs-extra");

  const filePath = MV_DIRS.PLOTSDIR;
  const baseName = params.key + ".png";
  const fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'image/png');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'application/txt');
    res.write("Error Error getting plot file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer script file


const _mvGetScript = function (params, req, res, next) {
  const fse = require("fs-extra");

  const filePath = MV_DIRS.SCRIPTSDIR;
  const baseName = params.key + ".R";
  const fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting script file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer sql file


const _mvGetSql = function (params, req, res, next) {
  const fse = require("fs-extra");

  const filePath = MV_DIRS.SQLDIR;
  const baseName = params.key + ".sql";
  const fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/sql');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting sql file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer log file


const _mvGetLog = function (params, req, res, next) {
  const fse = require("fs-extra");

  const filePath = MV_DIRS.LOGDIR;
  const baseName = params.key + ".log";
  const fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting log file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer err file


const _mvGetErr = function (params, req, res, next) {
  const fse = require("fs-extra");

  const filePath = MV_DIRS.ERRDIR;
  const baseName = params.key + ".err";
  const fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        res.setHeader('Content-Type', 'text/plain');
        res.write("Error Error getting err file :" + baseName);
        res.end();
      } else {
        res.end(data); // Send the file data to the browser.
      }
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting plot file :" + baseName);
    res.end();
  }
}; // private define a middleware for refreshing the metadata


const _refreshMetadataMWltData = function (params, req, res, next) {
  if (Meteor.isServer) {
    _checkMetaDataRefresh();

    res.end("<body><h1>refreshMetadata Done!</h1></body>");
  }
}; // private save the result from the query into mongo and downsample if that result's size is greater than 1Mb


const _saveResultData = function (result) {
  if (Meteor.isServer) {
    var sizeof = require('object-sizeof');

    var hash = require('object-hash');

    var key = hash(result.basis.plotParams);
    var threshold = 1000000;
    var ret = {};

    try {
      var dSize = sizeof(result.data); //console.log("result.basis.data size is ", dSize);
      // TimeSeries and DailyModelCycle are the only plot types that require downSampling

      if (dSize > threshold && (result.basis.plotParams.plotTypes.TimeSeries || result.basis.plotParams.plotTypes.DailyModelCycle)) {
        // greater than threshold need to downsample
        // downsample and save it in DownSampleResult
        console.log("DownSampling");

        var downsampler = require("downsample-lttb");

        var totalPoints = 0;

        for (var di = 0; di < result.data.length; di++) {
          totalPoints += result.data[di].x_epoch.length;
        }

        var allowedNumberOfPoints = threshold / dSize * totalPoints;
        var downSampleResult = result === undefined ? undefined : JSON.parse(JSON.stringify(result));

        for (var ci = 0; ci < result.data.length; ci++) {
          var dsData = {};
          var xyDataset = result.data[ci].x_epoch.map(function (d, index) {
            return [result.data[ci].x_epoch[index], result.data[ci].y[index]];
          });
          var ratioTotalPoints = xyDataset.length / totalPoints;
          var myAllowedPoints = Math.round(ratioTotalPoints * allowedNumberOfPoints); // downsample the array

          var downsampledSeries;

          if (myAllowedPoints < xyDataset.length && xyDataset.length > 2) {
            downsampledSeries = downsampler.processData(xyDataset, myAllowedPoints); // replace the y attributes (tooltips etc.) with the y attributes from the nearest x

            var originalIndex = 0; // skip through the original dataset capturing each downSampled data point

            var arrayKeys = [];
            var nonArrayKeys = [];
            var keys = Object.keys(result.data[ci]);

            for (var ki = 0; ki < keys.length; ki++) {
              if (keys[ki] !== 'x_epoch') {
                if (Array.isArray(result.data[ci][keys[ki]])) {
                  arrayKeys.push(keys[ki]);
                  dsData[keys[ki]] = [];
                } else {
                  nonArrayKeys.push(keys[ki]);
                }
              }
            } // We only ever downsample series plots - never profiles and series plots only ever have error_y arrays.
            // This is a little hacky but what is happening is we putting error_y.array on the arrayKeys list so that it gets its
            // downsampled equivalent values.


            for (ki = 0; ki < nonArrayKeys.length; ki++) {
              dsData[nonArrayKeys[ki]] = result.data[ci][nonArrayKeys[ki]];
            } // remove the original error_y array data.


            dsData['error_y'].array = [];

            for (var dsi = 0; dsi < downsampledSeries.length; dsi++) {
              while (originalIndex < result.data[ci].x_epoch.length && result.data[ci].x_epoch[originalIndex] < downsampledSeries[dsi][0]) {
                originalIndex++;
              } // capture the stuff related to this downSampled data point (downSampled data points are always a subset of original data points)


              for (ki = 0; ki < arrayKeys.length; ki++) {
                dsData[arrayKeys[ki]][dsi] = result.data[ci][arrayKeys[ki]][originalIndex];
              }

              dsData['error_y']['array'][dsi] = result.data[ci]['error_y']['array'][originalIndex];
            } // add downsampled annotation to curve options


            downSampleResult[ci] = dsData;
            downSampleResult[ci].annotation += "   **DOWNSAMPLED**";
          } else {
            downSampleResult[ci] = result.data[ci];
          }

          downSampleResult.data[ci] = downSampleResult[ci];
        }

        DownSampleResults.rawCollection().insert({
          "createdAt": new Date(),
          key: key,
          result: downSampleResult
        }); // createdAt ensures expiration set in mats-collections

        ret = {
          key: key,
          result: downSampleResult
        };
      } else {
        ret = {
          key: key,
          result: result
        };
      } // save original dataset in the matsCache


      if (result.basis.plotParams.plotTypes.TimeSeries || result.basis.plotParams.plotTypes.DailyModelCycle) {
        for (var ci = 0; ci < result.data.length; ci++) {
          delete result.data[ci]['x_epoch']; // we only needed this as an index for downsampling
        }
      }

      matsCache.storeResult(key, {
        key: key,
        result: result
      }); // lifespan is handled by lowDb (internally) in matscache
    } catch (error) {
      if (error.toLocaleString().indexOf("larger than the maximum size") != -1) {
        throw new Meteor.Error(+": Requesting too much data... try averaging");
      }
    }

    return ret;
  }
}; // PUBLIC METHODS
//administration tools


const addSentAddress = new ValidatedMethod({
  name: 'matsMethods.addSentAddress',
  validate: new SimpleSchema({
    toAddress: {
      type: String
    }
  }).validator(),

  run(toAddress) {
    if (!Meteor.userId()) {
      throw new Meteor.Error(401, "not-logged-in");
    }

    matsCollections.SentAddresses.upsert({
      address: toAddress
    }, {
      address: toAddress,
      userId: Meteor.userId()
    });
    return false;
  }

}); //  administation tool

const applyAuthorization = new ValidatedMethod({
  name: 'matsMethods.applyAuthorization',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),

  run(settings) {
    if (Meteor.isServer) {
      var roles;
      var roleName;
      var authorization;
      var userRoleName = settings.userRoleName;
      var userRoleDescription = settings.userRoleDescription;
      var authorizationRole = settings.authorizationRole;
      var newUserEmail = settings.newUserEmail;
      var existingUserEmail = settings.existingUserEmail;

      if (authorizationRole) {
        // existing role - the role roleName - no need to verify as the selection list came from the database
        roleName = authorizationRole;
      } else if (userRoleName && userRoleDescription) {
        // possible new role - see if it happens to already exist
        var role = matsCollections.Roles.findOne({
          name: userRoleName
        });

        if (role === undefined) {
          // need to add new role using description
          matsCollections.Roles.upsert({
            name: userRoleName
          }, {
            $set: {
              description: userRoleDescription
            }
          });
          roleName = userRoleName;
        } else {
          // see if the description matches...
          roleName = role.name;
          var description = role.description;

          if (description != userRoleDescription) {
            // have to update the description
            matsCollections.Roles.upsert({
              name: userRoleName
            }, {
              $set: {
                description: userRoleDescription
              }
            });
          }
        }
      } // now we have a role roleName - now we need an email


      if (existingUserEmail) {
        // existing user -  no need to verify as the selection list came from the database
        // see if it already has the role
        authorization = matsCollections.Authorization.findOne({
          email: existingUserEmail
        });
        roles = authorization.roles;

        if (roles.indexOf(roleName) == -1) {
          // have to add the role
          if (roleName) {
            roles.push(roleName);
          }

          matsCollections.Authorization.upsert({
            email: existingUserEmail
          }, {
            $set: {
              roles: roles
            }
          });
        }
      } else if (newUserEmail) {
        // possible new authorization - see if it happens to exist
        authorization = matsCollections.Authorization.findOne({
          email: newUserEmail
        });

        if (authorization !== undefined) {
          // authorization exists - add role to roles if necessary
          roles = authorization.roles;

          if (roles.indexOf(roleName) == -1) {
            // have to add the role
            if (roleName) {
              roles.push(roleName);
            }

            matsCollections.Authorization.upsert({
              email: existingUserEmail
            }, {
              $set: {
                roles: roles
              }
            });
          }
        } else {
          // need a new authorization
          roles = [];

          if (roleName) {
            roles.push(roleName);
          }

          if (newUserEmail) {
            matsCollections.Authorization.upsert({
              email: newUserEmail
            }, {
              $set: {
                roles: roles
              }
            });
          }
        }
      }

      return false;
    }
  }

}); // database controls

const applyDatabaseSettings = new ValidatedMethod({
  name: 'matsMethods.applyDatabaseSettings',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),

  run(settings) {
    if (Meteor.isServer) {
      if (settings.name) {
        matsCollections.Databases.upsert({
          name: settings.name
        }, {
          $set: {
            name: settings.name,
            role: settings.role,
            status: settings.status,
            host: settings.host,
            database: settings.database,
            user: settings.user,
            password: settings.password
          }
        });
      }

      return false;
    }
  }

}); //administration tools

const deleteSettings = new ValidatedMethod({
  name: 'matsMethods.deleteSettings',
  validate: new SimpleSchema({
    name: {
      type: String
    }
  }).validator(),

  run(params) {
    if (!Meteor.userId()) {
      throw new Meteor.Error("not-logged-in");
    }

    if (Meteor.isServer) {
      matsCollections.CurveSettings.remove({
        name: params.name
      });
    }
  }

}); //administration tools

const emailImage = new ValidatedMethod({
  name: 'matsMethods.emailImage',
  validate: new SimpleSchema({
    imageStr: {
      type: String
    },
    toAddress: {
      type: String
    },
    subject: {
      type: String
    }
  }).validator(),

  run(params) {
    var imageStr = params.imageStr;
    var toAddress = params.toAddress;
    var subject = params.subject;

    if (!Meteor.userId()) {
      throw new Meteor.Error(401, "not-logged-in");
    }

    var fromAddress = Meteor.user().services.google.email; // these come from google - see
    // http://masashi-k.blogspot.fr/2013/06/sending-mail-with-gmail-using-xoauth2.html
    //http://stackoverflow.com/questions/24098461/nodemailer-gmail-what-exactly-is-a-refresh-token-and-how-do-i-get-one/24123550
    // the gmail account for the credentials is mats.mail.daemon@gmail.com - pwd mats2015!
    //var clientId = "339389735380-382sf11aicmgdgn7e72p4end5gnm9sad.apps.googleusercontent.com";
    //var clientSecret = "7CfNN-tRl5QAL595JTW2TkRl";
    //var refresh_token = "1/PDql7FR01N2gmq5NiTfnrT-OlCYC3U67KJYYDNPeGnA";

    var credentials = matsCollections.Credentials.findOne({
      name: "oauth_google"
    }, {
      clientId: 1,
      clientSecret: 1,
      refresh_token: 1
    });
    var clientId = credentials.clientId;
    var clientSecret = credentials.clientSecret;
    var refresh_token = credentials.refresh_token;
    var smtpTransporter;

    try {
      smtpTransporter = Nodemailer.createTransport("SMTP", {
        service: "Gmail",
        auth: {
          XOAuth2: {
            user: "mats.gsd@noaa.gov",
            clientId: clientId,
            clientSecret: clientSecret,
            refreshToken: refresh_token
          }
        }
      });
    } catch (e) {
      throw new Meteor.Error(401, "Transport error " + e.message());
    }

    try {
      var mailOptions = {
        sender: fromAddress,
        replyTo: fromAddress,
        from: fromAddress,
        to: toAddress,
        subject: subject,
        attachments: [{
          filename: "graph.png",
          contents: new Buffer(imageStr.split("base64,")[1], "base64")
        }]
      };
      smtpTransporter.sendMail(mailOptions, function (error, response) {
        if (error) {
          console.log("smtpTransporter error " + error + " from:" + fromAddress + " to:" + toAddress);
        } else {
          console.log(response + " from:" + fromAddress + " to:" + toAddress);
        }

        smtpTransporter.close();
      });
    } catch (e) {
      throw new Meteor.Error(401, "Send error " + e.message());
    }

    return false;
  }

}); // administation tool

const getAuthorizations = new ValidatedMethod({
  name: 'matsMethods.getAuthorizations',
  validate: new SimpleSchema({}).validator(),

  run() {
    var roles = [];

    if (Meteor.isServer) {
      var userEmail = Meteor.user().services.google.email.toLowerCase();
      roles = matsCollections.Authorization.findOne({
        email: userEmail
      }).roles;
    }

    return roles;
  }

}); // administration tool

const getDataFunctionFileList = new ValidatedMethod({
  name: 'matsMethods.getDataFunctionFileList',
  validate: new SimpleSchema({}).validator(),

  run() {
    if (Meteor.isServer) {}
  }

}); // retrieves the saved query results (or downsampled results)

const getGraphData = new ValidatedMethod({
  name: 'matsMethods.getGraphData',
  validate: new SimpleSchema({
    plotParams: {
      type: Object,
      blackbox: true
    },
    plotType: {
      type: String
    },
    expireKey: {
      type: Boolean
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      var plotGraphFunction = matsCollections.PlotGraphFunctions.findOne({
        plotType: params.plotType
      });
      var dataFunction = plotGraphFunction.dataFunction;
      var ret;

      try {
        var hash = require('object-hash');

        var key = hash(params.plotParams);

        if (process.env.NODE_ENV === "development" || params.expireKey) {
          matsCache.expireKey(key);
        }

        var results = matsCache.getResult(key);

        if (results === undefined) {
          // results aren't in the cache - need to process data routine
          const Future = require('fibers/future');

          var future = new Future();
          global[dataFunction](params.plotParams, function (results) {
            ret = _saveResultData(results);
            future["return"](ret);
          });
          return future.wait();
        } else {
          // results were already in the matsCache (same params and not yet expired)
          // are results in the downsampled collection?
          var dsResults = DownSampleResults.findOne({
            key: key
          }, {}, {
            disableOplog: true
          });

          if (dsResults !== undefined) {
            // results are in the mongo cache downsampled collection - returned the downsampled graph data
            ret = dsResults; // update the expire time in the downsampled collection - this requires a new Date

            DownSampleResults.rawCollection().update({
              key: key
            }, {
              $set: {
                "createdAt": new Date()
              }
            });
          } else {
            ret = results; // {key:someKey, result:resultObject}
            // refresh expire time. The only way to perform a refresh on matsCache is to re-save the result.

            matsCache.storeResult(results.key, results);
          }

          var sizeof = require('object-sizeof');

          console.log("result.data size is ", sizeof(results));
          return ret;
        }
      } catch (dataFunctionError) {
        if (dataFunctionError.toLocaleString().indexOf("INFO:") !== -1) {
          throw new Meteor.Error(dataFunctionError.message);
        } else {
          throw new Meteor.Error("Error in getGraphData function:" + dataFunction + " : " + dataFunctionError.message);
        }
      }

      return undefined; // probably won't get here
    }
  }

}); // retrieves the saved query results (or downsampled results) for a specific key

const getGraphDataByKey = new ValidatedMethod({
  name: 'matsMethods.getGraphDataByKey',
  validate: new SimpleSchema({
    resultKey: {
      type: String
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      var ret;
      var key = params.resultKey;

      try {
        var dsResults = DownSampleResults.findOne({
          key: key
        }, {}, {
          disableOplog: true
        });

        if (dsResults !== undefined) {
          ret = dsResults;
        } else {
          ret = matsCache.getResult(key); // {key:someKey, result:resultObject}
        }

        var sizeof = require('object-sizeof');

        console.log("getGraphDataByKey results size is ", sizeof(dsResults));
        return ret;
      } catch (error) {
        throw new Meteor.Error("Error in getGraphDataByKey function:" + key + " : " + error.message);
      }

      return undefined;
    }
  }

}); // administration tool

const getGraphFunctionFileList = new ValidatedMethod({
  name: 'matsMethods.getGraphFunctionFileList',
  validate: new SimpleSchema({}).validator(),

  run() {
    if (Meteor.isServer) {}
  }

});
const getLayout = new ValidatedMethod({
  name: 'matsMethods.getLayout',
  validate: new SimpleSchema({
    resultKey: {
      type: String
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      var ret;
      var key = params.resultKey;

      try {
        ret = LayoutStoreCollection.rawCollection().findOne({
          key: key
        });
        return ret;
      } catch (error) {
        throw new Meteor.Error("Error in getLayout function:" + key + " : " + error.message);
      }

      return undefined;
    }
  }

}); // retrieves the saved artifacts (file urls) that were generated by nvBatch for a specific key

const getMvArtifactsByKey = new ValidatedMethod({
  name: 'matsMethods.getMvArtifactsByKey',
  validate: new SimpleSchema({
    key: {
      type: String
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      var ret;
      var key = params.key;

      try {
        ret = matsCache.getResult(key); // {key:someKey, result:resultObject}

        return ret;
      } catch (error) {
        throw new Meteor.Error("Error in getMvArtifactsByKey function:" + key + " : " + error.message);
      }

      return undefined;
    }
  }

});
/*
getPlotResult is used by the graph/text_*_output templates which are used to display textual results.
Because the data isn't being rendered graphically this data is always full size, i.e. NOT downsampled.
That is why it only finds it in the Result file cache, never the DownSampleResult collection.

Because the dataset can be so large ... e.g. megabytes the data retrieval is pagenated. The index is
applied to the underlying datasets.The data gets stripped down and flattened to only contain the data neccesary for text presentation.
A new page index of -1000 means get all the data i.e. no pagenation.
 */

const getPlotResult = new ValidatedMethod({
  name: 'matsMethods.getPlotResult',
  validate: new SimpleSchema({
    resultKey: {
      type: String
    },
    pageIndex: {
      type: Number
    },
    newPageIndex: {
      type: Number
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      var rKey = params.resultKey;
      var pi = params.pageIndex;
      var npi = params.newPageIndex;
      var ret = {};

      try {
        ret = _getFlattenedResultData(rKey, pi, npi);
      } catch (e) {
        console.log(e);
      }

      return ret;
    }
  }

});
const getReleaseNotes = new ValidatedMethod({
  name: 'matsMethods.getReleaseNotes',
  validate: new SimpleSchema({}).validator(),

  run() {
    //     return Assets.getText('public/MATSReleaseNotes.html');
    // }
    if (Meteor.isServer) {
      var future = require('fibers/future');

      var fse = require('fs-extra');

      var dFuture = new future();
      var fData;
      console.log(process.env.PWD);
      var file;

      if (process.env.NODE_ENV === "development") {
        file = process.env.PWD + "/../../meteor_packages/mats-common/public/MATSReleaseNotes.html";
      } else {
        file = process.env.PWD + "/programs/server/assets/packages/randyp_mats-common/public/MATSReleaseNotes.html";
      }

      try {
        fse.readFile(file, 'utf8', function (err, data) {
          if (err) {
            fData = err.message;
            dFuture["return"]();
          } else {
            fData = data;
            dFuture["return"]();
          }
        });
      } catch (e) {
        fData = e.message;
        dFuture["return"]();
      }

      dFuture.wait();
      return fData;
    }
  }

}); // administration tool

const getUserAddress = new ValidatedMethod({
  name: 'matsMethods.getUserAddress',
  validate: new SimpleSchema({}).validator(),

  run() {
    if (Meteor.isServer) {
      return Meteor.user().services.google.email.toLowerCase();
    }
  }

}); // app utility

const insertColor = new ValidatedMethod({
  name: 'matsMethods.insertColor',
  validate: new SimpleSchema({
    newColor: {
      type: String
    },
    insertAfterIndex: {
      type: Number
    }
  }).validator(),

  run(params) {
    if (params.newColor == "rgb(255,255,255)") {
      return false;
    }

    var colorScheme = matsCollections.ColorScheme.findOne({});
    colorScheme.colors.splice(params.insertAfterIndex, 0, newColor);
    matsCollections.update({}, colorScheme);
    return false;
  }

}); // checks to see if the mv artifacts are cached (based on plotspec hash) if not execs an mvbatch and caches the results

const mvBatch = new ValidatedMethod({
  name: 'matsMethods.mvBatch',
  validate: new SimpleSchema({
    plotParams: {
      type: Object,
      blackbox: true
    },
    plotType: {
      type: String
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      var mvbatch = MV_DIRS.HOME + "/bin/mv_batch.sh";
      var plotGraphFunction = matsCollections.PlotGraphFunctions.findOne({
        plotType: params.plotType
      });
      var plotSpecFunction = plotGraphFunction.plotSpecFunction;
      var ret;
      const appName = matsCollections.appName.findOne({}).app;

      const fse = require('fs-extra'); // generate the key from the params


      const hash = require('object-hash');

      const key = hash(params.plotParams); // generate the server router (Picker) urls according to the hash key.

      var artifacts = {};

      if (process.env.NODE_ENV === "development") {
        artifacts = {
          png: appName + "/mvplot/" + key,
          xml: appName + "/mvxml/" + key,
          sql: appName + "/mvsql/" + key,
          log: appName + "/mvlog/" + key,
          err: appName + "/mverr/" + key,
          R: appName + "/mvscript/" + key,
          data: appName + "/mvdata/" + key,
          points1: appName + "/mvpoints1/" + key,
          points2: appName + "/mvpoints2/" + key
        };
      } else {
        // in production the appName is already at the end of the location.href
        // - which is used to form a url for retrieving the artifact
        artifacts = {
          png: "/mvplot/" + key,
          xml: "/mvxml/" + key,
          sql: "/mvsql/" + key,
          log: "/mvlog/" + key,
          err: "/mverr/" + key,
          R: "/mvscript/" + key,
          data: "/mvdata/" + key,
          points1: "/mvpoints1/" + key,
          points2: "/mvpoints2/" + key
        };
      } // generate the real file paths (these are not exposed to clients)


      const plotSpecFilePath = MV_DIRS.XMLDIR + key + ".xml";
      const pngFilePath = MV_DIRS.PLOTSDIR + key + ".png";
      const sqlFilePath = MV_DIRS.SQLDIR + key + ".sql";
      const logFilePath = MV_DIRS.LOGDIR + key + ".log";
      const errFilePath = MV_DIRS.ERRDIR + key + ".err";
      const scriptFilePath = MV_DIRS.SCRIPTSDIR + key + ".R";
      const dataFilePath = MV_DIRS.DATADIR + key + ".data";
      const points1Path = MV_DIRS.DATADIR + key + ".points1";
      const points2Path = MV_DIRS.DATADIR + key + ".points2"; // NOTE: the plotParams should include an mvPlot:true parameter.
      // This should have been set in the caller. This makes the mv plotSpec cache entry unique from a MATS plot

      if (params.plotParams.mvPlot !== true) {
        throw new Meteor.Error("Error in mvBatch: Not an mv plot request: no plotParams.mvPlot:true");
      }

      if (process.env.NODE_ENV === "development" || params.expireKey) {
        matsCache.expireKey(key); // in development just blow away the files too

        try {
          fse.unlinkSync(plotSpecFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(pngFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(sqlFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(logFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(errFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(scriptFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(dataFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(points1Path);
        } catch (ignore) {}

        try {
          fse.unlinkSync(points2Path);
        } catch (ignore) {}
      } // try to get the key from the cache


      var artifactPaths = matsCache.getResult(key);
      var filesExist = false;

      if (artifactPaths != null) {
        // artifact paths were already cached
        // do the files exist?
        // check for file existence
        var xmlSpecExists = fse.existsSync(plotSpecFilePath);
        var plotExists = fse.existsSync(pngFilePath);
        var scriptExists = fse.existsSync(scriptFilePath);
        var dataExists = fse.existsSync(dataFilePath);
        var sqlExists = fse.existsSync(sqlFilePath);
        var logExists = fse.existsSync(logFilePath);
        filesExist = xmlSpecExists && plotExists && scriptExists && dataExists && sqlExists && logExists;
      } // either the artifacts were cached but the files don't exist or the artifacts were not cached


      if (artifactPaths == null || filesExist === false) {
        // artifactPaths are not in the cache - or the files are not there - need to process plotSpecFunction routine
        // translate the plotparams to a plotSpec and use the key in the plotSpec reference
        global[plotSpecFunction](params.plotParams, key, function (err, plotSpec) {
          // callback
          if (err) {
            console.log(err, "plotspecFunction:", plotSpecFunction);
            throw new Meteor.Error(err + "plotspecFunction: " + plotSpecFunction);
          } else {
            // no error and we have a plot spec
            // see if the artifacts exist as files. They might have been run before and are still hanging around.
            // NOTE: the MV_OUTPUT aren't cached at all (i.e. no expiration) -
            // therefore the expiration of the MATS cache plotSpec and the actual artifacts is sloppy.
            // check for file existence
            var xmlSpecExists = fse.existsSync(plotSpecFilePath);
            var plotExists = fse.existsSync(pngFilePath);
            var scriptExists = fse.existsSync(scriptFilePath);
            var dataExists = fse.existsSync(dataFilePath);
            var sqlExists = fse.existsSync(sqlFilePath);
            var logExists = fse.existsSync(logFilePath);
            var filesExist = xmlSpecExists && plotExists && scriptExists && dataExists && sqlExists && logExists;

            if (!filesExist) {
              const mvBatchCmd = MV_DIRS.HOME + "/bin/mv_batch.sh " + ' ' + plotSpecFilePath;

              const cp = require('child_process'); // save the plotSpec


              fse.outputFileSync(plotSpecFilePath, plotSpec); // exec mv batch with this plotSpec - this should be synchronous

              cp.execSync(mvBatchCmd, (error, stdout, stderr) => {
                if (stderr) {
                  fse.outputFileSync(errFilePath, stderr, function (err) {
                    if (err) {
                      console.log("Error:couldn't write error file" + err); //null
                    }
                  });
                } else {
                  fse.outputFileSync(errFilePath, "no stderr for key: " + key, function (err) {
                    if (err) {
                      console.log("Error:couldn't write error file" + err); //null
                    }
                  });
                }

                if (stdout) {
                  if (stdout.match(/ERROR/)) {
                    fse.outputFileSync(errFilePath, stdout, function (err) {
                      if (err) {
                        console.log("Error:couldn't write log/err file" + err);
                      }
                    });
                  }

                  fse.outputFileSync(logFilePath, stdout, function (err) {
                    if (err) {
                      console.log("Error:couldn't write log file" + err);
                    }
                  });
                  var sqlout = stdout.match(/[\s\S]*#*(SELECT[\s\S]*)Database/) == null ? null : stdout.match(/[\s\S]*#*(SELECT[\s\S]*)Database/)[1];

                  if (sqlout == null) {
                    fse.outputFileSync(sqlFilePath, "no sql statement found in output for key: " + key, function (err) {
                      if (err) {
                        console.log("Error:couldn't write sql file" + err);
                      }
                    });
                  } else {
                    fse.outputFileSync(sqlFilePath, sqlout, function (err) {
                      if (err) {
                        console.log("Error:couldn't write sql file" + err);
                      }
                    });
                  }
                } else {
                  fse.outputFileSync(logFilePath, "No stdout captured for: " + key, function (err) {
                    if (err) {
                      console.log("Error:couldn't write log file" + err);
                    }
                  });
                } // no error - check for the files and cache the spec and filePaths


                var xmlSpecExists = fse.existsSync(plotSpecFilePath);
                var plotExists = fse.existsSync(pngFilePath);
                var scriptExists = fse.existsSync(scriptFilePath);
                var dataExists = fse.existsSync(dataFilePath);
                var sqlExists = fse.existsSync(sqlFilePath);
                var logExists = fse.existsSync(logFilePath);
                var filesExist = xmlSpecExists && plotExists && scriptExists && dataExists && sqlExists && logExists;

                if (!filesExist) {
                  console.error('exec error: expected files do not exist');
                }

                matsCache.storeResult(key, artifacts);
                /*
                    The mvbatch should have saved the plot artifacts according to the following plotSpec elements
                        <data_file>key.data</data_file>
                        <plot_file>key.png</plot_file>
                        <r_file>key.R</r_file>
                    where key is the same as the key for the matsCache
                    The stored artifacts shoulkd be like ...
                        MV_OUTPUT/plots/key.png
                        MV_OUTPUT/xml/key.xml
                        MV_OUTPUT/xml/key.sql
                        MV_OUTPUT/xml/key.log
                        MV_OUTPUT/scripts/key.R
                        MV_OUTPUT/data/key.data
                        MV_OUTPUT/data/key.sum_stat.info
                        MV_OUTPUT/data/key.data.sum_stat
                         MV_OUTPUT/xml/key.xml is the plotSpec
                */

                return {
                  'key': key,
                  'artifacts': artifacts
                };
              }); //ret = {key:key, result:{artifacts:artifacts}}
              // return the key and the artifacts
            } // plotspec did not exist
            else {
                // the files actually already existed but we needed the plotspec
                // so just refresh the cache and return the key right away
                matsCache.storeResult(key, artifacts);
                return {
                  'key': key,
                  'artifacts': artifacts
                };
              }
          }
        });
      } // either artifactPaths == null || filesExist === false
      else {
          // artifacts existed and plotspec existed - refresh the cache
          matsCache.storeResult(key, artifacts);
          return {
            'key': key,
            'artifacts': artifacts
          };
        }

      return {
        'key': key,
        'artifacts': artifacts
      };
    } // if Meteor is Server

  } // run


}); // administration tool

const readFunctionFile = new ValidatedMethod({
  name: 'matsMethods.readFunctionFile',
  validate: new SimpleSchema({}).validator(),

  run() {
    if (Meteor.isServer) {
      var future = require('fibers/future');

      var fse = require('fs-extra');

      var path = "";
      var fData;

      if (type == "data") {
        path = "/web/static/dataFunctions/" + file;
        console.log('exporting data file: ' + path);
      } else if (type == "graph") {
        path = "/web/static/displayFunctions/" + file;
        console.log('exporting graph file: ' + path);
      } else {
        return "error - wrong type";
      }

      fse.readFile(path, function (err, data) {
        if (err) throw err;
        fData = data.toString();
        future["return"](fData);
      });
      return future.wait();
    }
  }

}); // refreshes the metadata for the app that's running

const refreshMetaData = new ValidatedMethod({
  name: 'matsMethods.refreshMetaData',
  validate: new SimpleSchema({}).validator(),

  run() {
    if (Meteor.isServer) {
      try {
        //console.log("Asked to refresh metadata");
        _checkMetaDataRefresh();
      } catch (e) {
        console.log(e);
        throw new Meteor.Error("Server error: ", e.message);
      }
    }

    return metaDataTableUpdates.find({}).fetch();
  }

}); // administation tool

const removeAuthorization = new ValidatedMethod({
  name: 'matsMethods.removeAuthorization',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),

  run(settings) {
    if (Meteor.isServer) {
      var email;
      var roleName;
      var userRoleName = settings.userRoleName;
      var authorizationRole = settings.authorizationRole;
      var newUserEmail = settings.newUserEmail;
      var existingUserEmail = settings.existingUserEmail;

      if (authorizationRole) {
        // existing role - the role roleName - no need to verify as the selection list came from the database
        roleName = authorizationRole;
      } else if (userRoleName) {
        roleName = userRoleName;
      }

      if (existingUserEmail) {
        email = existingUserEmail;
      } else {
        email = newUserEmail;
      } // if user and role remove the role from the user


      if (email && roleName) {
        matsCollections.Authorization.update({
          email: email
        }, {
          $pull: {
            roles: roleName
          }
        });
      } // if user and no role remove the user


      if (email && !roleName) {
        matsCollections.Authorization.remove({
          email: email
        });
      } // if role and no user remove role and remove role from all users


      if (roleName && !email) {
        // remove the role
        matsCollections.Roles.remove({
          name: roleName
        }); // remove the roleName role from all the authorizations

        matsCollections.Authorization.update({
          roles: roleName
        }, {
          $pull: {
            roles: roleName
          }
        }, {
          multi: true
        });
      }

      return false;
    }
  }

}); // app utility

const removeColor = new ValidatedMethod({
  name: 'matsMethods.removeColor',
  validate: new SimpleSchema({
    removeColor: {
      type: String
    }
  }).validator(),

  run(removeColor) {
    var colorScheme = matsCollections.ColorScheme.findOne({});
    var removeIndex = colorScheme.colors.indexOf(removeColor);
    colorScheme.colors.splice(removeIndex, 1);
    matsCollections.ColorScheme.update({}, colorScheme);
    return false;
  }

}); // database controls

const removeDatabase = new ValidatedMethod({
  name: 'matsMethods.removeDatabase',
  validate: new SimpleSchema({
    dbName: {
      type: String
    }
  }).validator(),

  run(dbName) {
    if (Meteor.isServer) {
      matsCollections.Databases.remove({
        name: dbName
      });
    }
  }

}); // makes sure all of the parameters display appropriate selections in relation to one another

const resetApp = function (appRef) {
  var fse = require('fs-extra');

  const metaDataTableRecords = appRef.appMdr;
  const type = appRef.appType;
  const appName = appRef.app;
  var dep_env = process.env.NODE_ENV; // set some defaults for python processing - these can be overridden

  if (Meteor.settings.private != null && Meteor.settings.private.PYTHON_PATH == null) {
    Meteor.settings.private.PYTHON_PATH = "/usr/bin/python";
  }

  if (Meteor.settings.private != null && Meteor.settings.private.process != null && Meteor.settings.private.process.RUN_ENV != null) {
    switch (Meteor.settings.private.process.RUN_ENV) {
      case "development":
      case "integration":
      case "production":
        dep_env = Meteor.settings.private.process.RUN_ENV;
        break;

      default:
        dep_env = process.env.NODE_ENV;
        break;
    }
  }

  var deployment;
  var deploymentText = Assets.getText('public/deployment/deployment.json');

  if (deploymentText == null) {// equivilent to deploymentText === null || deploymentText === undefined
  }

  deployment = JSON.parse(deploymentText);
  var app = {};

  for (var ai = 0; ai < deployment.length; ai++) {
    var dep = deployment[ai];

    if (dep.deployment_environment == dep_env) {
      app = dep.apps.filter(function (app) {
        return app.app === appName;
      })[0];
    }
  }

  const appVersion = app ? app.version : "unknown";
  const appTitle = app ? app.title : "unknown";
  const buildDate = app ? app.buildDate : "unknown";
  const appType = type ? type : matsTypes.AppTypes.mats;
  matsCollections.appName.upsert({
    app: appName
  }, {
    $set: {
      app: appName
    }
  }); // remember that we updated the metadata tables just now - create metaDataTableUpdates

  /*
      metaDataTableUpdates:
      {
          name: dataBaseName,
          tables: [tableName1, tableName2 ..],
          lastRefreshed : timestamp
      }
   */
  // only create metadata tables if the resetApp was called with a real metaDataTables object

  if (metaDataTableRecords instanceof matsTypes.MetaDataDBRecord) {
    var metaDataTables = metaDataTableRecords.getRecords();

    for (var mdti = 0; mdti < metaDataTables.length; mdti++) {
      const metaDataRef = metaDataTables[mdti];
      metaDataRef.lastRefreshed = moment().format();

      if (metaDataTableUpdates.find({
        name: metaDataRef.name
      }).count() == 0) {
        metaDataTableUpdates.update({
          name: metaDataRef.name
        }, metaDataRef, {
          upsert: true
        });
      }
    }
  } else {
    throw new Meteor.Error("Server error: ", "resetApp: bad pool-database entry");
  }

  matsCollections.Roles.remove({});
  matsDataUtils.doRoles();
  matsCollections.Authorization.remove({});
  matsDataUtils.doAuthorization();
  matsCollections.Credentials.remove({});
  matsDataUtils.doCredentials();
  matsCollections.PlotGraphFunctions.remove({});
  matsCollections.ColorScheme.remove({});
  matsDataUtils.doColorScheme();
  matsCollections.Settings.remove({});
  matsDataUtils.doSettings(appTitle, appVersion, buildDate, appType);
  matsCollections.CurveParams.remove({});
  matsCollections.PlotParams.remove({});
  matsCollections.CurveTextPatterns.remove({}); // app specific routines
  //const asrKeys = Object.keys(appSpecificResetRoutines);

  const asrKeys = appSpecificResetRoutines;

  for (var ai = 0; ai < asrKeys.length; ai++) {
    global.appSpecificResetRoutines[ai]();
  }

  matsCache.clear();
}; // administration tool


const restoreFromFile = new ValidatedMethod({
  name: 'matsMethods.restoreFromFile',
  validate: new SimpleSchema({
    type: {
      type: String
    },
    name: {
      type: String
    },
    data: {
      type: Object,
      blackbox: true
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      console.log("restoring " + params.type + " file " + params.name);
      var path = "";

      if (params.type == "data") {
        path = "/web/static/dataFunctions/" + params.name;
      } else if (params.ype == "graph") {
        path = "/web/static/displayFunctions/" + params.name;
      } else {
        return "error - wrong tyoe";
      }

      console.log('importing ' + params.type + ' file: ' + path);

      var fse = require('fs-extra');

      fse.writeFile(path, params.data.toString(), function (err) {
        if (err) {
          return err.toLocaleString();
        }

        console.log('imported ' + params.type + ' file: ' + path);
      });
    }
  }

}); // administration tool

const restoreFromParameterFile = new ValidatedMethod({
  name: 'matsMethods.restoreFromParameterFile',
  validate: new SimpleSchema({
    name: {
      type: String
    },
    data: {
      type: Object,
      blackbox: true
    }
  }).validator(),

  run(params) {
    var data = params.data;

    if (Meteor.isServer) {
      var d = [];

      if (data.CurveParams) {
        matsCollections.CurveParams.remove({});
        d = _.map(data.CurveParams, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.CurveParams.insert(o);
        });
      }

      if (data.PlotParams) {
        matsCollections.PlotParams.remove({});
        d = _.map(data.PlotParams, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.PlotParams.insert(o);
        });
      }

      if (data.PlotGraphFunctions) {
        matsCollections.PlotGraphFunctions.remove({});
        d = _.map(data.PlotGraphFunctions, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.PlotGraphFunctions.insert(o);
        });
      }

      if (data.Settings) {
        matsCollections.Settings.remove({});
        d = _.map(data.Settings, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Settings.insert(o);
        });
      }

      if (data.ColorScheme) {
        matsCollections.ColorScheme.remove({});
        d = _.map(data.ColorScheme, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.ColorScheme.insert(o);
        });
      }

      if (data.Authorization) {
        matsCollections.Authorization.remove({});
        d = _.map(data.Authorization, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Authorization.insert(o);
        });
      }

      if (data.Roles) {
        matsCollections.Roles.remove({});
        d = _.map(data.Roles, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Roles.insert(o);
        });
      }

      if (data.Databases) {
        matsCollections.Databases.remove({});
        d = _.map(data.Databases, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Databases.insert(o);
        });
      }

      if (data.Credentials) {
        matsCollections.Credentials.remove({});
        d = _.map(data.Credentials, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Credentials.insert(o);
        });
      }
    }
  }

});
const saveLayout = new ValidatedMethod({
  name: 'matsMethods.saveLayout',
  validate: new SimpleSchema({
    resultKey: {
      type: String
    },
    layout: {
      type: Object,
      blackbox: true
    },
    curveOpsUpdate: {
      type: Object,
      blackbox: true
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      var key = params.resultKey;
      var layout = params.layout;
      var curveOpsUpdate = params.curveOpsUpdate;

      try {
        LayoutStoreCollection.upsert({
          key: key
        }, {
          $set: {
            "createdAt": new Date(),
            layout: layout,
            curveOpsUpdate: curveOpsUpdate
          }
        });
      } catch (error) {
        throw new Meteor.Error("Error in saveLayout function:" + key + " : " + error.message);
      }
    }
  }

}); //administration tools

const saveSettings = new ValidatedMethod({
  name: 'matsMethods.saveSettings',
  validate: new SimpleSchema({
    saveAs: {
      type: String
    },
    p: {
      type: Object,
      blackbox: true
    },
    permission: {
      type: String
    }
  }).validator(),

  run(params) {
    var user = "anonymous";
    matsCollections.CurveSettings.upsert({
      name: params.saveAs
    }, {
      created: moment().format("MM/DD/YYYY HH:mm:ss"),
      name: params.saveAs,
      data: params.p,
      owner: Meteor.userId() == null ? "anonymous" : Meteor.userId(),
      permission: params.permission,
      savedAt: new Date(),
      savedBy: Meteor.user() == null ? "anonymous" : user
    });
  }

}); // administation tool

const setCredentials = new ValidatedMethod({
  name: 'matsMethods.setCredentials',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),

  run(settings) {
    if (Meteor.isServer) {
      var name = settings.name;
      var clientId = settings.clientId;
      var clientSecret = settings.clientSecret;
      var clientRefreshToken = settings.clientRefreshToken;
      matsCollections.Credentials.update({}, {
        $set: {
          name: name,
          clientId: clientId,
          clientSecret: clientSecret,
          refresh_token: clientRefreshToken
        }
      });
      return false;
    }
  }

});
const setSettings = new ValidatedMethod({
  name: 'matsMethods.setSettings',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      var settings = params.settings;
      var labelPrefix = settings.labelPrefix;
      var title = settings.title;
      var lineWidth = settings.lineWidth;
      var nullFillString = settings.nullFillString;
      var resetFromCode = settings.resetFromCode;
      matsCollections.Settings.update({}, {
        $set: {
          LabelPrefix: labelPrefix,
          Title: title,
          LineWidth: lineWidth,
          NullFillString: nullFillString,
          resetFromCode: resetFromCode
        }
      });
    }

    return false;
  }

});
/* test methods */

const testGetMetaDataTableUpdates = new ValidatedMethod({
  name: 'matsMethods.testGetMetaDataTableUpdates',
  validate: new SimpleSchema({}).validator(),

  run() {
    return metaDataTableUpdates.find({}).fetch();
  }

});
const testGetTables = new ValidatedMethod({
  name: 'matsMethods.testGetTables',
  validate: new SimpleSchema({
    host: {
      type: String
    },
    user: {
      type: String
    },
    password: {
      type: String
    },
    database: {
      type: String
    }
  }).validator(),

  run(params) {
    if (Meteor.isServer) {
      const Future = require('fibers/future');

      const queryWrap = Future.wrap(function (callback) {
        const connection = mysql.createConnection({
          host: params.host,
          user: params.user,
          password: params.password,
          database: params.database
        });
        connection.query("show tables;", function (err, result) {
          const tables = result.map(function (a) {
            return a.Tables_in_ruc_ua_sums2;
          });
          return callback(err, tables);
        });
        connection.end(function (err) {
          if (err) {
            console.log("testGetTables cannot end connection");
          }
        });
      });
      return queryWrap().wait();
    }
  }

});
const testSetMetaDataTableUpdatesLastRefreshedBack = new ValidatedMethod({
  name: 'matsMethods.testSetMetaDataTableUpdatesLastRefreshedBack',
  validate: new SimpleSchema({}).validator(),

  run() {
    var mtu = metaDataTableUpdates.find({}).fetch();
    var id = mtu[0]._id;
    metaDataTableUpdates.update({
      _id: id
    }, {
      $set: {
        lastRefreshed: 0
      }
    });
    return metaDataTableUpdates.find({}).fetch();
  }

});
module.exportDefault(matsMethods = {
  addSentAddress: addSentAddress,
  applyAuthorization: applyAuthorization,
  applyDatabaseSettings: applyDatabaseSettings,
  deleteSettings: deleteSettings,
  emailImage: emailImage,
  getAuthorizations: getAuthorizations,
  getDataFunctionFileList: getDataFunctionFileList,
  getGraphData: getGraphData,
  getGraphDataByKey: getGraphDataByKey,
  getGraphFunctionFileList: getGraphFunctionFileList,
  getLayout: getLayout,
  getMvArtifactsByKey: getMvArtifactsByKey,
  getPlotResult: getPlotResult,
  getReleaseNotes: getReleaseNotes,
  getUserAddress: getUserAddress,
  insertColor: insertColor,
  mvBatch: mvBatch,
  readFunctionFile: readFunctionFile,
  refreshMetaData: refreshMetaData,
  removeAuthorization: removeAuthorization,
  removeColor: removeColor,
  removeDatabase: removeDatabase,
  resetApp: resetApp,
  restoreFromFile: restoreFromFile,
  restoreFromParameterFile: restoreFromParameterFile,
  saveLayout: saveLayout,
  saveSettings: saveSettings,
  setCredentials: setCredentials,
  setSettings: setSettings,
  testGetMetaDataTableUpdates: testGetMetaDataTableUpdates,
  testGetTables: testGetTables,
  testSetMetaDataTableUpdatesLastRefreshedBack: testSetMetaDataTableUpdatesLastRefreshedBack,
  MV_DIRS: MV_DIRS
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"client":{"curve_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/curve_util.js                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes(v) {
    matsTypes = v;
  }

}, 0);
let matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  }

}, 1);
let matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils(v) {
    matsPlotUtils = v;
  }

}, 2);
let matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils(v) {
    matsParamUtils = v;
  }

}, 3);
let Info;
module.link("meteor/randyp:mats-common", {
  Info(v) {
    Info = v;
  }

}, 4);
let matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods(v) {
    matsMethods = v;
  }

}, 5);

/*
 global dataset variable - container for graph dataset.
 This (plotResult) is very important. It isn't "var" because it needs to be a meteor global scope.
 The page is rendered whe the graph page comes up, but the data from the data processing callback
 in plotList.js or curveList.js may not have set the global variable
 PlotResult.
 */
//var plotResultData = null; -- this was the global variable for the text output data, but now it is set elsewhere
var graphResult = null; // this is the global variable for the data on the graph

var plot;

const sizeof = function (_1) {
  var _2 = [_1];
  var _3 = 0;

  for (var _4 = 0; _4 < _2.length; _4++) {
    switch (typeof _2[_4]) {
      case "boolean":
        _3 += 4;
        break;

      case "number":
        _3 += 8;
        break;

      case "string":
        _3 += 2 * _2[_4].length;
        break;

      case "object":
        if (Object.prototype.toString.call(_2[_4]) != "[object Array]") {
          for (var _5 in _2[_4]) {
            _3 += 2 * _5.length;
          }
        }

        for (var _5 in _2[_4]) {
          var _6 = false;

          for (var _7 = 0; _7 < _2.length; _7++) {
            if (_2[_7] === _2[_4][_5]) {
              _6 = true;
              break;
            }
          }

          if (!_6) {
            _2.push(_2[_4][_5]);
          }
        }

    }
  }

  return _3;
}; // Retrieves the globally stored plotResultData for the text output and other things.
// Re-sets the plotResultData if the requested page range has changed, or if it has not been previously set.


const getPlotResultData = function () {
  var pageIndex = Session.get("pageIndex");
  var newPageIndex = Session.get("newPageIndex");

  if (plotResultData === undefined || plotResultData === null || Session.get('textRefreshNeeded') === true) {
    setPlotResultData();
  }

  return plotResultData;
}; // Sets the global plotResultData variable for the text output to the requested range from the Results data stored in mongo, via a MatsMethod.


const setPlotResultData = function () {
  var pageIndex = Session.get("pageIndex");
  var newPageIndex = Session.get("newPageIndex");

  if (Session.get('textRefreshNeeded') === true) {
    showSpinner();
    matsMethods.getPlotResult.call({
      resultKey: Session.get("plotResultKey"),
      pageIndex: pageIndex,
      newPageIndex: newPageIndex
    }, function (error, result) {
      if (error !== undefined) {
        setError(new Error("matsMethods.getPlotResult failed : error: " + error));
        Session.set('textRefreshNeeded', false);
      }

      if (result == undefined) {
        plotResultData = undefined;
        Session.set('textRefreshNeeded', false);
        hideSpinner();
        return;
      }

      plotResultData = result;
      Session.set("pageIndex", result.dsiRealPageIndex);
      Session.set("pageTextDirection", result.dsiTextDirection);
      Session.set('textLoaded', new Date());
      console.log("size of plotResultData is ", sizeof(plotResultData));
      Session.set('textRefreshNeeded', false);
      hideSpinner();
    });
  }
}; // resets the global plotResultData variable for the text output to null


const resetPlotResultData = function () {
  plotResultData = null;
  Session.set('textLoaded', new Date());
}; // gets the global graphResult variable, which is the data object for the (possibly downsampled) data on the graph


const getGraphResult = function () {
  if (graphResult === undefined || graphResult === null) {
    return [];
  }

  return graphResult;
}; // sets the global graphResult variable to the (possibly downsampled) data object returned from MatsMethods, in order to make the graph


const setGraphResult = function (result) {
  graphResult = result;
  Session.set('graphDataLoaded', new Date());
  console.log("size of graphResultData is", sizeof(graphResult));
}; // resets the global graphResult variable to null


const resetGraphResult = function () {
  graphResult = null;
  Session.set('graphDataLoaded', new Date());
};
/*
 Curve utilities - used to determine curve labels and colors etc.
 */


const getUsedLabels = function () {
  if (Session.get('UsedLabels') === undefined) {
    return [];
  }

  return Session.get('UsedLabels');
};

const getNextCurveLabel = function () {
  if (Session.get('NextCurveLabel') === undefined) {
    setNextCurveLabel();
  }

  return Session.get('NextCurveLabel');
}; // determine the next curve Label and set it in the session
// private, not exported


const setNextCurveLabel = function () {
  const usedLabels = Session.get('UsedLabels');
  const settings = matsCollections.Settings.findOne({}, {
    fields: {
      LabelPrefix: 1
    }
  });

  if (settings === undefined) {
    return false;
  }

  const labelPrefix = settings.LabelPrefix; // find all the labels that start with our prefix (some could be custom)

  const prefixLabels = _.filter(usedLabels, function (l) {
    return l && l.lastIndexOf(labelPrefix, 0) === 0 && l.match(new RegExp(labelPrefix, 'g')).length == 1;
  });

  const lastUsedLabel = _.last(prefixLabels);

  var lastLabelNumber = -1;

  if (lastUsedLabel !== undefined) {
    const minusPrefix = lastUsedLabel.replace(labelPrefix, '');
    const tryNum = parseInt(minusPrefix, 10);

    if (!isNaN(tryNum)) {
      lastLabelNumber = tryNum;
    }
  }

  var newLabelNumber = lastLabelNumber + 1;
  var nextCurveLabel = labelPrefix + newLabelNumber; // the label might be one from a removed curve so the next ones might be used

  while (_.indexOf(usedLabels, nextCurveLabel) != -1) {
    newLabelNumber++;
    nextCurveLabel = labelPrefix + newLabelNumber;
  }

  Session.set('NextCurveLabel', nextCurveLabel);
}; // determine the next curve color and set it in the session
// private - not exported


const setNextCurveColor = function () {
  var usedColors = Session.get('UsedColors');
  var colors = matsCollections.ColorScheme.findOne({}, {
    fields: {
      colors: 1
    }
  }).colors;
  var lastUsedIndex = -1;

  if (usedColors !== undefined) {
    lastUsedIndex = _.indexOf(colors, _.last(usedColors));
  }

  var nextCurveColor;

  if (lastUsedIndex !== undefined && lastUsedIndex != -1) {
    if (lastUsedIndex < colors.length - 1) {
      var newIndex = lastUsedIndex + 1;
      nextCurveColor = colors[newIndex]; // the color might be one from a removed curve so the next ones might be used

      while (_.indexOf(usedColors, nextCurveColor) != -1) {
        newIndex++;
        nextCurveColor = colors[newIndex];
      }
    } else {
      // out of defaults
      var rint = Math.round(0xffffff * Math.random());
      nextCurveColor = 'rgb(' + (rint >> 16) + ',' + (rint >> 8 & 255) + ',' + (rint & 255) + ')';
    }
  } else {
    nextCurveColor = colors[0];
  }

  Session.set('NextCurveColor', nextCurveColor);
}; // get the next curve color from the session
// private - not exported


const getNextCurveColor = function () {
  if (Session.get('NextCurveColor') === undefined) {
    setNextCurveColor();
  }

  return Session.get('NextCurveColor');
}; // clear a used label and set the nextCurveLabel to the one just cleared


const clearUsedLabel = function (label) {
  var usedLabels = Session.get('UsedLabels');

  var newUsedLabels = _.reject(usedLabels, function (l) {
    return l == label;
  });

  Session.set('UsedLabels', newUsedLabels);
  Session.set('NextCurveLabel', label);
}; // clear a used color and set the nextCurveColor to the one just cleared


const clearUsedColor = function (color) {
  var usedColors = Session.get('UsedColors');

  var newUsedColors = _.reject(usedColors, function (c) {
    return c == color;
  });

  Session.set('UsedColors', newUsedColors);
  Session.set('NextCurveColor', color);
}; // clear all the used colors and labels and set the nextCurve values
// to the first in the scheme and the first of the labelPrefix.
// This is used by the removeAll


const clearAllUsed = function () {
  Session.set('UsedColors', undefined);
  var colors = matsCollections.ColorScheme.findOne({}, {
    fields: {
      colors: 1
    }
  }).colors;
  Session.set('NextCurveColor', colors[0]);
  Session.set('UsedLabels', undefined);
  var labelPrefix = matsCollections.Settings.findOne({}, {
    fields: {
      LabelPrefix: 1
    }
  }).LabelPrefix;
  Session.set('NextCurveLabel', labelPrefix + 0);
  Session.set('Curves', []);
}; // use curves in session to determine which defaults are already used
// and to set the usedColors in the session
// this is used on restore settings to set up the usedColors
// private - not exported
//setUsedDefaults = function() {


const setUsedColors = function () {
  var curves = Session.get('Curves');
  var usedColors = [];

  for (var i = 0; i < curves.length; i++) {
    var color = curves[i].color;
    usedColors.push(color);
  }

  Session.set('UsedColors', usedColors);
  setNextCurveColor();
}; // private - not exported


const setUsedLabels = function () {
  var curves = Session.get('Curves');
  var usedLabels = [];

  for (var i = 0; i < curves.length; i++) {
    var label = curves[i].label;
    usedLabels.push(label);
  }

  Session.set('UsedLabels', usedLabels);
  setNextCurveLabel();
};

const setUsedColorsAndLabels = function () {
  setUsedColors();
  setUsedLabels();
};

const resetScatterApply = function () {
  if (matsPlotUtils.getPlotType() == matsTypes.PlotTypes.scatter2d) {
    Session.set('axisCurveIcon', 'fa-asterisk');
    Session.set('xaxisCurveText', 'XAXIS NOT YET APPLIED');
    Session.set('yaxisCurveText', 'YAXIS NOT YET APPLIED');
    Session.set('xaxisCurveColor', 'red');
    Session.set('yaxisCurveColor', 'red');

    if (document.getElementById('Fit-Type-radioGroup-none') !== null) {
      document.getElementById('Fit-Type-radioGroup-none').checked = true;
    }
  }
}; // add the difference curves
// private - not exported


const addDiffs = function () {
  var curves = Session.get('Curves');
  var newCurves = Session.get('Curves'); // diffs is checked -- have to add diff curves

  var curvesLength = curves.length;

  if (curvesLength <= 1) {
    setInfo("You cannot difference less than two curves!");
    return false;
  }

  switch (matsPlotUtils.getPlotFormat()) {
    case matsTypes.PlotFormats.matching:
      var baseIndex = 0; // This will probably not default to curve 0 in the future

      for (var ci = 1; ci < curves.length; ci++) {
        var newCurve = $.extend(true, {}, curves[ci]);
        newCurve.label = curves[ci].label + "-" + curves[0].label;
        newCurve.color = getNextCurveColor();
        newCurve.diffFrom = [ci, baseIndex]; // do not create extra diff if it already exists

        if (_.findWhere(curves, {
          label: newCurve.label
        }) === undefined) {
          newCurves.push(newCurve);
          Session.set('Curves', newCurves);
          setUsedColorsAndLabels();
        }
      }

      break;

    case matsTypes.PlotFormats.pairwise:
      var baseIndex = 0; // This will probably not default to curve 0 in the future

      for (var ci = 1; ci < curves.length; ci++) {
        if (ci % 2 != 0) {
          // only diff on odd curves against previous curve
          var base_index = ci - 1;
          var newCurve = $.extend(true, {}, curves[ci]);
          newCurve.label = curves[ci].label + "-" + curves[base_index].label;
          newCurve.color = getNextCurveColor();
          newCurve.diffFrom = [ci, baseIndex]; // do not create extra diff if it already exists

          if (_.findWhere(curves, {
            label: newCurve.label
          }) === undefined) {
            newCurves.push(newCurve);
            Session.set('Curves', newCurves);
            setUsedColorsAndLabels();
          }
        }
      }

      break;

    case matsTypes.PlotFormats.absolute:
      var baseIndex = 0; // This will probably not default to curve 0 in the future

      for (var ci = 1; ci < curves.length; ci++) {
        var newCurve = $.extend(true, {}, curves[ci]);
        newCurve.label = curves[ci].label + "-" + curves[0].label;
        newCurve.color = getNextCurveColor();
        newCurve.diffFrom = [ci, baseIndex]; // do not create extra diff if it already exists

        if (_.findWhere(curves, {
          label: newCurve.label
        }) === undefined) {
          newCurves.push(newCurve);
          Session.set('Curves', newCurves);
          setUsedColorsAndLabels();
        }
      }

      break;
  }
}; // remove difference curves
// private - not exported


const removeDiffs = function () {
  var curves = Session.get('Curves');

  var newCurves = _.reject(curves, function (curve) {
    return curve.diffFrom != null;
  });

  Session.set('Curves', newCurves);
  setUsedColorsAndLabels();
}; // resolve the difference curves
// (used after adding or removing a curve while the show diffs box is checked)


const checkDiffs = function () {
  var curves = Session.get('Curves');

  if (matsPlotUtils.getPlotType() == matsTypes.PlotTypes.scatter2d) {
    // scatter plots have no concept of difference curves.
    return;
  }

  var plotFormat = matsPlotUtils.getPlotFormat();

  if (curves.length > 1) {
    if (plotFormat !== matsTypes.PlotFormats.none) {
      removeDiffs();
      addDiffs();
    } else {
      removeDiffs();
    }
  }
}; // method to display the appropriate selectors for a timeseries curve


const showTimeseriesFace = function () {
  // move dates selector to plot parameters - one date range for all curves
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.timeSeries).checked === true) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'block',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.timeSeries); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a profile curve


const showProfileFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.profile).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'none',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.profile); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a dieoff curve


const showDieOffFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.dieoff).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'none',
      'dieoff-type': 'block',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    } // reset the value for dieoff-type, so that the checkHideOther routine will work


    const param = matsParamUtils.getParameterForName('dieoff-type');
    matsParamUtils.setValueTextForParamName(param.name, param.default);
    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.dieoff); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a threshold curve


const showThresholdFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.threshold).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'none',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.threshold); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a valid time curve


const showValidTimeFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.validtime).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'none',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.validtime); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a daily model cycle curve


const showDailyModelCycleFace = function () {
  // move dates selector to plot parameters - one date range for all curves
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.dailyModelCycle).checked === true) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'none',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'none',
      'utc-cycle-start': 'block',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.dailyModelCycle); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a reliability curve


const showReliabilityFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.reliability).checked === true) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'block',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'none',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.reliability); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a map


const showMapFace = function () {
  // move dates selector to plot parameters - one date range for all curves
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.map).checked === true) {
    var faceOptions;
    faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'none',
      'statistic': 'none',
      'threshold': 'none',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'none',
      'sites': 'block',
      'sitesMap': 'block',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.map); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a histogram


const showHistogramFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.histogram).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'block',
      'histogram-yaxis-controls': 'block',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.histogram); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a contour plot


const showContourFace = function () {
  // move dates selector to plot parameters - one date range for all curves
  const isContour = document.getElementById('plot-type-' + matsTypes.PlotTypes.contour) !== null && document.getElementById('plot-type-' + matsTypes.PlotTypes.contour).checked === true;
  const isContourDiff = document.getElementById('plot-type-' + matsTypes.PlotTypes.contourDiff) !== null && document.getElementById('plot-type-' + matsTypes.PlotTypes.contourDiff).checked === true;

  if (isContour || isContourDiff) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'block',
      'y-axis-parameter': 'block'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    } // //need to be consistent with the x and y axis 'hideOtherFor' settings
    // const xAxisVal = matsParamUtils.getValueForParamName('x-axis-parameter');
    // const yAxisVal = matsParamUtils.getValueForParamName('y-axis-parameter');
    // if (xAxisVal === 'Fcst lead time' || yAxisVal === 'Fcst lead time') {
    //     elem = document.getElementById('forecast-length-item');
    //     if (elem && elem.style) {
    //         elem.style.display = 'none';
    //     }
    // }
    // if (xAxisVal === 'Valid UTC hour' || yAxisVal === 'Valid UTC hour') {
    //     elem = document.getElementById('valid-time-item');
    //     if (elem && elem.style) {
    //         elem.style.display = 'none';
    //     }
    // }
    // if (xAxisVal === 'Pressure level' || yAxisVal === 'Pressure level') {
    //     elem = document.getElementById('pres-level-item');
    //     if (elem && elem.style) {
    //         elem.style.display = 'none';
    //     }
    // }


    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    if (isContour) {
      Session.set('plotType', matsTypes.PlotTypes.contour);
    } else {
      Session.set('plotType', matsTypes.PlotTypes.contourDiff);
    } // matsParamUtils.setAllParamsToDefault();


    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a scatter plot


const showScatterFace = function () {
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.scatter2d).checked === true) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    const faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "block";
    }

    Session.set('plotType', matsTypes.PlotTypes.scatter2d);
    Session.set('lastUpdate', Date.now()); // force curveParams to re-render
    // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // this is no longer used, but it was once employed by the text output routines to calculate the stats for the entire curve


const get_err = function (sVals, sSecs) {
  /* THIS IS DIFFERENT FROM THE ONE IN DATA_UTILS,
     This one does not throw away outliers and it captures minVal and maxVal
     refer to perl error_library.pl sub  get_stats
      to see the perl implementation of these statics calculations.
      These should match exactly those, except that they are processed in reverse order.
   */
  var subVals = [];
  var subSecs = [];
  var sVals = sVals;
  var sSecs = sSecs;
  var n = sVals.length;
  var n_good = 0;
  var sum_d = 0;
  var sum2_d = 0;
  var error = "";
  var i;

  for (i = 0; i < n; i++) {
    if (sVals[i] !== null) {
      n_good = n_good + 1;
      sum_d = sum_d + sVals[i];
      sum2_d = sum2_d + sVals[i] * sVals[i];
      subVals.push(sVals[i]);
      subSecs.push(sSecs[i]);
    }
  }

  var d_mean = sum_d / n_good;
  var sd2 = sum2_d / n_good - d_mean * d_mean;
  var sd = sd2 > 0 ? Math.sqrt(sd2) : sd2;
  var sd_limit = 3 * sd; //console.log("see error_library.pl l208 These are processed in reverse order to the perl code -  \nmean is " + d_mean + " sd_limit is +/- " + sd_limit + " n_good is " + n_good + " sum_d is" + sum_d + " sum2_d is " + sum2_d);
  // find minimum delta_time, if any value missing, set null

  var last_secs = Number.MIN_VALUE;
  var minDelta = Number.MAX_VALUE;
  var minSecs = Number.MAX_VALUE;
  var max_secs = Number.MIN_VALUE;
  var minVal = Number.MAX_VALUE;
  var maxVal = Number.MIN_VALUE;

  for (i = 0; i < subSecs.length; i++) {
    var secs = subSecs[i];
    var delta = Math.abs(secs - last_secs);

    if (delta < minDelta) {
      minDelta = delta;
    }

    if (secs < minSecs) {
      minSecs = secs;
    }

    if (secs > max_secs) {
      max_secs = secs;
    }

    last_secs = secs;
  }

  var data_wg = [];
  var n_gaps = 0;
  n_good = 0;
  var sum = 0;
  var sum2 = 0;
  var loopTime = minSecs;

  if (minDelta < 0) {
    error = "Invalid time interval - minDelta: " + minDelta;
  } // remove data more than $sd_limit from mean


  for (i = 0; i < subVals.length; i++) {
    minVal = minVal < subVals[i] ? minVal : subVals[i];
    maxVal = maxVal > subVals[i] ? maxVal : subVals[i];
    n_good++;
  } //console.log("new mean after throwing away outliers is " + sd + " n_good is " + n_good + " sum is " + sum  + " sum2 is " + sum2 + " d_mean is " + d_mean);
  // look for gaps.... per Bill, we only need one gap per series of gaps...


  var lastSecond = Number.MIN_VALUE;

  for (i = 0; i < subSecs.length; i++) {
    var sec = subSecs[i];

    if (lastSecond >= 0) {
      if (sec - lastSecond > minDelta) {
        // insert a gap
        data_wg.push(null);
        n_gaps++;
      }
    }

    lastSecond = sec;
    data_wg.push(subVals[i]);
  } //console.log ("n_gaps: " + n_gaps +  " time gaps in subseries");
  //from http://www.itl.nist.gov/div898/handbook/eda/section3/eda35c.htm


  var r = [];

  for (var lag = 0; lag <= 1; lag++) {
    r[lag] = 0;
    var n_in_lag = 0;

    for (var t = 0; t < n + n_gaps - lag; t++) {
      if (data_wg[t] != null && data_wg[t + lag] != null) {
        r[lag] += +(data_wg[t] - d_mean) * (data_wg[t + lag] - d_mean);
        n_in_lag++;
      }
    }

    if (n_in_lag > 0 && sd > 0) {
      r[lag] /= n_in_lag * sd * sd;
    } else {
      r[lag] = null;
    } //console.log('r for lag ' + lag + " is " + r[lag] + " n_in_lag is " + n_in_lag + " n_good is " + n_good);

  } // Betsy Weatherhead's correction, based on lag 1


  if (r[1] >= 1) {
    r[1] = .99999;
  }

  const betsy = Math.sqrt((n_good - 1) * (1 - r[1]));
  var stde_betsy;

  if (betsy != 0) {
    stde_betsy = sd / betsy;
  } else {
    stde_betsy = null;
  }

  const stats = {
    d_mean: d_mean,
    stde_betsy: stde_betsy,
    sd: sd,
    n_good: n_good,
    lag1: r[1],
    min: minSecs,
    max: max_secs,
    minVal: minVal,
    maxVal: maxVal,
    sum: sum_d
  }; //console.log("stats are " + JSON.stringify(stats));
  // stde_betsy is standard error with auto correlation
  //console.log("---------\n\n");

  return stats;
};

const showSpinner = function () {
  if (document.getElementById("spinner")) {
    document.getElementById("spinner").style.display = "block";
  }
};

const hideSpinner = function () {
  if (document.getElementById("spinner")) {
    document.getElementById("spinner").style.display = "none";
  }
};

module.exportDefault(matsCurveUtils = {
  resetScatterApply: resetScatterApply,
  getUsedLabels: getUsedLabels,
  getNextCurveLabel: getNextCurveLabel,
  getNextCurveColor: getNextCurveColor,
  clearAllUsed: clearAllUsed,
  clearUsedLabel: clearUsedLabel,
  clearUsedColor: clearUsedColor,
  setUsedLabels: setUsedLabels,
  setUsedColorsAndLabels: setUsedColorsAndLabels,
  addDiffs: addDiffs,
  removeDiffs: removeDiffs,
  checkDiffs: checkDiffs,
  showScatterFace: showScatterFace,
  showTimeseriesFace: showTimeseriesFace,
  showProfileFace: showProfileFace,
  showDieOffFace: showDieOffFace,
  showThresholdFace: showThresholdFace,
  showValidTimeFace: showValidTimeFace,
  showDailyModelCycleFace: showDailyModelCycleFace,
  showReliabilityFace: showReliabilityFace,
  showMapFace: showMapFace,
  showHistogramFace: showHistogramFace,
  showContourFace: showContourFace,
  get_err: get_err,
  getPlotResultData: getPlotResultData,
  //setPlotResultData: setPlotResultData,
  resetPlotResultData: resetPlotResultData,
  getGraphResult: getGraphResult,
  setGraphResult: setGraphResult,
  resetGraphResult: resetGraphResult,
  showSpinner: showSpinner,
  hideSpinner: hideSpinner
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"graph_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/graph_util.js                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes(v) {
    matsTypes = v;
  }

}, 0);

// set the label for the hide show buttons (NO DATA) for the initial time here
const setNoDataLabels = function (dataset) {
  for (var c = 0; c < dataset.length; c++) {
    if (dataset[c].x.length === 0) {
      Session.set(dataset[c].curveId + "hideButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["color"] = "white";
      }

      Session.set(dataset[c].curveId + "pointsButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-points')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["color"] = "white";
      }

      Session.set(dataset[c].curveId + "errorBarButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["color"] = "white";
      }

      Session.set(dataset[c].curveId + "barChartButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-bars')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["color"] = "white";
      }

      Session.set(dataset[c].curveId + "annotateButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["color"] = "white";
      }
    } else {
      Session.set(dataset[c].curveId + "hideButtonText", 'hide curve');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide').value = 'hide curve';
        document.getElementById(dataset[c].curveId + '-curve-show-hide').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["color"] = dataset[c].marker.color;
      }

      Session.set(dataset[c].curveId + "pointsButtonText", 'hide points');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-points')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').value = 'hide points';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["color"] = dataset[c].marker.color;
      }

      Session.set(dataset[c].curveId + "errorBarButtonText", 'hide error bars');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').value = 'hide error bars';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["color"] = dataset[c].marker.color;
      }

      Session.set(dataset[c].curveId + "barChartButtonText", 'hide bars');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-bars')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').value = 'hide bars';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["color"] = dataset[c].marker.color;
      }

      Session.set(dataset[c].curveId + "annotateButtonText", 'hide annotation');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').value = 'hide annotation';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["color"] = dataset[c].marker.color;
      }
    }
  }
};

const setNoDataLabelsMap = function (dataset) {
  for (var c = 0; c < dataset.length; c++) {
    if (dataset[c].lat.length === 0) {
      Session.set(dataset[c].curveId + "heatMapButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["color"] = "white";
      }
    } else {
      Session.set(dataset[c].curveId + "heatMapButtonText", 'show heat map');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').value = 'show heat map';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["border-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["color"] = "red";
      }
    }
  }
}; // plot width helper used in multiple places


const width = function (plotType) {
  switch (plotType) {
    case matsTypes.PlotTypes.profile:
    case matsTypes.PlotTypes.scatter2d:
      // set the width square
      return squareWidthHeight();
      break;

    case matsTypes.PlotTypes.timeSeries:
    case matsTypes.PlotTypes.dailyModelCycle:
    case matsTypes.PlotTypes.dieoff:
    case matsTypes.PlotTypes.threshold:
    case matsTypes.PlotTypes.validtime:
    case matsTypes.PlotTypes.reliability:
    case matsTypes.PlotTypes.map:
    case matsTypes.PlotTypes.histogram:
    case matsTypes.PlotTypes.contour:
    case matsTypes.PlotTypes.contourDiff:
    default:
      // set the width wide
      return rectangleWidth();
      break;
  }
}; // plot height helper used in multiple places


const height = function (plotType) {
  switch (plotType) {
    case matsTypes.PlotTypes.profile:
    case matsTypes.PlotTypes.scatter2d:
      // set the height square
      return squareWidthHeight();
      break;

    case matsTypes.PlotTypes.timeSeries:
    case matsTypes.PlotTypes.dailyModelCycle:
    case matsTypes.PlotTypes.dieoff:
    case matsTypes.PlotTypes.threshold:
    case matsTypes.PlotTypes.validtime:
    case matsTypes.PlotTypes.reliability:
    case matsTypes.PlotTypes.map:
    case matsTypes.PlotTypes.histogram:
    case matsTypes.PlotTypes.contour:
    case matsTypes.PlotTypes.contourDiff:
    default:
      // set the height wide
      return rectangleHeight();
      break;
  }
};

const standAloneWidth = function () {
  var vpw = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);
  return (.9 * vpw).toString() + "px";
};

const standAloneHeight = function () {
  var vph = Math.min(document.documentElement.clientHeight, window.innerHeight || 0);
  return (.825 * vph).toString() + "px";
};

const squareWidthHeight = function () {
  var vpw = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);
  var vph = Math.min(document.documentElement.clientHeight, window.innerHeight || 0);
  var min = Math.min(vpw, vph);

  if (min < 400) {
    return (.9 * min).toString() + "px";
  } else {
    return (.7 * min).toString() + "px";
  }
};

const rectangleWidth = function () {
  var vpw = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);

  if (vpw < 400) {
    return (.9 * vpw).toString() + "px";
  } else {
    return (.9 * vpw).toString() + "px";
  }
};

const rectangleHeight = function () {
  var vph = Math.min(document.documentElement.clientHeight, window.innerHeight || 0);

  if (vph < 400) {
    return (.8 * vph).toString() + "px";
  } else {
    return (.7 * vph).toString() + "px";
  }
};

const resizeGraph = function (plotType) {
  document.getElementById('placeholder').style.width = width(plotType);
  document.getElementById('placeholder').style.height = height(plotType);
}; // helper to bring up the text page


const setTextView = function (plotType) {
  //shows text page and proper text output, hides everything else
  document.getElementById('placeholder').style.width = width(plotType);
  document.getElementById('placeholder').style.height = height(plotType);
  document.getElementById("text-page-button-group").style.display = "block";
  document.getElementById("plot-page-button-group").style.display = "none";
  document.getElementById("curves").style.display = "none";
  document.getElementById("graphView").style.display = "none";
  document.getElementById("textView").style.display = "block";
  document.getElementById('plot-control-button-group').style.display = "none";
}; // helper to bring up the graph page


const setGraphView = function (plotType) {
  document.getElementById('placeholder').style.width = width(plotType);
  document.getElementById('placeholder').style.height = height(plotType); //shows graph page, hides everything else

  document.getElementById('graph-container').style.display = 'block';
  document.getElementById('plotType').style.display = 'none';
  document.getElementById('paramList').style.display = 'none';
  document.getElementById('plotList').style.display = 'none';
  document.getElementById('curveList').style.display = 'none';

  if (document.getElementById("plotTypeContainer")) {
    document.getElementById("plotTypeContainer").style.display = "none";
  }

  if (document.getElementById("scatter2d")) {
    document.getElementById("scatter2d").style.display = "none";
  }

  if (document.getElementById("scatterView")) {
    document.getElementById("scatterView").style.display = "none";
  }

  document.getElementById("text-page-button-group").style.display = "none";
  document.getElementById("plot-page-button-group").style.display = "block";
  document.getElementById("curves").style.display = "block";
  document.getElementById("graphView").style.display = "block";
  document.getElementById("textView").style.display = "none";

  if (Session.get('plotType') !== matsTypes.PlotTypes.map) {
    document.getElementById('plot-control-button-group').style.display = "block";
  } else {
    document.getElementById('plot-control-button-group').style.display = "none";
  }
}; // helper to bring up the graph page in a pop-up window


const standAloneSetGraphView = function () {
  //shows graph page, hides everything else
  document.getElementById('placeholder').style.width = standAloneWidth();
  document.getElementById('placeholder').style.height = standAloneHeight();
  document.getElementById('graph-container').style.display = 'block';
  document.getElementById("curves").style.display = "block";
  document.getElementById("graphView").style.display = "block";
}; // helper to bring up the main selector page


const setDefaultView = function () {
  // show elements of the main page
  if (document.getElementById('paramList')) {
    document.getElementById('paramList').style.display = 'block';
  }

  if (document.getElementById('plotList')) {
    document.getElementById('plotList').style.display = 'block';
  }

  if (document.getElementById('curveList')) {
    document.getElementById('curveList').style.display = 'block';
  }

  if (document.getElementById("plotTypeContainer")) {
    document.getElementById("plotTypeContainer").style.display = "block";
  }

  if (document.getElementById("scatterView")) {
    document.getElementById("scatterView").style.display = "block";
  }

  if (document.getElementById("scatter2d")) {
    document.getElementById("scatter2d").style.display = "block";
  } // hide graph page


  if (document.getElementById('graph-container')) {
    document.getElementById('graph-container').style.display = 'none';
  }

  document.getElementById("plot-page-button-group").style.display = "block";
  document.getElementById('plot-control-button-group').style.display = "block"; // hide text page

  document.getElementById("textView").style.display = "none";
};

const downloadFile = function (fileURL, fileName) {
  // for non-IE
  if (!window.ActiveXObject) {
    var save = document.createElement('a');
    save.href = fileURL;
    save.target = '_blank';
    var filename = fileURL.substring(fileURL.lastIndexOf('/') + 1);
    save.download = fileName || filename;

    if (navigator.userAgent.toLowerCase().match(/(ipad|iphone|safari)/) && navigator.userAgent.search("Chrome") < 0) {
      document.location = save.href; // window event not working here
    } else {
      var evt = new MouseEvent('click', {
        'view': window,
        'bubbles': true,
        'cancelable': false
      });
      save.dispatchEvent(evt);
      (window.URL || window.webkitURL).revokeObjectURL(save.href);
    }
  } // for IE < 11
  else if (!!window.ActiveXObject && document.execCommand) {
      var _window = window.open(fileURL, '_blank');

      _window.document.close();

      _window.document.execCommand('SaveAs', true, fileName || fileURL);

      _window.close();
    }
};

module.exportDefault(matsGraphUtils = {
  setNoDataLabels: setNoDataLabels,
  setNoDataLabelsMap: setNoDataLabelsMap,
  width: width,
  height: height,
  standAloneWidth: standAloneWidth,
  standAloneHeight: standAloneHeight,
  resizeGraph: resizeGraph,
  setTextView: setTextView,
  setGraphView: setGraphView,
  standAloneSetGraphView: standAloneSetGraphView,
  setDefaultView: setDefaultView,
  downloadFile: downloadFile
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"select_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/select_util.js                                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsCollections, matsMethods, matsParamUtils, matsPlotUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  },

  matsMethods(v) {
    matsMethods = v;
  },

  matsParamUtils(v) {
    matsParamUtils = v;
  },

  matsPlotUtils(v) {
    matsPlotUtils = v;
  },

  matsTypes(v) {
    matsTypes = v;
  }

}, 0);

// method to refresh the peers of the current selector
const refreshPeer = function (event, param) {
  try {
    const peerName = param.peerName;

    if (peerName !== undefined) {
      // refresh the peer
      const targetParam = matsParamUtils.getParameterForName(peerName);
      const targetId = targetParam.name + '-' + targetParam.type;
      const targetElem = document.getElementById(targetId);
      const refreshMapEvent = new CustomEvent("refresh", {
        detail: {
          refElement: null
        }
      });
      targetElem.dispatchEvent(refreshMapEvent);
    }

    refreshDependents(event, param);
  } catch (e) {
    e.message = "INFO: Error in select.js refreshPeer: " + e.message;
    setInfo(e.message);
  }
}; // method to refresh the dependents of the current selector


const refreshDependents = function (event, param) {
  try {
    const dependentNames = param.dependentNames;

    if (dependentNames && Object.prototype.toString.call(dependentNames) === '[object Array]' && dependentNames.length > 0) {
      // refresh the dependents
      var selectAllbool = false;

      for (var i = 0; i < dependentNames.length; i++) {
        const name = dependentNames[i];
        const targetParam = matsParamUtils.getParameterForName(name);
        var targetId;

        if (targetParam.type === matsTypes.InputTypes.dateRange) {
          targetId = "element-" + targetParam.name;
        } else {
          targetId = targetParam.name + '-' + targetParam.type;
        }

        const targetElem = document.getElementById(targetId);

        if (document.getElementById('selectAll')) {
          selectAllbool = document.getElementById('selectAll').checked;
        }

        try {
          targetElem.dispatchEvent(new CustomEvent("refresh"));
        } catch (re) {
          re.message = "INFO: refreshDependents of: " + param.name + " dependent: " + targetParam.name + " - error: " + re.message;
          setInfo(re.message);
        }

        const elements = targetElem.options;
        const select = true;

        if (targetElem.multiple && elements !== undefined && elements.length > 0) {
          if (selectAllbool) {
            for (var i1 = 0; i1 < elements.length; i1++) {
              elements[i1].selected = select;
            }

            matsParamUtils.setValueTextForParamName(name, "");
          } else {
            const previously_selected = Session.get('selected');

            for (var i2 = 0; i2 < elements.length; i2++) {
              if (_.indexOf(previously_selected, elements[i2].text) != -1) {
                elements[i2].selected = select;
              }
            }
          }
        }
      }
    }
  } catch (e) {
    e.message = "INFO: Error in select.js refreshDependents: " + e.message;
    setInfo(e.message);
  }
}; // check for enable controlled - This select might have control of another selector


const checkDisableOther = function (param, firstRender) {
  try {
    if (param.disableOtherFor !== undefined) {
      // this param controls the enable/disable properties of at least one other param.
      // Use the options to enable disable that param.
      const controlledSelectors = Object.keys(param.disableOtherFor);

      for (var i = 0; i < controlledSelectors.length; i++) {
        const elem = matsParamUtils.getInputElementForParamName(param.name);

        if (!elem) {
          return;
        }

        const selectedOptions = elem.selectedOptions;
        const selectedText = selectedOptions && selectedOptions.length > 0 ? selectedOptions[0].text : "";

        if (firstRender == true && param.default == param.hideOtherFor[controlledSelectors[i]] || param.disableOtherFor[controlledSelectors[i]] === matsTypes.InputTypes.unused && selectedText === "" || $.inArray(selectedText, param.disableOtherFor[controlledSelectors[i]]) !== -1) {
          matsParamUtils.getInputElementForParamName(controlledSelectors[i]).disabled = true;
          matsParamUtils.setValueTextForParamName(controlledSelectors[i], matsTypes.InputTypes.unused);
        } else {
          matsParamUtils.getInputElementForParamName(controlledSelectors[i]).disabled = false;
        }
      }
    }
  } catch (e) {
    e.message = "INFO: Error in select.js checkDisableOther: " + e.message;
    setInfo(e.message);
  }
}; // check for hide controlled - This select might have control of another selector's visibility


const checkHideOther = function (param, firstRender) {
  try {
    if (param.hideOtherFor !== undefined) {
      // this param controls the visibility of at least one other param.
      const controlledSelectors = Object.keys(param.hideOtherFor);

      for (var i = 0; i < controlledSelectors.length; i++) {
        const elem = matsParamUtils.getInputElementForParamName(param.name);

        if (!elem) {
          return;
        }

        const selectedOptions = elem.selectedOptions;
        const selectedText = selectedOptions && selectedOptions.length > 0 ? selectedOptions[0].text : "";
        var otherInputElement = matsParamUtils.getInputElementForParamName(controlledSelectors[i]);
        var selectorControlElem;

        if (firstRender == true && param.default == param.hideOtherFor[controlledSelectors[i]] || param.hideOtherFor[controlledSelectors[i]] === matsTypes.InputTypes.unused && selectedText === "" || $.inArray(selectedText, param.hideOtherFor[controlledSelectors[i]]) !== -1) {
          selectorControlElem = document.getElementById(controlledSelectors[i] + '-item');

          if (selectorControlElem && selectorControlElem.style) {
            selectorControlElem.style.display = "none";
          }

          matsParamUtils.setValueTextForParamName(controlledSelectors[i], matsTypes.InputTypes.unused);
        } else {
          selectorControlElem = document.getElementById(controlledSelectors[i] + '-item');

          if (selectorControlElem && selectorControlElem.style) {
            selectorControlElem.style.display = "block";
          }

          otherInputElement && otherInputElement.options && otherInputElement.selectedIndex >= 0 && otherInputElement.options[otherInputElement.selectedIndex].scrollIntoView();
        }
      }

      matsSelectUtils.checkDisableOther(param), firstRender;
    }
  } catch (e) {
    e.message = "INFO: Error in select.js checkHideOther: " + e.message;
    setInfo(e.message);
  }
}; // refresh the selector in question to the appropriate options indicated by the values of any superior selectors


const refresh = function (event, paramName) {
  if (paramName.search('axis') === 1) {
    // this is a "brother" (hidden) scatterplot param. There is no need to refresh it or add event listeners etc.
    return;
  }

  const param = matsParamUtils.getParameterForName(paramName);
  const elem = matsParamUtils.getInputElementForParamName(paramName);
  /*
  OptionsGroups are a mechanism for displaying the select options in groups.
  A disabled option is used for the group header. Disabled options simply show up
  in the selector list in bold font and act as group titles. They are disabled so that
  they cannot be clicked. DisabledOptions are the headers that the options are to be grouped under.
  disabledOptions are optional so if there are disabledOptions they are the keys in the optionsGroups
  and they are the sort order of those keys.
  */

  const disabledOptions = matsParamUtils.getDisabledOptionsForParamName(paramName);
  const optionsGroups = param.optionsGroups;
  const optionsMap = param.optionsMap;
  const superiorNames = param.superiorNames;
  const superiorDimensionality = superiorNames !== undefined && superiorNames !== null && superiorNames.length > 0 && Array.isArray(superiorNames[0]) ? superiorNames.length : 1;
  var superiors = []; // get a list of the current superior selected values - in order of superiority i.e. [databaseValue,dataSourceValue]

  var sNames;

  if (superiorNames !== undefined) {
    if (superiorDimensionality === 1) {
      sNames = superiorNames;
    } else {
      sNames = superiorNames[0];
    }

    for (var sn = 0; sn < sNames.length; sn++) {
      var superiorElement = matsParamUtils.getInputElementForParamName(sNames[sn]);
      var selectedSuperiorValue = superiorElement.options[superiorElement.selectedIndex] === undefined ? matsParamUtils.getParameterForName(sNames[sn]).default : superiorElement.options[superiorElement.selectedIndex].text;
      superiors[0] = superiors[0] === undefined ? [] : superiors[0];
      superiors[0].push({
        element: superiorElement,
        value: selectedSuperiorValue
      });
    }

    for (var sNameIndex = 1; sNameIndex < superiorDimensionality; sNameIndex++) {
      sNames = superiorNames[sNameIndex];

      for (var sn = 0; sn < sNames.length; sn++) {
        var superiorElement = matsParamUtils.getInputElementForParamName(sNames[sn]);
        var selectedSuperiorValue = superiorElement.options[superiorElement.selectedIndex] === undefined ? matsParamUtils.getParameterForName(sNames[sn]).default : superiorElement.options[superiorElement.selectedIndex].text;
        superiors[sNameIndex] = superiors[sNameIndex] === undefined ? [] : superiors[sNameIndex];
        superiors[sNameIndex].push({
          element: superiorElement,
          value: selectedSuperiorValue
        });
      }
    }
  }
  /*
  So what are superiors now.....
  superiors = [[{element:anElement,value:aValue},{element:anElement,value:aValue}...]]
  or they might be [[{element:anElement,value:aValue},{element:anElement,value:aValue}...],[{element:anElement,value:aValue},{element:anElement,value:aValue}...],...]
     Axis-brothers:
   Axis-brothers are for scatter plots. They are a second hidden set of parameters that apply to a different axis.
   Because there may be axis "brothers" This refresh must go and
   see if there are any brother elements that are essentially hidden copies
   of this one, and also refresh their options lists
    Superior Heirarchy:
   There can be a heirarchy of superiors and dependents. The superiorNames are a list of paramNames. The most superior has the 0th index and
   the least superior has the highest index.
   The Refresh uses the superiors to get the appropriate options for a given options map.
   The way it works is that superiors are always refreshed first. The superior heirarchy selections are then used by a
   dependent to retrieve its appropriate optionsMap from the superiorOptionsMap.
   superiorsOptionsMap = {
      mostSuperiorValue0: {  // optionsMap for the most superior first value
          nextSuperiorValue0: [value0,value1,value2,value3,...],
          nextSuperiorValue1: [value0,value1,value2,value3,...],
          nextSuperiorValue2: [value0,value1,value2,value3,...],
          ...
      },
      mostSuperiorValue1:{  // optionsMap for the most superior second value
          nextSuperiorValue0: [value0,value1,value2,value3,...],
          nextSuperiorValue1: [value0,value1,value2,value3,...],
          nextSuperiorValue2: [value0,value1,value2,value3,...],
          ...
      },
      ...,
      mostSuperiorValue2:{  // optionsMap for the most superior third value
          nextSuperiorValue0: [value0,value1,value2,value3,...],
          nextSuperiorValue1: [value0,value1,value2,value3,...],
          nextSuperiorValue2: [value0,value1,value2,value3,...],
          ...
      },
   }
   */
  // find all the elements that have ids like .... "x|y|z" + "axis-" + this.name


  const name = param.name;
  const elems = document.getElementsByClassName("data-input") === undefined ? [] : document.getElementsByClassName("data-input");
  Session.set('selected', $(elem).val());

  if (elem && elem.options) {
    if (elem.selectedIndex === undefined || elem.selectedIndex === -1) {
      if (param.default !== matsTypes.InputTypes.unused) {
        elem.selectedIndex = 0;
      }
    }

    const selectedText = elem.selectedIndex >= 0 ? elem.options[elem.selectedIndex].text : matsTypes.InputTypes.unused;
    var brothers = [];

    for (var i = 0; i < elems.length; i++) {
      if (elems[i].id.indexOf(name) >= 0 && elems[i].id !== elem.id) brothers.push(elems[i]);
    }

    var myOptions = [];
    var selectedSuperiorValues = [];

    try {
      // index down through the options for the list of superiors
      // starting with the most superior down through the least superior
      // and get the options list for the first set of superiors.
      // These are the ancestral options.
      if (param.optionsMap) {
        var firstSuperiorOptions = optionsMap;
        var theseSuperiors = superiors === undefined || superiors.length === 0 ? [] : superiors[0];

        for (var theseSuperiorsIndex = 0; theseSuperiorsIndex < theseSuperiors.length; theseSuperiorsIndex++) {
          var superior = theseSuperiors[theseSuperiorsIndex];
          var selectedSuperiorValue = superior.value;
          firstSuperiorOptions = firstSuperiorOptions[selectedSuperiorValue];
        }

        myOptions = Array.isArray(firstSuperiorOptions) ? firstSuperiorOptions : Object.keys(firstSuperiorOptions);
      } else {
        myOptions = param.options;
      } // need to get the ancestral truth options because we may need to intersect the options

      /* tricky little bit here:
      SuperiorDimensionality:
       It is possible to have two superior options maps.. i.e. datasource and truth.
       In that case the superiorNames won't look like ["something","somethingelse"],
       instead it will look like [["something","somethingelse"],["someotherthing","someotherthingelse"]]
       i.e. it will be a multidimensional array.
        If the controlButton for one of these multi-dimensional superior elements is hidden ....
       matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent !== null
       it has been hidden because it has a visibility dependency on another param
       i.e. truth-data-source and truth-variable (for mean there would be no truth, but for bias
       there must always be truth...).
       In this case these are dependent upon statistic such that if the statistic is "mean" the truth-data-source and truth-variable
       are hidden. See the wfip2 main.js statistic param as an example....
       "disableOtherFor:{'truth-data-source':[statisticOptionsMap.mean][0]},"
       and
       "hideOtherFor:{'truth-data-source':[statisticOptionsMap.mean][0]},"
       are the fields that cause the truth-data-source to be hidden when statistic is set to "mean".
       In that condition (the controlButton is hidden) the superior should not be used as an intersection in the selected sites.
       matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent will be null if the controlButton
       for this element (this superior) is hidden. That is the tricky part ... it will be null.
        Also the unused superior is tested against the superior according to the truth table...
       used && unused  -> use the used
       unused and used -> use the used
       used and used -> use the intersection
       unused and unused - set the options to []
        A select may have a list of disabledOptions. These are used as optionGroup markers.
       */
      // need to get the actual options here


      for (var sNameIndex = 1; sNameIndex < superiorDimensionality; sNameIndex++) {
        // index down through the options for the list of superiors
        // starting with the most superior down through the least superior
        // and get the options list for the first set of superiors.
        // These are the ancestral options.
        var nextSuperiorOptions = optionsMap;
        var theseSuperiors = superiors === undefined || superiors.length === 0 ? [] : superiors[sNameIndex];

        for (var theseSuperiorsIndex = 0; theseSuperiorsIndex < theseSuperiors.length; theseSuperiorsIndex++) {
          var superior = theseSuperiors[theseSuperiorsIndex];
          var selectedSuperiorValue = superior.value;
          nextSuperiorOptions = nextSuperiorOptions[selectedSuperiorValue];
        } // since we now have multiple options we have to intersect them


        myOptions = _.intersection(myOptions, nextSuperiorOptions);
      }

      if (myOptions === []) {
        // none used - set to []
        matsParamUtils.setValueTextForParamName(name, matsTypes.InputTypes.unused);
      }
    } catch (e) {
      e.message = "INFO: Error in select.js refresh: determining options from superiors: " + e.message;
      setInfo(e.message);
    }

    try {
      // reset the options of the select
      // if the options are null it might be that this is the initial setup.
      // so use the optionsmap and the default options for the map
      // it might also mean that there are no superiors for this param
      if (myOptions == null) {
        // get the default options
        if (optionsGroups) {
          // optionGroups are an ordered map. It probably has options that are in the disabledOption list
          // which are used as markers in the select options pulldown. This is typical for models
          const optionsGroupsKeys = Object.keys(optionsGroups);

          for (var k = 0; k < optionsGroupsKeys.length; k++) {
            if (myOptions === null) {
              myOptions = [];
              myOptions.push(optionsGroupsKeys[k]);
              myOptions = myOptions.concat(optionsGroups[optionsGroupsKeys[k]]); // the primary group does not get sorted
            } else {
              myOptions.push(optionsGroupsKeys[k]);
              myOptions = myOptions.concat(optionsGroups[optionsGroupsKeys[k]].sort()); // non primary  groups get sorted
            }
          }
        } else {
          myOptions = param.options;
        }
      }

      var optionsAsString = "";

      if (myOptions === undefined || myOptions == null) {
        return;
      }

      var firstGroup = true;

      for (var i = 0; i < myOptions.length; i++) {
        var dIndex = disabledOptions === undefined ? -1 : disabledOptions.indexOf(myOptions[i]);

        if (dIndex >= 0) {
          // the option was found in the disabled options so it needs to be an optgroup label
          // disabled option
          if (firstGroup === true) {
            // first in group
            optionsAsString += "<optgroup label=" + myOptions[i] + ">";
            firstGroup = false;
          } else {
            optionsAsString += "</optgroup>";
            optionsAsString += "<optgroup label=" + myOptions[i] + ">";
          }
        } else {
          //regular option - the option was not found in the disabled options
          optionsAsString += "<option value='" + myOptions[i] + "'>" + myOptions[i] + "</option>";
        }
      }

      if (disabledOptions !== undefined) {
        optionsAsString += "</optgroup>";
      }

      $('select[name="' + name + '"]').empty().append(optionsAsString); //reset the selected index if it had been set prior (the list may have changed so the index may have changed)

      var selectedOptionIndex;

      if (selectedText === 'initial') {
        selectedOptionIndex = myOptions.indexOf(param.default);
      } else {
        selectedOptionIndex = myOptions.indexOf(selectedText);
      }

      var sviText = "";

      if (selectedOptionIndex == -1 && elem.selectedIndex >= 0) {
        for (var svi = 0; svi < selectedSuperiorValues.length; svi++) {
          superior = superiors[svi];

          if (matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent !== null) {
            if (svi > 0) {
              sviText += " and ";
            }

            sviText += selectedSuperiorValues[svi];
          }
        }

        setInfo("I changed your selected " + name + ": '" + selectedText + "' to '" + myOptions[0] + "' because '" + selectedText + "' is no longer an option for " + sviText);
      } // if the selectedText existed in the new options list then the selectedOptionIndex won't be -1 and we have to choose the default option


      if (selectedOptionIndex === -1) {
        // if the param default is unused set it to unused
        // else just choose the 0th element in the element options. default?
        if (param.default === matsTypes.InputTypes.unused) {
          matsParamUtils.setValueTextForParamName(name, matsTypes.InputTypes.unused);
        } else {
          elem.selectedIndex = 0;
          elem && elem.options && elem.selectedIndex >= 0 && elem.options[elem.selectedIndex].scrollIntoView();
          elem && elem.options && elem.selectedIndex >= 0 && matsParamUtils.setValueTextForParamName(name, elem.options[elem.selectedIndex].text);
        }
      } else {
        elem.selectedIndex = selectedOptionIndex;
        elem && elem.options && elem.selectedIndex >= 0 && elem.options[elem.selectedIndex].scrollIntoView();
        elem && elem.options && elem.selectedIndex >= 0 && matsParamUtils.setValueTextForParamName(name, elem.options[elem.selectedIndex].text);
      }

      for (var i = 0; i < brothers.length; i++) {
        const belem = brothers[i];
        const belemSelectedOptions = $(belem.selectedOptions).map(function () {
          return this.value;
        }).get();

        if (belemSelectedOptions === undefined || belemSelectedOptions.length === 0) {
          belem.options = [];

          for (var i1 = 0; i1 < myOptions.length; i1++) {
            belem.options[belem.options.length] = new Option(myOptions[i1], myOptions[i1], i1 == 0, i1 == 0);
          }
        }
      }
    } catch (e) {
      e.message = "INFO: Error in select.js refresh: resetting selected options: " + e.message;
      setInfo(e.message);
    }
  }

  refreshPeer(event, param);
}; // refresh function


module.exportDefault(matsSelectUtils = {
  refresh: refresh,
  refreshPeer: refreshPeer,
  refreshDependents: refreshDependents,
  checkDisableOther: checkDisableOther,
  checkHideOther: checkHideOther
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/index.js                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("./curve_util.js");
module.link("./graph_util.js");
module.link("./select_util.js");
module.link("./init.js");
module.link("../both");
module.link("./routes.js");
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"init.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/init.js                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let Meteor;
module.link("meteor/meteor", {
  Meteor(v) {
    Meteor = v;
  }

}, 0);
let matsCollections;
module.link("meteor/randyp:mats-common", {
  default(v) {
    matsCollections = v;
  }

}, 1);

if (Meteor.isClient) {
  Meteor.subscribe("CurveParams");
  Meteor.subscribe("Scatter2dParams");
  Meteor.subscribe("SavedCurveParams");
  Meteor.subscribe("PlotParams");
  Meteor.subscribe("PlotGraphFunctions");
  Meteor.subscribe("RegionsPerModel");
  Meteor.subscribe("SitesPerModel");
  Meteor.subscribe("RegionDescriptions");
  Meteor.subscribe("Models");
  Meteor.subscribe("FcstLensPerModel");
  Meteor.subscribe("ColorScheme");
  Meteor.subscribe("Settings");
  Meteor.subscribe("CurveSettings");
  Meteor.subscribe("SentAddresses");
  Meteor.subscribe("Roles");
  Meteor.subscribe("Authorization");
  Meteor.subscribe("Credentials");
  Meteor.subscribe("Databases");
  Meteor.subscribe("CurveTextPatterns");
  Meteor.subscribe("ScatterAxisTextPattern");
  Meteor.subscribe("RangePerDescriptor");
  Meteor.subscribe("SiteMap");
  Meteor.subscribe("StationMap");
  Meteor.subscribe("appName");
  Meteor.subscribe("LayoutStoreCollection");
  Session.set('Curves', []);
  Session.set('PlotParams', []);
  Accounts.ui.config({
    requestOfflineToken: {
      google: true
    }
  });
  const ref = location.href;
  const pathArray = location.href.split('/');
  const protocol = pathArray[0];
  const hostport = pathArray[2];
  const hostName = hostport.split(':')[0];
  const app = pathArray[3] == "" ? "/" : pathArray[3];
  const matsRef = protocol + "//" + hostport;
  const helpRef = ref.endsWith('/') ? ref + "help" : ref + "/help";
  Session.set("app", {
    appName: app,
    matsref: matsRef,
    appref: ref,
    helpref: helpRef,
    hostName: hostName
  });
  var collections = Object.keys(matsCollections).map(key => matsCollections[key]);
  Session.set("Mongol", {
    'collections': collections,
    'display': false,
    'opacity_normal': ".7",
    'opacity_expand': ".9",
    'disable_warning': true
  });
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"routes.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/routes.js                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let Meteor;
module.link("meteor/meteor", {
  Meteor(v) {
    Meteor = v;
  }

}, 0);
let FlowRouter;
module.link("meteor/ostrio:flow-router-extra", {
  FlowRouter(v) {
    FlowRouter = v;
  }

}, 1);
//localhost routes
FlowRouter.route('/', {
  name: 'main',

  action() {
    this.render('Home');
  }

});
FlowRouter.route('/CSV/:graphFunction/:key/:matching/:appName', {
  name: 'csv',

  action(params) {
    console.log("in csv route");
    window.location.href = FlowRouter.path;
  }

});
FlowRouter.route('/JSON/:graphFunction/:key/:matching/:appName', {
  name: 'json',

  action(params) {
    console.log("in json route");
    window.location.href = FlowRouter.path;
  }

});
FlowRouter.route('/preview/:graphFunction/:key/:matching/:appName', {
  name: 'preview',

  action(params) {
    console.log("in preview route- setting params", params);
    this.render('GraphStandAlone', params);
  }

}); //prefix routes

FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/', {
  name: 'main',

  action() {
    this.render('Home');
  }

});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/CSV/:graphFunction/:key/:matching/:appName', {
  name: 'csv',

  action(params) {
    console.log("in csv route");
    window.location.href = FlowRouter.path;
  }

});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/JSON/:graphFunction/:key/:matching/:appName', {
  name: 'json',

  action(params) {
    console.log("in json route");
    window.location.href = FlowRouter.path;
  }

});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/preview/:graphFunction/:key/:matching/:appName', {
  name: 'preview',

  action(params) {
    console.log("in preview route- setting params", params);
    this.render('GraphStandAlone', params);
  }

}); // appname routes

FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/:appName', {
  name: 'main',

  action() {
    this.render('Home');
  }

});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/*/CSV/:graphFunction/:key/:matching/:appName', {
  name: 'csv',

  action(params) {
    console.log("in csv route");
    window.location.href = FlowRouter.path;
  }

});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/*/JSON/:graphFunction/:key/:matching/:appName', {
  name: 'json',

  action(params) {
    console.log("in json route");
    window.location.href = FlowRouter.path;
  }

});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/*/preview/:graphFunction/:key/:matching/:appName', {
  name: 'preview',

  action(params) {
    console.log("in preview route- setting params", params);
    this.render('GraphStandAlone', params);
  }

}); // exception routes

FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/*/', {
  name: 'main',

  action() {
    this.render('notFound');
  }

});
FlowRouter.route('*', {
  action() {
    console.log('route: ' + ' not found');
    this.render('notFound');
  }

});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"server":{"data_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_util.js                                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes(v) {
    matsTypes = v;
  }

}, 0);
let matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  }

}, 1);
let matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils(v) {
    matsPlotUtils = v;
  }

}, 2);

//this function checks if two JSON objects are identical
const areObjectsEqual = function (o, p) {
  if (o && !p || p && !o) {
    return false;
  }

  if (JSON.stringify(o) === JSON.stringify(p)) {
    return true;
  } else {
    return false;
  }
}; //this function checks if values of subArray are also in superArray


const arrayContainsArray = function (superArray, subArray) {
  superArray.sort(function (a, b) {
    return Number(a) - Number(b);
  });
  subArray.sort(function (a, b) {
    return Number(a) - Number(b);
  });
  var i, j;

  for (i = 0, j = 0; i < superArray.length && j < subArray.length;) {
    if (superArray[i] < subArray[j]) {
      ++i;
    } else if (superArray[i] === subArray[j]) {
      ++i;
      ++j;
    } else {
      // subArray[j] not in superArray, so superArray does not contain all elements of subArray
      return false;
    }
  } // make sure there are no elements left in sub


  return j === subArray.length;
}; //this function checks if the entire array subArray is contained in superArray


const arrayContainsSubArray = function (superArray, subArray) {
  var i, j, current;

  for (i = 0; i < superArray.length; ++i) {
    if (subArray.length === superArray[i].length) {
      current = superArray[i];

      for (j = 0; j < subArray.length && subArray[j] === current[j]; ++j);

      if (j === subArray.length) return true;
    }
  }

  return false;
}; //this function checks if two arrays are identical


const arraysEqual = function (a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length !== b.length) return false;

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }

  return true;
};

const arrayUnique = function (a) {
  var arr = [];

  for (var i = 0; i < a.length; i++) {
    if (!arr.includes(a[i])) {
      arr.push(a[i]);
    }
  }

  return arr;
}; //this function finds the position of the array subArray in superArray


const findArrayInSubArray = function (superArray, subArray) {
  var i, j, current;

  for (i = 0; i < superArray.length; ++i) {
    if (subArray.length === superArray[i].length) {
      current = superArray[i];

      for (j = 0; j < subArray.length && subArray[j] === current[j]; ++j);

      if (j === subArray.length) return i;
    }
  }

  return -1;
}; //this function checks if an object is a value in another object


const objectContainsObject = function (superObject, subObject) {
  const superObjectKeys = Object.keys(superObject);
  var currentObject;

  for (var i = 0; i < superObjectKeys.length; i++) {
    currentObject = superObject[superObjectKeys[i]];

    if (areObjectsEqual(subObject, currentObject)) {
      return true;
    }
  } // if the loop completes, the subObject was not found


  return false;
}; //utility for calculating the average of an array


const average = function (data) {
  var sum = data.reduce(function (sum, value) {
    return value == null ? sum : sum + value;
  }, 0);
  var avg = sum / data.length;
  return avg;
}; //utility for calculating the stdev of an array


const stdev = function (data) {
  var avg = average(data);
  var squareDiffs = data.map(function (value) {
    var diff = value - avg;
    return diff * diff;
  });
  var avgSquareDiff = average(squareDiffs);
  var stdDev = Math.sqrt(avgSquareDiff);
  return stdDev;
}; //this function makes sure date strings are in the correct format


const dateConvert = function (dStr) {
  if (dStr === undefined || dStr === " ") {
    var now = new Date();
    var date = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
    var yr = date.getUTCFullYear();
    var day = date.getUTCDate();
    var month = date.getUTCMonth();
    var hour = date.getUTCHours();
    var minute = date.getUTCMinutes();
    return month + "/" + day + '/' + yr + ' ' + hour + ":" + minute;
  }

  var dateParts = dStr.split(' ');
  var dateArray = dateParts[0].split(/[\-\/]/); // split on - or /    01-01-2017 OR 01/01/2017

  var month = dateArray[0];
  var day = dateArray[1];
  var yr = dateArray[2];
  var hour = 0;
  var minute = 0;

  if (dateParts[1]) {
    var timeArray = dateParts[1].split(":");
    hour = timeArray[0];
    minute = timeArray[1];
  }

  return month + "/" + day + '/' + yr + ' ' + hour + ":" + minute;
}; //splits the date range string from the date selector into standardized fromDate/toDate strings,
// plus the epochs for the fromDate and toDate


const getDateRange = function (dateRange) {
  var dates = dateRange.split(' - ');
  var fromDateStr = dates[0];
  var fromDate = dateConvert(fromDateStr);
  var toDateStr = dates[1];
  var toDate = dateConvert(toDateStr);
  var fromSecs = secsConvert(fromDateStr);
  var toSecs = secsConvert(toDateStr);
  return {
    fromDate: fromDate,
    toDate: toDate,
    fromSeconds: fromSecs,
    toSeconds: toSecs
  };
}; //this function converts a date string into an epoch


const secsConvert = function (dStr) {
  if (dStr === undefined || dStr === " ") {
    var now = new Date();
    return now.getTime() / 1000;
  } else {
    var dateParts = dStr.split(' ');
    var dateArray = dateParts[0].split(/[\-\/]/); // split on - or /    01-01-2017 OR 01/01/2017

    var month = dateArray[0];
    var day = dateArray[1];
    var yr = dateArray[2];
    var hour = 0;
    var minute = 0;

    if (dateParts[1]) {
      var timeArray = dateParts[1].split(":");
      hour = timeArray[0];
      minute = timeArray[1];
    }

    var my_date = new Date(Date.UTC(yr, month - 1, day, hour, minute, 0)); // to UTC time, not local time

    var date_in_secs = my_date.getTime();
  } // to UTC time, not local time
  //return date_in_secs/1000 -3600*6;


  return date_in_secs / 1000;
}; //function to manage authorized logins for MATS


const doAuthorization = function () {
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.Authorization.remove({});
  }

  if (matsCollections.Authorization.find().count() == 0) {
    matsCollections.Authorization.insert({
      email: "randy.pierce@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "kirk.l.holub@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "jeffrey.a.hamilton@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "bonny.strong@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "molly.b.smith@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "mats.gsd@noaa.gov",
      roles: ["administrator"]
    });
  }
}; //master list of colors for MATS curves


const doColorScheme = function () {
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.ColorScheme.remove({});
  }

  if (matsCollections.ColorScheme.find().count() == 0) {
    matsCollections.ColorScheme.insert({
      colors: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,165,0)", "rgb(128,128,128)", "rgb(238,130,238)", "rgb(238,130,238)", "rgb(0,0,139)", "rgb(148,0,211)", "rgb(105,105,105)", "rgb(255,140,0)", "rgb(235,92,92)", "rgb(82,92,245)", "rgb(133,143,143)", "rgb(235,143,92)", "rgb(190,120,120)", "rgb(225,82,92)", "rgb(72,82,245)", "rgb(123,133,143)", "rgb(225,133,92)", "rgb(180,120,120)"]
    });
  }
}; //utility for google login capabilities in MATS -- broken for esrl.noaa.gov/gsd/mats?


const doCredentials = function () {
  // the gmail account for the credentials is mats.mail.daemon@gmail.com - pwd mats2015!
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.Credentials.remove({});
  }

  if (matsCollections.Credentials.find().count() == 0) {
    matsCollections.Credentials.insert({
      name: "oauth_google",
      clientId: "499180266722-aai2tddo8s9edv4km1pst88vebpf9hec.apps.googleusercontent.com",
      clientSecret: "xdU0sc7SbdOOEzSyID_PTIRE",
      refresh_token: "1/3bhWyvCMMfwwDdd4F3ftlJs3-vksgg7G8POtiOBwYnhIgOrJDtdun6zK6XiATCKT"
    });
  }
}; //another utility to assist at logging into MATS


const doRoles = function () {
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.Roles.remove({});
  }

  if (matsCollections.Roles.find().count() == 0) {
    matsCollections.Roles.insert({
      name: "administrator",
      description: "administrator privileges"
    });
  }
}; //for use in matsMethods.resetApp() to establish default settings


const doSettings = function (title, version, buildDate, appType) {
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.Settings.remove({});
  }

  if (matsCollections.Settings.find().count() == 0) {
    matsCollections.Settings.insert({
      LabelPrefix: "Curve",
      Title: title,
      appVersion: version,
      buildDate: buildDate,
      appType: appType,
      LineWidth: 3.5,
      NullFillString: "---",
      resetFromCode: false
    });
  } // always update the version, roles, and the hostname, not just if it doesn't exist...


  var settings = matsCollections.Settings.findOne({});
  const deploymentRoles = {
    "mats-dev": "development",
    "mats-int": "integration",
    "mats": "production"
  };
  var settingsId = settings._id;

  var os = Npm.require('os');

  var hostname = os.hostname().split('.')[0];
  settings['appVersion'] = version;
  settings['hostname'] = hostname;
  settings['deploymentRoles'] = JSON.stringify(deploymentRoles);
  matsCollections.Settings.update(settingsId, {
    $set: settings
  });
}; //Utility for transferring client-side parameters to the server-side methods via the "PlotParams" object in the stack.
//Add values to this object in the 'click .submit-params' event handler in plot_list.js


const getPlotParamsFromStack = function () {
  var params = {};
  const err = new Error();
  Error.captureStackTrace(err, arguments.callee.arguments.callee);
  const stack = err.stack;
  const stackElems = stack.split("\n");

  for (si = 0; si < stackElems.length; si++) {
    const sElem = stackElems[si].trim();

    if (sElem.indexOf('dataFunctions') !== -1 && sElem.startsWith("at data")) {
      const dataFunctionName = sElem.split('at ')[1];

      try {
        params = global[sElem.split('at ')[1].split(' ')[0]].arguments[0];
      } catch (noJoy) {}

      break;
    }
  }

  return params;
}; //calculates mean, stdev, and other statistics for curve data points in all apps and plot types


const get_err = function (sVals, sSecs, sLevs) {
  /* refer to perl error_library.pl sub  get_stats
   to see the perl implementation of these statics calculations.
   These should match exactly those, except that they are processed in reverse order.
   */
  const autocorr_limit = 0.95;
  const hasLevels = sLevs.length > 0;
  const plotParams = getPlotParamsFromStack();
  var outlierQCParam;

  if (plotParams["outliers"] !== "all") {
    outlierQCParam = Number(plotParams["outliers"]);
  } else {
    outlierQCParam = 100;
  }

  var subVals = [];
  var subSecs = [];
  var subLevs = [];
  var n = sVals.length;
  var n_good = 0;
  var sum_d = 0;
  var sum2_d = 0;
  var error = "";
  var i;

  for (i = 0; i < n; i++) {
    if (sVals[i] !== null && !isNaN(sVals[i])) {
      n_good = n_good + 1;
      sum_d = sum_d + sVals[i];
      sum2_d = sum2_d + sVals[i] * sVals[i];
      subVals.push(sVals[i]);
      subSecs.push(sSecs[i]);

      if (hasLevels) {
        subLevs.push(sLevs[i]);
      }
    }
  }

  var d_mean = sum_d / n_good;
  var sd2 = sum2_d / n_good - d_mean * d_mean;
  var sd = sd2 > 0 ? Math.sqrt(sd2) : sd2;
  var sd_limit = outlierQCParam * sd; //console.log("see error_library.pl l208 These are processed in reverse order to the perl code -  \nmean is " + d_mean + " sd_limit is +/- " + sd_limit + " n_good is " + n_good + " sum_d is" + sum_d + " sum2_d is " + sum2_d);
  // find minimum delta_time, if any value missing, set null

  var last_secs = 0;
  var minDelta = Number.MAX_VALUE;
  var minSecs = Number.MAX_VALUE;
  var max_secs = Number.MIN_VALUE;
  var minVal = Number.MAX_VALUE;
  var maxVal = -1 * Number.MAX_VALUE;
  var secs;
  var delta;

  for (i = 0; i < subSecs.length; i++) {
    secs = subSecs[i];
    delta = Math.abs(secs - last_secs);

    if (delta > 0 && delta < minDelta) {
      minDelta = delta;
    }

    if (secs < minSecs) {
      minSecs = secs;
    }

    if (secs > max_secs) {
      max_secs = secs;
    }

    last_secs = secs;
  }

  var data_wg = [];
  var n_gaps = 0;
  n_good = 0;
  var sum = 0;
  var sum2 = 0;

  if (minDelta < 0) {
    error = "Invalid time interval - minDelta: " + minDelta;
    console.log("matsDataUtil.getErr: Invalid time interval - minDelta: " + minDelta);
  } // remove data more than $sd_limit from mean


  var qaCorrected = [];

  for (i = 0; i < subVals.length; i++) {
    if (Math.abs(subVals[i] - d_mean) > sd_limit) {
      qaCorrected.push("removing datum " + i + " with value " + subVals[i] + " because it exceeds " + outlierQCParam + " standard deviations from the mean - mean: " + d_mean + " " + outlierQCParam + " * sd: " + sd_limit + " delta: " + (subVals[i] - d_mean)); // console.log(qaCorrected.join('\n'));

      subVals[i] = null;
    } else {
      minVal = minVal < subVals[i] ? minVal : subVals[i];
      maxVal = maxVal > subVals[i] ? maxVal : subVals[i];
      sum += subVals[i];
      sum2 += subVals[i] * subVals[i];
      n_good++;
    }
  }

  if (n_good < 1) {
    return {
      d_mean: null,
      stde_betsy: null,
      sd: null,
      n_good: n_good,
      lag1: null,
      min: null,
      max: null,
      sum: null
    };
  } // recalculate if we threw anything away.


  d_mean = sum / n_good;
  sd2 = sum2 / n_good - d_mean * d_mean;
  sd = 0;

  if (sd2 > 0) {
    sd = Math.sqrt(sd2);
  } //console.log("new mean after throwing away outliers is " + sd + " n_good is " + n_good + " sum is " + sum  + " sum2 is " + sum2 + " d_mean is " + d_mean);
  // look for gaps


  var lastSecond = -1 * Number.MAX_VALUE;
  var lastPressure = -1 * Number.MAX_VALUE;
  var n_pressures;

  if (hasLevels) {
    n_pressures = arrayUnique(subLevs).length;
  } else {
    n_pressures = 1;
  } // set lag1_t to the first time the time changes from its initial value + 1 (data zero based)
  // set lag1_p to the first time the pressure changes from its initial value + 1 (data zero based)


  var lag1_t = 0;
  var lag1_p = 0;
  var r1_t = 0; // autocorrelation for time

  var r1_p = 0; // autocorrelation for pressure

  var j = 0; // i is loop index without gaps; j is loop index with gaps

  var n_deltas = 0;

  for (i = 0; i < subSecs.length; i++) {
    var sec = subSecs[i];
    var lev;

    if (hasLevels) {
      lev = subLevs[i]; // find first time the pressure changes

      if (lag1_p === 0 && lastPressure > 0) {
        if (lev !== lastPressure) {
          lag1_p = j;
        }
      }
    }

    if (lastSecond >= 0) {
      if (lag1_t === 0 && sec !== lastSecond) {
        lag1_t = j;
      }

      if (Math.abs(sec - lastSecond) > minDelta) {
        n_deltas = (Math.abs(sec - lastSecond) / minDelta - 1) * n_pressures; // for the Autocorrelation at lag 1, it doesn't matter how many missing
        // data we put in within gaps! (But for the other AC's it does.)
        // since we're using only the AC at lag 1 for calculating std err, let's
        // save cpu time and only put in one missing datum per gap, no matter
        // how long. WRM 2/22/2019
        // but if we're using a different lag, which could happen, we'll need
        // to insert all the missing data in each gap. WRM 2/22/2019
        // $n_deltas=1;

        for (var count = 0; count < n_deltas; count++) {
          data_wg.push(null);
          n_gaps++;
          j++;
        }
      }
    }

    lastSecond = sec;

    if (hasLevels) {
      lastPressure = lev;
    }

    data_wg.push(subVals[i]);
    j++;
  } //from http://www.itl.nist.gov/div898/handbook/eda/section3/eda35c.htm


  var r = [];
  var lag_by_r = {};
  var lag1_max = lag1_p > lag1_t ? lag1_p : lag1_t;
  var r_sum = 0;
  var n_r = 0;
  var n_in_lag;
  var lag;
  var t;

  for (lag = 0; lag <= lag1_max; lag++) {
    r[lag] = 0;
    n_in_lag = 0;

    for (t = 0; t < n + n_gaps - lag; t++) {
      if (data_wg[t] != null && data_wg[t + lag] != null) {
        r[lag] += +(data_wg[t] - d_mean) * (data_wg[t + lag] - d_mean);
        n_in_lag++;
      }
    }

    if (n_in_lag > 0 && sd > 0) {
      r[lag] /= n_in_lag * sd * sd;
      r_sum += r[lag];
      n_r++;
    } else {
      r[lag] = null;
    }

    if (lag >= 1 && lag < (n + n_gaps) / 2) {
      lag_by_r[r[lag]] = lag;
    }
  }

  if (lag1_t > 0) {
    r1_t = r[lag1_t] !== undefined ? r[lag1_t] : 0;
  }

  if (lag1_p > 0) {
    r1_p = r[lag1_p] !== undefined ? r[lag1_p] : 0;
  } // Betsy Weatherhead's correction, based on lag 1, augmented by the highest
  // lag > 1 and < n/2


  if (r1_p >= autocorr_limit) {
    r1_p = autocorr_limit;
  }

  if (r1_t >= autocorr_limit) {
    r1_t = autocorr_limit;
  }

  const betsy = Math.sqrt((n_good - 1) * (1. - r1_p) * (1. - r1_t));
  var stde_betsy;

  if (betsy !== 0) {
    stde_betsy = sd / betsy;
  } else {
    stde_betsy = null;
  }

  const stats = {
    d_mean: d_mean,
    stde_betsy: stde_betsy,
    sd: sd,
    n_good: n_good,
    lag1: r[1],
    min: minSecs,
    max: max_secs,
    minVal: minVal,
    maxVal: maxVal,
    sum: sum_d,
    qaCorrected: qaCorrected
  }; //console.log("stats are " + JSON.stringify(stats));
  // stde_betsy is standard error with auto correlation
  //console.log("---------\n\n");

  return stats;
}; // utility to process the user-input histogram customization controls


const setHistogramParameters = function (plotParams) {
  var yAxisFormat = plotParams['histogram-yaxis-controls'];
  var binType = plotParams['histogram-bin-controls'];
  var binNum = 12; // default bin number

  var binStart = undefined; // default is no mandated bin start

  var binStride = undefined; // default is no mandated stride

  var pivotVal = undefined; // default is not to shift the bins over to a pivot

  var binBounds = []; // default is no specified bin bounds -- our algorithm will figure them out if this array stays empty

  switch (binType) {
    case "Set number of bins":
      // get the user's chosen number of bins
      binNum = Number(plotParams['bin-number']);

      if (isNaN(binNum)) {
        throw new Error("Error parsing bin number: please enter the desired number of bins.");
      }

      break;

    case "Make zero a bin bound":
      // let the histogram routine know that we want the bins shifted over to zero
      pivotVal = 0;
      break;

    case "Choose a bin bound":
      // let the histogram routine know that we want the bins shifted over to whatever was input
      pivotVal = Number(plotParams['bin-pivot']);

      if (isNaN(pivotVal)) {
        throw new Error("Error parsing bin pivot: please enter the desired bin pivot.");
      }

      break;

    case "Set number of bins and make zero a bin bound":
      // get the user's chosen number of bins and let the histogram routine know that we want the bins shifted over to zero
      binNum = Number(plotParams['bin-number']);

      if (isNaN(binNum)) {
        throw new Error("Error parsing bin number: please enter the desired number of bins.");
      }

      pivotVal = 0;
      break;

    case "Set number of bins and choose a bin bound":
      // get the user's chosen number of bins and let the histogram routine know that we want the bins shifted over to whatever was input
      binNum = Number(plotParams['bin-number']);

      if (isNaN(binNum)) {
        throw new Error("Error parsing bin number: please enter the desired number of bins.");
      }

      pivotVal = Number(plotParams['bin-pivot']);

      if (isNaN(pivotVal)) {
        throw new Error("Error parsing bin pivot: please enter the desired bin pivot.");
      }

      break;

    case "Manual bins":
      // try to parse whatever we've been given for bin bounds. Throw an error if they didn't follow directions to enter a comma-separated list of numbers.
      try {
        binBounds = plotParams['bin-bounds'].split(",").map(function (item) {
          item.trim();
          item = Number(item);

          if (!isNaN(item)) {
            return item;
          } else {
            throw new Error("Error parsing bin bounds: please enter  at least two numbers delimited by commas.");
          }
        });
        binNum = binBounds.length + 1; // add 1 because these are inner bin bounds
      } catch (e) {
        throw new Error("Error parsing bin bounds: please enter  at least two numbers delimited by commas.");
      } // make sure that we've been given at least two good bin bounds (enough to make one bin).


      if (binNum < 3) {
        throw new Error("Error parsing bin bounds: please enter at least two numbers delimited by commas.");
      }

      break;

    case "Manual bin start, number, and stride":
      // get the bin start, number, and stride.
      binNum = Number(plotParams['bin-number']);

      if (isNaN(binNum)) {
        throw new Error("Error parsing bin number: please enter the desired number of bins.");
      }

      binStart = Number(plotParams['bin-start']);

      if (isNaN(binStart)) {
        throw new Error("Error parsing bin start: please enter the desired bin start.");
      }

      binStride = Number(plotParams['bin-stride']);

      if (isNaN(binStride)) {
        throw new Error("Error parsing bin stride: please enter the desired bin stride.");
      }

      break;

    case "Default bins":
    default:
      break;
  }

  return {
    yAxisFormat: yAxisFormat,
    binNum: binNum,
    binStart: binStart,
    binStride: binStride,
    pivotVal: pivotVal,
    binBounds: binBounds
  };
}; // utility that takes arrays of seconds and values and produces a data structure containing bin information for histogram plotting


const calculateHistogramBins = function (curveSubStats, curveSubSecs, binParams) {
  // binStart and binStride will only be defined if the user wants to specify the bin spacing.
  // otherwise, we'll use the mean and standard deviation of the data to space the bins.
  // pivotVal will only be defined if the user wants to shift the bin limits to align with a certain value.
  // otherwise, we'll keep everything aligned with the data mean.
  var binStats = {};
  var binUpBounds = [];
  var binLowBounds = [];
  var binMeans = []; // calculate the global stats across all of the data

  const globalStats = get_err(curveSubStats, curveSubSecs, []); // we don't need levels for the mean or sd calculations, so just pass in an empty array

  const glob_mean = globalStats.d_mean;
  const glob_sd = globalStats.sd;
  var fullLowBound;
  var fullUpBound;
  var fullRange;
  var binInterval;

  if (binParams.binStart === undefined || binParams.binStride === undefined) {
    // use the global stats to determine the bin bounds -- should be based on dividing up +/- 3*sd from the mean into requested number of bins
    fullLowBound = glob_mean - 3 * glob_sd;
    fullUpBound = glob_mean + 3 * glob_sd;
    fullRange = 6 * glob_sd;
    binInterval = fullRange / (binParams.binNum - 2); // take off two bins from the total number of requested bins to represent values either less than - 3*sd from the mean or greater than 3*sd from the mean
  } else {
    // use the user-defined start, number, and stride to determine the bin bounds
    fullLowBound = binParams.binStart;
    fullUpBound = binParams.binStart + (binParams.binNum - 2) * binParams.binStride; // take off two bins from the total number of requested bins to represent values that fall outside of the prescribed range

    fullRange = (binParams.binNum - 2) * binParams.binStride;
    binInterval = binParams.binStride;
  } // store an array of the upper and lower bounding values for each bin.


  binUpBounds[0] = fullLowBound; // the first upper bound should be exactly - 3*sd from the mean, or the previously calculated fullLowBound

  binLowBounds[0] = -1 * Number.MAX_VALUE;
  binMeans[0] = fullLowBound - binInterval / 2;

  for (var b_idx = 1; b_idx < binParams.binNum - 1; b_idx++) {
    binUpBounds[b_idx] = binUpBounds[b_idx - 1] + binInterval; // increment from fullLowBound to get the rest of the bin upper limits

    binLowBounds[b_idx] = binUpBounds[b_idx - 1];
    binMeans[b_idx] = binUpBounds[b_idx - 1] + binInterval / 2;
  }

  binUpBounds[binParams.binNum - 1] = Number.MAX_VALUE; // the last bin should have everything too large to fit into the previous bins, so make its upper bound the max number value

  binLowBounds[binParams.binNum - 1] = fullUpBound;
  binMeans[binParams.binNum - 1] = fullUpBound + binInterval / 2;

  if (binParams.pivotVal !== undefined && !isNaN(binParams.pivotVal)) {
    // need to shift the bounds and means over so that one of the bounds is on the chosen pivot
    var closestBoundToPivot = binLowBounds.reduce(function (prev, curr) {
      return Math.abs(curr - binParams.pivotVal) < Math.abs(prev - binParams.pivotVal) ? curr : prev;
    });
    binUpBounds = binUpBounds.map(function (val) {
      return val - (closestBoundToPivot - binParams.pivotVal);
    });
    binLowBounds = binLowBounds.map(function (val) {
      return val - (closestBoundToPivot - binParams.pivotVal);
    });
    binMeans = binMeans.map(function (val) {
      return val - (closestBoundToPivot - binParams.pivotVal);
    });
  } // calculate the labels for each bin, based on the data bounding range, for the graph x-axis later


  var binLabels = [];
  var lowSdFromMean;
  var upSdFromMean;

  for (b_idx = 0; b_idx < binParams.binNum; b_idx++) {
    lowSdFromMean = binLowBounds[b_idx].toFixed(2);
    upSdFromMean = binUpBounds[b_idx].toFixed(2);

    if (b_idx === 0) {
      binLabels[b_idx] = "< " + upSdFromMean;
    } else if (b_idx === binParams.binNum - 1) {
      binLabels[b_idx] = "> " + lowSdFromMean;
    } else {
      binLabels[b_idx] = lowSdFromMean + "-" + upSdFromMean;
    }
  }

  binStats['glob_mean'] = glob_mean;
  binStats['glob_sd'] = glob_sd;
  binStats['binUpBounds'] = binUpBounds;
  binStats['binLowBounds'] = binLowBounds;
  binStats['binMeans'] = binMeans;
  binStats['binLabels'] = binLabels;
  return {
    'binStats': binStats
  };
}; // utility that takes an array of user-defined bin bounds and produces a data structure containing bin information for histogram plotting


const prescribeHistogramBins = function (curveSubStats, curveSubSecs, binParams) {
  var binStats = {}; // calculate the global stats across all of the data

  const globalStats = get_err(curveSubStats, curveSubSecs, []); // we don't need levels for the mean or sd calculations, so just pass in an empty array

  const glob_mean = globalStats.d_mean;
  const glob_sd = globalStats.sd; // make sure the user-defined bins are in order from least to greatest

  binParams.binBounds = binParams.binBounds.sort(function (a, b) {
    return Number(a) - Number(b);
  }); // store an array of the upper and lower bounding values for each bin.

  var binUpBounds = [];
  var binLowBounds = [];
  var binMeans = [];
  var binIntervalSum = 0;

  for (var b_idx = 1; b_idx < binParams.binNum - 1; b_idx++) {
    binUpBounds[b_idx] = binParams.binBounds[b_idx];
    binLowBounds[b_idx] = binParams.binBounds[b_idx - 1];
    binMeans[b_idx] = (binUpBounds[b_idx] + binLowBounds[b_idx]) / 2;
    binIntervalSum = binIntervalSum + (binUpBounds[b_idx] - binLowBounds[b_idx]);
  }

  const binIntervalAverage = binIntervalSum / (binParams.binNum - 2);
  binUpBounds[0] = binLowBounds[1];
  binLowBounds[0] = -1 * Number.MAX_VALUE; // the first bin should have everything too small to fit into the other bins, so make its lower bound -1 * the max number value

  binMeans[0] = binLowBounds[1] - binIntervalAverage / 2; // the bin means for the edge bins is a little arbitrary, so base it on the average bin width

  binUpBounds[binParams.binNum - 1] = Number.MAX_VALUE; // the last bin should have everything too large to fit into the previous bins, so make its upper bound the max number value

  binLowBounds[binParams.binNum - 1] = binUpBounds[binParams.binNum - 2];
  binMeans[binParams.binNum - 1] = binUpBounds[binParams.binNum - 2] + binIntervalAverage / 2; // the bin means for the edge bins is a little arbitrary, so base it on the average bin width
  // calculate the labels for each bin, based on the data bounding range, for the graph x-axis later

  var binLabels = [];
  var lowSdFromMean;
  var upSdFromMean;

  for (b_idx = 0; b_idx < binParams.binNum; b_idx++) {
    lowSdFromMean = binLowBounds[b_idx].toFixed(2);
    upSdFromMean = binUpBounds[b_idx].toFixed(2);

    if (b_idx === 0) {
      binLabels[b_idx] = "< " + upSdFromMean;
    } else if (b_idx === binParams.binNum - 1) {
      binLabels[b_idx] = "> " + lowSdFromMean;
    } else {
      binLabels[b_idx] = lowSdFromMean + "-" + upSdFromMean;
    }
  }

  binStats['glob_mean'] = glob_mean;
  binStats['glob_sd'] = glob_sd;
  binStats['binUpBounds'] = binUpBounds;
  binStats['binLowBounds'] = binLowBounds;
  binStats['binMeans'] = binMeans;
  binStats['binLabels'] = binLabels;
  return {
    'binStats': binStats
  };
}; // utility that takes arrays of seconds, values, and optionally levels, and produces a data structure for histogram data
// processing. Used in the initial histogram DB query and in matching.


const sortHistogramBins = function (curveSubStats, curveSubSecs, curveSubLevs, binNum, masterBinStats, hasLevels, d) {
  // need maps to hold the sub values and seconds (and levels) for each bin, after the bin bounds are calculated.
  var binSubStats = {};
  var binSubSecs = {};
  var binSubLevs = {};

  for (var b_idx = 0; b_idx < binNum; b_idx++) {
    binSubStats[b_idx] = [];
    binSubSecs[b_idx] = [];
    binSubLevs[b_idx] = [];
  } // calculate the global stats across all of the data


  var globalStats;

  if (hasLevels) {
    globalStats = get_err(curveSubStats, curveSubSecs, curveSubLevs);
  } else {
    globalStats = get_err(curveSubStats, curveSubSecs, []);
  }

  const glob_mean = globalStats.d_mean;
  const glob_sd = globalStats.sd;
  const glob_n = globalStats.n_good;
  const glob_max = globalStats.maxVal;
  const glob_min = globalStats.minVal; // sort data into bins

  const binUpBounds = masterBinStats.binUpBounds;
  const binLowBounds = masterBinStats.binLowBounds;
  const binMeans = masterBinStats.binMeans;
  const binLabels = masterBinStats.binLabels;

  for (var d_idx = 0; d_idx < curveSubStats.length; d_idx++) {
    // iterate through all of the bins until we find one where the upper limit is greater than our datum.
    for (b_idx = 0; b_idx < binNum; b_idx++) {
      if (curveSubStats[d_idx] <= binUpBounds[b_idx]) {
        binSubStats[b_idx].push(curveSubStats[d_idx]);
        binSubSecs[b_idx].push(curveSubSecs[d_idx]);

        if (hasLevels) {
          binSubLevs[b_idx].push(curveSubLevs[d_idx]);
        }

        break;
      }
    }
  } // calculate the statistics for each bin
  // we are especially interested in the number of values in each bin, as that is the plotted stat in a histogram


  var binStats;
  var bin_mean;
  var bin_sd;
  var bin_n;
  var bin_rf;
  var sum = 0;
  var count = 0;

  for (b_idx = 0; b_idx < binNum; b_idx++) {
    if (hasLevels) {
      binStats = get_err(binSubStats[b_idx], binSubSecs[b_idx], binSubLevs[b_idx]);
    } else {
      binStats = get_err(binSubStats[b_idx], binSubSecs[b_idx], []);
    }

    bin_mean = binStats.d_mean;
    bin_sd = binStats.sd;
    bin_n = binStats.n_good;
    bin_rf = bin_n / glob_n;
    /*
    var d = {// d will contain the curve data
        x: [], //placeholder
        y: [], //placeholder
        error_x: [], // unused
        error_y: [], // unused
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {}, // placeholder
        bin_stats: [], // placeholder
        text: [], //placeholder
        xmax: Number.MIN_VALUE,
        xmin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE
    };
    */

    d.x.push(binMeans[b_idx]);
    d.y.push(bin_n);
    d.subVals.push(binSubStats[b_idx]);
    d.subSecs.push(binSubSecs[b_idx]);
    d.bin_stats.push({
      'bin_mean': bin_mean,
      'bin_sd': bin_sd,
      'bin_n': bin_n,
      'bin_rf': bin_rf,
      'binLowBound': binLowBounds[b_idx],
      'binUpBound': binUpBounds[b_idx],
      'binLabel': binLabels[b_idx]
    });
    d.text.push(null);

    if (hasLevels) {
      d.subLevs.push(binSubLevs[b_idx]);
    } // set axis limits based on returned data


    if (d.y[b_idx] !== null) {
      sum = sum + d.y[b_idx];
      count++;
      d.ymin = d.ymin < d.y[b_idx] ? d.ymin : d.y[b_idx];
      d.ymax = d.ymax > d.y[b_idx] ? d.ymax : d.y[b_idx];
    }
  }

  d.glob_stats = {
    'glob_mean': glob_mean,
    'glob_sd': glob_sd,
    'glob_n': glob_n,
    'glob_max': glob_max,
    'glob_min': glob_min
  };
  d.xmin = d.x[0];
  d.xmax = d.x[binNum - 1];
  return {
    d: d
  };
}; // utility that takes the curve params for two contour plots and collapses them into the curve params for one diff contour.


const getDiffContourCurveParams = function (curves) {
  var newCurve = {};
  const curveKeys = Object.keys(curves[0]);
  var currKey;

  for (var ckidx = 0; ckidx < curveKeys.length; ckidx++) {
    currKey = curveKeys[ckidx];

    if (currKey === 'color') {
      newCurve['color'] = "rgb(255,165,0)";
    } else if (curves[0][currKey] === curves[1][currKey]) {
      newCurve[currKey] = curves[0][currKey];
    } else {
      newCurve[currKey] = curves[1][currKey] + "-" + curves[0][currKey];
    }
  }

  return [newCurve];
}; //used for sorting arrays


const sortFunction = function (a, b) {
  if (a[0] === b[0]) {
    return 0;
  } else {
    return a[0] < b[0] ? -1 : 1;
  }
};

module.exportDefault(matsDataUtils = {
  areObjectsEqual: areObjectsEqual,
  arrayContainsArray: arrayContainsArray,
  arrayContainsSubArray: arrayContainsSubArray,
  arraysEqual: arraysEqual,
  arrayUnique: arrayUnique,
  findArrayInSubArray: findArrayInSubArray,
  objectContainsObject: objectContainsObject,
  average: average,
  stdev: stdev,
  dateConvert: dateConvert,
  getDateRange: getDateRange,
  secsConvert: secsConvert,
  doAuthorization: doAuthorization,
  doColorScheme: doColorScheme,
  doCredentials: doCredentials,
  doRoles: doRoles,
  doSettings: doSettings,
  getPlotParamsFromStack: getPlotParamsFromStack,
  get_err: get_err,
  setHistogramParameters: setHistogramParameters,
  calculateHistogramBins: calculateHistogramBins,
  prescribeHistogramBins: prescribeHistogramBins,
  sortHistogramBins: sortHistogramBins,
  getDiffContourCurveParams: getDiffContourCurveParams,
  sortFunction: sortFunction
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_query_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_query_util.js                                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsDataUtils, matsTypes, matsCollections;
module.link("meteor/randyp:mats-common", {
  matsDataUtils(v) {
    matsDataUtils = v;
  },

  matsTypes(v) {
    matsTypes = v;
  },

  matsCollections(v) {
    matsCollections = v;
  }

}, 0);
let Meteor;
module.link("meteor/meteor", {
  Meteor(v) {
    Meteor = v;
  }

}, 1);

//const Future = require('fibers/future');
//utility to get the cadence for a particular model, so that the query function
//knows where to include null points for missing data.
const getModelCadence = function (pool, dataSource, startDate, endDate) {
  var rows = [];
  var cycles;

  try {
    //this query should only return data if the model cadence is irregular.
    //otherwise, the cadence will be calculated later by the query function.
    rows = simplePoolQueryWrapSynchronous(pool, "select cycle_seconds " + "from mats_common.primary_model_orders " + "where model = " + "(select new_model as display_text from mats_common.standardized_model_list where old_model = '" + dataSource + "');");
    var cycles_raw = JSON.parse(rows[0].cycle_seconds);
    var cycles_keys = Object.keys(cycles_raw).sort(); //there can be difference cadences for different time periods (each time period is a key in cycles_keys,
    //with the cadences for that period represented as values in cycles_raw), so this section identifies all
    //time periods relevant to the requested date range, and returns the union of their cadences.

    if (cycles_keys.length !== 0) {
      var newTime;
      var chosenStartTime;
      var chosenEndTime;
      var chosenStartIdx;
      var chosenEndIdx;
      var foundStart = false;
      var foundEnd = false;

      for (var ti = cycles_keys.length - 1; ti >= 0; ti--) {
        newTime = cycles_keys[ti];

        if (startDate >= Number(newTime) && !foundStart) {
          chosenStartTime = newTime;
          chosenStartIdx = ti;
          foundStart = true;
        }

        if (endDate >= Number(newTime) && !foundEnd) {
          chosenEndTime = newTime;
          chosenEndIdx = ti;
          foundEnd = true;
        }

        if (foundStart && foundEnd) {
          break;
        }
      }

      if (chosenStartTime !== undefined && chosenEndTime !== undefined) {
        if (Number(chosenStartTime) === Number(chosenEndTime)) {
          cycles = cycles_raw[chosenStartTime];
        } else if (chosenEndIdx - chosenStartIdx === 1) {
          const startCycles = cycles_raw[chosenStartTime];
          const endCycles = cycles_raw[chosenEndTime];
          cycles = _.union(startCycles, endCycles);
        } else {
          var middleCycles = [];
          var currCycles;

          for (ti = chosenStartIdx + 1; ti < chosenEndIdx; ti++) {
            currCycles = cycles_raw[cycles_keys[ti]];
            middleCycles = _.union(middleCycles, currCycles);
          }

          const startCycles = cycles_raw[chosenStartTime];
          const endCycles = cycles_raw[chosenEndTime];
          cycles = _.union(startCycles, endCycles, middleCycles);
        }
      }
    }
  } catch (e) {//ignore - just a safety check, don't want to exit if there isn't a cycles_per_model entry
    //if there isn't a cycles_per_model entry, it just means that the model has a regular cadence
  }

  if (cycles !== null && cycles !== undefined && cycles.length > 0) {
    for (var c = 0; c < cycles.length; c++) {
      cycles[c] = cycles[c] * 1000; // convert to milliseconds
    }
  } else {
    cycles = []; //regular cadence model--cycles will be calculated later by the query function
  }

  return cycles;
}; //this function calculates the interval between the current time and the next time for irregular cadence models.


const getTimeInterval = function (avTime, time_interval, foreCastOffset, cycles) {
  //have to calculate the time_interval
  var ti;
  var dayInMilliSeconds = 24 * 3600 * 1000;
  var minCycleTime = Math.min(...cycles);
  var thisCadence = avTime % dayInMilliSeconds; //current hour of day (valid time)

  if (Number(thisCadence) - Number(foreCastOffset) * 3600 * 1000 < 0) {
    //check to see if cycle time was on previous day -- if so, need to wrap around 00Z to get current hour of day (cycle time)
    thisCadence = Number(thisCadence) - Number(foreCastOffset) * 3600 * 1000 + dayInMilliSeconds; //current hour of day (cycle time)
  } else {
    thisCadence = Number(thisCadence) - Number(foreCastOffset) * 3600 * 1000; //current hour of day (cycle time)
  }

  var thisCadenceIdx = cycles.indexOf(thisCadence); //fnd our where the current hour of day is in the cycles array

  if (thisCadenceIdx !== -1) {
    var nextCadenceIdx = thisCadenceIdx + 1; //choose the next hour of the day

    if (nextCadenceIdx >= cycles.length) {
      ti = dayInMilliSeconds - thisCadence + minCycleTime; //if we were at the last cycle cadence, wrap back around to the first cycle cadence
    } else {
      ti = cycles[nextCadenceIdx] - cycles[thisCadenceIdx]; //otherwise take the difference between the current and next hours of the day.
    }
  } else {
    ti = time_interval; //if for some reason the current hour of the day isn't in the cycles array, default to the regular cadence interval
  }

  return ti;
}; //utility for querying the DB


const simplePoolQueryWrapSynchronous = function (pool, statement) {
  /*
   simple synchronous query of statement to the specified pool.
   params :
   pool - a predefined db pool (usually defined in main.js). i.e. wfip2Pool = mysql.createPool(wfip2Settings);
   statement - String - a valid sql statement
   actions - queries database and will wait until query returns.
   return: rowset - an array of rows
   throws: error
   */
  if (Meteor.isServer) {
    const Future = require('fibers/future');

    const queryWrap = Future.wrap(function (pool, statement, callback) {
      pool.query(statement, function (err, rows) {
        return callback(err, rows);
      });
    });
    return queryWrap(pool, statement).wait();
  }
}; //this method queries the database for timeseries plots


const queryDBTimeSeries = function (pool, statement, dataSource, forecastOffset, startDate, endDate, averageStr, validTimes, hasLevels, forceRegularCadence) {
  //upper air is only verified at 00Z and 12Z, so you need to force irregular models to verify at that regular cadence
  const Future = require('fibers/future');

  if (Meteor.isServer) {
    const plotParams = matsDataUtils.getPlotParamsFromStack();
    const completenessQCParam = Number(plotParams["completeness"]) / 100;
    var cycles = getModelCadence(pool, dataSource, startDate, endDate); // if irregular model cadence, get cycle times. If regular, get empty array.

    if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {
      var vtCycles = validTimes.map(function (x) {
        return (Number(x) - forecastOffset) * 3600 * 1000;
      }); // selecting validTimes makes the cadence irregular

      vtCycles = vtCycles.map(function (x) {
        return x < 0 ? x + 24 * 3600 * 1000 : x;
      }); // make sure no cycles are negative

      vtCycles = vtCycles.sort(function (a, b) {
        return Number(a) - Number(b);
      }); //sort 'em

      cycles = cycles.length > 0 ? _.intersection(cycles, vtCycles) : vtCycles; // if we already had cycles get the ones that correspond to valid times
    }

    const regular = forceRegularCadence || averageStr !== "None" || !(cycles !== null && cycles.length > 0); // If curves have averaging, the cadence is always regular, i.e. it's the cadence of the average

    var dFuture = new Future();
    var d = {
      // d will contain the curve data
      x: [],
      y: [],
      error_x: [],
      error_y: [],
      subVals: [],
      subSecs: [],
      subLevs: [],
      stats: [],
      text: [],
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE,
      sum: 0
    };
    var error = "";
    var N0 = [];
    var N_times = [];
    pool.query(statement, function (err, rows) {
      // query callback - build the curve data from the results - or set an error
      if (err !== undefined && err !== null) {
        error = err.message;
      } else if (rows === undefined || rows === null || rows.length === 0) {
        error = matsTypes.Messages.NO_DATA_FOUND;
      } else {
        const parsedData = parseQueryDataTimeSeries(pool, rows, d, completenessQCParam, hasLevels, averageStr, forecastOffset, cycles, regular);
        d = parsedData.d;
        N0 = parsedData.N0;
        N_times = parsedData.N_times;
        cycles = parsedData.cycles;
      } // done waiting - have results


      dFuture['return']();
    }); // wait for future to finish

    dFuture.wait();
    return {
      data: d,
      error: error,
      N0: N0,
      N_times: N_times,
      averageStr: averageStr,
      cycles: cycles
    };
  }
}; //this method queries the database for specialty curves such as profiles, dieoffs, threshold plots, valid time plots, and histograms


const queryDBSpecialtyCurve = function (pool, statement, plotType, hasLevels) {
  if (Meteor.isServer) {
    const Future = require('fibers/future');

    const plotParams = matsDataUtils.getPlotParamsFromStack();
    const completenessQCParam = Number(plotParams["completeness"]) / 100;
    const appType = matsCollections.Settings.findOne({}).appType;
    var dFuture = new Future();
    var d = {
      // d will contain the curve data
      x: [],
      y: [],
      error_x: [],
      error_y: [],
      subVals: [],
      subSecs: [],
      subLevs: [],
      stats: [],
      text: [],
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE,
      sum: 0
    };
    var error = "";
    var N0 = [];
    var N_times = [];
    pool.query(statement, function (err, rows) {
      // query callback - build the curve data from the results - or set an error
      if (err !== undefined && err !== null) {
        error = err.message;
      } else if (rows === undefined || rows === null || rows.length === 0) {
        error = matsTypes.Messages.NO_DATA_FOUND;
      } else {
        var parsedData;

        if (plotType !== matsTypes.PlotTypes.histogram) {
          parsedData = parseQueryDataSpecialtyCurve(rows, d, completenessQCParam, plotType, appType, hasLevels);
        } else {
          parsedData = parseQueryDataHistogram(d, rows, hasLevels);
        }

        d = parsedData.d;
        N0 = parsedData.N0;
        N_times = parsedData.N_times;
      }

      dFuture['return']();
    }); // wait for future to finish

    dFuture.wait();
    return {
      data: d,
      error: error,
      N0: N0,
      N_times: N_times
    };
  }
}; //this method queries the database for map plots


const queryMapDB = function (pool, statement, dataSource, variable, varUnits, siteMap) {
  if (Meteor.isServer) {
    // d will contain the curve data
    var d = {
      siteName: [],
      queryVal: [],
      lat: [],
      lon: [],
      color: [],
      stats: [],
      text: []
    }; // for biases <= -1

    var dBlue = {
      siteName: [],
      queryVal: [],
      lat: [],
      lon: [],
      stats: [],
      text: [],
      color: "rgb(0,0,255)"
    }; // for biases > -1 and < 1

    var dBlack = {
      siteName: [],
      queryVal: [],
      lat: [],
      lon: [],
      stats: [],
      text: [],
      color: "rgb(0,0,0)"
    }; // for biases >= 1

    var dRed = {
      siteName: [],
      queryVal: [],
      lat: [],
      lon: [],
      stats: [],
      text: [],
      color: "rgb(255,0,0)"
    };
    var error = "";

    const Future = require('fibers/future');

    var pFuture = new Future();
    pool.query(statement, function (err, rows) {
      // query callback - build the curve data from the results - or set an error
      if (err !== undefined && err !== null) {
        error = err.message;
      } else if (rows === undefined || rows === null || rows.length === 0) {
        error = matsTypes.Messages.NO_DATA_FOUND;
      } else {
        var queryVal;

        for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
          const site = rows[rowIndex].sta_name;
          queryVal = rows[rowIndex].model_ob_diff;
          d.siteName.push(site);
          d.queryVal.push(queryVal);
          d.stats.push({
            N_times: rows[rowIndex].N_times,
            min_time: rows[rowIndex].min_time,
            max_time: rows[rowIndex].max_time
          });
          var tooltips = site + "<br>" + "variable: " + variable + "<br>" + "model: " + dataSource + "<br>" + "model-obs: " + queryVal + " " + varUnits + "<br>" + "n: " + rows[rowIndex].N_times;
          d.text.push(tooltips);
          var thisSite = siteMap.find(obj => {
            return obj.name === site;
          });
          d.lat.push(thisSite.point[0]);
          d.lon.push(thisSite.point[1]);
          var textMarker = queryVal === null ? "" : queryVal.toFixed(0);

          if (queryVal <= -1) {
            d.color.push("rgb(0,0,255)");
            dBlue.siteName.push(site);
            dBlue.queryVal.push(queryVal);
            dBlue.text.push(textMarker);
            dBlue.lat.push(thisSite.point[0]);
            dBlue.lon.push(thisSite.point[1]);
          } else if (queryVal >= 1) {
            d.color.push("rgb(255,0,0)");
            dRed.siteName.push(site);
            dRed.queryVal.push(queryVal);
            dRed.text.push(textMarker);
            dRed.lat.push(thisSite.point[0]);
            dRed.lon.push(thisSite.point[1]);
          } else {
            d.color.push("rgb(0,0,0)");
            dBlack.siteName.push(site);
            dBlack.queryVal.push(queryVal);
            dBlack.text.push(textMarker);
            dBlack.lat.push(thisSite.point[0]);
            dBlack.lon.push(thisSite.point[1]);
          }
        } // end of loop row

      } // done waiting - have results


      pFuture['return']();
    }); // wait for future to finish

    pFuture.wait();
    return {
      data: d,
      // [sub_values,sub_secs] as arrays
      dataBlue: dBlue,
      // [sub_values,sub_secs] as arrays
      dataBlack: dBlack,
      // [sub_values,sub_secs] as arrays
      dataRed: dRed,
      // [sub_values,sub_secs] as arrays
      error: error
    };
  }
}; //this method queries the database for contour plots


const queryDBContour = function (pool, statement) {
  if (Meteor.isServer) {
    const Future = require('fibers/future');

    var dFuture = new Future();
    var d = {
      // d will contain the curve data
      x: [],
      y: [],
      z: [],
      n: [],
      text: [],
      xTextOutput: [],
      yTextOutput: [],
      zTextOutput: [],
      nTextOutput: [],
      minDateTextOutput: [],
      maxDateTextOutput: [],
      stats: [],
      glob_stats: {},
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE,
      zmin: Number.MAX_VALUE,
      zmax: Number.MIN_VALUE,
      sum: 0
    };
    var error = "";
    pool.query(statement, function (err, rows) {
      // query callback - build the curve data from the results - or set an error
      if (err !== undefined && err !== null) {
        error = err.message;
      } else if (rows === undefined || rows === null || rows.length === 0) {
        error = matsTypes.Messages.NO_DATA_FOUND;
      } else {
        const parsedData = parseQueryDataContour(rows, d);
        d = parsedData.d;
      }

      dFuture['return']();
    }); // wait for future to finish

    dFuture.wait();
    return {
      data: d,
      error: error
    };
  }
}; //this method parses the returned query data for timeseries plots


const parseQueryDataTimeSeries = function (pool, rows, d, completenessQCParam, hasLevels, averageStr, foreCastOffset, cycles, regular) {
  /*
      var d = {// d will contain the curve data
          x: [],
          y: [],
          error_x: [],   // curveTime
          error_y: [],   // values
          subVals: [],   //subVals
          subSecs: [],   //subSecs
          subLevs: [],   //subLevs
          stats: [],     //pointStats
          text: [],
          glob_stats: {},     //curveStats
          xmin: Number.MAX_VALUE,
          xmax: Number.MIN_VALUE,
          ymin: Number.MAX_VALUE,
          ymax: Number.MIN_VALUE,
          sum: 0
      };
  */
  d.error_x = null; // time series doesn't use x errorbars

  var N0 = [];
  var N_times = [];
  var xmax = Number.MIN_VALUE;
  var xmin = Number.MAX_VALUE;
  var curveTime = [];
  var curveStats = [];
  var subVals = [];
  var subSecs = [];
  var subLevs = [];
  var time_interval = rows.length > 1 ? Number(rows[1].avtime) - Number(rows[0].avtime) : undefined; //calculate a base time interval -- will be used if data is regular

  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var avSeconds = Number(rows[rowIndex].avtime);
    var avTime = avSeconds * 1000;
    xmin = avTime < xmin ? avTime : xmin;
    xmax = avTime > xmax ? avTime : xmax;
    var stat = rows[rowIndex].stat;
    N0.push(rows[rowIndex].N0); // number of values that go into a time series point

    N_times.push(rows[rowIndex].N_times); // number of times that go into a time series point
    // find the minimum time_interval. For regular models, this will differ from the previous time_interval
    // if the interval was artificially large due to missing values. For irregular models, we need the minimum
    // interval to be sure we don't accidentally go past the next data point.

    if (rowIndex < rows.length - 1) {
      var time_diff = Number(rows[rowIndex + 1].avtime) - Number(rows[rowIndex].avtime);

      if (time_diff < time_interval) {
        time_interval = time_diff;
      }
    } // store sub values that will later be used for calculating error bar statistics.


    var sub_values = [];
    var sub_secs = [];
    var sub_levs = [];

    if (stat !== null && stat !== "NULL" && rows[rowIndex].sub_data !== undefined) {
      try {
        var sub_data = rows[rowIndex].sub_data.toString().split(',');
        var curr_sub_data;

        for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {
          curr_sub_data = sub_data[sd_idx].split(';');
          sub_values.push(Number(curr_sub_data[0]));
          sub_secs.push(Number(curr_sub_data[1]));

          if (hasLevels) {
            if (!isNaN(Number(curr_sub_data[2]))) {
              sub_levs.push(Number(curr_sub_data[2]));
            } else {
              sub_levs.push(curr_sub_data[2]);
            }
          }
        }
      } catch (e) {
        // this is an error produced by a bug in the query function, not an error returned by the mysql database
        e.message = "Error in parseQueryDataTimeSeries. The expected fields don't seem to be present in the results cache: " + e.message;
        throw new Error(e.message);
      }
    } else {
      sub_values = NaN;
      sub_secs = NaN;

      if (hasLevels) {
        sub_levs = NaN;
      }
    }

    curveTime.push(avTime);
    curveStats.push(stat);
    subVals.push(sub_values);
    subSecs.push(sub_secs);

    if (hasLevels) {
      subLevs.push(sub_levs);
    }
  }

  var N0_max = Math.max(...N0);
  var N_times_max = Math.max(...N_times);

  if (xmin < Number(rows[0].avtime) * 1000 || averageStr !== "None") {
    xmin = Number(rows[0].avtime) * 1000;
  }

  time_interval = time_interval * 1000;
  var loopTime = xmin;
  var sum = 0;

  while (loopTime <= xmax) {
    var d_idx = curveTime.indexOf(loopTime);

    if (d_idx < 0) {
      if (hasLevels) {
        //d.push([loopTime, null, -1, NaN, NaN, NaN]);// add a null for missing data
        d.x.push(loopTime);
        d.y.push(null); //d.error_x not used

        d.error_y.push(null); //placeholder

        d.subVals.push(NaN);
        d.subSecs.push(NaN);
        d.subLevs.push(NaN);
      } else {
        //d.push([loopTime, null, -1, NaN, NaN]);     // add a null for missing data
        d.x.push(loopTime);
        d.y.push(null); //d.error_x not used

        d.error_y.push(null); //placeholder

        d.subVals.push(NaN);
        d.subSecs.push(NaN);
      }
    } else {
      var this_N0 = N0[d_idx];
      var this_N_times = N_times[d_idx]; // Make sure that we don't have any points with far less data than the rest of the graph, and that
      // we don't have any points with a smaller completeness value than specified by the user.

      if (this_N0 < 0.1 * N0_max || this_N_times < completenessQCParam * N_times_max) {
        if (hasLevels) {
          //                    d.push([loopTime, null, -1, NaN, NaN, NaN]);     // add a null if this time doesn't pass QC
          d.x.push(loopTime);
          d.y.push(null); //d.error_x not used

          d.error_y.push(null); //placeholder

          d.subVals.push(NaN);
          d.subSecs.push(NaN);
          d.subLevs.push(NaN);
        } else {
          //                    d.push([loopTime, null, -1, NaN, NaN]);     // add a null if this time doesn't pass QC
          d.x.push(loopTime);
          d.y.push(null); //d.error_x not used

          d.error_y.push(null); //placeholder

          d.subVals.push(NaN);
          d.subSecs.push(NaN);
        }
      } else {
        sum += curveStats[d_idx];

        if (hasLevels) {
          //d.push([loopTime, curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);   // else add the real data
          d.x.push(loopTime);
          d.y.push(curveStats[d_idx]); //d.error_x not used

          d.error_y.push(null);
          d.subVals.push(subVals[d_idx]);
          d.subSecs.push(subSecs[d_idx]);
          d.subLevs.push(subLevs[d_idx]);
        } else {
          //d.push([loopTime, curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx]]);   // else add the real data
          d.x.push(loopTime);
          d.y.push(curveStats[d_idx]); //d.error_x not used

          d.error_y.push(null);
          d.subVals.push(subVals[d_idx]);
          d.subSecs.push(subSecs[d_idx]);
        }
      }
    }

    if (!regular) {
      // it is a model that has an irregular set of intervals, i.e. an irregular cadence
      time_interval = getTimeInterval(loopTime, time_interval, foreCastOffset, cycles); // the time interval most likely will not be the one calculated above
    }

    loopTime = loopTime + time_interval; // advance to the next time.
  }

  if (regular) {
    cycles = [time_interval]; // regular models will return one cycle cadence
  }

  const filteredx = d.x.filter(x => x);
  const filteredy = d.y.filter(y => y);
  d.xmin = Math.min(...filteredx);
  d.xmax = Math.max(...filteredx);
  d.ymin = Math.min(...filteredy);
  d.ymax = Math.max(...filteredy);
  d.sum = sum;

  if (d.xmin == "-Infinity" || d.x.indexOf(0) !== -1 && 0 < d.xmin) {
    d.xmin = 0;
  }

  if (d.ymin == "-Infinity" || d.y.indexOf(0) !== -1 && 0 < d.ymin) {
    d.ymin = 0;
  }

  if (d.xmax == "-Infinity") {
    d.xmax = 0;
  }

  if (d.ymax == "-Infinity") {
    d.ymax = 0;
  }

  return {
    d: d,
    N0: N0,
    N_times: N_times,
    cycles: cycles
  };
}; //this method parses the returned query data for specialty curves such as profiles, dieoffs, threshold plots, and valid time plots


const parseQueryDataSpecialtyCurve = function (rows, d, completenessQCParam, plotType, appType, hasLevels) {
  /*
      var d = {// d will contain the curve data
          x: [],
          y: [],
          error_x: [],   // curveTime
          error_y: [],   // values
          subVals: [],   //subVals
          subSecs: [],   //subSecs
          subLevs: [],   //subLevs
          stats: [],     //pointStats
          text: [],
          glob_stats: {},     //curveStats
          xmin:num,
          ymin:num,
          xmax:num,
          ymax:num,
          sum:num;
      };
  */
  var N0 = [];
  var N_times = [];
  var curveIndependentVars = [];
  var curveStats = [];
  var subVals = [];
  var subSecs = [];
  var subLevs = [];

  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var independentVar;

    if (plotType === matsTypes.PlotTypes.validtime) {
      independentVar = Number(rows[rowIndex].hr_of_day);
    } else if (plotType === matsTypes.PlotTypes.profile) {
      independentVar = Number(rows[rowIndex].avVal.toString().replace('P', ''));
    } else if (plotType === matsTypes.PlotTypes.dailyModelCycle) {
      independentVar = Number(rows[rowIndex].avtime) * 1000;
    } else {
      independentVar = Number(rows[rowIndex].avtime);
    }

    var stat = rows[rowIndex].stat;
    N0.push(rows[rowIndex].N0); // number of values that go into a point on the graph

    N_times.push(rows[rowIndex].N_times); // number of times that go into a point on the graph

    var sub_stats = [];
    var sub_secs = [];
    var sub_levs = [];

    if (stat !== null && stat !== "NULL" && rows[rowIndex].sub_data !== undefined) {
      try {
        var sub_data = rows[rowIndex].sub_data.toString().split(',');
        var curr_sub_data;

        for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {
          curr_sub_data = sub_data[sd_idx].split(';');
          sub_stats.push(Number(curr_sub_data[0]));
          sub_secs.push(Number(curr_sub_data[1]));

          if (hasLevels) {
            if (!isNaN(Number(curr_sub_data[2]))) {
              sub_levs.push(Number(curr_sub_data[2]));
            } else {
              sub_levs.push(curr_sub_data[2]);
            }
          }
        }
      } catch (e) {
        // this is an error produced by a bug in the query function, not an error returned by the mysql database
        e.message = "Error in parseQueryDataSpecialtyCurve. The expected fields don't seem to be present in the results cache: " + e.message;
        throw new Error(e.message);
      }
    } else {
      sub_stats = NaN;
      sub_secs = NaN;

      if (hasLevels) {
        sub_levs = NaN;
      }
    } // deal with missing forecast cycles for dailyModelCycle plot type


    if (plotType === matsTypes.PlotTypes.dailyModelCycle && rowIndex > 0 && Number(independentVar) - Number(rows[rowIndex - 1].avtime * 1000) > 3600 * 24 * 1000) {
      const cycles_missing = Math.floor((Number(independentVar) - Number(rows[rowIndex - 1].avtime * 1000)) / (3600 * 24 * 1000));

      for (var missingIdx = cycles_missing; missingIdx > 0; missingIdx--) {
        curveIndependentVars.push(independentVar - 3600 * 24 * 1000 * missingIdx);
        curveStats.push(null);
        subVals.push(NaN);
        subSecs.push(NaN);

        if (hasLevels) {
          subLevs.push(NaN);
        }
      }
    }

    curveIndependentVars.push(independentVar);
    curveStats.push(stat);
    subVals.push(sub_stats);
    subSecs.push(sub_secs);

    if (hasLevels) {
      subLevs.push(sub_levs);
    }
  }

  var N0_max = Math.max(...N0);
  var N_times_max = Math.max(...N_times);
  var sum = 0;

  for (var d_idx = 0; d_idx < curveIndependentVars.length; d_idx++) {
    var this_N0 = N0[d_idx];
    var this_N_times = N_times[d_idx]; // Make sure that we don't have any points with far less data than the rest of the graph, and that
    // we don't have any points with a smaller completeness value than specified by the user.

    if (this_N0 < 0.05 * N0_max || this_N_times < completenessQCParam * N_times_max) {
      if (plotType === matsTypes.PlotTypes.profile) {
        // profile has the stat first, and then the independent var. The others have independent var and then stat.
        // this is in the pattern of x-plotted-variable, y-plotted-variable.
        //d.push([null, curveIndependentVars[d_idx], -1, NaN, NaN, NaN]);
        d.x.push(null);
        d.y.push(curveIndependentVars[d_idx]);
        d.error_x.push(null); // placeholder
        //d.error_y not used for profile

        d.subVals.push(NaN);
        d.subSecs.push(NaN);
        d.subLevs.push(NaN);
      } else if (plotType !== matsTypes.PlotTypes.dieoff) {
        // for dieoffs, we don't want to add a null for missing data. Just don't have a point for that FHR.
        if (hasLevels) {
          //d.push([curveIndependentVars[d_idx], null, -1, NaN, NaN, NaN]);
          d.x.push(curveIndependentVars[d_idx]);
          d.y.push(null); //d.error_x not used for curves other than profile

          d.error_y.push(null); // placeholder

          d.subVals.push(NaN);
          d.subSecs.push(NaN);
          d.subLevs.push(NaN);
        } else {
          //d.push([curveIndependentVars[d_idx], null, -1, NaN, NaN]);
          d.x.push(curveIndependentVars[d_idx]);
          d.y.push(null); //d.error_x not used for curves other than profile

          d.error_y.push(null); // placeholder

          d.subVals.push(NaN);
          d.subSecs.push(NaN);
        }
      }
    } else {
      // else add the real data
      sum += curveStats[d_idx];

      if (plotType === matsTypes.PlotTypes.profile) {
        // profile has the stat first, and then the independent var. The others have independent var and then stat.
        // this is in the pattern of x-plotted-variable, y-plotted-variable.
        //                d.push([curveStats[d_idx], curveIndependentVars[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);
        d.x.push(curveStats[d_idx]);
        d.y.push(curveIndependentVars[d_idx]);
        d.error_x.push(null); // placeholder
        //d.error_y not used for curves other than profile

        d.subVals.push(subVals[d_idx]);
        d.subSecs.push(subSecs[d_idx]);
        d.subLevs.push(subLevs[d_idx]);
      } else if (hasLevels) {
        //                d.push([curveIndependentVars[d_idx], curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);
        d.x.push(curveIndependentVars[d_idx]);
        d.y.push(curveStats[d_idx]); //d.error_x not used for curves other than profile

        d.error_y.push(null); // placeholder

        d.subVals.push(subVals[d_idx]);
        d.subSecs.push(subSecs[d_idx]);
        d.subLevs.push(subLevs[d_idx]);
      } else {
        //                d.push([curveIndependentVars[d_idx], curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx]]);
        d.x.push(curveIndependentVars[d_idx]);
        d.y.push(curveStats[d_idx]); //d.error_x not used for curves other than profile

        d.error_y.push(null); // placeholder

        d.subVals.push(subVals[d_idx]);
        d.subSecs.push(subSecs[d_idx]);
      }
    }
  } // the met levels are ordered as strings, so we need to re-sort them


  if (plotType === matsTypes.PlotTypes.profile && appType === matsTypes.AppTypes.metexpress) {
    var dSorted = [];

    for (var didx = 0; didx < d.y.length; didx++) {
      dSorted.push({
        y: d.y[didx],
        x: d.x[didx],
        error_x: d.error_x[didx],
        subVals: d.subVals[didx],
        subSecs: d.subSecs[didx],
        subLevs: d.subLevs[didx]
      });
    }

    d.y = [];
    d.x = [];
    d.error_x = [];
    d.subVals = [];
    d.subSecs = [];
    d.subLevs = [];
    dSorted.sort(function (a, b) {
      return a.y - b.y;
    });
    dSorted.map(function (elem) {
      d.y.push(elem.y);
      d.x.push(elem.x);
      d.error_x.push(elem.error_x);
      d.subVals.push(elem.subVals);
      d.subSecs.push(elem.subSecs);
      d.subLevs.push(elem.subLevs);
    });
  }

  const filteredx = d.x.filter(x => x);
  const filteredy = d.y.filter(y => y);
  d.xmin = Math.min(...filteredx);
  d.xmax = Math.max(...filteredx);
  d.ymin = Math.min(...filteredy);
  d.ymax = Math.max(...filteredy);
  d.sum = sum;

  if (d.xmin == "-Infinity" || d.x.indexOf(0) !== -1 && 0 < d.xmin) {
    d.xmin = 0;
  }

  if (d.ymin == "-Infinity" || d.y.indexOf(0) !== -1 && 0 < d.ymin) {
    d.ymin = 0;
  }

  if (d.xmax == "-Infinity") {
    d.xmax = 0;
  }

  if (d.ymax == "-Infinity") {
    d.ymax = 0;
  }

  return {
    d: d,
    N0: N0,
    N_times: N_times
  };
}; // this method parses the returned query data for histograms


const parseQueryDataHistogram = function (d, rows, hasLevels) {
  /*
      var d = {// d will contain the curve data
          x: [], //placeholder
          y: [], //placeholder
          error_x: [], // unused
          error_y: [], // unused
          subVals: [],
          subSecs: [],
          subLevs: [],
          glob_stats: [], // placeholder
          bin_stats: [], // placeholder
          text: [] //placeholder
          xmin:num,
          xmax:num,
          ymin:num,
          ymax:num
      };
  */
  // these arrays hold all the sub values and seconds (and levels) until they are sorted into bins
  var curveSubStatsRaw = [];
  var curveSubSecsRaw = [];
  var curveSubLevsRaw = []; // parse the data returned from the query

  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var stat = rows[rowIndex].stat;
    var sub_stats = [];
    var sub_secs = [];
    var sub_levs = [];

    if (stat !== null && stat !== "NULL" && rows[rowIndex].sub_data !== undefined) {
      try {
        var sub_data = rows[rowIndex].sub_data.toString().split(',');
        var curr_sub_data;

        for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {
          curr_sub_data = sub_data[sd_idx].split(';');
          sub_stats.push(Number(curr_sub_data[0]));
          sub_secs.push(Number(curr_sub_data[1]));

          if (hasLevels) {
            if (!isNaN(Number(curr_sub_data[2]))) {
              sub_levs.push(Number(curr_sub_data[2]));
            } else {
              sub_levs.push(curr_sub_data[2]);
            }
          }

          curveSubLevsRaw.push(sub_levs);
        }

        curveSubStatsRaw.push(sub_stats);
        curveSubSecsRaw.push(sub_secs);
      } catch (e) {
        // this is an error produced by a bug in the query function, not an error returned by the mysql database
        e.message = "Error in parseQueryDataHistogram. The expected fields don't seem to be present in the results cache: " + e.message;
        throw new Error(e.message);
      }
    }
  } // we don't have bins yet, so we want all of the data in one array


  const subVals = [].concat.apply([], curveSubStatsRaw);
  const subSecs = [].concat.apply([], curveSubSecsRaw);
  var subLevs;

  if (hasLevels) {
    subLevs = [].concat.apply([], curveSubLevsRaw);
  }

  d.subVals = subVals;
  d.subSecs = subSecs;
  d.subLevs = subLevs;
  return {
    d: d,
    N0: subVals.length,
    N_times: subSecs.length
  };
}; //this method parses the returned query data for contour plots


const parseQueryDataContour = function (rows, d) {
  /*
      var d = {// d will contain the curve data
          x: [],
          y: [],
          z: [],
          n: [],
          text: [],
          xTextOutput: [],
          yTextOutput: [],
          zTextOutput: [],
          nTextOutput: [],
          minDateTextOutput: [],
          maxDateTextOutput: [],
          stats: []],
          glob_stats: {},
          xmin:num,
          ymin:num,
          zmin:num,
          xmax:num,
          ymax:num,
          zmax:num,
          sum:num
      };
  */
  var curveStatLookup = {};
  var curveNLookup = {}; // get all the data out of the query array

  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var rowXVal = rows[rowIndex].xVal;
    var rowYVal = rows[rowIndex].yVal;
    var statKey = rowXVal.toString() + '_' + rowYVal.toString();
    var stat = rows[rowIndex].stat;
    var n = rows[rowIndex].sub_data !== null ? rows[rowIndex].sub_data.toString().split(',').length : 0;
    var minDate = rows[rowIndex].min_secs;
    var maxDate = rows[rowIndex].max_secs;

    if (stat === undefined || stat === null || stat === 'NULL') {
      stat = null;
      n = 0;
      minDate = null;
      maxDate = null;
    } // store flat arrays of all the parsed data, used by the text output and for some calculations later


    d.xTextOutput.push(Number(rowXVal));
    d.yTextOutput.push(Number(rowYVal));
    d.zTextOutput.push(stat);
    d.nTextOutput.push(n);
    d.minDateTextOutput.push(minDate);
    d.maxDateTextOutput.push(maxDate);
    curveStatLookup[statKey] = stat;
    curveNLookup[statKey] = n;
  } // get the unique x and y values and sort the stats into the 2D z array accordingly


  d.x = matsDataUtils.arrayUnique(d.xTextOutput).sort(function (a, b) {
    return a - b;
  });
  d.y = matsDataUtils.arrayUnique(d.yTextOutput).sort(function (a, b) {
    return a - b;
  });
  var i;
  var j;
  var currX;
  var currY;
  var currStat;
  var currN;
  var currStatKey;
  var currYStatArray;
  var currYNArray;
  var sum = 0;
  var nPoints = 0;

  for (j = 0; j < d.y.length; j++) {
    currY = d.y[j];
    currYStatArray = [];
    currYNArray = [];

    for (i = 0; i < d.x.length; i++) {
      currX = d.x[i];
      currStatKey = currX.toString() + '_' + currY.toString();
      currStat = curveStatLookup[currStatKey];
      currN = curveNLookup[currStatKey];

      if (currStat === undefined) {
        currYStatArray.push(null);
        currYNArray.push(0);
      } else {
        sum += currStat;
        nPoints = nPoints + 1;
        currYStatArray.push(currStat);
        currYNArray.push(currN);
      }
    }

    d.z.push(currYStatArray);
    d.n.push(currYNArray);
  } // calculate statistics


  const filteredx = d.x.filter(x => x);
  const filteredy = d.y.filter(y => y);
  const filteredz = d.zTextOutput.filter(z => z);
  d.xmin = Math.min(...filteredx);
  d.xmax = Math.max(...filteredx);
  d.ymin = Math.min(...filteredy);
  d.ymax = Math.max(...filteredy);
  d.zmin = Math.min(...filteredz);
  d.zmax = Math.max(...filteredz);
  d.sum = sum;

  if (d.xmin == "-Infinity" || d.x.indexOf(0) !== -1 && 0 < d.xmin) {
    d.xmin = 0;
  }

  if (d.ymin == "-Infinity" || d.y.indexOf(0) !== -1 && 0 < d.ymin) {
    d.ymin = 0;
  }

  if (d.zmin == "-Infinity" || d.zTextOutput.indexOf(0) !== -1 && 0 < d.zmin) {
    d.zmin = 0;
  }

  if (d.xmax == "-Infinity") {
    d.xmax = 0;
  }

  if (d.ymax == "-Infinity") {
    d.ymax = 0;
  }

  if (d.zmax == "-Infinity") {
    d.zmax = 0;
  }

  const filteredMinDate = d.minDateTextOutput.filter(t => t);
  const filteredMaxDate = d.maxDateTextOutput.filter(t => t);
  d.glob_stats['mean'] = sum / nPoints;
  d.glob_stats['minDate'] = Math.min(...filteredMinDate);
  d.glob_stats['maxDate'] = Math.max(...filteredMaxDate);
  d.glob_stats['n'] = nPoints;
  return {
    d: d
  };
};

module.exportDefault(matsDataQueryUtils = {
  simplePoolQueryWrapSynchronous: simplePoolQueryWrapSynchronous,
  queryDBTimeSeries: queryDBTimeSeries,
  queryDBSpecialtyCurve: queryDBSpecialtyCurve,
  queryMapDB: queryMapDB,
  queryDBContour: queryDBContour
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_diff_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_diff_util.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes(v) {
    matsTypes = v;
  }

}, 0);
let matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  }

}, 1);
let matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils(v) {
    matsPlotUtils = v;
  }

}, 2);

// returns the data for whichever curve has the larger interval in its independent variable
const getLargeIntervalCurveData = function (dataset, diffFrom, independentVarName) {
  var dataMaxInterval = Number.MIN_VALUE;
  var largeIntervalCurveData = dataset[diffFrom[0]]; // set up the indexes and determine the minimum independentVarName value for the dataset

  for (var ci = 0; ci < dataset.length; ci++) {
    if (dataset[ci][independentVarName] === undefined || dataset[ci][independentVarName].length === 0) {
      // one of the curves has no data. No match possible. Just use interval from first curve
      break;
    }

    if (dataset[ci][independentVarName].length > 1) {
      var diff;

      for (var di = 0; di < dataset[ci][independentVarName].length - 1; di++) {
        // don't go all the way to the end - one shy
        diff = dataset[ci][independentVarName][di + 1] - dataset[ci][independentVarName][di];

        if (diff > dataMaxInterval) {
          dataMaxInterval = diff;
          largeIntervalCurveData = dataset[ci];
        }
      }
    }
  }

  return largeIntervalCurveData;
}; // generates diff curves for all plot types that have diff curves.


const getDataForDiffCurve = function (dataset, diffFrom, plotType, hasLevels) {
  /*
   DATASET ELEMENTS:
      series: [data,data,data ...... ]   each data is itself an object
      d = {
          x: [],
          y: [],
          error_x: [],   // curveTime
          error_y: [],   // values
          subVals: [],   //subVals
          subSecs: [],   //subSecs
          subLevs: [],   //subLevs
          stats: [],     //pointStats
          text: [],
          glob_stats: {},     //curveStats
          xmin: Number.MAX_VALUE,
          xmax: Number.MIN_VALUE,
          ymin: Number.MAX_VALUE,
          ymax: Number.MIN_VALUE,
          sum: 0
      };
    NOTE -- for profiles, x is the statVarName and y is the independentVarName, because profiles plot the statVarName
      on the x axis and the independentVarName on the y axis.
   For histograms:
  DATASET ELEMENTS:
      series: [data,data,data ...... ]   each data is itself an array
      d = {
          x: [], //placeholder
          y: [], //placeholder
          error_x: [], // unused
          error_y: [], // unused
          subVals: [],
          subSecs: [],
          subLevs: [],
          glob_stats: [], // placeholder
          bin_stats: [], // placeholder
          text: [] //placeholder
      };
    */
  // determine whether data[0] or data[1] is the independent variable, and which is the stat value
  var independentVarName;
  var statVarName;

  if (plotType !== matsTypes.PlotTypes.profile) {
    independentVarName = 'x';
    statVarName = 'y';
  } else {
    independentVarName = 'y';
    statVarName = 'x';
  } // initialize variables


  var minuendData = dataset[diffFrom[0]];
  var subtrahendData = dataset[diffFrom[1]];
  var subtrahendIndex = 0;
  var minuendIndex = 0;
  var d;

  if (plotType !== matsTypes.PlotTypes.histogram) {
    d = {
      x: [],
      y: [],
      error_x: [],
      // curveTime
      error_y: [],
      // values
      subVals: [],
      //subVals
      subSecs: [],
      //subSecs
      subLevs: [],
      //subLevs
      glob_stats: [],
      stats: [],
      //curveStats
      text: [],
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE,
      sum: 0
    };
  } else {
    d = {
      x: [],
      y: [],
      error_x: [],
      error_y: [],
      subVals: [],
      subSecs: [],
      subLevs: [],
      glob_stats: {
        'glob_mean': null,
        'glob_sd': null,
        'glob_n': null,
        'glob_max': null,
        'glob_min': null
      },
      bin_stats: [],
      text: [],
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE
    };
  } // make sure neither curve is empty


  if (minuendData.x.length === 0 || subtrahendData.x.length === 0) {
    return {
      'dataset': d
    };
  } // this is a difference curve - we are differencing diffFrom[0] - diffFrom[1] based on the
  // independentVarName values of whichever has the largest interval
  // find the largest interval between diffFrom[0] curve and diffFrom[1] curve


  var largeIntervalCurveData = getLargeIntervalCurveData(dataset, diffFrom, independentVarName); // calculate the differences

  for (var largeIntervalCurveIndex = 0; largeIntervalCurveIndex < largeIntervalCurveData[independentVarName].length; largeIntervalCurveIndex++) {
    // make sure that we are actually on the same independentVarName value for each curve
    var subtrahendIndependentVar = subtrahendData[independentVarName][subtrahendIndex];
    var minuendIndependentVar = minuendData[independentVarName][minuendIndex];
    var largeIntervalIndependentVar = largeIntervalCurveData[independentVarName][largeIntervalCurveIndex]; // increment the minuendIndex until it reaches this iteration's largeIntervalIndependentVar

    var minuendChanged = false;

    while (largeIntervalIndependentVar > minuendIndependentVar && minuendIndex < minuendData[independentVarName].length - 1) {
      minuendIndependentVar = minuendData[independentVarName][++minuendIndex];
      minuendChanged = true;
    } // if the end of the curve was reached without finding the largeIntervalIndependentVar, increase the minuendIndex to trigger the end conditions.


    if (!minuendChanged && minuendIndex >= minuendData[independentVarName].length - 1) {
      ++minuendIndex;
    } // increment the subtrahendIndex until it reaches this iteration's largeIntervalIndependentVar


    var subtrahendChanged = false;

    while (largeIntervalIndependentVar > subtrahendIndependentVar && subtrahendIndex < subtrahendData[independentVarName].length - 1) {
      subtrahendIndependentVar = subtrahendData[independentVarName][++subtrahendIndex];
      subtrahendChanged = true;
    } // if the end of the curve was reached without finding the largeIntervalIndependentVar, increase the subtrahendIndex to trigger the end conditions.


    if (!subtrahendChanged && subtrahendIndex >= subtrahendData[independentVarName].length - 1) {
      ++subtrahendIndex;
    }

    var diffValue = null;
    var tempSubValsArray;
    var tempSubSecsArray;
    var tempSubLevsArray;

    if (minuendData[independentVarName][minuendIndex] !== undefined && subtrahendData[independentVarName][subtrahendIndex] !== undefined) {
      // make sure both curves actually have data at this index
      if (minuendData[statVarName][minuendIndex] !== null && subtrahendData[statVarName][subtrahendIndex] !== null && minuendData[independentVarName][minuendIndex] === subtrahendData[independentVarName][subtrahendIndex]) {
        // make sure data is not null at this point and the independentVars actually match
        diffValue = minuendData[statVarName][minuendIndex] - subtrahendData[statVarName][subtrahendIndex];
        d[independentVarName].push(largeIntervalIndependentVar);
        d[statVarName].push(diffValue);
        d.error_x.push(null);
        d.error_y.push(null);
        tempSubValsArray = [];
        tempSubSecsArray = [];

        if (hasLevels) {
          tempSubLevsArray = [];
        }

        if (plotType !== matsTypes.PlotTypes.histogram) {
          var minuendDataSubValues = minuendData.subVals[minuendIndex];
          var minuendDataSubSeconds = minuendData.subSecs[minuendIndex];

          if (hasLevels) {
            var minuendDataSubLevels = minuendData.subLevs[minuendIndex];
          }

          var subtrahendDataSubValues = subtrahendData.subVals[subtrahendIndex];
          var subtrahendDataSubSeconds = subtrahendData.subSecs[subtrahendIndex];

          if (hasLevels) {
            var subtrahendDataSubLevels = subtrahendData.subLevs[subtrahendIndex];
          } // find matching sub values and diff those


          for (var mvalIdx = 0; mvalIdx < minuendDataSubValues.length; mvalIdx++) {
            for (var svalIdx = 0; svalIdx < subtrahendDataSubValues.length; svalIdx++) {
              if (hasLevels && minuendDataSubSeconds[mvalIdx] === subtrahendDataSubSeconds[svalIdx] && minuendDataSubLevels[mvalIdx] === subtrahendDataSubLevels[svalIdx]) {
                tempSubValsArray.push(minuendDataSubValues[mvalIdx] - subtrahendDataSubValues[svalIdx]);
                tempSubSecsArray.push(minuendDataSubSeconds[mvalIdx]);
                tempSubLevsArray.push(minuendDataSubLevels[mvalIdx]);
              } else if (!hasLevels && minuendDataSubSeconds[mvalIdx] === subtrahendDataSubSeconds[svalIdx]) {
                tempSubValsArray.push(minuendDataSubValues[mvalIdx] - subtrahendDataSubValues[svalIdx]);
                tempSubSecsArray.push(minuendDataSubSeconds[mvalIdx]);
              }
            }
          }

          d.subVals.push(tempSubValsArray);
          d.subSecs.push(tempSubSecsArray);

          if (hasLevels) {
            d.subLevs.push(tempSubLevsArray);
          }

          d.sum = d.sum + d[independentVarName][largeIntervalCurveIndex];
        } else {
          d.bin_stats.push({
            'bin_mean': null,
            'bin_sd': null,
            'bin_n': diffValue,
            'bin_rf': minuendData.bin_stats[minuendIndex].bin_rf - subtrahendData.bin_stats[subtrahendIndex].bin_rf,
            'binLowBound': minuendData.bin_stats[minuendIndex].binLowBound,
            'binUpBound': minuendData.bin_stats[minuendIndex].binUpBound,
            'binLabel': minuendData.bin_stats[minuendIndex].binLabel
          });
        }
      } else {
        // no match for this independentVarName
        d[independentVarName].push(largeIntervalIndependentVar);
        d[statVarName].push(null);
        d.error_x.push(null);
        d.error_y.push(null);
        d.subVals.push([]);
        d.subSecs.push([]);

        if (hasLevels) {
          d.subLevs.push([]);
        }

        if (plotType === matsTypes.PlotTypes.histogram) {
          d.bin_stats.push({
            'bin_mean': null,
            'bin_sd': null,
            'bin_n': null,
            'bin_rf': null,
            'binLowBound': minuendData.bin_stats[minuendIndex].binLowBound,
            'binUpBound': minuendData.bin_stats[minuendIndex].binUpBound,
            'binLabel': minuendData.bin_stats[minuendIndex].binLabel
          });
        }
      }
    } else if (!subtrahendChanged && subtrahendIndex >= subtrahendData[independentVarName].length - 1 || !minuendChanged && minuendIndex >= minuendData[independentVarName].length - 1) {
      // we've reached the end of at least one curve, so end the diffing.
      break;
    }
  }

  const filteredx = d.x.filter(x => x);
  const filteredy = d.y.filter(y => y);
  d.xmin = Math.min(...filteredx);
  d.xmax = Math.max(...filteredx);
  d.ymin = Math.min(...filteredy);
  d.ymax = Math.max(...filteredy);
  return {
    'dataset': d
  };
}; // generates diff of two contours.


const getDataForDiffContour = function (dataset) {
  /*
   DATASET ELEMENTS:
      d[i] = {
          label: string,
          curveId: string,
          name: string,
          annotateColor: string,
          annotation: string,             -----
          x: [],                          *****
          y: [],                          *****
          z: [[]],                        *****
          n: [[]],                        *****
          text: [],
          stats: [],
          glob_stats: object,             -----
          type: string,
          autocontour: boolean,
          ncontours: number,
          colorbar: object,
          colorscale: string,
          reversescale: boolean,
          contours: object,
          marker: object,
          xAxisKey: [],
          yAxisKey: [],
          visible: boolean,
          xTextOutput: [],                *****
          yTextOutput: [],                *****
          zTextOutput: [],                *****
          nTextOutput: [],                *****
          maxDateTextOutput: [],          *****
          minDateTextOutput: [],          *****
          xmax: number,                   -----
          xmin: number,                   -----
          ymax: number,                   -----
          ymin: number,                   -----
          zmax: number,                   -----
          zmin: number,                   -----
          sum: number                     *****
      };
       ***** indicates calculation in loops
      ----- indicates calculation after loops
   */
  // initialize output object
  var diffDataset = {};
  diffDataset['label'] = dataset[1].label + '-' + dataset[0].label;
  diffDataset['curveId'] = dataset[1].curveId + '-' + dataset[0].curveId;
  diffDataset['name'] = dataset[1].name + '-' + dataset[0].name;
  diffDataset['annotateColor'] = "rgb(255,165,0)";
  diffDataset['annotation'] = "";
  diffDataset['text'] = [];
  diffDataset['type'] = dataset[0].type;
  diffDataset['marker'] = dataset[0].marker;
  diffDataset['xAxisKey'] = dataset[0].xAxisKey;
  diffDataset['yAxisKey'] = dataset[0].yAxisKey;
  diffDataset['visible'] = dataset[0].visible;
  diffDataset['x'] = [];
  diffDataset['y'] = [];
  diffDataset['z'] = [];
  diffDataset['n'] = [];
  diffDataset['xTextOutput'] = [];
  diffDataset['yTextOutput'] = [];
  diffDataset['zTextOutput'] = [];
  diffDataset['nTextOutput'] = [];
  diffDataset['maxDateTextOutput'] = [];
  diffDataset['minDateTextOutput'] = [];
  diffDataset['stats'] = [];
  diffDataset['glob_stats'] = {};
  diffDataset['xmax'] = -1 * Number.MAX_VALUE;
  diffDataset['xmin'] = Number.MAX_VALUE;
  diffDataset['ymax'] = -1 * Number.MAX_VALUE;
  diffDataset['ymin'] = Number.MAX_VALUE;
  diffDataset['zmax'] = -1 * Number.MAX_VALUE;
  diffDataset['zmin'] = Number.MAX_VALUE;
  diffDataset['sum'] = 0; // initialize local variables

  var minuendData = dataset[1];
  var subtrahendData = dataset[0]; // get common x and y

  diffDataset.x = _.intersection(minuendData.x, subtrahendData.x).sort(function (a, b) {
    return a - b;
  });
  diffDataset.y = _.intersection(minuendData.y, subtrahendData.y).sort(function (a, b) {
    return a - b;
  }); // make we actually have matches

  if (diffDataset.x.length === 0 || diffDataset.y.length === 0) {
    diffDataset.x = [];
    diffDataset.y = [];
    return [diffDataset];
  } // make sure neither dataset is empty


  if (minuendData.x.length === 0 || subtrahendData.x.length === 0 || minuendData.y.length === 0 || subtrahendData.y.length === 0) {
    return [diffDataset];
  }

  var minuendYIndex = 0;
  var subtrahendYIndex = 0;
  var nPoints = 0; // loop through common Ys

  for (var diffDataYIndex = 0; diffDataYIndex < diffDataset.y.length; diffDataYIndex++) {
    //make sure that we are actually on the same y value for each curve
    var diffDataY = diffDataset.y[diffDataYIndex];
    var minuendY = minuendData.y[minuendYIndex];
    var subtrahendY = subtrahendData.y[subtrahendYIndex]; //increment the minuendYIndex until it reaches this iteration's diffDataY

    while (diffDataY > minuendY && minuendYIndex < minuendData.y.length - 1) {
      minuendY = minuendData.y[++minuendYIndex];
    } //increment the subtrahendYIndex until it reaches this iteration's diffDataY


    while (diffDataY > subtrahendY && subtrahendYIndex < subtrahendData.y.length - 1) {
      subtrahendY = subtrahendData.y[++subtrahendYIndex];
    } // initialize n and z arrays for this Y


    diffDataset.z[diffDataYIndex] = [];
    diffDataset.n[diffDataYIndex] = [];
    var minuendXIndex = 0;
    var subtrahendXIndex = 0;

    for (var diffDataXIndex = 0; diffDataXIndex < diffDataset.x.length; diffDataXIndex++) {
      //make sure that we are actually on the same x value for each curve
      var diffDataX = diffDataset.x[diffDataXIndex];
      var minuendX = minuendData.x[minuendXIndex];
      var subtrahendX = subtrahendData.x[subtrahendXIndex]; //increment the minuendXIndex until it reaches this iteration's diffDataX

      while (diffDataX > minuendX && minuendXIndex < minuendData.x.length - 1) {
        minuendX = minuendData.x[++minuendXIndex];
      } //increment the subtrahendXIndex until it reaches this iteration's diffDataX


      while (diffDataX > subtrahendX && subtrahendXIndex < subtrahendData.x.length - 1) {
        subtrahendX = subtrahendData.x[++subtrahendXIndex];
      }

      var diffValue = null;
      var diffNumber = 0;
      var diffMinDate = null;
      var diffMaxDate = null;

      if (minuendData.z[minuendYIndex][minuendXIndex] !== undefined && subtrahendData.z[subtrahendYIndex][subtrahendXIndex] !== undefined && minuendData.z[minuendYIndex][minuendXIndex] !== null && subtrahendData.z[subtrahendYIndex][subtrahendXIndex] !== null && minuendX === subtrahendX && minuendY === subtrahendY) {
        // make sure both contours actually have data at these indices, data is not null at this point, and the x and y actually match
        // calculate the difference values
        diffValue = minuendData.z[minuendYIndex][minuendXIndex] - subtrahendData.z[subtrahendYIndex][subtrahendXIndex];
        diffNumber = minuendData.n[minuendYIndex][minuendXIndex] <= subtrahendData.n[subtrahendYIndex][subtrahendXIndex] ? minuendData.n[minuendYIndex][minuendXIndex] : subtrahendData.n[subtrahendYIndex][subtrahendXIndex];
        diffMinDate = minuendData.minDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] <= subtrahendData.minDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex] ? minuendData.minDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] : subtrahendData.minDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex];
        diffMaxDate = minuendData.maxDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] >= subtrahendData.maxDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex] ? minuendData.maxDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] : subtrahendData.maxDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex];
        diffDataset['sum'] += diffValue;
        nPoints = nPoints + 1;
      }

      diffDataset.z[diffDataYIndex].push(diffValue);
      diffDataset.n[diffDataYIndex].push(diffNumber);
      diffDataset.xTextOutput.push(diffDataX);
      diffDataset.yTextOutput.push(diffDataY);
      diffDataset.zTextOutput.push(diffValue);
      diffDataset.nTextOutput.push(diffNumber);
      diffDataset.minDateTextOutput.push(diffMinDate);
      diffDataset.maxDateTextOutput.push(diffMaxDate);
    }
  } // calculate statistics


  const filteredx = diffDataset.x.filter(x => x);
  const filteredy = diffDataset.y.filter(y => y);
  const filteredz = diffDataset.zTextOutput.filter(z => z);
  diffDataset.xmin = Math.min(...filteredx);
  diffDataset.xmax = Math.max(...filteredx);
  diffDataset.ymin = Math.min(...filteredy);
  diffDataset.ymax = Math.max(...filteredy);
  diffDataset.zmin = Math.min(...filteredz);
  diffDataset.zmax = Math.max(...filteredz);

  if (diffDataset.xmin == "-Infinity" || diffDataset.x.indexOf(0) !== -1 && 0 < diffDataset.xmin) {
    diffDataset.xmin = 0;
  }

  if (diffDataset.ymin == "-Infinity" || diffDataset.y.indexOf(0) !== -1 && 0 < diffDataset.ymin) {
    diffDataset.ymin = 0;
  }

  if (diffDataset.zmin == "-Infinity" || diffDataset.zTextOutput.indexOf(0) !== -1 && 0 < diffDataset.zmin) {
    diffDataset.zmin = 0;
  }

  if (diffDataset.xmax == "-Infinity") {
    diffDataset.xmax = 0;
  }

  if (diffDataset.ymax == "-Infinity") {
    diffDataset.ymax = 0;
  }

  if (diffDataset.zmax == "-Infinity") {
    diffDataset.zmax = 0;
  }

  const filteredMinDate = diffDataset.minDateTextOutput.filter(t => t);
  const filteredMaxDate = diffDataset.maxDateTextOutput.filter(t => t);
  diffDataset.glob_stats['mean'] = diffDataset.sum / nPoints;
  diffDataset.glob_stats['minDate'] = Math.min(...filteredMinDate);
  diffDataset.glob_stats['maxDate'] = Math.max(...filteredMaxDate);
  diffDataset.glob_stats['n'] = nPoints;
  diffDataset['annotation'] = diffDataset.glob_stats.mean === undefined ? diffDataset.label + "- mean = NaN" : diffDataset.label + "- mean = " + diffDataset.glob_stats.mean.toPrecision(4); // make contours symmetrical around 0

  diffDataset['autocontour'] = false;
  diffDataset['ncontours'] = 15;
  diffDataset['colorbar'] = dataset[0].colorbar;
  diffDataset['colorbar']['title'] = dataset[0].colorbar.title === dataset[1].colorbar.title ? dataset[0].colorbar.title : dataset[1].colorbar.title + " - " + dataset[0].colorbar.title;
  diffDataset['colorscale'] = [[0, "rgb(5,10,172)"], [0.35, "rgb(106,137,247)"], [0.45, "rgb(255,255,255)"], [0.55, "rgb(255,255,255)"], [0.6, "rgb(220,170,132)"], [0.7, "rgb(230,145,90)"], [1, "rgb(178,10,28)"]];
  diffDataset['reversescale'] = dataset[0].reversescale;
  diffDataset['contours'] = dataset[0].contours;
  const maxZ = Math.abs(diffDataset.zmax) > Math.abs(diffDataset.zmin) ? Math.abs(diffDataset.zmax) : Math.abs(diffDataset.zmin);
  diffDataset['contours']['start'] = -1 * maxZ + 2 * maxZ / 16;
  diffDataset['contours']['end'] = maxZ - 2 * maxZ / 16;
  diffDataset['contours']['size'] = 2 * maxZ / 16;
  return [diffDataset];
};

module.exportDefault(matsDataDiffUtils = {
  getDataForDiffCurve: getDataForDiffCurve,
  getDataForDiffContour: getDataForDiffContour
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_match_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_match_util.js                                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsDataUtils;
module.link("meteor/randyp:mats-common", {
  matsDataUtils(v) {
    matsDataUtils = v;
  }

}, 0);
let matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes(v) {
    matsTypes = v;
  }

}, 1);

// function for removing unmatched data from a dataset containing multiple curves *without* levels
const getMatchedDataSet = function (dataset, curvesLength) {
  var subSecs = [];
  var subValues = [];
  var newSubSecs = [];
  var newSubValues = [];
  var independentVarGroups = [];
  var independentVarHasPoint = [];
  var currIndependentVar;
  var curveIndex;
  var data;
  var di;
  var fi;
  var si; // matching in this function is based on a curve's independent variable. For a timeseries, the independentVar is epoch,
  // for a profile, it's level, for a dieoff, it's forecast hour, for a threshold plot, it's threshold, and for a
  // valid time plot, it's hour of day. This function identifies the the independentVar values common across all of
  // the curves, and then the common sub times/levels/values for those independentVar values.
  // find the matching independentVars shared across all curves

  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // every curve
    independentVarGroups[curveIndex] = []; // store the independentVars for each curve that are not null

    independentVarHasPoint[curveIndex] = []; // store the *all* of the independentVars for each curve

    subSecs[curveIndex] = {}; // store the individual record times (subSecs) going into each independentVar for each curve

    data = dataset[curveIndex];

    for (di = 0; di < data.x.length; di++) {
      // loop over every independentVar value in this curve
      currIndependentVar = data.x[di];

      if (data.y[di] !== null) {
        subSecs[curveIndex][currIndependentVar] = data.subSecs[di]; // store raw secs for this independentVar value, since it's not a null point

        independentVarGroups[curveIndex].push(currIndependentVar); // store this independentVar value, since it's not a null point
      }

      independentVarHasPoint[curveIndex].push(currIndependentVar); // store all the independentVar values, regardless of whether they're null
    }
  }

  var matchingIndependentVars = _.intersection.apply(_, independentVarGroups); // find all of the non-null independentVar values common across all the curves


  var matchingIndependentHasPoint = _.intersection.apply(_, independentVarHasPoint); // find all of the independentVar values common across all the curves, regardless of whether or not they're null


  var subSecIntersection = {}; // eventually find the intersecting subSecs for each common non-null independentVar value

  for (fi = 0; fi < matchingIndependentVars.length; fi++) {
    // loop over each common non-null independentVar value
    currIndependentVar = matchingIndependentVars[fi];
    var currSubSecIntersection = subSecs[0][currIndependentVar]; // fill current subSecs intersection array with subSecs from the first curve

    for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {
      // loop over every curve
      currSubSecIntersection = _.intersection(currSubSecIntersection, subSecs[curveIndex][currIndependentVar]); // keep taking the intersection of the current subSecs intersection array with each curve's subSecs array for this independentVar value
    }

    subSecIntersection[currIndependentVar] = currSubSecIntersection; // store the final intersecting subSecs array for this common non-null independentVar value
  } // remove non-matching independentVars and subSecs


  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    data = dataset[curveIndex]; // need to loop backwards through the data array so that we can splice non-matching indices
    // while still having the remaining indices in the correct order

    var dataLength = data.x.length;

    for (di = dataLength - 1; di >= 0; di--) {
      if (matchingIndependentVars.indexOf(data.x[di]) === -1) {
        // if this is not a common non-null independentVar value, we'll have to remove some data
        if (matchingIndependentHasPoint.indexOf(data.x[di]) === -1) {
          // if at least one curve doesn't even have a null here, much less a matching value (beacause of the cadence), just drop this independentVar
          data.x.splice(di, 1);
          data.y.splice(di, 1);
          data.error_y.array.splice(di, 1);
          data.subVals.splice(di, 1);
          data.subSecs.splice(di, 1);
          data.stats.splice(di, 1);
          data.text.splice(di, 1);
        } else {
          // if all of the curves have either data or nulls at this independentVar, and there is at least one null, ensure all of the curves are null
          data.y[di] = null;
          data.subVals[di] = NaN;
          data.subSecs[di] = NaN;
        }

        continue; // then move on to the next independentVar. There's no need to mess with the subSecs
      }

      subSecs = data.subSecs[di];
      subValues = data.subVals[di];

      if (subSecs.length > 0) {
        currIndependentVar = data.x[di];
        newSubValues = [];
        newSubSecs = [];

        for (si = 0; si < subSecs.length; si++) {
          // loop over all subSecs for this independentVar
          if (subSecIntersection[currIndependentVar].indexOf(subSecs[si]) !== -1) {
            // keep the subValue only if its associated subSec is common to all curves for this independentVar
            var newVal = subValues[si];
            var newSec = subSecs[si];

            if (newVal !== undefined) {
              newSubValues.push(newVal);
              newSubSecs.push(newSec);
            }
          }
        } // store the filtered data


        data.subVals[di] = newSubValues;
        data.subSecs[di] = newSubSecs;
      }
    }

    dataset[curveIndex] = data;
  }

  return dataset;
}; // function for removing unmatched data from a dataset containing multiple curves *with* levels


const getMatchedDataSetWithLevels = function (dataset, curvesLength, plotType) {
  var subSecs = [];
  var subLevs = [];
  var subValues = [];
  var newSubSecs = [];
  var newSubLevs = [];
  var newSubValues = [];
  var independentVarGroups = [];
  var independentVarHasPoint = [];
  var currIndependentVar;
  var curveIndex;
  var data;
  var di;
  var fi;
  var si; // matching in this function is based on a curve's independent variable. For a timeseries, the independentVar is epoch,
  // for a profile, it's level, for a dieoff, it's forecast hour, for a threshold plot, it's threshold, and for a
  // valid time plot, it's hour of day. This function identifies the the independentVar values common across all of
  // the curves, and then the common sub times/levels/values for those independentVar values.
  //determine whether data.x or data.y is the independent variable, and which is the stat value

  var independentVarName;
  var statVarName;

  if (plotType !== matsTypes.PlotTypes.profile) {
    independentVarName = 'x';
    statVarName = 'y';
  } else {
    independentVarName = 'y';
    statVarName = 'x';
  }

  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // every curve
    independentVarGroups[curveIndex] = []; // store the independentVars for each curve that are not null

    independentVarHasPoint[curveIndex] = []; // store the *all* of the independentVars for each curve

    subSecs[curveIndex] = {}; // store the individual record times (subSecs) going into each independentVar for each curve

    subLevs[curveIndex] = {}; // store the individual record levels (subLevs) going into each independentVar for each curve

    data = dataset[curveIndex];

    for (di = 0; di < data[independentVarName].length; di++) {
      // loop over every independentVar value in this curve
      currIndependentVar = data[independentVarName][di];

      if (data[statVarName][di] !== null) {
        subSecs[curveIndex][currIndependentVar] = data.subSecs[di]; // store raw secs for this independentVar value, since it's not a null point

        subLevs[curveIndex][currIndependentVar] = data.subLevs[di]; // store raw levs for this independentVar value, since it's not a null point

        independentVarGroups[curveIndex].push(currIndependentVar); // store this independentVar value, since it's not a null point
      }

      independentVarHasPoint[curveIndex].push(currIndependentVar); // store all the independentVar values, regardless of whether they're null
    }
  }

  var matchingIndependentVars = _.intersection.apply(_, independentVarGroups); // find all of the non-null independentVar values common across all the curves


  var matchingIndependentHasPoint = _.intersection.apply(_, independentVarHasPoint); // find all of the independentVar values common across all the curves, regardless of whether or not they're null


  var subIntersections = []; // eventually find the intersecting subSecs and subLevs for each common non-null independentVar value

  for (fi = 0; fi < matchingIndependentVars.length; fi++) {
    // loop over each common non-null independentVar value
    currIndependentVar = matchingIndependentVars[fi];
    subIntersections[currIndependentVar] = [];
    var currSubIntersections = [];

    for (si = 0; si < subSecs[0][currIndependentVar].length; si++) {
      // fill current intersection array with sec-lev pairs from the first curve
      currSubIntersections.push([subSecs[0][currIndependentVar][si], subLevs[0][currIndependentVar][si]]);
    }

    for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {
      // loop over every curve after the first
      var tempSubIntersections = [];
      var tempPair;

      for (si = 0; si < subSecs[curveIndex][currIndependentVar].length; si++) {
        // loop over every subSecs value
        tempPair = [subSecs[curveIndex][currIndependentVar][si], subLevs[curveIndex][currIndependentVar][si]]; // create an individual sec-lev pair for each index in the subSecs and subLevs arrays

        if (matsDataUtils.arrayContainsSubArray(currSubIntersections, tempPair)) {
          // see if the individual sec-lev pair matches a pair from the current intersection array
          tempSubIntersections.push(tempPair); // store matching pairs
        }
      }

      currSubIntersections = tempSubIntersections; //replace current intersection array with array of only pairs that matched from this loop through.
    }

    subIntersections[currIndependentVar] = currSubIntersections; // store the final intersecting subSecs array for this common non-null independentVar value
  } // remove non-matching independentVars and subSecs


  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    data = dataset[curveIndex]; // need to loop backwards through the data array so that we can splice non-matching indices
    // while still having the remaining indices in the correct order

    var dataLength = data[independentVarName].length;

    for (di = dataLength - 1; di >= 0; di--) {
      if (matchingIndependentVars.indexOf(data[independentVarName][di]) === -1) {
        // if this is not a common non-null independentVar value, we'll have to remove some data
        if (matchingIndependentHasPoint.indexOf(data[independentVarName][di]) === -1) {
          // if at least one curve doesn't even have a null here, much less a matching value (beacause of the cadence), just drop this independentVar
          data.x.splice(di, 1);
          data.y.splice(di, 1);
          data['error_' + statVarName].array.splice(di, 1);
          data.subVals.splice(di, 1);
          data.subSecs.splice(di, 1);
          data.subLevs.splice(di, 1);
          data.stats.splice(di, 1);
          data.text.splice(di, 1);
        } else {
          // if all of the curves have either data or nulls at this independentVar, and there is at least one null, ensure all of the curves are null
          data[statVarName][di] = null;
          data.subVals[di] = NaN;
          data.subSecs[di] = NaN;
          data.subLevs[di] = NaN;
        }

        continue; // then move on to the next independentVar. There's no need to mess with the subSecs or subLevs
      }

      subSecs = data.subSecs[di];
      subLevs = data.subLevs[di];
      subValues = data.subVals[di];

      if (subSecs.length > 0 && subLevs.length > 0) {
        currIndependentVar = data[independentVarName][di];
        newSubValues = [];
        newSubSecs = [];
        newSubLevs = [];

        for (si = 0; si < subSecs.length; si++) {
          // loop over all subSecs for this independentVar
          tempPair = [subSecs[si], subLevs[si]]; //create sec-lev pair for each sub value

          if (matsDataUtils.arrayContainsSubArray(subIntersections[currIndependentVar], tempPair)) {
            // keep the subValue only if its sec-lev pair is common to all curves for this independentVar
            var newVal = subValues[si];
            var newSec = subSecs[si];
            var newLev = subLevs[si];

            if (newVal !== undefined) {
              newSubValues.push(newVal);
              newSubSecs.push(newSec);
              newSubLevs.push(newLev);
            }
          }
        } // store the filtered data


        data.subVals[di] = newSubValues;
        data.subSecs[di] = newSubSecs;
        data.subLevs[di] = newSubLevs;
      }
    }

    dataset[curveIndex] = data;
  }

  return dataset;
}; // function for removing unmatched data from a dataset containing multiple curves for a histogram *without* levels.
// separate matching functions are needed for histograms because you have to take all of the data out of the bins, then
// match it, then recalculate the bins. For other plot types, you can just leave the data in its already-sorted fhr, level, etc.


const getMatchedDataSetHistogram = function (dataset, curvesLength, binStats) {
  var subStatsRaw = {};
  var subSecsRaw = {};
  var subStats = {};
  var subSecs = {};
  var newSubStats = {};
  var newSubSecs = {};
  var newCurveData;
  var curveIndex;
  var di;
  var si; // pull all subSecs and subStats out of their bins, and back into one master array

  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    data = dataset[curveIndex];
    subStatsRaw[curveIndex] = [];
    subSecsRaw[curveIndex] = [];
    subStats[curveIndex] = [];
    subSecs[curveIndex] = [];

    for (di = 0; di < data.x.length; di++) {
      subStatsRaw[curveIndex].push(data.subVals[di]);
      subSecsRaw[curveIndex].push(data.subSecs[di]);
    }

    subStats[curveIndex] = [].concat.apply([], subStatsRaw[curveIndex]);
    subSecs[curveIndex] = [].concat.apply([], subSecsRaw[curveIndex]);
  } // determine which seconds are present in all curves


  var subSecIntersection = subSecs[0]; // fill current subSecs intersection array with subSecs from the first curve

  for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    subSecIntersection = _.intersection(subSecIntersection, subSecs[curveIndex]); // keep taking the intersection of the current subSecs intersection array with each curve's subSecs array
  } // remove non-matching subSecs and subStats


  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    data = dataset[curveIndex];

    if (subSecIntersection.length > 0) {
      newSubStats[curveIndex] = [];
      newSubSecs[curveIndex] = [];

      for (si = 0; si < subSecs[curveIndex].length; si++) {
        // loop over all subSecs for this curve
        if (subSecIntersection.indexOf(subSecs[curveIndex][si]) !== -1) {
          // keep the subStat only if its associated subSec is common to all curves
          var newStat = subStats[curveIndex][si];
          var newSec = subSecs[curveIndex][si];

          if (newStat !== undefined) {
            newSubStats[curveIndex].push(newStat);
            newSubSecs[curveIndex].push(newSec);
          }
        }
      } // re-sort all of the data into histogram bins


      var d = {
        // d will contain the curve data
        x: [],
        //placeholder
        y: [],
        //placeholder
        error_x: [],
        // unused
        error_y: [],
        // unused
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {},
        // placeholder
        bin_stats: [],
        // placeholder
        text: [],
        //placeholder
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE
      };
      newCurveData = matsDataUtils.sortHistogramBins(newSubStats[curveIndex], newSubSecs[curveIndex], [], data.x.length, binStats, false, d);
      var newCurveDataKeys = Object.keys(newCurveData.d);

      for (var didx = 0; didx < newCurveDataKeys.length; didx++) {
        dataset[curveIndex][newCurveDataKeys[didx]] = newCurveData.d[newCurveDataKeys[didx]];
      }
    } else {
      // if there are no matching values, set data to an empty array
      dataset[curveIndex] = {
        x: [],
        y: [],
        error_x: [],
        error_y: [],
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {},
        bin_stats: [],
        text: [],
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE
      };
    }
  }

  return dataset;
}; // function for removing unmatched data from a dataset containing multiple curves for a histogram *with* levels.
// separate matching functions are needed for histograms because you have to take all of the data out of the bins, then
// match it, then recalculate the bins. For other plot types, you can just leave the data in its already-sorted fhr, level, etc.


const getMatchedDataSetHistogramWithLevels = function (dataset, curvesLength, binStats) {
  var subStatsRaw = {};
  var subSecsRaw = {};
  var subLevsRaw = {};
  var subStats = {};
  var subSecs = {};
  var subLevs = {};
  var newSubStats = {};
  var newSubSecs = {};
  var newSubLevs = {};
  var newCurveData;
  var curveIndex;
  var di;
  var si; // pull all subSecs and subStats out of their bins, and back into one master array

  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    data = dataset[curveIndex];
    subStatsRaw[curveIndex] = [];
    subSecsRaw[curveIndex] = [];
    subLevsRaw[curveIndex] = [];
    subStats[curveIndex] = [];
    subSecs[curveIndex] = [];
    subLevs[curveIndex] = [];

    for (di = 0; di < data.x.length; di++) {
      subStatsRaw[curveIndex].push(data.subVals[di]);
      subSecsRaw[curveIndex].push(data.subSecs[di]);
      subLevsRaw[curveIndex].push(data.subLevs[di]);
    }

    subStats[curveIndex] = [].concat.apply([], subStatsRaw[curveIndex]);
    subSecs[curveIndex] = [].concat.apply([], subSecsRaw[curveIndex]);
    subLevs[curveIndex] = [].concat.apply([], subLevsRaw[curveIndex]);
  } // determine which seconds and levels are present in all curves


  var subIntersections = []; // eventually find the intersecting subSecs and subLevs across all curves

  for (si = 0; si < subSecs[0].length; si++) {
    // fill current intersection array with sec-lev pairs from the first curve
    subIntersections.push([subSecs[0][si], subLevs[0][si]]);
  }

  for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve after the first
    var tempSubIntersections = [];
    var tempPair;

    for (si = 0; si < subSecs[curveIndex].length; si++) {
      // loop over every subSecs value
      tempPair = [subSecs[curveIndex][si], subLevs[curveIndex][si]]; // create an individual sec-lev pair for each index in the subSecs and subLevs arrays

      if (matsDataUtils.arrayContainsSubArray(subIntersections, tempPair)) {
        // see if the individual sec-lev pair matches a pair from the current intersection array
        tempSubIntersections.push(tempPair); // store matching pairs
      }
    }

    subIntersections = tempSubIntersections; //replace current intersection array with array of only pairs that matched from this loop through.
  } // remove non-matching subSecs, subLevs, and subStats


  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    data = dataset[curveIndex];

    if (subIntersections.length > 0) {
      newSubStats[curveIndex] = [];
      newSubSecs[curveIndex] = [];
      newSubLevs[curveIndex] = [];

      for (si = 0; si < subSecs[curveIndex].length; si++) {
        // loop over all subSecs for this curve
        tempPair = [subSecs[curveIndex][si], subLevs[curveIndex][si]]; //create sec-lev pair for each subStat

        if (matsDataUtils.arrayContainsSubArray(subIntersections, tempPair)) {
          // keep the subStat only if its sec-lev pair is common to all curves
          var newStat = subStats[curveIndex][si];
          var newSec = subSecs[curveIndex][si];
          var newLev = subLevs[curveIndex][si];

          if (newStat !== undefined) {
            newSubStats[curveIndex].push(newStat);
            newSubSecs[curveIndex].push(newSec);
            newSubLevs[curveIndex].push(newLev);
          }
        }
      } // re-sort all of the data into histogram bins


      var d = {
        // d will contain the curve data
        x: [],
        //placeholder
        y: [],
        //placeholder
        error_x: [],
        // unused
        error_y: [],
        // unused
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {},
        // placeholder
        bin_stats: [],
        // placeholder
        text: [],
        //placeholder
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE
      };
      newCurveData = matsDataUtils.sortHistogramBins(newSubStats[curveIndex], newSubSecs[curveIndex], newSubLevs[curveIndex], data.x.length, binStats, true, d);
      var newCurveDataKeys = Object.keys(newCurveData.d);

      for (var didx = 0; didx < newCurveDataKeys.length; didx++) {
        dataset[curveIndex][newCurveDataKeys[didx]] = newCurveData.d[newCurveDataKeys[didx]];
      }
    } else {
      // if there are no matching values, set data to an empty dataset
      dataset[curveIndex] = {
        x: [],
        y: [],
        error_x: [],
        error_y: [],
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {},
        bin_stats: [],
        text: [],
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE
      };
    }
  }

  return dataset;
};

module.exportDefault(matsDataMatchUtils = {
  getMatchedDataSet: getMatchedDataSet,
  getMatchedDataSetWithLevels: getMatchedDataSetWithLevels,
  getMatchedDataSetHistogram: getMatchedDataSetHistogram,
  getMatchedDataSetHistogramWithLevels: getMatchedDataSetHistogramWithLevels
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_curve_ops_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_curve_ops_util.js                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */
// adds a horizontal black line along a specific y value
const getHorizontalValueLine = function (xmax, xmin, yValue, cLabel) {
  const valueLine = {
    "label": cLabel,
    "curveId": cLabel,
    "annotation": "",
    "name": "y = " + yValue.toString(),
    "mode": "lines",
    "x": [xmin, xmax],
    "x_epoch": [xmin, xmax],
    "y": [yValue, yValue],
    "error_x": [null, null],
    "error_y": [null, null],
    "subVals": [],
    "subSecs": [],
    "subLevs": [],
    "stats": [{
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }, {
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }],
    "tooltip": ["y = " + yValue.toString(), "y = " + yValue.toString()],
    "xmin": xmin,
    "xmax": xmax,
    "ymin": yValue,
    "ymax": yValue,
    "line": {
      "color": "rgb(0,0,0)"
    }
  };
  return valueLine;
}; // adds a vertical black line along a specific x value


const getVerticalValueLine = function (ymax, ymin, xValue, cLabel) {
  const valueLine = {
    "label": cLabel,
    "curveId": cLabel,
    "annotation": "",
    "name": "x = " + xValue.toString(),
    "mode": "lines",
    "x": [xValue, xValue],
    "y": [ymin, ymax],
    "error_x": [null, null],
    "error_y": [null, null],
    "subVals": [],
    "subSecs": [],
    "subLevs": [],
    "stats": [{
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }, {
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }],
    "tooltip": ["x = " + xValue.toString(), "x = " + xValue.toString()],
    "xmin": xValue,
    "xmax": xValue,
    "ymin": ymin,
    "ymax": ymax,
    "line": {
      "color": "rgb(0,0,0)"
    }
  };
  return valueLine;
}; // adds a linear line


const getLinearValueLine = function (xmax, xmin, ymax, ymin, cLabel) {
  const valueLine = {
    "label": cLabel,
    "curveId": cLabel,
    "annotation": "",
    "name": cLabel,
    "mode": "lines",
    "x": [xmin, xmax],
    "x_epoch": [xmin, xmax],
    "y": [ymin, ymax],
    "error_x": [null, null],
    "error_y": [null, null],
    "subVals": [],
    "subSecs": [],
    "subLevs": [],
    "stats": [{
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }, {
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }],
    "tooltip": "",
    "xmin": xmin,
    "xmax": xmax,
    "ymin": ymin,
    "ymax": ymax,
    "line": {
      "color": "rgb(0,0,0)"
    }
  };
  return valueLine;
}; // provides curve options for all plot types with an independent x axis and a dependent y axis


const generateSeriesCurveOptions = function (curve, curveIndex, axisMap, dataSeries) {
  const label = curve['label'];
  const annotation = curve['annotation']; // adjust axes for later setting of the plot options

  const ymin = curve['ymin'];
  const ymax = curve['ymax'];
  const xmin = curve['xmin'];
  const xmax = curve['xmax'];
  const axisKey = curve['axisKey'];

  if (axisKey in axisMap) {
    axisMap[axisKey].axisLabel = axisKey;
    axisMap[axisKey].ymin = ymin < axisMap[axisKey].ymin ? ymin : axisMap[axisKey].ymin;
    axisMap[axisKey].ymax = ymax > axisMap[axisKey].ymax ? ymax : axisMap[axisKey].ymax;
    axisMap[axisKey].xmin = xmin < axisMap[axisKey].xmin ? xmin : axisMap[axisKey].xmin;
    axisMap[axisKey].xmax = xmax > axisMap[axisKey].xmax ? xmax : axisMap[axisKey].xmax;
  } else {
    axisMap[axisKey] = {
      index: Object.keys(axisMap).length + 1,
      xmin: xmin,
      xmax: xmax,
      ymin: ymin,
      ymax: ymax,
      axisLabel: axisKey
    };
  }

  const axisNumber = Object.keys(axisMap).indexOf(axisKey);
  var error_y_temp = {
    error_y: {
      array: dataSeries.error_y,
      thickness: 1,
      // set the thickness of the error bars
      color: curve['color'],
      visible: false // changed later if matching
      // width: 0

    }
  };
  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    xaxis: "x1",
    yaxis: "y" + (axisNumber + 1),
    annotation: annotation,
    annotateColor: curve['color'],
    mode: "lines+markers",
    marker: {
      symbol: "circle",
      color: curve['color'],
      size: 8
    },
    line: {
      dash: 'solid',
      color: curve['color'],
      width: 2
    },
    visible: true
  }, dataSeries);
  delete curveOptions.error_y;
  curveOptions['error_y'] = error_y_temp.error_y;
  return curveOptions;
}; // provides curve options for all plot types with an independent y axis and a dependent x axis


const generateProfileCurveOptions = function (curve, curveIndex, axisMap, dataProfile) {
  const label = curve['label'];
  const annotation = curve['annotation']; // adjust axes for later setting of the plot options

  const ymin = curve['ymin'];
  const ymax = curve['ymax'];
  const xmin = curve['xmin'];
  const xmax = curve['xmax'];
  const axisKey = curve['axisKey'];

  if (axisKey in axisMap) {
    axisMap[axisKey].axisLabel = axisKey;
    axisMap[axisKey].ymin = ymin < axisMap[axisKey].ymin ? ymin : axisMap[axisKey].ymin;
    axisMap[axisKey].ymax = ymax > axisMap[axisKey].ymax ? ymax : axisMap[axisKey].ymax;
    axisMap[axisKey].xmin = xmin < axisMap[axisKey].xmin ? xmin : axisMap[axisKey].xmin;
    axisMap[axisKey].xmax = xmax > axisMap[axisKey].xmax ? xmax : axisMap[axisKey].xmax;
  } else {
    axisMap[axisKey] = {
      index: Object.keys(axisMap).length + 1,
      xmin: xmin,
      xmax: xmax,
      ymin: ymin,
      ymax: ymax,
      axisLabel: axisKey
    };
  }

  const axisNumber = Object.keys(axisMap).indexOf(axisKey);
  var error_x_temp = {
    error_x: {
      array: dataProfile.error_x,
      thickness: 1,
      // set the thickness of the error bars
      color: curve['color'],
      visible: false // changed later if matching
      // width: 0

    }
  };
  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    xaxis: "x" + (axisNumber + 1),
    yaxis: "y1",
    annotation: annotation,
    annotateColor: curve['color'],
    mode: "lines+markers",
    marker: {
      symbol: "circle",
      color: curve['color'],
      size: 8
    },
    line: {
      dash: 'solid',
      color: curve['color'],
      width: 2
    },
    visible: true
  }, dataProfile);
  delete curveOptions.error_x;
  curveOptions['error_x'] = error_x_temp.error_x;
  return curveOptions;
}; // provides curve options for reliability diagrams


const generateReliabilityCurveOptions = function (curve, curveIndex, axisMap, dataSeries) {
  const label = curve['label'];
  const annotation = curve['annotation']; // adjust axes for later setting of the plot options

  const ymin = curve['ymin'];
  const ymax = curve['ymax'];
  const xmin = curve['xmin'];
  const xmax = curve['xmax'];
  const axisKey = curve['axisKey'];

  if (axisKey in axisMap) {
    axisMap[axisKey].axisLabel = axisKey;
    axisMap[axisKey].ymin = ymin < axisMap[axisKey].ymin ? ymin : axisMap[axisKey].ymin;
    axisMap[axisKey].ymax = ymax > axisMap[axisKey].ymax ? ymax : axisMap[axisKey].ymax;
    axisMap[axisKey].xmin = xmin < axisMap[axisKey].xmin ? xmin : axisMap[axisKey].xmin;
    axisMap[axisKey].xmax = xmax > axisMap[axisKey].xmax ? xmax : axisMap[axisKey].xmax;
  } else {
    axisMap[axisKey] = {
      index: Object.keys(axisMap).length + 1,
      xmin: xmin,
      xmax: xmax,
      ymin: ymin,
      ymax: ymax,
      axisLabel: axisKey
    };
  }

  const axisNumber = Object.keys(axisMap).indexOf(axisKey);
  var error_y_temp = {
    error_y: {
      array: dataSeries.error_y,
      thickness: 1,
      // set the thickness of the error bars
      color: curve['color'],
      visible: false // changed later if matching
      // width: 0

    }
  };
  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    xaxis: "x1",
    yaxis: "y" + (axisNumber + 1),
    annotation: annotation,
    annotateColor: curve['color'],
    mode: "lines+markers",
    marker: {
      symbol: "circle",
      color: curve['color'],
      size: 8
    },
    line: {
      dash: 'solid',
      color: curve['color'],
      width: 2
    },
    visible: true
  }, dataSeries);
  delete curveOptions.error_y;
  curveOptions['error_y'] = error_y_temp.error_y;
  return curveOptions;
}; // provides curve options for all plot types with an independent x axis and a dependent y axis


const generateBarChartCurveOptions = function (curve, curveIndex, axisMap, dataBars) {
  const label = curve['label'];
  const annotation = curve['annotation']; // adjust axes for later setting of the plot options

  const ymin = curve['ymin'];
  const ymax = curve['ymax'];
  const xmin = curve['xmin'];
  const xmax = curve['xmax'];
  const axisKey = curve['axisKey'];

  if (axisKey in axisMap) {
    axisMap[axisKey].axisLabel = axisKey;
    axisMap[axisKey].ymin = ymin < axisMap[axisKey].ymin ? ymin : axisMap[axisKey].ymin;
    axisMap[axisKey].ymax = ymax > axisMap[axisKey].ymax ? ymax : axisMap[axisKey].ymax;
    axisMap[axisKey].xmin = xmin < axisMap[axisKey].xmin ? xmin : axisMap[axisKey].xmin;
    axisMap[axisKey].xmax = xmax > axisMap[axisKey].xmax ? xmax : axisMap[axisKey].xmax;
  } else {
    axisMap[axisKey] = {
      index: Object.keys(axisMap).length + 1,
      xmin: xmin,
      xmax: xmax,
      ymin: ymin,
      ymax: ymax,
      axisLabel: axisKey
    };
  }

  const curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    annotation: annotation,
    annotateColor: curve['color'],
    marker: {
      color: curve['color'],
      line: {
        color: "rgb(0,0,0)"
      }
    },
    type: 'bar',
    visible: true
  }, dataBars);
  return curveOptions;
};

const generateMapCurveOptions = function (curve, dataSeries) {
  const markerSizes = dataSeries.queryVal.map(function (val) {
    return Math.ceil(Math.abs(val * 4)) + 2;
  });
  const label = curve['label'];
  const curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    type: 'scattermapbox',
    mode: 'markers',
    marker: {
      color: dataSeries.color,
      size: markerSizes,
      opacity: 0
    }
  }, dataSeries);
  delete curveOptions.color;
  return curveOptions;
};

const generateMapColorTextOptions = function (label, dataSeries) {
  const curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    type: 'scattermapbox',
    mode: 'markers+text',
    marker: {
      opacity: 0
    },
    textfont: {
      family: 'sans serif',
      // size: 18,
      color: dataSeries.color
    },
    hoverinfo: 'skip',
    visible: true
  }, dataSeries);
  delete curveOptions.color;
  return curveOptions;
};

const generateContourCurveOptions = function (curve, axisMap, dataset) {
  const label = curve['label'];
  const annotation = curve['annotation'];
  const unitKey = curve['unitKey'];
  const curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    annotation: annotation,
    annotateColor: curve['color'],
    xAxisKey: curve['xAxisKey'],
    yAxisKey: curve['yAxisKey'],
    marker: {
      color: curve['color']
    },
    type: 'contour',
    autocontour: false,
    ncontours: 15,
    // apparently plotly regards this as a "less than or equal to" field
    contours: {
      // these are only used if autocontour is set to false and ncontour is disregarded
      start: dataset.zmin + (dataset.zmax - dataset.zmin) / 16,
      end: dataset.zmax - (dataset.zmax - dataset.zmin) / 16,
      size: (dataset.zmax - dataset.zmin) / 16,
      showlabels: false
    },
    colorscale: 'RdBu',
    reversescale: false,
    colorbar: {
      title: unitKey,
      titleside: 'right',
      titlefont: {
        size: 20,
        family: 'Arial, sans-serif'
      }
    },
    // connectgaps: true,   // this option will interpolate to fill in nulls
    visible: true
  }, dataset);
  return curveOptions;
};

module.exportDefault(matsDataCurveOpsUtils = {
  getHorizontalValueLine: getHorizontalValueLine,
  getVerticalValueLine: getVerticalValueLine,
  getLinearValueLine: getLinearValueLine,
  generateSeriesCurveOptions: generateSeriesCurveOptions,
  generateReliabilityCurveOptions: generateReliabilityCurveOptions,
  generateProfileCurveOptions: generateProfileCurveOptions,
  generateBarChartCurveOptions: generateBarChartCurveOptions,
  generateMapCurveOptions: generateMapCurveOptions,
  generateMapColorTextOptions: generateMapColorTextOptions,
  generateContourCurveOptions: generateContourCurveOptions
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_plot_ops_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_plot_ops_util.js                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  }

}, 0);
let matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes(v) {
    matsTypes = v;
  }

}, 1);
let moment;
module.link("meteor/momentjs:moment", {
  moment(v) {
    moment = v;
  }

}, 2);

// sets plot options for timeseries graphs
const generateSeriesPlotOptions = function (dataset, curves, axisMap, errorMax) {
  var xmin = axisMap[Object.keys(axisMap)[0]].xmin;
  var xmax = axisMap[Object.keys(axisMap)[0]].xmax;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Time',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 12
    }
  };
  const axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  const axisSide = {
    0: 'left',
    1: 'right',
    2: 'left',
    3: 'right',
    4: 'left',
    5: 'right',
    6: 'left',
    7: 'right'
  };
  const axisPosition = {
    0: 0,
    1: 1,
    2: 0.1,
    3: 0.9,
    4: 0.2,
    5: 0.8,
    6: 0.3,
    7: 0.7
  };
  const yAxisNumber = Object.keys(axisMap).length;
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < yAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var ymin = axisMap[axisKey].ymin;
    var ymax = axisMap[axisKey].ymax;
    ymax = ymax + errorMax;
    ymin = ymin - errorMax;
    const yPad = (ymax - ymin) * 0.05 !== 0 ? (ymax - ymin) * 0.05 : 0.05;
    xmin = axisMap[axisKey].xmin < xmin ? axisMap[axisKey].xmin : xmin;
    xmax = axisMap[axisKey].xmax > xmax ? axisMap[axisKey].xmax : xmax;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'yaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'y',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'y',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  const xPad = (xmax - xmin) * 0.075 !== 0 ? (xmax - xmin) * 0.075 : 0.075;
  xmax = moment.utc(xmax + xPad * Math.ceil(yAxisNumber / 2)).format("YYYY-MM-DD HH:mm");
  xmin = moment.utc(xmin - xPad * Math.ceil(yAxisNumber / 2)).format("YYYY-MM-DD HH:mm");
  layout['xaxis']['range'] = [xmin, xmax];
  return layout;
}; // sets plot options for profile graphs


const generateProfilePlotOptions = function (dataset, curves, axisMap, errorMax) {
  var ymin = 10;
  var ymax = 1075;
  const xAxisNumber = Object.keys(axisMap).length;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: xAxisNumber > 1 ? 80 : 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  var tickVals;
  var tickText;

  if (matsCollections.Settings.findOne({}).appType === matsTypes.AppTypes.metexpress) {
    tickVals = [1000, 850, 700, 600, 500, 400, 300, 250, 200, 150, 100, 50, 10];
    tickText = ['1000', '850', '700', '600', '500', '400', '300', '250', '200', '150', '100', '50', '10'];
  } else {
    tickVals = [1000, 900, 800, 700, 600, 500, 400, 300, 200, 100];
    tickText = ['1000', '900', '800', '700', '600', '500', '400', '300', '200', '100'];
  }

  layout['yaxis'] = {
    title: 'Pressure Level',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: tickVals,
    ticktext: tickText,
    type: 'linear',
    autorange: 'reversed'
  };
  const axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  const axisSide = {
    0: 'bottom',
    1: 'top',
    2: 'bottom',
    3: 'top',
    4: 'bottom',
    5: 'top',
    6: 'bottom',
    7: 'top'
  };
  const axisPosition = {
    0: 0,
    1: 1,
    2: 0.15,
    3: 0.85,
    4: 0.3,
    5: 0.7,
    6: 0.45,
    7: 0.55
  };
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < xAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var xmin = axisMap[axisKey].xmin;
    var xmax = axisMap[axisKey].xmax;
    xmax = xmax + errorMax;
    xmin = xmin - errorMax;
    axisLabel = axisMap[axisKey].axisLabel;
    const xPad = (xmax - xmin) * 0.05 !== 0 ? (xmax - xmin) * 0.05 : 0.05;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'xaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [xmin - xPad, xmax + xPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'xaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [xmin - xPad, xmax + xPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'x',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'xaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [xmin - xPad, xmax + xPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'x',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  const yPad = (ymax - ymin) * 0.25 !== 0 ? (ymax - ymin) * 0.25 : 0.25;
  ymax = ymax + yPad * Math.ceil(xAxisNumber / 2);
  ymin = ymin - yPad * Math.ceil(xAxisNumber / 2);
  layout['yaxis']['range'] = [ymin, ymax];
  return layout;
}; // sets plot options for dieoff graphs


const generateDieoffPlotOptions = function (dataset, curves, axisMap, errorMax) {
  var xmin = axisMap[Object.keys(axisMap)[0]].xmin;
  var xmax = axisMap[Object.keys(axisMap)[0]].xmax;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Forecast Hour',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    }
  };
  const axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  const axisSide = {
    0: 'left',
    1: 'right',
    2: 'left',
    3: 'right',
    4: 'left',
    5: 'right',
    6: 'left',
    7: 'right'
  };
  const axisPosition = {
    0: 0,
    1: 1,
    2: 0.1,
    3: 0.9,
    4: 0.2,
    5: 0.8,
    6: 0.3,
    7: 0.7
  };
  const yAxisNumber = Object.keys(axisMap).length;
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < yAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var ymin = axisMap[axisKey].ymin;
    var ymax = axisMap[axisKey].ymax;
    ymax = ymax + errorMax;
    ymin = ymin - errorMax;
    const yPad = (ymax - ymin) * 0.05 !== 0 ? (ymax - ymin) * 0.05 : 0.05;
    xmin = axisMap[axisKey].xmin < xmin ? axisMap[axisKey].xmin : xmin;
    xmax = axisMap[axisKey].xmax > xmax ? axisMap[axisKey].xmax : xmax;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'yaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'y',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'y',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  const xPad = (xmax - xmin) * 0.075 !== 0 ? (xmax - xmin) * 0.075 : 0.075;
  xmax = xmax + xPad * Math.ceil(yAxisNumber / 2);
  xmin = xmin - xPad * Math.ceil(yAxisNumber / 2);
  layout['xaxis']['range'] = [xmin, xmax];
  return layout;
}; // sets plot options for threshold graphs


const generateThresholdPlotOptions = function (dataset, curves, axisMap, errorMax) {
  var xmin = 0;
  var xmax = 3;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Threshold',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: [0.01, 0.1, 0.25, 0.5, 1.0, 1.5, 2.0, 3.0],
    ticktext: ["0.01", "0.10", "0.25", "0.50", "1.00", "1.50", "2.00", "3.00"]
  };
  const axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  const axisSide = {
    0: 'left',
    1: 'right',
    2: 'left',
    3: 'right',
    4: 'left',
    5: 'right',
    6: 'left',
    7: 'right'
  };
  const axisPosition = {
    0: 0,
    1: 1,
    2: 0.1,
    3: 0.9,
    4: 0.2,
    5: 0.8,
    6: 0.3,
    7: 0.7
  };
  const yAxisNumber = Object.keys(axisMap).length;
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < yAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var ymin = axisMap[axisKey].ymin;
    var ymax = axisMap[axisKey].ymax;
    ymax = ymax + errorMax;
    ymin = ymin - errorMax;
    const yPad = (ymax - ymin) * 0.05 !== 0 ? (ymax - ymin) * 0.05 : 0.05;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'yaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'y',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'y',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  const xPad = (xmax - xmin) * 0.075 !== 0 ? (xmax - xmin) * 0.075 : 0.075;
  xmax = xmax + xPad * Math.ceil(yAxisNumber / 2);
  xmin = xmin - xPad * Math.ceil(yAxisNumber / 2);
  layout['xaxis']['range'] = [xmin, xmax];
  return layout;
}; // sets plot options for valid time graphs


const generateValidTimePlotOptions = function (dataset, curves, axisMap, errorMax) {
  var xmin = 0;
  var xmax = 23;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Hour of Day',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],
    ticktext: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"]
  };
  const axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  const axisSide = {
    0: 'left',
    1: 'right',
    2: 'left',
    3: 'right',
    4: 'left',
    5: 'right',
    6: 'left',
    7: 'right'
  };
  const axisPosition = {
    0: 0,
    1: 1,
    2: 0.1,
    3: 0.9,
    4: 0.2,
    5: 0.8,
    6: 0.3,
    7: 0.7
  };
  const yAxisNumber = Object.keys(axisMap).length;
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < yAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var ymin = axisMap[axisKey].ymin;
    var ymax = axisMap[axisKey].ymax;
    ymax = ymax + errorMax;
    ymin = ymin - errorMax;
    const yPad = (ymax - ymin) * 0.05 !== 0 ? (ymax - ymin) * 0.05 : 0.05;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'yaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'y',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'y',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  const xPad = (xmax - xmin) * 0.075 !== 0 ? (xmax - xmin) * 0.075 : 0.075;
  xmax = xmax + xPad * Math.ceil(yAxisNumber / 2);
  xmin = xmin - xPad * Math.ceil(yAxisNumber / 2);
  layout['xaxis']['range'] = [xmin, xmax];
  return layout;
}; // sets plot options for reliability graphs


const generateReliabilityPlotOptions = function (dataset) {
  var xmin = 0;
  var xmax = 1;
  var ymin = 0;
  var ymax = 1;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: true,
    perfectLine: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Forecast Probability',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
    ticktext: ["0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0"],
    range: [xmin, xmax]
  };
  layout['yaxis'] = {
    title: 'Observed Relative Frequency',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
    ticktext: ["0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0"],
    range: [ymin, ymax]
  };
  return layout;
}; // sets plot options for map graphs


const generateMapPlotOptions = function () {
  const options = {
    autosize: true,
    hovermode: 'closest',
    mapbox: {
      bearing: 0,
      center: {
        lat: 39.834,
        lon: -98.604
      },
      pitch: 0,
      zoom: 3.25,
      accesstoken: 'pk.eyJ1IjoibWF0cy1nc2QiLCJhIjoiY2pvN2l1N2MyMG9xdTN3bWR3ODV5a2E2ZiJ9.PtgcGhxaoD43N0OwJSNVMg',
      style: 'light'
    },
    margin: {
      l: 30,
      r: 30,
      b: 40,
      t: 10,
      pad: 4
    },
    showlegend: false
  };
  return options;
}; // sets plot options for valid time graphs


const generateHistogramPlotOptions = function (dataset, curves, axisMap, plotBins) {
  const axisKey = curves[0].axisKey;
  const axisLabel = axisMap[axisKey].axisLabel;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    bargap: 0.25,
    barmode: 'group',
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Bin',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 12
    },
    tickvals: plotBins.binMeans,
    ticktext: plotBins.binLabels
  };
  layout['yaxis'] = {
    title: axisLabel,
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    }
  };
  return layout;
}; // sets plot options for valid time graphs


const generateContourPlotOptions = function (dataset, axisMap) {
  const xAxisKey = dataset[0]['xAxisKey'];
  const yAxisKey = dataset[0]['yAxisKey'];
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    }
  };
  layout['xaxis'] = {
    title: xAxisKey,
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 12
    }
  };

  if (yAxisKey === "Pressure level") {
    layout['yaxis'] = {
      title: yAxisKey,
      titlefont: {
        color: '#000000',
        size: 22
      },
      tickfont: {
        color: '#000000',
        size: 14
      },
      tickvals: [1000, 900, 800, 700, 600, 500, 400, 300, 200, 100],
      ticktext: ['1000', '900', '800', '700', '600', '500', '400', '300', '200', '100'],
      range: [1100, 0],
      type: 'linear',
      autorange: 'reversed'
    };
  } else {
    layout['yaxis'] = {
      title: yAxisKey,
      titlefont: {
        color: '#000000',
        size: 22
      },
      tickfont: {
        color: '#000000',
        size: 14
      }
    };
  }

  return layout;
};

module.exportDefault(matsDataPlotOpsUtils = {
  generateSeriesPlotOptions: generateSeriesPlotOptions,
  generateProfilePlotOptions: generateProfilePlotOptions,
  generateDieoffPlotOptions: generateDieoffPlotOptions,
  generateThresholdPlotOptions: generateThresholdPlotOptions,
  generateValidTimePlotOptions: generateValidTimePlotOptions,
  generateReliabilityPlotOptions: generateReliabilityPlotOptions,
  generateMapPlotOptions: generateMapPlotOptions,
  generateHistogramPlotOptions: generateHistogramPlotOptions,
  generateContourPlotOptions: generateContourPlotOptions
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_process_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_process_util.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes(v) {
    matsTypes = v;
  }

}, 0);
let matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  }

}, 1);
let matsDataUtils;
module.link("meteor/randyp:mats-common", {
  matsDataUtils(v) {
    matsDataUtils = v;
  }

}, 2);
let matsDataMatchUtils;
module.link("meteor/randyp:mats-common", {
  matsDataMatchUtils(v) {
    matsDataMatchUtils = v;
  }

}, 3);
let matsDataDiffUtils;
module.link("meteor/randyp:mats-common", {
  matsDataDiffUtils(v) {
    matsDataDiffUtils = v;
  }

}, 4);
let matsDataCurveOpsUtils;
module.link("meteor/randyp:mats-common", {
  matsDataCurveOpsUtils(v) {
    matsDataCurveOpsUtils = v;
  }

}, 5);
let matsDataPlotOpsUtils;
module.link("meteor/randyp:mats-common", {
  matsDataPlotOpsUtils(v) {
    matsDataPlotOpsUtils = v;
  }

}, 6);
let moment;
module.link("meteor/momentjs:moment", {
  moment(v) {
    moment = v;
  }

}, 7);

const processDataXYCurve = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {
  // variable to store maximum error bar length
  var errorMax = Number.MIN_VALUE;
  var error = "";
  const appName = matsCollections.appName.findOne({}).app; // if matching, pare down dataset to only matching data

  if (curveInfoParams.curvesLength > 1 && appParams.matching) {
    if (appParams.hasLevels) {
      dataset = matsDataMatchUtils.getMatchedDataSetWithLevels(dataset, curveInfoParams.curvesLength, appParams.plotType);
    } else {
      dataset = matsDataMatchUtils.getMatchedDataSet(dataset, curveInfoParams.curvesLength);
    }
  } // we may need to recalculate the axis limits after unmatched data and outliers are removed


  var axisLimitReprocessed = {}; // calculate data statistics (including error bars) for each curve

  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    if (appName !== "surfrad") {
      axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] = axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] !== undefined;
    }

    var diffFrom = curveInfoParams.curves[curveIndex].diffFrom;
    var statisticSelect = appName.indexOf("anomalycor") !== -1 ? "ACC" : curveInfoParams.curves[curveIndex]['statistic'];
    var data = dataset[curveIndex];
    const label = dataset[curveIndex].label;
    var di = 0;
    var values = [];
    var indVars = [];
    var means = [];
    var rawStat;
    /*
    dataset[curveIndex] is the dataset.
    it looks like:
     d = {
        x: [],
        y: [],
        error_x: [],   // curveTime
        error_y: [],   // values
        subVals: [],   //subVals
        subSecs: [],   //subSecs
        subLevs: [],   //subLevs
        stats: [],     //pointStats
        text: [],
        glob_stats: {},     //curveStats
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE,
        sum: 0
    };
    */

    while (di < data.x.length) {
      // errorResult holds all the calculated curve stats like mean, sd, etc.
      var errorResult;

      if (appParams.hasLevels) {
        errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], data.subLevs[di]);
      } else {
        errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], []);
      } // store raw statistic from query before recalculating that statistic to account for data removed due to matching, QC, etc.


      rawStat = data.y[di]; // this ungainly if statement is because the surfrad3 database doesn't support recalculating some stats.

      if (appName !== "surfrad" || !(appName === "surfrad" && (statisticSelect === 'Std deviation (do not plot matched)' || statisticSelect === 'RMS (do not plot matched)') && !appParams.matching)) {
        if (diffFrom === null || diffFrom === undefined || !appParams.matching) {
          // assign recalculated statistic to data[di][1], which is the value to be plotted
          data.y[di] = errorResult.d_mean;
        } else {
          if (dataset[diffFrom[0]].y[di] !== null && dataset[diffFrom[1]].y[di] !== null) {
            // make sure that the diff curve actually shows the difference when matching. Otherwise outlier filtering etc. can make it slightly off.
            data.y[di] = dataset[diffFrom[0]].y[di] - dataset[diffFrom[1]].y[di];
          } else {
            // keep the null for no data at this point
            data.y[di] = null;
          }
        }
      }

      values.push(data.y[di]);
      indVars.push(data.x[di]);
      means.push(errorResult.d_mean); // store error bars if matching

      const errorBar = errorResult.stde_betsy * 1.96;

      if (appParams.matching) {
        errorMax = errorMax > errorBar ? errorMax : errorBar;
        data.error_y.array[di] = errorBar;
      } else {
        data.error_y.array[di] = null;
      } // remove sub values and times to save space


      data.subVals[di] = [];
      data.subSecs[di] = [];
      data.subLevs[di] = []; // store statistics for this di datapoint

      data.stats[di] = {
        raw_stat: rawStat,
        d_mean: errorResult.d_mean,
        sd: errorResult.sd,
        n_good: errorResult.n_good,
        lag1: errorResult.lag1,
        stde_betsy: errorResult.stde_betsy
      }; // this is the tooltip, it is the last element of each dataseries element.
      // also change the x array from epoch to date for timeseries and DMC, as we are now done with it for calculations.

      data.text[di] = label;

      switch (appParams.plotType) {
        case matsTypes.PlotTypes.timeSeries:
          data.text[di] = data.text[di] + "<br>time: " + moment.utc(data.x[di]).format("YYYY-MM-DD HH:mm");
          break;

        case matsTypes.PlotTypes.dailyModelCycle:
          var fhr = data.x[di] / 1000 % (24 * 3600) / 3600 - curveInfoParams.utcCycleStarts[curveIndex];
          fhr = fhr < 0 ? fhr + 24 : fhr;
          data.text[di] = data.text[di] + "<br>time: " + moment.utc(data.x[di]).format("YYYY-MM-DD HH:mm");
          data.text[di] = data.text[di] + "<br>forecast hour: " + fhr;
          break;

        case matsTypes.PlotTypes.dieoff:
          data.text[di] = data.text[di] + "<br>fhr: " + data.x[di];
          break;

        case matsTypes.PlotTypes.threshold:
          data.text[di] = data.text[di] + "<br>threshold: " + data.x[di];
          break;

        case matsTypes.PlotTypes.validtime:
          data.text[di] = data.text[di] + "<br>hour of day: " + data.x[di];
          break;

        default:
          data.text[di] = data.text[di] + "<br>" + data.x[di];
          break;
      }

      data.text[di] = data.text[di] + "<br>" + statisticSelect + ": " + (data.y[di] === null ? null : data.y[di].toPrecision(4)) + "<br>sd: " + (errorResult.sd === null ? null : errorResult.sd.toPrecision(4)) + "<br>mean: " + (errorResult.d_mean === null ? null : errorResult.d_mean.toPrecision(4)) + "<br>n: " + errorResult.n_good + // "<br>lag1: " + (errorResult.lag1 === null ? null : errorResult.lag1.toPrecision(4)) +
      // "<br>stde: " + errorResult.stde_betsy +
      "<br>errorbars: " + Number(data.y[di] - errorResult.stde_betsy * 1.96).toPrecision(4) + " to " + Number(data.y[di] + errorResult.stde_betsy * 1.96).toPrecision(4);
      di++;
    } // enable error bars if matching and they aren't null


    if (appParams.matching && data.error_y.array.filter(x => x).length > 0) {
      data.error_y.visible = true;
    } // get the overall stats for the text output - this uses the means not the stats.


    const stats = matsDataUtils.get_err(values, indVars, []);
    const filteredMeans = means.filter(x => x);
    var miny = Math.min(...filteredMeans);
    var maxy = Math.max(...filteredMeans);

    if (means.indexOf(0) !== -1 && 0 < miny) {
      miny = 0;
    }

    if (means.indexOf(0) !== -1 && 0 > maxy) {
      maxy = 0;
    }

    stats.miny = miny;
    stats.maxy = maxy;
    dataset[curveIndex]['glob_stats'] = stats; // recalculate axis options after QC and matching

    if (appName !== "surfrad") {
      const minx = Math.min(...indVars);
      const maxx = Math.max(...indVars);
      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'] < maxy || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? maxy : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'];
      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'] > miny || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? miny : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'];
      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] < maxx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? maxx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'];
      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] > minx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? minx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'];
    } // recalculate curve annotation after QC and matching


    if (stats.d_mean !== undefined && stats.d_mean !== null) {
      dataset[curveIndex]['annotation'] = label + "- mean = " + stats.d_mean.toPrecision(4);
    }

    if (appParams.plotType === matsTypes.PlotTypes.timeSeries || appParams.plotType === matsTypes.PlotTypes.dailyModelCycle) {
      data['x_epoch'] = data.x;
      data.x = data.x.map(function (val) {
        return moment.utc(val).format("YYYY-MM-DD HH:mm");
      });
    }
  } // add black 0 line curve
  // need to define the minimum and maximum x value for making the zero curve


  const zeroLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, 0, matsTypes.ReservedWords.zero);
  dataset.push(zeroLine); //add ideal value lines, if any

  var idealValueLine;
  var idealLabel;

  for (var ivIdx = 0; ivIdx < curveInfoParams.idealValues.length; ivIdx++) {
    idealLabel = "ideal" + ivIdx.toString();
    idealValueLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, curveInfoParams.idealValues[ivIdx], matsTypes.ReservedWords[idealLabel]);
    dataset.push(idealValueLine);
  } // generate plot options


  var resultOptions;

  switch (appParams.plotType) {
    case matsTypes.PlotTypes.timeSeries:
    case matsTypes.PlotTypes.dailyModelCycle:
      resultOptions = matsDataPlotOpsUtils.generateSeriesPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
      break;

    case matsTypes.PlotTypes.dieoff:
      resultOptions = matsDataPlotOpsUtils.generateDieoffPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
      break;

    case matsTypes.PlotTypes.validtime:
      resultOptions = matsDataPlotOpsUtils.generateValidTimePlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
      break;

    case matsTypes.PlotTypes.threshold:
      resultOptions = matsDataPlotOpsUtils.generateThresholdPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
      break;

    default:
      break;
  }

  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

const processDataProfile = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {
  // variable to store maximum error bar length
  var errorMax = Number.MIN_VALUE;
  var error = "";
  const appName = matsCollections.appName.findOne({}).app; // if matching, pare down dataset to only matching data

  if (curveInfoParams.curvesLength > 1 && appParams.matching) {
    dataset = matsDataMatchUtils.getMatchedDataSetWithLevels(dataset, curveInfoParams.curvesLength, appParams.plotType);
  } // we may need to recalculate the axis limits after unmatched data and outliers are removed


  var axisLimitReprocessed = {}; // calculate data statistics (including error bars) for each curve

  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] = axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] !== undefined;
    var diffFrom = curveInfoParams.curves[curveIndex].diffFrom;
    var statisticSelect = appName.indexOf("anomalycor") !== -1 ? "ACC" : curveInfoParams.curves[curveIndex]['statistic'];
    var data = dataset[curveIndex];
    const label = dataset[curveIndex].label;
    var di = 0;
    var values = [];
    var levels = [];
    var means = [];
    var rawStat;
    /*
    dataset[curveIndex] is the dataset.
    it looks like:
     d = {
        x: [],
        y: [],
        error_x: [],   // curveTime
        error_y: [],   // values
        subVals: [],   //subVals
        subSecs: [],   //subSecs
        subLevs: [],   //subLevs
        stats: [],     //pointStats
        text: [],
        glob_stats: {},     //curveStats
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE,
        sum: 0
    };
    */

    while (di < data.y.length) {
      // errorResult holds all the calculated curve stats like mean, sd, etc.
      var errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], data.subLevs[di]); // store raw statistic from query before recalculating that statistic to account for data removed due to matching, QC, etc.

      rawStat = data.x[di];

      if (diffFrom === null || diffFrom === undefined || !appParams.matching) {
        // assign recalculated statistic to data[di][1], which is the value to be plotted
        data.x[di] = errorResult.d_mean;
      } else {
        if (dataset[diffFrom[0]].x[di] !== null && dataset[diffFrom[1]].x[di] !== null) {
          // make sure that the diff curve actually shows the difference when matching. Otherwise outlier filtering etc. can make it slightly off.
          data.x[di] = dataset[diffFrom[0]].x[di] - dataset[diffFrom[1]].x[di];
        } else {
          // keep the null for no data at this point
          data.x[di] = null;
        }
      }

      values.push(data.x[di]);
      levels.push(data.y[di]);
      means.push(errorResult.d_mean); // store error bars if matching

      const errorBar = errorResult.stde_betsy * 1.96;

      if (appParams.matching) {
        errorMax = errorMax > errorBar ? errorMax : errorBar;
        data.error_x.array[di] = errorBar;
      } else {
        data.error_x.array[di] = null;
      } // remove sub values and times to save space


      data.subVals[di] = [];
      data.subSecs[di] = [];
      data.subLevs[di] = []; // store statistics

      data.stats[di] = {
        raw_stat: rawStat,
        d_mean: errorResult.d_mean,
        sd: errorResult.sd,
        n_good: errorResult.n_good,
        lag1: errorResult.lag1,
        stde_betsy: errorResult.stde_betsy
      }; // this is the tooltip, it is the last element of each dataseries element

      data.text[di] = label + "<br>" + data.y[di] + "mb" + "<br>" + statisticSelect + ": " + (data.x[di] === null ? null : data.x[di].toPrecision(4)) + "<br>sd: " + (errorResult.sd === null ? null : errorResult.sd.toPrecision(4)) + "<br>mean: " + (errorResult.d_mean === null ? null : errorResult.d_mean.toPrecision(4)) + "<br>n: " + errorResult.n_good + // "<br>lag1: " + (errorResult.lag1 === null ? null : errorResult.lag1.toPrecision(4)) +
      // "<br>stde: " + errorResult.stde_betsy +
      "<br>errorbars: " + Number(data.x[di] - errorResult.stde_betsy * 1.96).toPrecision(4) + " to " + Number(data.x[di] + errorResult.stde_betsy * 1.96).toPrecision(4);
      di++;
    } // enable error bars if matching and they aren't null


    if (appParams.matching && data.error_x.array.filter(x => x).length > 0) {
      data.error_x.visible = true;
    } // get the overall stats for the text output - this uses the means not the stats.


    const stats = matsDataUtils.get_err(values.reverse(), levels.reverse(), []); // have to reverse because of data inversion

    const filteredMeans = means.filter(x => x);
    var minx = Math.min(...filteredMeans);
    var maxx = Math.max(...filteredMeans);

    if (means.indexOf(0) !== -1 && 0 < minx) {
      minx = 0;
    }

    if (means.indexOf(0) !== -1 && 0 > maxx) {
      maxx = 0;
    }

    stats.minx = minx;
    stats.maxx = maxx;
    dataset[curveIndex]['glob_stats'] = stats; // recalculate axis options after QC and matching

    curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] < maxx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? maxx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'];
    curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] > minx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? minx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin']; // recalculate curve annotation after QC and matching

    if (stats.d_mean !== undefined && stats.d_mean !== null) {
      dataset[curveIndex]['annotation'] = label + "- mean = " + stats.d_mean.toPrecision(4);
    }
  } // add black 0 line curve
  // need to define the minimum and maximum x value for making the zero curve


  const zeroLine = matsDataCurveOpsUtils.getVerticalValueLine(1100, 0, 0, matsTypes.ReservedWords.zero);
  dataset.push(zeroLine); //add ideal value lines, if any

  var idealValueLine;
  var idealLabel;

  for (var ivIdx = 0; ivIdx < curveInfoParams.idealValues.length; ivIdx++) {
    idealLabel = "ideal" + ivIdx.toString();
    idealValueLine = matsDataCurveOpsUtils.getVerticalValueLine(1100, 0, curveInfoParams.idealValues[ivIdx], matsTypes.ReservedWords[idealLabel]);
    dataset.push(idealValueLine);
  } // generate plot options


  const resultOptions = matsDataPlotOpsUtils.generateProfilePlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

const processDataReliability = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {
  var error = ""; // calculate data statistics (including error bars) for each curve

  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    var data = dataset[curveIndex];
    const label = dataset[curveIndex].label;
    var sample_climo = data.subVals;
    var di = 0;
    /*
    dataset[curveIndex] is the dataset.
    it looks like:
     d = {
        x: [],
        y: [],
        error_x: [],   // curveTime
        error_y: [],   // values
        subVals: [],   //subVals
        subSecs: [],   //subSecs
        subLevs: [],   //subLevs
        stats: [],     //pointStats
        text: [],
        glob_stats: {},     //curveStats
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE,
        sum: 0
    };
    */

    while (di < data.x.length) {
      // store statistics for this di datapoint
      data.stats[di] = {
        prob_bin: data.x[di],
        hit_rate: data.y[di],
        obs_y: data.error_x[di],
        obs_n: data.subLevs[di]
      }; // this is the tooltip, it is the last element of each dataseries element.
      // also change the x array from epoch to date for timeseries and DMC, as we are now done with it for calculations.

      data.text[di] = label;
      data.text[di] = data.text[di] + "<br>probability bin: " + data.x[di];
      data.text[di] = data.text[di] + "<br>hit rate: " + data.y[di];
      data.text[di] = data.text[di] + "<br>oy: " + data.error_x[di];
      data.text[di] = data.text[di] + "<br>on: " + data.subLevs[di]; // remove sub values and times to save space

      data.subVals[di] = [];
      data.subSecs[di] = [];
      data.subLevs[di] = [];
      di++;
    }

    dataset[curveIndex]['glob_stats'] = {
      sample_climo: sample_climo
    };
  } // add black perfect reliability line curve


  const perfectLine = matsDataCurveOpsUtils.getLinearValueLine(curveInfoParams.xmax, curveInfoParams.xmin, data.ymax, data.ymin, matsTypes.ReservedWords.perfectReliability);
  dataset.push(perfectLine);

  if (sample_climo >= data.ymin) {
    var skillmin = sample_climo - (sample_climo - data.xmin) / 2;
  } else {
    var skillmin = data.xmin - (data.xmin - sample_climo) / 2;
  }

  if (sample_climo >= data.ymax) {
    var skillmax = sample_climo - (sample_climo - data.xmax) / 2;
  } else {
    var skillmax = data.xmax - (data.xmax - sample_climo) / 2;
  } // add black no skill line curve


  const noSkillLine = matsDataCurveOpsUtils.getLinearValueLine(curveInfoParams.xmax, curveInfoParams.xmin, skillmax, skillmin, matsTypes.ReservedWords.noSkill);
  dataset.push(noSkillLine); // add sample climo lines
  // need to define the minimum and maximum x value for making the curves

  const xClimoLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, sample_climo, matsTypes.ReservedWords.zero);
  dataset.push(xClimoLine);
  const yClimoLine = matsDataCurveOpsUtils.getVerticalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, sample_climo, matsTypes.ReservedWords.zero);
  dataset.push(yClimoLine); // generate plot options

  var resultOptions = matsDataPlotOpsUtils.generateReliabilityPlotOptions();
  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

const processDataHistogram = function (allReturnedSubStats, allReturnedSubSecs, allReturnedSubLevs, dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams) {
  var error = "";
  var curvesLengthSoFar = 0; // flatten all the returned data into one stats array and one secs array in order to calculate histogram bins over the whole range.

  const curveSubStats = [].concat.apply([], allReturnedSubStats);
  const curveSubSecs = [].concat.apply([], allReturnedSubSecs);
  var binStats;

  if (binParams.binBounds.length === 0) {
    binStats = matsDataUtils.calculateHistogramBins(curveSubStats, curveSubSecs, binParams).binStats;
  } else {
    binStats = matsDataUtils.prescribeHistogramBins(curveSubStats, curveSubSecs, binParams).binStats;
  } // store bin labels and x-axis positions of those labels for later when we set up the plot options


  var plotBins = {};
  plotBins['binMeans'] = [];
  plotBins['binLabels'] = [];

  for (var b_idx = 0; b_idx < binStats.binMeans.length; b_idx++) {
    plotBins['binMeans'].push(binStats.binMeans[b_idx]);
    plotBins['binLabels'].push(binStats.binLabels[b_idx]);
  } // post process curves


  var sortedData;
  var curve;
  var diffFrom;
  var label;

  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    curve = curveInfoParams.curves[curveIndex];
    diffFrom = curve.diffFrom;
    label = curve.label;
    var d = {
      // d will contain the curve data
      x: [],
      //placeholder
      y: [],
      //placeholder
      error_x: [],
      // unused
      error_y: [],
      // unused
      subVals: [],
      subSecs: [],
      subLevs: [],
      glob_stats: {},
      // placeholder
      bin_stats: [],
      // placeholder
      text: [],
      //placeholder
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE
    };

    if (diffFrom == null) {
      var postQueryStartMoment = moment();

      if (curveInfoParams.dataFoundForCurve[curveIndex]) {
        // sort queried data into the full set of histogram bins
        sortedData = matsDataUtils.sortHistogramBins(allReturnedSubStats[curveIndex], allReturnedSubSecs[curveIndex], allReturnedSubLevs[curveIndex], binParams.binNum, binStats, appParams.hasLevels, d);
        d = sortedData.d;
      }
    } else {
      // this is a difference curve, so we're done with regular curves.
      // do any matching that needs to be done.
      if (appParams.matching && !bookkeepingParams.alreadyMatched) {
        if (appParams.hasLevels) {
          dataset = matsDataMatchUtils.getMatchedDataSetHistogramWithLevels(dataset, curvesLengthSoFar, binStats);
        } else {
          dataset = matsDataMatchUtils.getMatchedDataSetHistogram(dataset, curvesLengthSoFar, binStats);
        }

        bookkeepingParams.alreadyMatched = true;
      } // then take diffs


      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, matsTypes.PlotTypes.histogram, appParams.hasLevels); // adjust axis stats based on new data from diff curve

      d = diffResult.dataset;
    } // set curve annotation to be the curve mean -- may be recalculated later
    // also pass previously calculated axis stats to curve options


    curve['annotation'] = "";
    curve['axisKey'] = curveInfoParams.curves[curveIndex].axisKey;
    const cOptions = matsDataCurveOpsUtils.generateBarChartCurveOptions(curve, curveIndex, curveInfoParams.axisMap, d); // generate plot with data, curve annotation, axis labels, etc.

    dataset.push(cOptions);
    curvesLengthSoFar++;
    var postQueryFinishMoment = moment();
    bookkeepingParams.dataRequests["post data retrieval (query) process time - " + curve.label] = {
      begin: postQueryStartMoment.format(),
      finish: postQueryFinishMoment.format(),
      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'
    };
  } // end for curves
  // if matching, pare down dataset to only matching data. Only do this if we didn't already do it while calculating diffs.


  if (curveInfoParams.curvesLength > 1 && appParams.matching && !bookkeepingParams.alreadyMatched) {
    if (appParams.hasLevels) {
      dataset = matsDataMatchUtils.getMatchedDataSetHistogramWithLevels(dataset, curveInfoParams.curvesLength, binStats);
    } else {
      dataset = matsDataMatchUtils.getMatchedDataSetHistogram(dataset, curveInfoParams.curvesLength, binStats);
    }
  } // calculate data statistics (including error bars) for each curve


  for (curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    var statisticSelect = curveInfoParams.curves[curveIndex]['statistic'];
    diffFrom = curveInfoParams.curves[curveIndex].diffFrom;
    var data = dataset[curveIndex];
    label = dataset[curveIndex].label;
    var di = 0;

    while (di < data.x.length) {
      if (curveInfoParams.yAxisFormat === 'Relative frequency') {
        // replace the bin number with the bin relative frequency for the plotted statistic
        data.y[di] = data.bin_stats[di].bin_rf * 100;
      } // remove sub values and times to save space


      data.subVals[di] = [];
      data.subSecs[di] = [];
      data.subLevs[di] = []; // this is the tooltip, it is the last element of each dataseries element

      data.text[di] = label + "<br>" + "bin: " + di + " (" + statisticSelect + " values between " + (data.bin_stats[di].binLowBound === null ? null : data.bin_stats[di].binLowBound.toPrecision(4)) + " and " + (data.bin_stats[di].binUpBound === null ? null : data.bin_stats[di].binUpBound.toPrecision(4)) + ")" + "<br>" + "number in bin for this curve: " + (data.y[di] === null ? null : data.y[di]) + "<br>bin mean for this curve: " + statisticSelect + " = " + (data.bin_stats[di].bin_mean === null ? null : data.bin_stats[di].bin_mean.toPrecision(4)) + "<br>bin sd  for this curve: " + statisticSelect + " = " + (data.bin_stats[di].bin_sd === null ? null : data.bin_stats[di].bin_sd.toPrecision(4));
      di++;
    }
  } // end curves
  // generate plot options


  const resultOptions = matsDataPlotOpsUtils.generateHistogramPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, plotBins);
  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

const processDataContour = function (dataset, curveInfoParams, plotParams, bookkeepingParams) {
  var error = "";
  const appName = matsCollections.appName.findOne({}).app;
  var statisticSelect = appName.indexOf("anomalycor") !== -1 ? "ACC" : curveInfoParams.curve[0]['statistic'];
  var data = dataset[0];
  const label = dataset[0].label;

  if (data.xAxisKey.indexOf("Date") !== -1) {
    data.x = data.x.map(function (val) {
      return moment.utc(val * 1000).format("YYYY-MM-DD HH:mm");
    });
  } else if (data.yAxisKey.indexOf("Date") !== -1) {
    data.y = data.y.map(function (val) {
      return moment.utc(val * 1000).format("YYYY-MM-DD HH:mm");
    });
  }

  var i;
  var j;
  var currX;
  var currY;
  var currText;
  var currYTextArray;

  for (j = 0; j < data.y.length; j++) {
    currY = data.y[j];
    currYTextArray = [];

    for (i = 0; i < data.x.length; i++) {
      currX = data.x[i];
      currText = label + "<br>" + data['xAxisKey'] + ": " + data.x[i] + "<br>" + data['yAxisKey'] + ": " + data.y[j] + "<br>" + statisticSelect + ": " + (data.z[j][i] === undefined || data.z[j][i] === null || data.z[j][i] === 'null' ? null : data.z[j][i].toPrecision(4)) + "<br>n: " + data['n'][j][i];
      currYTextArray.push(currText);
    }

    data.text.push(currYTextArray);
  } // generate plot options


  const resultOptions = matsDataPlotOpsUtils.generateContourPlotOptions(dataset, curveInfoParams.axisMap);
  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

module.exportDefault(matsDataProcessUtils = {
  processDataXYCurve: processDataXYCurve,
  processDataProfile: processDataProfile,
  processDataReliability: processDataReliability,
  processDataHistogram: processDataHistogram,
  processDataContour: processDataContour
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"plot_spec_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/plot_spec_util.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let Meteor;
module.link("meteor/meteor", {
  Meteor(v) {
    Meteor = v;
  }

}, 0);
let matsCollections, matsDataCurveOpsUtils, matsDataDiffUtils, matsDataProcessUtils, matsDataQueryUtils, matsDataUtils, matsMethods, matsParamUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  },

  matsDataCurveOpsUtils(v) {
    matsDataCurveOpsUtils = v;
  },

  matsDataDiffUtils(v) {
    matsDataDiffUtils = v;
  },

  matsDataProcessUtils(v) {
    matsDataProcessUtils = v;
  },

  matsDataQueryUtils(v) {
    matsDataQueryUtils = v;
  },

  matsDataUtils(v) {
    matsDataUtils = v;
  },

  matsMethods(v) {
    matsMethods = v;
  },

  matsParamUtils(v) {
    matsParamUtils = v;
  },

  matsTypes(v) {
    matsTypes = v;
  }

}, 1);
let mysql;
module.link("meteor/pcel:mysql", {
  mysql(v) {
    mysql = v;
  }

}, 2);
let moment;
module.link("meteor/momentjs:moment", {
  moment(v) {
    moment = v;
  }

}, 3);
const statMvTranslation = {
  'ACC': "ANOM_CORR",
  'RMS': 'RMSE',
  'Bias (Model - Obs)': 'ME',
  'Model average': "FBAR",
  'Obs average': "OBAR"
};

const xmlBuilder = require('xmlbuilder');

const _pad = function (num, size) {
  var s = num + "";

  while (s.length < size) s = "0" + s;

  return s;
};

const _title = function () {
  try {
    if (matsCollections.Settings === undefined || matsCollections.Settings.findOne({}, {
      fields: {
        Title: 1
      }
    }) === undefined) {
      return "";
    } else {
      return matsCollections.Settings.findOne({}, {
        fields: {
          Title: 1
        }
      }).Title;
    }
  } catch (someError) {
    return "";
  }
};

const _plotText = function (plotParams) {
  var format = plotParams.plotFormat;

  if (matsCollections.PlotParams.findOne({
    name: 'plotFormat'
  }) && matsCollections.PlotParams.findOne({
    name: 'plotFormat'
  }).optionsMap && matsCollections.PlotParams.findOne({
    name: 'plotFormat'
  }).optionsMap[plotParams.plotFormat] !== undefined) {
    format = matsCollections.PlotParams.findOne({
      name: 'plotFormat'
    }).optionsMap[plotParams.plotFormat];
  }

  if (format === undefined) {
    format = "Unmatched";
  }

  const plotType = _.invert(plotParams.plotTypes)[true];

  switch (plotType) {
    case matsTypes.PlotTypes.timeSeries:
      return "TimeSeries " + plotParams.dates + " : " + format;
      break;

    case matsTypes.PlotTypes.profile:
      return "Profile: " + format;
      break;

    case matsTypes.PlotTypes.dieoff:
      return "DieOff: " + format;
      break;

    case matsTypes.PlotTypes.threshold:
      return "Threshold: " + format;
      break;

    case matsTypes.PlotTypes.validtime:
      return "ValidTime: " + format;
      break;

    case matsTypes.PlotTypes.dailyModelCycle:
      return "DailyModelCycle " + plotParams.dates + " : " + format;
      break;

    case matsTypes.PlotTypes.reliability:
      return "Reliability: " + format;
      break;

    case matsTypes.PlotTypes.map:
      return "Map " + plotParams.dates + " ";
      break;

    case matsTypes.PlotTypes.histogram:
      return "Histogram: " + format;
      break;

    default:
      return "Scatter: " + plotParams.dates + " : " + format;
  }
};

const _componentToHex = function (c) {
  var hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
};

const _rgbToHex = function (color) {
  const cParts = color.replace('rgb(', '').replace(')', '').split(',');
  const r = Number(cParts[0]);
  const g = Number(cParts[1]);
  const b = Number(cParts[2]);
  return "#" + _componentToHex(r) + _componentToHex(g) + _componentToHex(b);
};

const _getUniqDates = function (dates, database, model, dataSource, region, variable, forecastLength, fromSecs, toSecs, validTimes) {
  var regionsClause = "";

  if (region != null) {
    region = Array.isArray(region) ? region : [region];

    if (region.length > 0) {
      const regions = region.map(function (r) {
        return "'" + r + "'";
      }).join(',');
      regionsClause = "and h.vx_mask IN(" + regions + ")";
    }
  } // the forecast lengths appear to have sometimes been inconsistent (by format) in the varias databases
  // so they have been sanitized for display purposes in the forecastValueMap.
  // now we have to go get the damn ole unsanitary ones for the database.


  var forecastLengthsClause = "";

  if (forecastLength != null) {
    forecastLength = Array.isArray(forecastLength) ? forecastLength : [forecastLength];

    if (forecastLength.length > 0) {
      const forecastValueMap = matsCollections.CurveParams.findOne({
        name: 'forecast-length'
      }, {
        valuesMap: 1
      })['valuesMap'][database][dataSource];
      const forecastLengths = forecastLength.map(function (fl) {
        return forecastValueMap[fl];
      }).join(',');
      forecastLengthsClause = "and ld.fcst_lead IN (" + forecastLengths + ")";
    }
  }

  var statement = "select ld.fcst_valid_beg as avtime " + "from " + database + ".stat_header h, " + database + ".line_data_sl1l2 ld " + "where 1=1 and h.model = '" + model + "' " + regionsClause + "and unix_timestamp(ld.fcst_valid_beg) >= '" + fromSecs + "' " + "and unix_timestamp(ld.fcst_valid_beg) <= '" + toSecs + "' " + forecastLengthsClause + "and h.fcst_var = '" + variable + "' " + "and ld.stat_header_id = h.stat_header_id " + "group by avtime order by avtime;";
  var rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(metadataPool, statement);

  if (rows === undefined || rows === null || rows.length === 0) {
    console.log(matsTypes.Messages.NO_DATA_FOUND);
  } else {
    for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      const dstrMoment = moment(rows[rowIndex].avtime);
      const dstr = dstrMoment.format('YYYY-MM-DD HH:mm:ss').trim(); // apply the valid-time filter here.....

      var valid = true;

      if (validTimes != null && validTimes.length > 0) {
        valid = false;
        const momentSdiHour = Number(dstrMoment.format("HH"));

        for (var vti = 0; vti < validTimes.length; vti++) {
          const thisvt = Number(validTimes[vti]);

          if (momentSdiHour === thisvt) {
            // it is valid
            valid = true;
            break;
          }
        }
      }

      if (valid === true && dates.indexOf(dstr) === -1) {
        dates.push(dstr);
      }
    }
  }

  return dates;
}; // adds date elements to an element of the current xml between a start and an end date, incremented by specific seconds
// series variables can be grouped or ungrouped.
// e.g. grouped ...    <val>2018-11-01 00:00:00,2018-11-01 06:00:00,2018-11-01 12:00:00,2018-11-01</val>
// e.g. ungrouped ...    <val>2018-11-01 00:00:00</val>
//                       <val>2018-11-01 06:00:00</val>
//                       <val>2018-11-01 12:00:00</val>
//                       <val>2018-11-01</val>
// for time series valid_beg is always ungrouped.


const _getSortedDatesForIndepRange = function (plotParams) {
  const dateRange = matsDataUtils.getDateRange(plotParams.dates);
  const fromSecs = dateRange.fromSeconds;
  const toSecs = dateRange.toSeconds;
  const curves = plotParams.curves; // have to get all the valid dates for each curve then union them
  // to get a complete date list

  var dates = [];

  for (var ci = 0; ci < curves.length; ci++) {
    if (curves[ci]['diffFrom']) {
      // currrently we do not do mv differencing
      continue;
    }

    var curve = curves[ci];
    const validTimes = curve['valid-time'];
    const region = curve['region'];
    const forecastLength = curve['forecast-length'];
    const variable = curve['variable']; //example 2018-11-06 00:00:00

    const database = curve['database'];
    const dataSource = curve['data-source'];
    const model = matsCollections.CurveParams.findOne({
      name: 'data-source'
    }).optionsMap[database][dataSource][0];
    dates = _getUniqDates(dates, database, model, dataSource, region, variable, forecastLength, fromSecs, toSecs, validTimes);
  } // sort the dates


  const sortedDates = dates.sort(function (a, b) {
    return new moment(a) - new moment(b);
  });
  return sortedDates;
};

const _getSortedHoursForIndepRange = function (plotParams) {
  const sortedDates = _getSortedDatesForIndepRange(plotParams);

  var hours = new Set();

  for (var di = 0; di < sortedDates.length; di++) {
    const hour = moment(sortedDates[di]).format("HH");
    hours.add(hour);
  }

  return Array.from(hours).sort();
};

const _getSortedDatesForDepRange = function (curve) {
  var dates = [];
  const dateRange = matsDataUtils.getDateRange(curve['curve-dates']);
  const fromSecs = dateRange.fromSeconds;
  const toSecs = dateRange.toSeconds;
  const validTimes = curve['valid-time'];
  const region = curve['region'];
  const forecastLength = curve['forecast-length'];
  const variable = curve['variable']; //example 2018-11-06 00:00:00

  const database = curve['database'];
  const dataSource = curve['data-source'];
  const model = matsCollections.CurveParams.findOne({
    name: 'data-source'
  }).optionsMap[database][dataSource][0];
  dates = _getUniqDates(dates, database, model, dataSource, region, variable, forecastLength, fromSecs, toSecs, validTimes); // sort the dates

  const sortedDates = dates.sort(function (a, b) {
    return new moment(a) - new moment(b);
  });
  return sortedDates;
}; // for profiles valid_beg is always grouped.


const addIndepUngroupedDateElementsBetween = function (element, plotParams) {
  const sortedDates = _getSortedDatesForIndepRange(plotParams); //these must be ungrouped


  for (var sdi = 0; sdi < sortedDates.length; sdi++) {
    element.ele('val', {
      'label': sortedDates[sdi],
      'plot_val': ""
    }, sortedDates[sdi]);
  }
}; // parse the databases from the curves and add a database string


const addDatabaseElement = function (element, curves) {
  try {
    databases = [];

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      if (!databases.includes(curves[ci].database)) {
        databases.push(curves[ci].database);
      }
    }

    databasesStr = databases.join("'");
    element.ele('database', databasesStr);
    return element;
  } catch (someError) {
    return "";
  }
}; // add the required metviewer folders


const addFolders = function (element) {
  try {
    element.ele('rscript', Meteor.settings.private.MV_RSCRIPT);
    var folders = element.ele('folders');
    folders.ele('r_tmpl', matsMethods.MV_DIRS.HOME + "/R_tmpl");
    folders.ele('r_work', matsMethods.MV_DIRS.HOME + "/R_work");
    folders.ele('plots', matsMethods.MV_DIRS.PLOTSDIR);
    folders.ele('data', matsMethods.MV_DIRS.DATADIR);
    folders.ele('scripts', matsMethods.MV_DIRS.SCRIPTSDIR);
    return element;
  } catch (e) {}
}; // start the plotspec


const startPlotSpec = function (pool, plotParams) {
  try {
    var xml = xmlBuilder.create('plot_spec', {
      version: "1.0",
      encoding: "UTF-8",
      standalone: false
    });
    var connection = xml.ele('connection');
    connection.ele('host', sumPool.config.connectionConfig.host + ":" + sumPool.config.connectionConfig.port);
    addDatabaseElement(connection, plotParams.curves);
    connection.ele('user', sumPool.config.connectionConfig.user);
    connection.ele('password', sumPool.config.connectionConfig.password);
    const management_system = Meteor.settings.private.MV_DB_MANAGEMENT_SYSTEM != null ? Meteor.settings.private.MV_DB_MANAGEMENT_SYSTEM : "mysql";
    connection.ele('management_system', management_system);
    addFolders(xml);
    var plot = xml.ele('plot');
    return {
      xml: xml,
      plot: plot
    };
  } catch (e) {}
};

const addPlotCi = function (element, plotParams) {
  try {
    //example c("none","none")
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('"none"');
    }

    cListStr += cList.join(',') + ')';
    element.ele('plot_ci', cListStr);
  } catch (e) {}
};

const addShowSignif = function (element, plotParams) {
  try {
    //example c(FALSE,FALSE)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('FALSE');
    }

    cListStr += cList.join(',') + ')';
    element.ele('show_signif', cListStr);
  } catch (e) {}
};

const addPlotDisp = function (element, plotParams) {
  try {
    //example c(TRUE,TRUE)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      cList.push('TRUE');
    }

    cListStr += cList.join(',') + ')';
    element.ele('plot_disp', cListStr);
  } catch (e) {}
};

const addColors = function (element, plotParams) {
  try {
    //  example  'c("#ff0000FF","#8000ffFF")'
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      var ch = _rgbToHex(curves[ci].color) + "FF";
      cList.push('"' + ch + '"');
    }

    cListStr += cList.join(',') + ')';
    element.ele('colors', cListStr);
  } catch (e) {}
};

const addPch = function (element, plotParams) {
  try {
    //example c(20,20)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('20');
    }

    cListStr += cList.join(',') + ')';
    element.ele('pch', cListStr);
  } catch (e) {}
};

const addType = function (element, plotParams) {
  try {
    //example c("b","b")
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('"b"');
    }

    cListStr += cList.join(',') + ')';
    element.ele('type', cListStr);
  } catch (e) {}
};

const addLty = function (element, plotParams) {
  try {
    // example c(1,1)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push(1);
    }

    cListStr += cList.join(',') + ')';
    element.ele('lty', cListStr);
  } catch (e) {}
};

const addLwd = function (element, plotParams) {
  try {
    // example c(1,1)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push(1);
    }

    cListStr += cList.join(',') + ')';
    element.ele('lwd', cListStr);
  } catch (e) {}
};

const addConSeries = function (element, plotParams) {
  try {
    // example c(1,1)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push(1);
    }

    cListStr += cList.join(',') + ')';
    element.ele('con_series', cListStr);
  } catch (e) {}
};

const addOrderSeries = function (element, plotParams) {
  try {
    // example c(1,2)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push(ci + 1);
    }

    cListStr += cList.join(',') + ')';
    element.ele('order_series', cListStr);
  } catch (e) {}
};

const addLegend = function (element, plotParams) {
  try {
    // example c("","")
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('""');
    }

    cListStr += cList.join(',') + ')';
    element.ele('legend', cListStr);
  } catch (e) {}
};

const addSeries = function (plot, dependentAxes, plotParams) {
  /***
   data-source(models), region(vx_mask),forecast_length (fcst_lead), and pres-level(fcst_lev)
   are series variables. Multiple selections for a given curve are MV grouped (join'd)
   Multiple selections associated with different curves are seperate <val> tags.
    All of the non grouped combinations are added which results in possibly too many curves. The redundant ones are later hidden.
    They can also go on the axis that is associated with the curve that the region parameter is on.
   In other words force a new series.
   i.e. Y1 Series variables or Y2 Series variables
    series variables can be grouped or ungrouped.
   e.g. grouped ...    <val>2018-11-01 00:00:00,2018-11-01 06:00:00,2018-11-01 12:00:00,2018-11-01</val>
   e.g. ungrouped ...    <val>2018-11-01 00:00:00</val>
   <val>2018-11-01 06:00:00</val>
   <val>2018-11-01 12:00:00</val>
   <val>2018-11-01</val>
   For MATS curves they are grouped for each curve and added ase series variables. This results in redundant curves in MV and so the
   redundant curves will be hidden.
   Curves that were assigned to different axis were figured out and assigned in getDependents and are assigned in the dependentAxes structure.
   ***/
  var hiddenCurves = [];
  var sVars = {
    'data-source': 'model',
    'region': 'vx_mask',
    'forecast-length': 'fcst_lead',
    'pres-level': 'fcst_lev'
  };

  const type = _.invert(plotParams.plotTypes)[true];

  const seriesAxisMap = {
    'series1': 'y1',
    'series2': 'y2'
  };
  Object.keys(seriesAxisMap).forEach(function (series) {
    var models = [];
    var vx_masks = [];
    var fcst_leads = [];
    var fcst_levls = [];
    var seriesElem = plot.ele(series);
    const axis = seriesAxisMap[series];
    var initHours = new Set();

    switch (type) {
      case matsTypes.PlotTypes.timeSeries:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev'
        };
        break;

      case matsTypes.PlotTypes.dailyModelCycle:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev'
        };
        break;

      case matsTypes.PlotTypes.profile:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      case matsTypes.PlotTypes.dieoff:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };

        for (var ci = 0; ci < plotParams.curves.length; ci++) {
          if (curves[ci]['diffFrom']) {
            // currrently we do not do mv differencing
            continue;
          }

          const c = plotParams.curves[ci];

          if (c['dieoff-type'] === 'Dieoff for a specified UTC cycle init hour') {
            initHours.add(c['utc-cycle-start']);
          } else if (c.dieoff - type === matsTypes.ForecastTypes.singleCycle) {// placeholder for if issue 60313 gets resolved
          }
        }

        if (initHours.size > 0) {
          sVars['utc-cycle-start'] = 'init_hour';
        }

        break;

      case matsTypes.PlotTypes.threshold:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      case matsTypes.PlotTypes.validtime:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      case matsTypes.PlotTypes.reliability:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      case matsTypes.PlotTypes.histogram:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      default:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev'
        };
    }

    if (type === matsTypes.PlotTypes.profile) {
      delete sVars['pres-level'];
    } else {
      // we only consider pressure levels when it isn't a profile
      sVars['pres-level'] = 'fcst_lev';
    }

    var seriesElements = {};
    var seriesElementValues = {};

    for (var daci = 0; daci < dependentAxes[axis].length; daci++) {
      const curve = dependentAxes[axis][daci];
      const database = curve['database'];
      const dataSource = curve['data-source'];
      Object.keys(sVars).forEach(function (sVar) {
        try {
          // models - not multiple - ungrouped
          var sValues = [];

          switch (sVar) {
            case 'data-source':
              // convert data-source to single element array
              sValues = [matsParamUtils.getParameterForName(sVar).optionsMap[database][dataSource][0]];
              break;

            case 'curve-dates':
              sValues = _getSortedDatesForDepRange(curve);
              break;

            case 'utc-cycle-start':
              const v = curve['utc-cycle-start'];

              const paddedV = _pad(v, 2);

              sValues = [paddedV]; // turn single selection padded value into array

              break;

            case 'forecast-length':
              sValues = curve[sVar];

              if (sValues == null || sValues.length === 0) {
                sValues = matsParamUtils.getParameterForName(sVar).optionsMap[database][dataSource]; // have to assign all the fcst leads
              }

              const forecastValueMap = matsParamUtils.getParameterForName(sVar).valuesMap[database][dataSource];
              sValues = sValues.map(function (fl) {
                return forecastValueMap[fl];
              }).join(',');
              break;

            default:
              sValues = curve[sVar];

              if (sValues == null || sValues.length === 0) {
                sValues = matsParamUtils.getParameterForName(sVar).optionsMap[database][dataSource]; // have to assign all the regions
              }

          } // check to see if this element was already added.
          // if not added then add the element.
          // if element was already added see if we need to add this value.
          // multiples are always grouped.


          if (sValues !== undefined) {
            sValues = Array.isArray(sValues) ? sValues : [sValues];

            if (sValues.length > 0) {
              const sValuesStr = sValues.join(',');

              if (sValuesStr !== undefined) {
                const thisVar = sVars[sVar];

                if (seriesElements[thisVar] == null) {
                  seriesElements[thisVar] = seriesElem.ele('field', {
                    'name': sVars[sVar]
                  });
                  seriesElementValues[thisVar] = new Set();
                  seriesElementValues[thisVar].add(sValuesStr);
                } else {
                  // already exists
                  if (seriesElementValues[thisVar].has(sValuesStr) === false) {
                    seriesElementValues[thisVar].add(sValuesStr);
                  }
                }
              }
            }
          }
        } catch (error) {
          console.log(error);
          throw new Meteor.Error(error);
        }
      });
    }

    const sElementKeys = Object.keys(seriesElements);

    for (var sei = 0; sei < sElementKeys.length; sei++) {
      const seVar = sElementKeys[sei];
      const svars = Array.from(seriesElementValues[seVar]).sort();

      for (var svi = 0; svi < svars.length; svi++) {
        const v = svars[svi];

        if (v !== "undefined") {
          seriesElements[seVar].ele('val', v);
        }
      }

      ;
    }
  });
};

const getDependentAxis = function (plotParams) {
  // there are two possible axis for metviewer. We want to collect all the variables
  // into groups. We will take the two largest groups.
  // variables and statistics go together. They are dependent variabales in MV.
  // The variable/stat pairs always are associated with different curves, and will always be on different axis,
  // if possible, but might be assigned an axis via an axes parameter.
  const yaxesDefault = "auto-by-variable";
  var curves = plotParams['curves'];
  var dependentAxes = {
    'y1': [],
    'y2': []
  };
  dependentAxes['y1'].push(curves[0]);
  var dependentAxesVariables = {
    'y1': [curves[0]['variable']],
    'y2': []
  };

  for (var ci = 1; ci < curves.length; ci++) {
    if (curves[ci]['diffFrom']) {
      // currrently we do not do mv differencing
      continue;
    }

    if (curves[ci].yaxes != yaxesDefault) {
      // it was assigned an axis by the axis param so sort it into its selectedYaxes
      dependentAxes[curves[ci].yaxes].push(curves[ci]);
    } else {
      // sort it into an axis by its variable/stat combination
      //     variables:
      //     variables that share an axis are different dependent variables. Put them in dep1.
      // unless it is a variable with multiple stats.
      // different variable with different stats that have differing axis must go in different Y axis vars (and you can only have two of those)
      const variable = curves[ci].variable;

      if (dependentAxesVariables['y1'].includes(variable)) {
        dependentAxes['y1'].push(curves[ci]);
      } else {
        dependentAxes['y2'].push(curves[ci]);
      }
    }
  }

  return dependentAxes;
};

function addDeps(plot, dependentAxes) {
  var dep = plot.ele('dep');
  const deps = {
    "dep1": "y1",
    "dep2": "y2"
  };

  for (var di = 0; di < Object.keys(deps).length; di++) {
    // [dep1, dep2]
    var depKey = Object.keys(deps)[di]; // dep1 or dep2

    var depAxis = deps[depKey];
    var subDep = dep.ele(depKey); //<dep><dep1/><dep2/>

    var variableStatisticPairs = {};

    for (var daci = 0; daci < dependentAxes[depAxis].length; daci++) {
      //[y1,y2]
      // record the variable-statistic pair
      const variable = dependentAxes[depAxis][daci]['variable'];
      const stat = statMvTranslation[dependentAxes[depAxis][daci]['statistic']];

      if (variableStatisticPairs[variable] == null) {
        variableStatisticPairs[variable] = [stat];
      } else {
        variableStatisticPairs[variable].push(stat);
      }
    }

    var vars = Object.keys(variableStatisticPairs); //['T','HGT','WIND'...]

    for (var v = 0; v < vars.length; v++) {
      const stats = Array.from(new Set(variableStatisticPairs[vars[v]]));
      var depElem = subDep.ele('fcst_var', {
        'name': vars[v]
      }); //<dep><dep1><fcst_var name='T'><stat>RMS</stat></fcst_var> </dep1><dep2/>

      for (var si = 0; si < stats.length; si++) {
        depElem.ele('stat', stats[si]);
      }
    }
  }
}

function addAnomalycorrDeps(plot, dependentAxes) {
  var dep = plot.ele('dep');
  const deps = {
    "dep1": "y1",
    "dep2": "y2"
  };

  for (var di = 0; di < Object.keys(deps).length; di++) {
    // [dep1, dep2]
    var depKey = Object.keys(deps)[di]; // dep1 or dep2

    var depAxis = deps[depKey];
    var subDep = dep.ele(depKey); //<dep><dep1/><dep2/>

    var variables = new Set();

    for (var daci = 0; daci < dependentAxes[depAxis].length; daci++) {
      //[y1,y2]
      const variable = dependentAxes[depAxis][daci]['variable'];
      variables.add(variable);
    }

    var vars = Array.from(variables);

    for (var v = 0; v < vars.length; v++) {
      subDep.ele('fcst_var', {
        'name': vars[v]
      }).ele('stat', 'ANOM_CORR');
    }
  }
}

const _addSeriesLabels = function (element, dependentAxes, plotParams) {
  const plotType = _.invert(plotParams.plotTypes)[true];

  var label;

  switch (plotType) {
    case matsTypes.PlotTypes.timeSeries:
      label = "Time";
      break;

    case matsTypes.PlotTypes.dieoff:
      label = "Forecast Hour";
      break;

    case matsTypes.PlotTypes.dailyModelCycle:
      label = "Time";
      break;

    case matsTypes.PlotTypes.histogram:
      label = "Bin";
      break;

    case matsTypes.PlotTypes.validtime:
      label = "Hour of Day";
      break;

    case matsTypes.PlotTypes.reliability:
      label = "Reliability";
      break;

    case matsTypes.PlotTypes.threshold:
      label = "Threshold";
      break;

    case matsTypes.PlotTypes.profile:
      var vars = new Set();
      plotParams.curves.forEach(function (c) {
        vars.add(c.variable);
      });
      label = Array.from(vars).join(' - ');
      break;

    default:
      label = "Time";
  }

  element.ele('x_label', label);
  var y1vars = [];

  for (var y1i = 0; y1i < dependentAxes['y1'].length; y1i++) {
    if (!y1vars.includes(dependentAxes['y1'][y1i]['variable'])) {
      y1vars.push(dependentAxes['y1'][y1i]['variable']);
    }
  }

  element.ele('y1_label', y1vars.join(','));
  var y2vars = [];

  for (var y2i = 0; y2i < dependentAxes['y2'].length; y2i++) {
    if (!y2vars.includes(dependentAxes['y2'][y2i]['variable'])) {
      y2vars.push(dependentAxes['y2'][y2i]['variable']);
    }
  }

  element.ele('y2_label', y2vars.join(','));
};

const addTemplate = function (plot, templateStr) {
  plot.ele('template', templateStr);
};

const addIndepDates = function (plot, plotParams) {
  var indep = plot.ele('indep', {
    'equalize': 'false',
    'name': 'fcst_valid_beg'
  });
  addIndepUngroupedDateElementsBetween(indep, plotParams);
};

const addIndepLevels = function (plot, plotParams) {
  // for profiles we use a union of all the levels available for all the data-sources
  var indep = plot.ele('indep', {
    'equalize': 'false',
    'name': 'fcst_lev'
  });
  var curves = plotParams.curves;
  var lvlSet = new Set(); // use a set to accumulate all the levels

  for (var ci = 0; ci < curves.length; ci++) {
    if (curves[ci]['diffFrom']) {
      // currrently we do not do mv differencing
      continue;
    }

    const curve = curves[ci];
    const database = curve['database'];
    const dataSource = curve['data-source'];
    const levelVals = matsCollections.CurveParams.findOne({
      name: 'data-source'
    })['levelsMap'][database][dataSource];
    lvlSet.add(levelVals);
  } // only add the fcst_lev tag if there are pres-levels requested - leaving it out will get them all


  const lvls = Array.from(lvlSet)[0];

  for (var li = 0; li < lvls.length; li++) {
    var val = indep.ele('val', lvls[li]);
    val.att('label', lvls[li]);
    val.att('plot_val', "");
  }
};

const addIndepValidHours = function (plot, plotParams) {
  // for validTimes we use a union of all the vts available for all the data-sources
  var indep = plot.ele('indep', {
    'equalize': 'false',
    'name': 'valid_hour'
  });

  const hours = _getSortedHoursForIndepRange(plotParams);

  for (var hi = 0; hi < hours.length; hi++) {
    var val = indep.ele('val', hours[hi]);
    val.att('label', hours[hi]);
    val.att('plot_val', "");
  }
};

const addIndepForecastHours = function (plot, plotParams) {
  // for dieoffs we use a union of all the fhrs available for all the data-sources
  var indep = plot.ele('indep', {
    'equalize': 'false',
    'name': 'fcst_lead'
  });
  var curves = plotParams.curves;
  var leadSet = new Set(); // use a set to accumulate all the levels

  for (var ci = 0; ci < curves.length; ci++) {
    if (curves[ci]['diffFrom']) {
      // currrently we do not do mv differencing
      continue;
    }

    const curve = curves[ci];
    const database = curve['database'];
    const dataSource = curve['data-source'];
    const forecastLengths = matsCollections.CurveParams.findOne({
      name: 'forecast-length'
    })['optionsMap'][database][dataSource];
    leadSet.add(forecastLengths);
  }

  const leads = Array.from(leadSet)[0];

  for (var li = 0; li < leads.length; li++) {
    var val = indep.ele('val', leads[li]);
    val.att('label', leads[li]);
    val.att('plot_val', "");
  }
};

const addTmpl = function (plot, key, plotParams, dependentAxes) {
  var tmpl = plot.ele('tmpl');
  tmpl.ele('data_file', key + '.data');
  tmpl.ele('plot_file', key + '.png');
  tmpl.ele('r_file', key + '.R');
  tmpl.ele('title', _title() + " : " + _plotText(plotParams) + " " + plotParams.plotAction);

  _addSeriesLabels(tmpl, dependentAxes, plotParams);

  tmpl.ele('caption');
  tmpl.ele('job_title');
  tmpl.ele('keep_revisions', 'false');
  tmpl.ele('listdiffseries1', 'list()');
  tmpl.ele('listdiffseries2', 'list()');
};

const addPlotFix = function (plot) {
  plot.ele('plot_fix');
};

const addPlotCond = function (plot, plotParams) {
  plot.ele('plot_cond');
};

const addCalcStat = function (plot, statType) {
  plot.ele('calc_stat').ele(statType, true);
}; // unused for time series


const addPlotStat = function (plot, stat) {
  //Statistics --- We always do Summary with Mean - so there
  plot.ele('plot_stat', stat);
};

const addPlotCmd = function (plot) {
  plot.ele('plot_cmd');
};

const addY1Lim = function (plot) {
  plot.ele('y1_lim', 'c()');
};

const addY1Bufr = function (plot) {
  plot.ele('y1_bufr', '0.04');
};

const addY2Lim = function (plot) {
  plot.ele('y2_lim', 'c()');
};

const addMiscellaneous = function (plot, plotParams) {
  plot.ele('event_equal', 'false');

  const plotType = _.invert(plotParams.plotTypes)[true];

  switch (plotType) {
    case matsTypes.PlotTypes.timeSeries:
    case matsTypes.PlotTypes.dieoff:
    case matsTypes.PlotTypes.dailyModelCycle:
    case matsTypes.PlotTypes.histogram:
    case matsTypes.PlotTypes.validtime:
    case matsTypes.PlotTypes.reliability:
    case matsTypes.PlotTypes.threshold:
      plot.ele('vert_plot', 'false');
      plot.ele('x_reverse', 'false');
      break;

    case matsTypes.PlotTypes.profile:
      plot.ele('vert_plot', 'true');
      plot.ele('x_reverse', 'true');
      break;

    default:
      plot.ele('vert_plot', 'false');
      plot.ele('x_reverse', 'false');
  }

  plot.ele('num_stats', 'false');
  plot.ele('indy1_stag', 'false');
  plot.ele('indy2_stag', 'false');
  plot.ele('grid_on', 'true');
  plot.ele('sync_axes', 'false');
  plot.ele('dump_points1', 'true');
  plot.ele('dump_points2', 'true');
  plot.ele('log_y1', 'false');
  plot.ele('log_y2', 'false');
  plot.ele('varianceinflationfactor', 'false');
  plot.ele('plot_type', 'png16m');
  plot.ele('plot_height', '8.5');
  plot.ele('plot_width', '11');
  plot.ele('plot_res', '72');
  plot.ele('plot_units', 'in');
  plot.ele('mar', 'c(8,4,5,4)');
  plot.ele('mgp', 'c(1,1,0)');
  plot.ele('cex', '1');
  plot.ele('title_weight', '2');
  plot.ele('title_size', '1.4');
  plot.ele('title_offset', '-2');
  plot.ele('title_align', '0.5');
  plot.ele('xtlab_orient', '1');
  plot.ele('xtlab_perp', '-0.75');
  plot.ele('xtlab_horiz', '0.5');
  plot.ele('xtlab_freq', '0');
  plot.ele('xtlab_size', '1');
  plot.ele('xlab_weight', '1');
  plot.ele('xlab_size', '1');
  plot.ele('xlab_offset', '2');
  plot.ele('xlab_align', '0.5');
  plot.ele('ytlab_orient', '1');
  plot.ele('ytlab_perp', '0.5');
  plot.ele('ytlab_horiz', '0.5');
  plot.ele('ytlab_size', '1');
  plot.ele('ylab_weight', '1');
  plot.ele('ylab_size', '1');
  plot.ele('ylab_offset', '-2');
  plot.ele('ylab_align', '0.5');
  plot.ele('grid_lty', '3');
  plot.ele('grid_col', '#cccccc');
  plot.ele('grid_lwd', '1');
  plot.ele('grid_x', 'listX');
  plot.ele('x2tlab_orient', '1');
  plot.ele('x2tlab_perp', '1');
  plot.ele('x2tlab_horiz', '0.5');
  plot.ele('x2tlab_size', '0.8');
  plot.ele('x2lab_size', '0.8');
  plot.ele('x2lab_offset', '-0.5');
  plot.ele('x2lab_align', '0.5');
  plot.ele('y2tlab_orient', '1');
  plot.ele('y2tlab_perp', '0.5');
  plot.ele('y2tlab_horiz', '0.5');
  plot.ele('y2tlab_size', '1');
  plot.ele('y2lab_size', '1');
  plot.ele('y2lab_offset', '1');
  plot.ele('y2lab_align', '0.5');
  plot.ele('legend_box', 'o');
  plot.ele('legend_inset', 'c(0, -.25)');
  plot.ele('legend_ncol', '3');
  plot.ele('legend_size', '0.8');
  plot.ele('caption_weight', '1');
  plot.ele('caption_col', '#333333');
  plot.ele('caption_size', '0.8');
  plot.ele('caption_offset', '3');
  plot.ele('caption_align', '0');
  plot.ele('ci_alpha', '0.05');
};

const endPlotSpec = function (xml) {
  xml.end({
    pretty: true
  });
};

module.exportDefault(matsPlotSpecUtils = {
  startPlotSpec: startPlotSpec,
  addDeps: addDeps,
  addAnomalycorrDeps: addAnomalycorrDeps,
  getDependentAxis: getDependentAxis,
  addDatabaseElement: addDatabaseElement,
  addFolders: addFolders,
  addPlotCi: addPlotCi,
  addShowSignif: addShowSignif,
  addPlotDisp: addPlotDisp,
  addColors: addColors,
  addPch: addPch,
  addType: addType,
  addLty: addLty,
  addLwd: addLwd,
  addConSeries: addConSeries,
  addOrderSeries: addOrderSeries,
  addLegend: addLegend,
  addSeries: addSeries,
  addTemplate: addTemplate,
  addIndepDates: addIndepDates,
  addTmpl: addTmpl,
  addPlotFix: addPlotFix,
  addPlotCond: addPlotCond,
  addCalcStat: addCalcStat,
  addPlotStat: addPlotStat,
  addPlotCmd: addPlotCmd,
  addY1Lim: addY1Lim,
  addY1Bufr: addY1Bufr,
  addY2Lim: addY2Lim,
  addMiscellaneous: addMiscellaneous,
  endPlotSpec: endPlotSpec,
  addIndepLevels: addIndepLevels,
  addIndepForecastHours: addIndepForecastHours,
  addIndepValidHours: addIndepValidHours
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/index.js                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("./publications.js");
module.link("./data_util.js");
module.link("./data_query_util.js");
module.link("./data_diff_util.js");
module.link("./data_match_util.js");
module.link("./data_curve_ops_util.js");
module.link("./data_plot_ops_util.js");
module.link("./data_process_util.js");
module.link("./plot_spec_util.js");
module.link("./cache.js");
module.link("../both");
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"publications.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/publications.js                                                  //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let Meteor;
module.link("meteor/meteor", {
  Meteor(v) {
    Meteor = v;
  }

}, 0);
let matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  }

}, 1);

if (Meteor.isServer) {
  Meteor.publish("CurveParams", function () {
    var data = matsCollections.CurveParams.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("CurveTextPatterns", function () {
    var data = matsCollections.CurveTextPatterns.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("ScatterAxisTextPattern", function () {
    var data = matsCollections.ScatterAxisTextPattern.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("SavedCurveParams", function () {
    var data = matsCollections.SavedCurveParams.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("PlotParams", function () {
    var data = matsCollections.PlotParams.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("Scatter2dParams", function () {
    var data = matsCollections.Scatter2dParams.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("PlotGraphFunctions", function () {
    var data = matsCollections.PlotGraphFunctions.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("RegionsPerModel", function () {
    var data = matsCollections.RegionsPerModel.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("SitesPerModel", function () {
    var data = matsCollections.SitesPerModel.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("RegionDescriptions", function () {
    var data = matsCollections.RegionDescriptions.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("Models", function () {
    var data = matsCollections.Models.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("FcstLensPerModel", function () {
    var data = matsCollections.FcstLensPerModel.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("ColorScheme", function () {
    var data = matsCollections.ColorScheme.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("Settings", function () {
    var data = matsCollections.Settings.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("CurveSettings", function () {
    var data = matsCollections.CurveSettings.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("SentAddresses", function () {
    var data = matsCollections.SentAddresses.find({
      userId: this.userId
    });

    if (data) {
      return data;
    }

    return this.ready();
  }); // do not publish roles
  // Meteor.publish("Roles", function () {
  //     var data = matsCollections.Roles.find({});
  //     if (data) {
  //         return data;
  //     }
  //     return this.ready();
  // });
  // do not publish Authorization
  // Meteor.publish("Authorization", function () {
  //     var data = matsCollections.Authorization.find({});
  //     if (data) {
  //         return data;
  //     }
  //     return this.ready();
  // });
  // do not publish credentials
  // Meteor.publish("Credentials", function () {
  //     var data = matsCollections.Credentials.find({});
  //     if (data) {
  //         return data;
  //     }
  //     return this.ready();
  // });
  //do not publish databases
  // Meteor.publish("Databases", function () {
  //     var data = matsCollections.Databases.find({});
  //     if (data) {
  //         return data;
  //     }
  //     return this.ready();
  // });

  Meteor.publish("SiteMap", function () {
    var data = matsCollections.SiteMap.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("StationMap", function () {
    var data = matsCollections.StationMap.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("appName", function () {
    var data = matsCollections.appName.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"cache.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/cache.js                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let Meteor;
module.link("meteor/meteor", {
  Meteor(v) {
    Meteor = v;
  }

}, 0);
let matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  }

}, 1);

if (Meteor.isServer) {
  const Results = require('node-file-cache').create({
    file: 'fileCache',
    life: 8 * 3600
  });

  var getResult = function (key) {
    //console.log('asked to get result from cache for key:', key);
    var result = Results.get(key);
    return result === null ? undefined : result;
  };

  var storeResult = function (key, result) {
    //console.log('asked to set result in cache for app: ',process.env.PWD, ' key:', key);
    Results.set(key, result); //console.log('set result in cache for app: ', process.env.PWD, 'key:', key);
  };

  var clear = function () {
    //console.log('asked to clear result cache');
    Results.clear();
  };

  var expireKey = function (key) {
    //console.log('asked to clear result cache for key ', key);
    Results.expire(key);
  };
}

module.exportDefault(matsCache = {
  getResult: getResult,
  storeResult: storeResult,
  clear: clear,
  expireKey: expireKey
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}}},"lib":{"regression.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/lib/regression.js                                                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */
var gaussianElimination = function (a, o) {
  var i = 0,
      j = 0,
      k = 0,
      maxrow = 0,
      tmp = 0,
      n = a.length - 1,
      x = new Array(o);

  for (i = 0; i < n; i++) {
    maxrow = i;

    for (j = i + 1; j < n; j++) {
      if (Math.abs(a[i][j]) > Math.abs(a[i][maxrow])) maxrow = j;
    }

    for (k = i; k < n + 1; k++) {
      tmp = a[k][i];
      a[k][i] = a[k][maxrow];
      a[k][maxrow] = tmp;
    }

    for (j = i + 1; j < n; j++) {
      for (k = n; k >= i; k--) {
        a[k][j] -= a[k][i] * a[i][j] / a[i][i];
      }
    }
  }

  for (j = n - 1; j >= 0; j--) {
    tmp = 0;

    for (k = j + 1; k < n; k++) tmp += a[k][j] * x[k];

    x[j] = (a[n][j] - tmp) / a[j][j];
  }

  return x;
};

var methods = {
  linear: function (data) {
    var sum = [0, 0, 0, 0, 0],
        n = 0,
        results = [];

    for (; n < data.length; n++) {
      if (data[n][1] != null) {
        sum[0] += data[n][0];
        sum[1] += data[n][1];
        sum[2] += data[n][0] * data[n][0];
        sum[3] += data[n][0] * data[n][1];
        sum[4] += data[n][1] * data[n][1];
      }
    }

    var gradient = (n * sum[3] - sum[0] * sum[1]) / (n * sum[2] - sum[0] * sum[0]);
    var intercept = sum[1] / n - gradient * sum[0] / n; //  var correlation = (n * sum[3] - sum[0] * sum[1]) / Math.sqrt((n * sum[2] - sum[0] * sum[0]) * (n * sum[4] - sum[1] * sum[1]));

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], data[i][0] * gradient + intercept];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(gradient * 100) / 100 + 'x + ' + Math.round(intercept * 100) / 100;
    return {
      equation: [gradient, intercept],
      points: results,
      string: string
    };
  },
  linearThroughOrigin: function (data) {
    var sum = [0, 0],
        n = 0,
        results = [];

    for (; n < data.length; n++) {
      if (data[n][1] != null) {
        sum[0] += data[n][0] * data[n][0]; //sumSqX

        sum[1] += data[n][0] * data[n][1]; //sumXY
      }
    }

    var gradient = sum[1] / sum[0];

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], data[i][0] * gradient];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(gradient * 100) / 100 + 'x';
    return {
      equation: [gradient],
      points: results,
      string: string
    };
  },
  exponential: function (data) {
    var sum = [0, 0, 0, 0, 0, 0],
        n = 0,
        results = [];

    for (len = data.length; n < len; n++) {
      if (data[n][1] != null) {
        sum[0] += data[n][0];
        sum[1] += data[n][1];
        sum[2] += data[n][0] * data[n][0] * data[n][1];
        sum[3] += data[n][1] * Math.log(data[n][1]);
        sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
        sum[5] += data[n][0] * data[n][1];
      }
    }

    var denominator = sum[1] * sum[2] - sum[5] * sum[5];
    var A = Math.pow(Math.E, (sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
    var B = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], A * Math.pow(Math.E, B * data[i][0])];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(A * 100) / 100 + 'e^(' + Math.round(B * 100) / 100 + 'x)';
    return {
      equation: [A, B],
      points: results,
      string: string
    };
  },
  logarithmic: function (data) {
    var sum = [0, 0, 0, 0],
        n = 0,
        results = [];

    for (len = data.length; n < len; n++) {
      if (data[n][1] != null) {
        sum[0] += Math.log(data[n][0]);
        sum[1] += data[n][1] * Math.log(data[n][0]);
        sum[2] += data[n][1];
        sum[3] += Math.pow(Math.log(data[n][0]), 2);
      }
    }

    var B = (n * sum[1] - sum[2] * sum[0]) / (n * sum[3] - sum[0] * sum[0]);
    var A = (sum[2] - B * sum[0]) / n;

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], A + B * Math.log(data[i][0])];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(A * 100) / 100 + ' + ' + Math.round(B * 100) / 100 + ' ln(x)';
    return {
      equation: [A, B],
      points: results,
      string: string
    };
  },
  power: function (data) {
    var sum = [0, 0, 0, 0],
        n = 0,
        results = [];

    for (len = data.length; n < len; n++) {
      if (data[n][1] != null) {
        sum[0] += Math.log(data[n][0]);
        sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
        sum[2] += Math.log(data[n][1]);
        sum[3] += Math.pow(Math.log(data[n][0]), 2);
      }
    }

    var B = (n * sum[1] - sum[2] * sum[0]) / (n * sum[3] - sum[0] * sum[0]);
    var A = Math.pow(Math.E, (sum[2] - B * sum[0]) / n);

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], A * Math.pow(data[i][0], B)];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(A * 100) / 100 + 'x^' + Math.round(B * 100) / 100;
    return {
      equation: [A, B],
      points: results,
      string: string
    };
  },
  polynomial: function (data, order) {
    if (typeof order == 'undefined') {
      order = 2;
    }

    var lhs = [],
        rhs = [],
        results = [],
        a = 0,
        b = 0,
        i = 0,
        k = order + 1;

    for (; i < k; i++) {
      for (var l = 0, len = data.length; l < len; l++) {
        if (data[l][1] != null) {
          a += Math.pow(data[l][0], i) * data[l][1];
        }
      }

      lhs.push(a), a = 0;
      var c = [];

      for (var j = 0; j < k; j++) {
        for (var l = 0, len = data.length; l < len; l++) {
          if (data[l][1] != null) {
            b += Math.pow(data[l][0], i + j);
          }
        }

        c.push(b), b = 0;
      }

      rhs.push(c);
    }

    rhs.push(lhs);
    var equation = gaussianElimination(rhs, k);

    for (var i = 0, len = data.length; i < len; i++) {
      var answer = 0;

      for (var w = 0; w < equation.length; w++) {
        answer += equation[w] * Math.pow(data[i][0], w);
      }

      results.push([data[i][0], answer]);
    }

    var string = 'y = ';

    for (var i = equation.length - 1; i >= 0; i--) {
      if (i > 1) string += Math.round(equation[i] * Math.pow(10, i)) / Math.pow(10, i) + 'x^' + i + ' + ';else if (i == 1) string += Math.round(equation[i] * 100) / 100 + 'x' + ' + ';else string += Math.round(equation[i] * 100) / 100;
    }

    return {
      equation: equation,
      points: results,
      string: string
    };
  },
  lastvalue: function (data) {
    var results = [];
    var lastvalue = null;

    for (var i = 0; i < data.length; i++) {
      if (data[i][1]) {
        lastvalue = data[i][1];
        results.push([data[i][0], data[i][1]]);
      } else {
        results.push([data[i][0], lastvalue]);
      }
    }

    return {
      equation: [lastvalue],
      points: results,
      string: "" + lastvalue
    };
  }
};
module.exportDefault(regression = function (method, data, order) {
  if (typeof method == 'string') {
    return methods[method](data, order);
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"param_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/lib/param_util.js                                                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes(v) {
    matsTypes = v;
  }

}, 0);
let matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  }

}, 1);
let matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils(v) {
    matsCurveUtils = v;
  }

}, 2);
let matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils(v) {
    matsPlotUtils = v;
  }

}, 3);
let moment;
module.link("meteor/momentjs:moment", {
  moment(v) {
    moment = v;
  }

}, 4);

// get the document id for the control button element that corresponds to the param name
const getControlButtonIdForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  const pname = paramName.replace(/^.axis-/, '');
  const param = matsCollections.CurveParams.findOne({
    name: pname
  });

  if (param !== undefined) {
    const id = "controlButton-" + param.name;
    return id;
  }
}; // get the control Button Element that corresponds to the param name


const getControlElementForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  const pname = paramName.replace(/^.axis-/, '');
  return document.getElementById(getControlButtonIdForParamName(pname));
}; // get the document element that corresponds to the param name


const getValueElementForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  const pname = paramName.replace(/^.axis-/, '');
  const val = getValueIdForParamName(pname);
  return document.getElementById(val);
}; // get the current selected value in the document element that corresponds to the param name
// Note that the value should be reflected in the adjoining control button value textContent.


const getValueForParamName = function (paramName) {
  try {
    const elem = getValueElementForParamName(paramName);
    return getValueElementForParamName(paramName).textContent.trim();
  } catch (error) {
    return undefined;
  }
}; // get the VALUE BOX id for the element that corresponds to the param name


const getValueIdForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  const pname = paramName.replace(/^.axis-/, '');
  return "controlButton-" + pname + "-value";
}; // set the VALUE BOX text for the element that corresponds to the param name


const setValueTextForParamName = function (paramName, text) {
  try {
    var text = text;
    var param = matsCollections.CurveParams.findOne({
      name: paramName
    });

    if (param === undefined) {
      param = matsCollections.PlotParams.findOne({
        name: paramName
      });
    }

    if (param === undefined) {
      return;
    }

    if (text === undefined) {
      if (param.multiple) {
        // .... if multi selected  get the first .. last
        const selection = getInputElementForParamName(paramName).selectedOptions;

        if (selection.length == 0) {
          text = "";
        } else if (selection.length == 1) {
          text = selection[0].textContent;
        } else {
          text = selection[0].textContent + " .. " + selection[selection.length - 1].textContent;
        }
      }
    }

    const elem = getValueElementForParamName(paramName);

    if (elem.textContent !== text) {
      elem.textContent = text;
    }
  } catch (error) {
    console.log("Error: could not find param: " + paramName);
  }
}; // get the document id for the element that corresponds to the param name


const getInputIdForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  const pname = paramName.replace(/^.axis-/, '');
  var param = matsCollections.CurveParams.findOne({
    name: pname
  });

  if (param === undefined) {
    param = matsCollections.PlotParams.findOne({
      name: pname
    });
  }

  if (param === undefined) {
    param = matsCollections.Scatter2dParams.findOne({
      name: pname
    });

    if (param === undefined) {
      return undefined;
    }
  }

  if (param.type === matsTypes.InputTypes.dateRange) {
    return ("element-" + param.name).replace(/ /g, '-');
  } else {
    return (param.name + "-" + param.type).replace(/ /g, '-');
  }
}; // get the parameter for the element that corresponds to the param name


const getParameterForName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  const pname = paramName.replace(/^.axis-/, '');
  var param = matsCollections.CurveParams.findOne({
    name: pname
  });

  if (param === undefined) {
    param = matsCollections.PlotParams.findOne({
      name: pname
    });
  }

  if (param === undefined) {
    param = matsCollections.Scatter2dParams.findOne({
      name: pname
    });

    if (param === undefined) {
      return undefined;
    }
  }

  return param;
}; // get the document element that corresponds to the param name


const getInputElementForParamName = function (paramName) {
  const name = paramName.replace(/^.axis-/, '');
  const id = getInputIdForParamName(name);

  if (id === undefined) {
    return undefined;
  }

  return document.getElementById(id);
}; // get a param disabledOptions list - if any.


const getDisabledOptionsForParamName = function (paramName) {
  const name = paramName.replace(/^.axis-/, '');
  const id = getInputIdForParamName(name);

  if (id === undefined) {
    return undefined;
  }

  const param = getParameterForName(name);

  if (!param) {
    return undefined;
  }

  return param.disabledOptions;
}; // set the input for the element that corresponds to the param name
// also sets a data-mats-currentValue attribute


const setInputForParamName = function (paramName, value) {
  const param = getParameterForName(paramName);
  const id = getInputIdForParamName(paramName);
  const idSelectorStr = "#" + id;
  const idSelector = $(idSelectorStr); // SHOULD DEAL WITH CHECKBOXES HERE

  if (param.type === matsTypes.InputTypes.radioGroup) {
    $("#" + id + "-" + value).prop("checked", true);
  } else {
    idSelector.val(value);
    setValueTextForParamName(paramName, value);
  }
};

const getElementValues = function () {
  const data = {
    curveParams: {},
    plotParams: {},
    scatterParams: {}
  };
  const axis = ['xaxis-', 'yaxis-'];
  var params = matsCollections.CurveParams.find({}).fetch();
  params.forEach(function (param) {
    var val = "";

    if (param.type === matsTypes.InputTypes.radioGroup) {
      var selector = "input:radio[name='" + param.name + "']:checked";
      val = $(selector).val();
    } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
      var selector = "input[name='" + param.name + "']:checked";
      val = $(selector).map(function (_, el) {
        return $(el).val();
      }).get();
    } else if (param.type === matsTypes.InputTypes.dateRange) {
      val = getValueForParamName(param.name);
    } else {
      var idSelect = '#' + getInputIdForParamName(param.name);
      val = $(idSelect).val();
    }

    data.curveParams[param.name] = val;

    if (matsPlotUtils.getPlotType() == matsTypes.PlotTypes.scatter2d) {
      for (var a = 0; a < axis.length; a++) {
        const axisStr = axis[a];
        const name = axisStr + param.name;
        var val = "";

        if (param.type === matsTypes.InputTypes.radioGroup) {
          var selector = "input:radio[name='" + name + "']:checked";
          val = $(selector).val();
        } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
          var selector = "input[name='" + name + "']:checked";
          val = $(selector).map(function (_, el) {
            return $(el).val();
          }).get();
        } else {
          var idSelect = '#' + getInputIdForParamName(name);
          val = $(idSelect).val();
        }

        data.curveParams[name] = val;
      }
    }
  });
  params = matsCollections.PlotParams.find({}).fetch();
  params.forEach(function (param) {
    var val = "";

    if (param.type === matsTypes.InputTypes.radioGroup) {
      var selector = "input:radio[name='" + param.name + "']:checked";
      val = $(selector).val();
    } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
      var selector = "input[name='" + param.name + "']:checked";
      val = $(selector).map(function (_, el) {
        return $(el).val();
      }).get();
    } else {
      var idSelect = '#' + getInputIdForParamName(param.name);
      val = $(idSelect).val();
    }

    data.plotParams[param.name] = val;
  });
  params = matsCollections.Scatter2dParams.find({}).fetch();
  params.forEach(function (param) {
    var val = "";

    if (param.type === matsTypes.InputTypes.radioGroup) {
      var selector = "input:radio[name='" + param.name + "']:checked";
      val = $(selector).val();
    } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
      var selector = "input[name='" + param.name + "']:checked";
      val = $(selector).map(function (_, el) {
        return $(el).val();
      }).get();
    } else {
      var idSelect = '#' + getInputIdForParamName(param.name);
      val = $(idSelect).val();
    }

    data.scatterParams[param.name] = val;

    if (matsPlotUtils.getPlotType() == matsTypes.PlotTypes.scatter2d) {
      for (var a = 0; a < axis.length; a++) {
        var axisStr = axis[a];
        var name = axisStr + param.name;
        var val = "";

        if (param.type === matsTypes.InputTypes.radioGroup) {
          var selector = "input:radio[name='" + name + "']:checked";
          val = $(selector).val();
        } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
          var selector = "input[name='" + name + "']:checked";
          val = $(selector).map(function (_, el) {
            return $(el).val();
          }).get();
        } else {
          var idSelect = '#' + getInputIdForParamName(name);
          val = $(idSelect).val();
        }

        data.scatterParams[name] = val;
      }
    }
  });
  return data;
};

const expandParams = function () {
  const params = matsCollections.CurveParams.find({}).fetch();
  params.forEach(function (param) {
    if (param.type !== matsTypes.InputTypes.selectMap) {
      const selector = "element" + "-" + param.name;
      const elem = document.getElementById(selector);

      if (elem) {
        elem.style.display = "block";
        const dataElem = document.getElementById(param.name + "-" + param.type);

        if (dataElem && dataElem.options && dataElem.selectedIndex >= 0) {
          dataElem.options[dataElem.selectedIndex].scrollIntoView();
        }
      }
    }
  });
};

const collapseParams = function () {
  const params = matsCollections.CurveParams.find({}).fetch();
  params.forEach(function (param) {
    if (param.type !== matsTypes.InputTypes.selectMap) {
      const selector = "element" + "-" + param.name;

      if (document.getElementById(selector)) {
        document.getElementById(selector).style.display = "none";
      }
    }
  });
};

const collapseParam = function (paramName) {
  const param = matsCollections.CurveParams.findOne({
    name: paramName
  });

  if (param === undefined || param === null) {
    return;
  }

  if (param.type !== matsTypes.InputTypes.selectMap) {
    const selector = "element" + "-" + param.name;

    if (document.getElementById(selector)) {
      document.getElementById(selector).style.display = "none";
    }
  }
};

const typeSort = function (arr) {
  if (arr === undefined) {
    return undefined;
  }

  return arr.sort(function (a, b) {
    if (isNaN(Number(a) && isNaN(Number(b)))) {
      // string compare
      const A = a.toLowerCase();
      const B = b.toLowerCase();

      if (A < B) {
        return -1;
      } else if (A > B) {
        return 1;
      } else {
        return 0;
      }
    } else if (isNaN(Number(a) || isNaN(Number(b)))) {
      // number always precedes
      if (isNaN(Number(a))) {
        return 1;
      } else {
        return -1;
      }
    } else {
      return a - b; // numerical compare
    }
  });
};

const setDefaultForParamName = function (param) {
  const paramName = param.name;
  const type = param.type;
  const defaultValue = param.default;

  if (paramName == 'label') {
    setInputForParamName(paramName, Session.get('NextCurveLabel'));
  } else {
    if (defaultValue != "undefined") {
      if (type === matsTypes.InputTypes.select && (defaultValue === -1 || defaultValue === undefined || defaultValue === matsTypes.InputTypes.unused)) {
        setInputForParamName(paramName, matsTypes.InputTypes.unused);
      } else {
        setInputForParamName(paramName, defaultValue);
      }
    }
  }
};

const getDefaultDateRange = function (name) {
  var dateParam = matsCollections.CurveParams.findOne({
    name: name
  });

  if (dateParam === undefined) {
    dateParam = matsCollections.PlotParams.findOne({
      name: name
    });
  }

  const startInit = dateParam.startDate;
  const stopInit = dateParam.stopDate;
  const dstr = dateParam.default;
  return {
    startDate: startInit,
    stopDate: stopInit,
    dstr: dstr
  };
};

const getMinMaxDates = function (minDate, maxDate) {
  var minMoment = moment(minDate, "MM/DD/YYYY HH:mm");
  var maxMoment = moment(maxDate, "MM/DD/YYYY HH:mm");

  if (maxMoment.diff(minMoment, 'days') > 30) {
    minDate = moment(maxMoment.subtract(30, 'days')).format("MM/DD/YYYY HH:mm");
  }

  return {
    minDate: minDate,
    maxDate: maxDate
  };
};

const setAllParamsToDefault = function () {
  // default the superiors and refresh them so that they cause the dependent options to refresh
  var params = matsCollections.CurveParams.find({}).fetch();
  const superiors = matsCollections.CurveParams.find({
    "dependentNames": {
      "$exists": true
    }
  }).fetch();
  superiors.forEach(function (param) {
    setDefaultForParamName(param); // actually call the refresh directly - don't use an event, because we want this all to be synchronous

    matsSelectUtils.refresh(null, param.name); // remove from params list - actually rewrite params list NOT with this param

    params = params.filter(function (obj) {
      return obj.name !== param.name;
    });
  }); // refresh all the non superiors to their default values

  const nonDependents = matsCollections.CurveParams.find({
    "superiorNames": {
      "$exists": true
    }
  }).fetch();
  nonDependents.forEach(function (param) {
    setDefaultForParamName(param);

    if (param.type === matsTypes.InputTypes.dateRange) {
      const dstr = getDefaultDateRange(param.name).dstr;
      setValueTextForParamName(param.name, dstr);
    } else {
      matsSelectUtils.refresh(null, param.name); // remove from params list - actually rewrite params list NOT with this param

      params = params.filter(function (obj) {
        return obj.name !== param.name;
      });
    }
  }); // reset everything else

  params.forEach(function (param) {
    if (param.type === matsTypes.InputTypes.dateRange) {
      const dstr = getDefaultDateRange(param.name).dstr;
      setValueTextForParamName(param.name, dstr);
    } else if (param.type === matsTypes.InputTypes.selectMap) {
      const targetId = param.name + '-' + param.type;
      const targetElem = document.getElementById(targetId);
      const resetMapEvent = new CustomEvent("reset", {
        detail: {
          refElement: null
        }
      });
      targetElem.dispatchEvent(resetMapEvent);
    } else {
      setDefaultForParamName(param);
    }
  });
  matsCollections.PlotParams.find({}).fetch().forEach(function (param) {
    if (param.type === matsTypes.InputTypes.dateRange) {
      const dstr = getDefaultDateRange(param.name).dstr;
      setValueTextForParamName(param.name, dstr);
    } else {
      setDefaultForParamName(param);
    }
  });
}; // is the input element displaying? used by curve_param_item_group


const isInputElementVisible = function (paramName) {
  const name = paramName.replace(/^.axis-/, ''); // need to acount for scatter plots params

  const inputElement = getInputElementForParamName(name);
  return $(inputElement).is(':visible');
}; // is the input element displaying? used by curve_param_item_group


const isParamVisible = function (paramName) {
  const name = paramName.replace(/^.axis-/, ''); // need to acount for scatter plots params

  const paramRef = "#" + name + "-item";
  return $(paramRef).is(':visible');
}; // is the input element displaying? used by curve_param_item_group


const isControlButtonVisible = function (paramName) {
  const name = paramName.replace(/^.axis-/, ''); // need to acount for scatter plots params

  const paramRef = "#controlButton-" + name;
  return $(paramRef).is(':visible');
};

const setInputValueForParamAndtriggerChange = function (paramName, value) {
  const elem = getInputElementForParamName(paramName);
  elem.value = value;
  setValueTextForParamName(paramName, elem.value);
  $(elem).trigger('change');
};

const getOptionsMapForParam = function (paramName) {
  const param = matsCollections.CurveParams.findOne({
    name: paramName
  });
  return param.optionsMap;
};

const getOptionsForParam = function (paramName) {
  const param = matsCollections.CurveParams.findOne({
    name: paramName
  });
  return param.options;
};

const getAppName = function () {
  const app = matsCollections.appName.findOne({}).app;
  return app;
};

const getCurveItemValueForParamName = function (curveNumber, paramName) {//MODEL-curve-0-Item
  //    const id = paramName.toString().toUpperCase() + "-curve-" + curveNumber + "-Item"; // the id of the text span for a curveItem
  //    return text = ‌‌document.getElementById(id).innerText;
  // const elem = $("#" + id);
  // var text = undefined;
  // if (elem) {
  //     text = elem.text();
  // }
};

const visibilityControllerForParam = function (paramName) {
  /*
  Need to iterate all the params looking for one that has this paramName as a key in its
  hideOtherFor map.
  If it exists, that param is returned. Otherwise return undefined.
   */
  var params = matsCollections.CurveParams.find({}).fetch();
  var found = undefined;
  params.some(function (param) {
    if (param.hideOtherFor) {
      const pKeys = Object.keys(param.hideOtherFor);

      if (pKeys.indexOf(paramName) !== -1) {
        found = param;
        return;
      }
    }
  });
  return found;
};

module.exportDefault(matsParamUtils = {
  getDisabledOptionsForParamName: getDisabledOptionsForParamName,
  getControlButtonIdForParamName: getControlButtonIdForParamName,
  getControlElementForParamName: getControlElementForParamName,
  getValueElementForParamName: getValueElementForParamName,
  getValueForParamName: getValueForParamName,
  setValueTextForParamName: setValueTextForParamName,
  getValueIdForParamName: getValueIdForParamName,
  getInputIdForParamName: getInputIdForParamName,
  getInputElementForParamName: getInputElementForParamName,
  getElementValues: getElementValues,
  setInputForParamName: setInputForParamName,
  expandParams: expandParams,
  collapseParams: collapseParams,
  collapseParam: collapseParam,
  getParameterForName: getParameterForName,
  setDefaultForParamName: setDefaultForParamName,
  setAllParamsToDefault: setAllParamsToDefault,
  typeSort: typeSort,
  isInputElementVisible: isInputElementVisible,
  isParamVisible: isParamVisible,
  isControlButtonVisible: isControlButtonVisible,
  setInputValueForParamAndtriggerChange: setInputValueForParamAndtriggerChange,
  getOptionsForParam: getOptionsForParam,
  getOptionsMapForParam: getOptionsMapForParam,
  getCurveItemValueForParamName: getCurveItemValueForParamName,
  visibilityControllerForParam: visibilityControllerForParam,
  getAppName: getAppName,
  getDefaultDateRange: getDefaultDateRange,
  getMinMaxDates: getMinMaxDates
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"plot_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/lib/plot_util.js                                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
let matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections(v) {
    matsCollections = v;
  }

}, 0);
let matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils(v) {
    matsParamUtils = v;
  }

}, 1);
let matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes(v) {
    matsTypes = v;
  }

}, 2);

// determine the axisText (used in scatter_axis.js for example)
// according to the Scatter Axis Text Patterns Pattern defined in
// ScatterAxisTextPatterns according to plotType - and derived from
// currently selected inputs in the document.
const getAxisText = function (plotType) {
  var scatterAxisTextPattern = matsCollections.ScatterAxisTextPattern.findOne({
    plotType: getPlotType()
  });
  var textPattern = scatterAxisTextPattern ? matsCollections.ScatterAxisTextPattern.findOne({
    plotType: getPlotType()
  }).textPattern : undefined;

  if (scatterAxisTextPattern === undefined) {
    return "";
  }

  var text = "";

  for (var i = 0; i < scatterAxisTextPattern.length; i++) {
    var pName = scatterAxisTextPattern[i][0];
    var delimiter = scatterAxisTextPattern[i][1];
    var value = matsParamUtils.getValueForParamName(pName);
    text += value += delimiter;
  }

  return text;
}; // determine the curveText (used in curveItem for example) for a given curve (from Session.get('curves'))
// that has already been added


const getCurveText = function (plotType, curve) {
  var curveTextPattern = matsCollections.CurveTextPatterns.findOne({
    plotType: plotType
  }).textPattern;
  var text = "";

  for (var i = 0; i < curveTextPattern.length; i++) {
    var a = curveTextPattern[i];

    if (a === undefined || a === null || curve[a[1]] === undefined) {
      continue;
    }

    text += a[0];

    if (curve[a[1]] instanceof Array && curve[a[1]].length > 2) {
      text += curve[a[1]][0] + ".." + curve[a[1]][curve[a[1]].length - 1];
    } else {
      text += curve[a[1]];
    }

    text += a[2];
  }

  return text;
}; // determine which plotType radio button is checked


const getPlotType = function () {
  var buttons = document.getElementsByName('plot-type');

  for (var i = 0, len = buttons.length; i < len; i++) {
    if (buttons[i].checked) {
      return buttons[i].value;
    }
  }

  return ""; // error condition actually - shouldn't ever happen
}; // determine which plotFormat radio button is checked


const getPlotFormat = function () {
  var buttons = document.getElementsByName('plotFormat');

  if (buttons === undefined) {
    return ""; // app may not have plotFormat?
  }

  var plotFormatParam = matsCollections.PlotParams.findOne({
    name: 'plotFormat'
  });

  if (plotFormatParam === undefined) {
    return ""; // app may not have plotFormat?
  }

  var optionsMap = plotFormatParam.optionsMap;

  for (var i = 0, len = buttons.length; i < len; i++) {
    if (buttons[i].checked) {
      return buttons[i].value;
    }
  }

  return ""; // error condition actually - shouldn't ever happen
}; // Determine which BestFit radio button is checked


const getBestFit = function () {
  var buttons = document.getElementsByName('Fit Type');
  var optionsMap = matsCollections.PlotParams.findOne({
    name: 'bestFit'
  }).optionsMap;

  for (var i = 0, len = buttons.length; i < len; i++) {
    if (buttons[i].checked) {
      return buttons[i].value;
    }
  }

  return ""; // error condition actually - shouldn't ever happen
};

const containsPoint = function (pointArray, point) {
  var lat = point[0];
  var lon = point[1];

  for (var i = 0; i < pointArray.length; i++) {
    var pLat = pointArray[i][0];
    var pLon = pointArray[i][1];

    if (lat === pLat && lon === pLon) {
      return true;
    }
  }

  return false;
}; // disable the action buttons while the query and plot routines are processing, then re-enable them afterwards


const disableActionButtons = function () {
  document.getElementById('plotMatched').disabled = true;
  document.getElementById('plotUnmatched').disabled = true;
  document.getElementById('add').disabled = true;
  document.getElementById('remove-all').disabled = true;
};

const enableActionButtons = function () {
  document.getElementById('plotMatched').disabled = false;
  document.getElementById('plotUnmatched').disabled = false;
  document.getElementById('add').disabled = false;
  document.getElementById('remove-all').disabled = false;
};

module.exportDefault(matsPlotUtils = {
  getAxisText: getAxisText,
  getCurveText: getCurveText,
  getPlotType: getPlotType,
  getPlotFormat: getPlotFormat,
  getBestFit: getBestFit,
  containsPoint: containsPoint,
  disableActionButtons: disableActionButtons,
  enableActionButtons: enableActionButtons
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"math_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/lib/math_util.js                                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */

/*
generic Math Functions
 */
var isNum = function (args) {
  if (args == null || args == undefined) {
    return false;
  }

  args = args.toString();
  if (args.length == 0) return false;

  for (var i = 0; i < args.length; i++) {
    if ((args.substring(i, i + 1) < "0" || args.substring(i, i + 1) > "9") && args.substring(i, i + 1) != "." && args.substring(i, i + 1) != "-") {
      return false;
    }
  }

  return true;
};

var mean = function (arr) {
  var len = 0;
  var sum = 0;

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] == "") {} else if (!isNum(arr[i])) {
      //alert(arr[i] + " is not number!");
      console.log("Error: value at position: " + i + " is not number! Mean Calculation failed!");
      return 0;
    } else {
      len = len + 1;
      sum = sum + parseFloat(arr[i]);
    }
  }

  return sum / len;
};

var variance = function (arr) {
  var len = 0;
  var sum = 0;

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] == "") {} else if (!isNum(arr[i])) {
      //alert(arr[i] + " is not number, Variance Calculation failed!");
      console.log("value at position " + i + " is not number, Variance Calculation failed!");
      return 0;
    } else {
      len = len + 1;
      sum = sum + parseFloat(arr[i]);
    }
  }

  var v = 0;

  if (len > 1) {
    var mean = sum / len;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] == "") {} else {
        v = v + (arr[i] - mean) * (arr[i] - mean);
      }
    }

    return v / len;
  } else {
    return 0;
  }
};

var median = function (arr) {
  arr.sort(function (a, b) {
    return a - b;
  });
  var median = 0;

  if (arr.length % 2 == 1) {
    median = arr[(arr.length + 1) / 2 - 1];
  } else {
    median = (1 * arr[arr.length / 2 - 1] + 1 * arr[arr.length / 2]) / 2;
  }

  return median;
};

module.exportDefault(matsMathUtils = {
  isNum: isNum,
  mean: mean,
  variance: variance,
  median: median
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"node_modules":{"fibers":{"future.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fibers/future.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.useNode();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"@babel":{"runtime":{"helpers":{"interopRequireDefault.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/interopRequireDefault.js                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.useNode();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"objectSpread.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/objectSpread.js                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.useNode();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}}},"node-file-cache":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/node-file-cache/package.json                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "node-file-cache",
  "version": "1.0.2",
  "main": "lib/index.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"lib":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/node-file-cache/lib/index.js                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.useNode();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}},"csv-stringify":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/csv-stringify/package.json                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "csv-stringify",
  "version": "4.3.1",
  "main": "./lib"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"lib":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/csv-stringify/lib/index.js                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.useNode();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}},"fs-extra":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/package.json                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "fs-extra",
  "version": "7.0.0",
  "main": "./lib/index.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"lib":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/index.js                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.useNode();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}}}}}}},{
  "extensions": [
    ".js",
    ".json"
  ]
});

var exports = require("/node_modules/meteor/randyp:mats-common/server/main.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/both/index.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/both/mats-types.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/both/mats-collections.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/api/matsMethods.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/curve_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/graph_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/select_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/index.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/init.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/routes.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_query_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_diff_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_match_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_curve_ops_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_plot_ops_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_process_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/plot_spec_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/index.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/publications.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/cache.js");
require("/node_modules/meteor/randyp:mats-common/lib/regression.js");
require("/node_modules/meteor/randyp:mats-common/lib/param_util.js");
require("/node_modules/meteor/randyp:mats-common/lib/plot_util.js");
require("/node_modules/meteor/randyp:mats-common/lib/math_util.js");

/* Exports */
Package._define("randyp:mats-common", exports, {
  matsCollections: matsCollections,
  matsTypes: matsTypes,
  matsMethods: matsMethods,
  matsParamUtils: matsParamUtils,
  matsMathUtils: matsMathUtils,
  matsPlotUtils: matsPlotUtils,
  matsPlotSpecUtils: matsPlotSpecUtils,
  matsDataUtils: matsDataUtils,
  matsDataQueryUtils: matsDataQueryUtils,
  matsDataDiffUtils: matsDataDiffUtils,
  matsDataMatchUtils: matsDataMatchUtils,
  matsDataCurveOpsUtils: matsDataCurveOpsUtils,
  matsDataPlotOpsUtils: matsDataPlotOpsUtils,
  matsDataProcessUtils: matsDataProcessUtils,
  regression: regression,
  matsCache: matsCache
});

})();

//# sourceURL=meteor://💻app/packages/randyp_mats-common.js
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGVvcjovL/CfkrthcHAvcGFja2FnZXMvcmFuZHlwOm1hdHMtY29tbW9uL3NlcnZlci9tYWluLmpzIiwibWV0ZW9yOi8v8J+Su2FwcC9wYWNrYWdlcy9yYW5keXA6bWF0cy1jb21tb24vaW1wb3J0cy9zdGFydHVwL2JvdGgvaW5kZXguanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9pbXBvcnRzL3N0YXJ0dXAvYm90aC9tYXRzLXR5cGVzLmpzIiwibWV0ZW9yOi8v8J+Su2FwcC9wYWNrYWdlcy9yYW5keXA6bWF0cy1jb21tb24vaW1wb3J0cy9zdGFydHVwL2JvdGgvbWF0cy1jb2xsZWN0aW9ucy5qcyIsIm1ldGVvcjovL/CfkrthcHAvcGFja2FnZXMvcmFuZHlwOm1hdHMtY29tbW9uL2ltcG9ydHMvc3RhcnR1cC9hcGkvbWF0c01ldGhvZHMuanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9pbXBvcnRzL3N0YXJ0dXAvY2xpZW50L2N1cnZlX3V0aWwuanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9pbXBvcnRzL3N0YXJ0dXAvY2xpZW50L2dyYXBoX3V0aWwuanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9pbXBvcnRzL3N0YXJ0dXAvY2xpZW50L3NlbGVjdF91dGlsLmpzIiwibWV0ZW9yOi8v8J+Su2FwcC9wYWNrYWdlcy9yYW5keXA6bWF0cy1jb21tb24vaW1wb3J0cy9zdGFydHVwL2NsaWVudC9pbmRleC5qcyIsIm1ldGVvcjovL/CfkrthcHAvcGFja2FnZXMvcmFuZHlwOm1hdHMtY29tbW9uL2ltcG9ydHMvc3RhcnR1cC9jbGllbnQvaW5pdC5qcyIsIm1ldGVvcjovL/CfkrthcHAvcGFja2FnZXMvcmFuZHlwOm1hdHMtY29tbW9uL2ltcG9ydHMvc3RhcnR1cC9jbGllbnQvcm91dGVzLmpzIiwibWV0ZW9yOi8v8J+Su2FwcC9wYWNrYWdlcy9yYW5keXA6bWF0cy1jb21tb24vaW1wb3J0cy9zdGFydHVwL3NlcnZlci9kYXRhX3V0aWwuanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9pbXBvcnRzL3N0YXJ0dXAvc2VydmVyL2RhdGFfcXVlcnlfdXRpbC5qcyIsIm1ldGVvcjovL/CfkrthcHAvcGFja2FnZXMvcmFuZHlwOm1hdHMtY29tbW9uL2ltcG9ydHMvc3RhcnR1cC9zZXJ2ZXIvZGF0YV9kaWZmX3V0aWwuanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9pbXBvcnRzL3N0YXJ0dXAvc2VydmVyL2RhdGFfbWF0Y2hfdXRpbC5qcyIsIm1ldGVvcjovL/CfkrthcHAvcGFja2FnZXMvcmFuZHlwOm1hdHMtY29tbW9uL2ltcG9ydHMvc3RhcnR1cC9zZXJ2ZXIvZGF0YV9jdXJ2ZV9vcHNfdXRpbC5qcyIsIm1ldGVvcjovL/CfkrthcHAvcGFja2FnZXMvcmFuZHlwOm1hdHMtY29tbW9uL2ltcG9ydHMvc3RhcnR1cC9zZXJ2ZXIvZGF0YV9wbG90X29wc191dGlsLmpzIiwibWV0ZW9yOi8v8J+Su2FwcC9wYWNrYWdlcy9yYW5keXA6bWF0cy1jb21tb24vaW1wb3J0cy9zdGFydHVwL3NlcnZlci9kYXRhX3Byb2Nlc3NfdXRpbC5qcyIsIm1ldGVvcjovL/CfkrthcHAvcGFja2FnZXMvcmFuZHlwOm1hdHMtY29tbW9uL2ltcG9ydHMvc3RhcnR1cC9zZXJ2ZXIvcGxvdF9zcGVjX3V0aWwuanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9pbXBvcnRzL3N0YXJ0dXAvc2VydmVyL2luZGV4LmpzIiwibWV0ZW9yOi8v8J+Su2FwcC9wYWNrYWdlcy9yYW5keXA6bWF0cy1jb21tb24vaW1wb3J0cy9zdGFydHVwL3NlcnZlci9wdWJsaWNhdGlvbnMuanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9pbXBvcnRzL3N0YXJ0dXAvc2VydmVyL2NhY2hlLmpzIiwibWV0ZW9yOi8v8J+Su2FwcC9wYWNrYWdlcy9yYW5keXA6bWF0cy1jb21tb24vbGliL3JlZ3Jlc3Npb24uanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9saWIvcGFyYW1fdXRpbC5qcyIsIm1ldGVvcjovL/CfkrthcHAvcGFja2FnZXMvcmFuZHlwOm1hdHMtY29tbW9uL2xpYi9wbG90X3V0aWwuanMiLCJtZXRlb3I6Ly/wn5K7YXBwL3BhY2thZ2VzL3JhbmR5cDptYXRzLWNvbW1vbi9saWIvbWF0aF91dGlsLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImxpbmsiLCJTZXJ2aWNlQ29uZmlndXJhdGlvbiIsInYiLCJzZXRHb29nbGVDcmVkIiwiTWV0ZW9yIiwiaXNTZXJ2ZXIiLCJvcyIsIk5wbSIsInJlcXVpcmUiLCJob3N0bmFtZSIsImNpZCIsImNTZWNyZXQiLCJnaWQiLCJnU2VjcmV0IiwiX2lkIiwiY3JlZCIsImNvbmZpZ3VyYXRpb25zIiwiZmluZE9uZSIsInNlcnZpY2UiLCJjbGllbnRJZCIsInNlY3JldCIsImlnbm9yZSIsInNwbGl0IiwidXBkYXRlIiwiJHNldCIsImluc2VydCIsImxvZ2luU3R5bGUiLCJEYXRhYmFzZVJvbGVzIiwiTU9ERUxfREFUQSIsIk1FVEFfREFUQSIsIlNVTVNfREFUQSIsIlNJVEVfREFUQSIsIkFwcFR5cGVzIiwibWF0cyIsIm1ldGV4cHJlc3MiLCJtYXRzNG1ldCIsIklucHV0VHlwZXMiLCJ0ZXh0SW5wdXQiLCJzZWxlY3QiLCJzZWxlY3RPcmRlckVuZm9yY2VkIiwibnVtYmVyU3Bpbm5lciIsImRhdGVSYW5nZSIsInJhZGlvR3JvdXAiLCJjaGVja0JveEdyb3VwIiwicmVzZXRCdXR0b24iLCJjb250cm9sQnV0dG9uIiwiZWxlbWVudCIsInNlbGVjdE1hcCIsImN1c3RvbSIsInVudXNlZCIsImZvcmVjYXN0U2luZ2xlQ3ljbGUiLCJmb3JlY2FzdE11bHRpQ3ljbGUiLCJQbG90VHlwZXMiLCJ0aW1lU2VyaWVzIiwicHJvZmlsZSIsImRpZW9mZiIsInRocmVzaG9sZCIsInZhbGlkdGltZSIsImRhaWx5TW9kZWxDeWNsZSIsInJlbGlhYmlsaXR5IiwibWFwIiwiaGlzdG9ncmFtIiwiY29udG91ciIsImNvbnRvdXJEaWZmIiwic2NhdHRlcjJkIiwiRm9yZWNhc3RUeXBlcyIsInV0Y0N5Y2xlIiwic2luZ2xlQ3ljbGUiLCJQbG90Rm9ybWF0cyIsIm5vbmUiLCJtYXRjaGluZyIsInBhaXJ3aXNlIiwiYWJzb2x1dGUiLCJQbG90QWN0aW9ucyIsIm1hdGNoZWQiLCJ1bm1hdGNoZWQiLCJCZXN0Rml0cyIsImxpbmVhciIsImxpbmVhclRocm91Z2hPcmlnaW4iLCJleHBvbmVudGlhbCIsImxvZ2FyaXRobWljIiwicG93ZXIiLCJNYXRjaEZvcm1hdHMiLCJ0aW1lIiwibGV2ZWwiLCJzaXRlIiwiUGxvdEF4aXNGaWx0ZXJzIiwiUGxvdFZpZXciLCJncmFwaCIsInRleHRTZXJpZXMiLCJSZXNlcnZlZFdvcmRzIiwiWmVybyIsInplcm8iLCJpZGVhbDAiLCJpZGVhbDEiLCJpZGVhbDIiLCJpZGVhbDMiLCJpZGVhbDQiLCJpZGVhbDUiLCJpZGVhbDYiLCJpZGVhbDciLCJpZGVhbDgiLCJpZGVhbDkiLCJwZXJmZWN0UmVsaWFiaWxpdHkiLCJub1NraWxsIiwiYmx1ZUN1cnZlVGV4dCIsImJsYWNrQ3VydmVUZXh0IiwicmVkQ3VydmVUZXh0IiwiTWVzc2FnZXMiLCJOT19EQVRBX0ZPVU5EIiwic2VsZWN0b3JzVG9IaWRlIiwiTWV0YURhdGFEQlJlY29yZCIsImNvbnN0cnVjdG9yIiwicG9vbE5hbWUiLCJkYk5hbWUiLCJ0YWJsZXMiLCJFcnJvciIsIkFycmF5IiwiX3JlY29yZHMiLCJyZWNvcmQiLCJwdXNoIiwiYWRkUmVjb3JkIiwiZ2V0UmVjb3JkcyIsImV4cG9ydERlZmF1bHQiLCJtYXRzVHlwZXMiLCJNb25nbyIsIkN1cnZlUGFyYW1zIiwiQ29sbGVjdGlvbiIsIlNjYXR0ZXIyZFBhcmFtcyIsIkN1cnZlVGV4dFBhdHRlcm5zIiwiU2NhdHRlckF4aXNUZXh0UGF0dGVybiIsIlNhdmVkQ3VydmVQYXJhbXMiLCJQbG90UGFyYW1zIiwiU2F2ZWRQbG90UGFyYW1zIiwiUGxvdEdyYXBoRnVuY3Rpb25zIiwiU2F2ZWRQbG90R3JhcGhGdW5jdGlvbnMiLCJSZWdpb25zUGVyTW9kZWwiLCJTaXRlc1Blck1vZGVsIiwiUmVnaW9uRGVzY3JpcHRpb25zIiwiTW9kZWxzIiwiSW5zdHJ1bWVudHMiLCJGY3N0TGVuc1Blck1vZGVsIiwiQ3VydmVTZXR0aW5ncyIsIlNldHRpbmdzIiwiQ29sb3JTY2hlbWUiLCJTZW50QWRkcmVzc2VzIiwiQXV0aG9yaXphdGlvbiIsIlJvbGVzIiwiU2F2ZWRSb2xlcyIsIkRhdGFiYXNlcyIsIlNhdmVkRGF0YWJhc2VzIiwiQ3JlZGVudGlhbHMiLCJTYXZlZENyZWRlbnRpYWxzIiwiU2l0ZU1hcCIsIlN0YXRpb25NYXAiLCJhcHBOYW1lIiwibWF0c0NvbGxlY3Rpb25zIiwiVmFsaWRhdGVkTWV0aG9kIiwiU2ltcGxlU2NoZW1hIiwibWF0c0NhY2hlIiwibWF0c0RhdGFRdWVyeVV0aWxzIiwibWF0c0RhdGFVdGlscyIsIm15c3FsIiwidXJsIiwibWV0YURhdGFUYWJsZVVwZGF0ZXMiLCJMYXlvdXRTdG9yZUNvbGxlY3Rpb24iLCJEb3duU2FtcGxlUmVzdWx0cyIsIk1WX0RJUlMiLCJzZXR0aW5ncyIsInByaXZhdGUiLCJ1bmRlZmluZWQiLCJfTVZfT1VUIiwiTVZfT1VUUFVUIiwiX01WX0hPTUUiLCJNVl9IT01FIiwiX01WX0xPR0RJUiIsIl9NVl9FUlJESVIiLCJfTVZfREFUQURJUiIsIl9NVl9TUUxESVIiLCJfTVZfWE1MRElSIiwiX01WX1NDUklQVFNESVIiLCJfTVZfUExPVFNTRElSIiwicHJvY2VzcyIsImVudiIsIkpBVkFfSE9NRSIsIkxPR0RJUiIsIkVSUkRJUiIsIkRBVEFESVIiLCJTUUxESVIiLCJYTUxESVIiLCJTQ1JJUFRTRElSIiwiUExPVFNESVIiLCJIT01FIiwicmF3Q29sbGVjdGlvbiIsImNyZWF0ZUluZGV4IiwiZXhwaXJlQWZ0ZXJTZWNvbmRzIiwicHVibGljIiwicHJveHlfcHJlZml4X3BhdGgiLCJQaWNrZXIiLCJyb3V0ZSIsInBhcmFtcyIsInJlcSIsInJlcyIsIm5leHQiLCJtaWRkbGV3YXJlIiwiX2dldENTViIsIl9nZXRKU09OIiwiX2NsZWFyQ2FjaGUiLCJfcmVmcmVzaE1ldGFkYXRhTVdsdERhdGEiLCJfbXZHZXREYXRhIiwiX212R2V0UG9pbnRzMSIsIl9tdkdldFBvaW50czIiLCJfbXZHZXRYbWwiLCJfbXZHZXRQbG90IiwiX212R2V0U2NyaXB0IiwiX212R2V0U3FsIiwiX212R2V0TG9nIiwiX212R2V0RXJyIiwiX2NoZWNrTWV0YURhdGFSZWZyZXNoIiwicmVmcmVzaCIsInRhYmxlVXBkYXRlcyIsImZpbmQiLCJmZXRjaCIsInR1aSIsImxlbmd0aCIsImlkIiwicG9vbCIsIm5hbWUiLCJ0YWJsZU5hbWVzIiwibGFzdFJlZnJlc2hlZCIsInVwZGF0ZWRFcG9jaCIsIk51bWJlciIsIk1BWF9WQUxVRSIsInRpIiwidE5hbWUiLCJyb3dzIiwic2ltcGxlUG9vbFF1ZXJ5V3JhcFN5bmNocm9ub3VzIiwiZ2xvYmFsIiwiaSIsImUiLCJtZXNzYWdlIiwibGFzdFJlZnJlc2hlZEVwb2NoIiwibW9tZW50IiwidmFsdWVPZiIsImNvbnNvbGUiLCJsb2ciLCJ1dGMiLCJmb3JtYXQiLCJhc3JLZXlzIiwiYXBwU3BlY2lmaWNSZXNldFJvdXRpbmVzIiwiYWkiLCJjbGVhciIsImVuZCIsInN0cmluZ2lmeSIsImNzdiIsInJlc3VsdCIsIl9nZXRGbGF0dGVuZWRSZXN1bHREYXRhIiwia2V5Iiwic3RhdEFycmF5IiwiT2JqZWN0IiwidmFsdWVzIiwic3RhdHMiLCJkYXRhQXJyYXkiLCJkYXRhIiwic3RhdFJlc3VsdEFycmF5IiwiZGF0YVJlc3VsdEFycmF5Iiwic2kiLCJrZXlzIiwibGFiZWwiLCJkaSIsImRhdGFTdWJBcnJheSIsImRhdGFIZWFkZXIiLCJmaWx0ZXIiLCJpbmRleE9mIiwiZHNpIiwiZmlsZU5hbWUiLCJzZXRIZWFkZXIiLCJoZWFkZXIiLCJlcnIiLCJvdXRwdXQiLCJ3cml0ZSIsInRvTG9jYWxlU3RyaW5nIiwiZmxhdEpTT04iLCJfZ2V0UGFnZW5hdGVkRGF0YSIsIkpTT04iLCJlcnJvciIsImRzaVJlYWxQYWdlSW5kZXgiLCJkc2lUZXh0RGlyZWN0aW9uIiwicmsiLCJwIiwibnAiLCJyZXNwIiwiciIsInBsb3RUeXBlcyIsImJhc2lzIiwicGxvdFBhcmFtcyIsInBsb3RUeXBlIiwiXyIsImludmVydCIsInJldHVybkRhdGEiLCJjaSIsInJlc2VydmVkV29yZHMiLCJnbG9iX3N0YXRzIiwiZF9tZWFuIiwic2QiLCJuX2dvb2QiLCJzdGRlX2JldHN5IiwibGFnMSIsIm1pblZhbCIsIm1heFZhbCIsImN1cnZlRGF0YSIsImNkaSIsIngiLCJjdXJ2ZURhdGFFbGVtZW50IiwicmF3X3N0YXQiLCJ5IiwiY2RhdGEiLCJsYWJlbFN1ZmZpeCIsInNhbXBsZV9jbGltbyIsInByb2JfYmluIiwiaGl0X3JhdGUiLCJvYnNfeSIsIm9ic19uIiwicmVkdWNlIiwicHJldiIsImN1cnIiLCJOX3RpbWVzIiwiYXZlcmFnZSIsInF1ZXJ5VmFsIiwic3RkZXYiLCJtaW5fdGltZSIsIm1heF90aW1lIiwic2l0ZU5hbWUiLCJnbG9iX21lYW4iLCJnbG9iX3NkIiwiZ2xvYl9uIiwiZ2xvYl9taW4iLCJnbG9iX21heCIsImJpbl9zdGF0cyIsImJpbl9uIiwiYmluX3JmIiwiYmluTG93Qm91bmQiLCJiaW5VcEJvdW5kIiwiYmluX21lYW4iLCJiaW5fc2QiLCJuIiwibWVhbiIsIm1pbkRhdGUiLCJtYXhEYXRlIiwieFRleHRPdXRwdXQiLCJ5VGV4dE91dHB1dCIsInpUZXh0T3V0cHV0IiwiblRleHRPdXRwdXQiLCJtaW5EYXRlVGV4dE91dHB1dCIsIm1heERhdGVUZXh0T3V0cHV0IiwiZmlyc3RCZXN0Rml0SW5kZXgiLCJiZXN0Rml0SW5kZXhlcyIsImJlc3RGaXRJbmRleCIsImNiaSIsImN1cnZlVGV4dERhdGEiLCJya3kiLCJteVBhZ2VJbmRleCIsIm5ld1BhZ2VJbmRleCIsInJldCIsInJhd1JldHVybiIsImdldFJlc3VsdCIsInBhcnNlIiwic3RhcnQiLCJkaXJlY3Rpb24iLCJkc2lTdGFydCIsImRzaUVuZCIsImNzaSIsIk1hdGgiLCJmbG9vciIsInNsaWNlIiwiZnNlIiwiZmlsZVBhdGgiLCJiYXNlTmFtZSIsInJlYWRGaWxlIiwiX3NhdmVSZXN1bHREYXRhIiwic2l6ZW9mIiwiaGFzaCIsImRTaXplIiwiVGltZVNlcmllcyIsIkRhaWx5TW9kZWxDeWNsZSIsImRvd25zYW1wbGVyIiwidG90YWxQb2ludHMiLCJ4X2Vwb2NoIiwiYWxsb3dlZE51bWJlck9mUG9pbnRzIiwiZG93blNhbXBsZVJlc3VsdCIsImRzRGF0YSIsInh5RGF0YXNldCIsImQiLCJpbmRleCIsInJhdGlvVG90YWxQb2ludHMiLCJteUFsbG93ZWRQb2ludHMiLCJyb3VuZCIsImRvd25zYW1wbGVkU2VyaWVzIiwicHJvY2Vzc0RhdGEiLCJvcmlnaW5hbEluZGV4IiwiYXJyYXlLZXlzIiwibm9uQXJyYXlLZXlzIiwia2kiLCJpc0FycmF5IiwiYXJyYXkiLCJhbm5vdGF0aW9uIiwiRGF0ZSIsInN0b3JlUmVzdWx0IiwiYWRkU2VudEFkZHJlc3MiLCJ2YWxpZGF0ZSIsInRvQWRkcmVzcyIsInR5cGUiLCJTdHJpbmciLCJ2YWxpZGF0b3IiLCJydW4iLCJ1c2VySWQiLCJ1cHNlcnQiLCJhZGRyZXNzIiwiYXBwbHlBdXRob3JpemF0aW9uIiwiYmxhY2tib3giLCJyb2xlcyIsInJvbGVOYW1lIiwiYXV0aG9yaXphdGlvbiIsInVzZXJSb2xlTmFtZSIsInVzZXJSb2xlRGVzY3JpcHRpb24iLCJhdXRob3JpemF0aW9uUm9sZSIsIm5ld1VzZXJFbWFpbCIsImV4aXN0aW5nVXNlckVtYWlsIiwicm9sZSIsImRlc2NyaXB0aW9uIiwiZW1haWwiLCJhcHBseURhdGFiYXNlU2V0dGluZ3MiLCJzdGF0dXMiLCJob3N0IiwiZGF0YWJhc2UiLCJ1c2VyIiwicGFzc3dvcmQiLCJkZWxldGVTZXR0aW5ncyIsInJlbW92ZSIsImVtYWlsSW1hZ2UiLCJpbWFnZVN0ciIsInN1YmplY3QiLCJmcm9tQWRkcmVzcyIsInNlcnZpY2VzIiwiZ29vZ2xlIiwiY3JlZGVudGlhbHMiLCJjbGllbnRTZWNyZXQiLCJyZWZyZXNoX3Rva2VuIiwic210cFRyYW5zcG9ydGVyIiwiTm9kZW1haWxlciIsImNyZWF0ZVRyYW5zcG9ydCIsImF1dGgiLCJYT0F1dGgyIiwicmVmcmVzaFRva2VuIiwibWFpbE9wdGlvbnMiLCJzZW5kZXIiLCJyZXBseVRvIiwiZnJvbSIsInRvIiwiYXR0YWNobWVudHMiLCJmaWxlbmFtZSIsImNvbnRlbnRzIiwiQnVmZmVyIiwic2VuZE1haWwiLCJyZXNwb25zZSIsImNsb3NlIiwiZ2V0QXV0aG9yaXphdGlvbnMiLCJ1c2VyRW1haWwiLCJ0b0xvd2VyQ2FzZSIsImdldERhdGFGdW5jdGlvbkZpbGVMaXN0IiwiZ2V0R3JhcGhEYXRhIiwiZXhwaXJlS2V5IiwiQm9vbGVhbiIsInBsb3RHcmFwaEZ1bmN0aW9uIiwiZGF0YUZ1bmN0aW9uIiwiTk9ERV9FTlYiLCJyZXN1bHRzIiwiRnV0dXJlIiwiZnV0dXJlIiwid2FpdCIsImRzUmVzdWx0cyIsImRpc2FibGVPcGxvZyIsImRhdGFGdW5jdGlvbkVycm9yIiwiZ2V0R3JhcGhEYXRhQnlLZXkiLCJyZXN1bHRLZXkiLCJnZXRHcmFwaEZ1bmN0aW9uRmlsZUxpc3QiLCJnZXRMYXlvdXQiLCJnZXRNdkFydGlmYWN0c0J5S2V5IiwiZ2V0UGxvdFJlc3VsdCIsInBhZ2VJbmRleCIsInJLZXkiLCJwaSIsIm5waSIsImdldFJlbGVhc2VOb3RlcyIsImRGdXR1cmUiLCJmRGF0YSIsIlBXRCIsImZpbGUiLCJnZXRVc2VyQWRkcmVzcyIsImluc2VydENvbG9yIiwibmV3Q29sb3IiLCJpbnNlcnRBZnRlckluZGV4IiwiY29sb3JTY2hlbWUiLCJjb2xvcnMiLCJzcGxpY2UiLCJtdkJhdGNoIiwibXZiYXRjaCIsInBsb3RTcGVjRnVuY3Rpb24iLCJhcHAiLCJhcnRpZmFjdHMiLCJwbmciLCJ4bWwiLCJzcWwiLCJSIiwicG9pbnRzMSIsInBvaW50czIiLCJwbG90U3BlY0ZpbGVQYXRoIiwicG5nRmlsZVBhdGgiLCJzcWxGaWxlUGF0aCIsImxvZ0ZpbGVQYXRoIiwiZXJyRmlsZVBhdGgiLCJzY3JpcHRGaWxlUGF0aCIsImRhdGFGaWxlUGF0aCIsInBvaW50czFQYXRoIiwicG9pbnRzMlBhdGgiLCJtdlBsb3QiLCJ1bmxpbmtTeW5jIiwiYXJ0aWZhY3RQYXRocyIsImZpbGVzRXhpc3QiLCJ4bWxTcGVjRXhpc3RzIiwiZXhpc3RzU3luYyIsInBsb3RFeGlzdHMiLCJzY3JpcHRFeGlzdHMiLCJkYXRhRXhpc3RzIiwic3FsRXhpc3RzIiwibG9nRXhpc3RzIiwicGxvdFNwZWMiLCJtdkJhdGNoQ21kIiwiY3AiLCJvdXRwdXRGaWxlU3luYyIsImV4ZWNTeW5jIiwic3Rkb3V0Iiwic3RkZXJyIiwibWF0Y2giLCJzcWxvdXQiLCJyZWFkRnVuY3Rpb25GaWxlIiwicGF0aCIsInRvU3RyaW5nIiwicmVmcmVzaE1ldGFEYXRhIiwicmVtb3ZlQXV0aG9yaXphdGlvbiIsIiRwdWxsIiwibXVsdGkiLCJyZW1vdmVDb2xvciIsInJlbW92ZUluZGV4IiwicmVtb3ZlRGF0YWJhc2UiLCJyZXNldEFwcCIsImFwcFJlZiIsIm1ldGFEYXRhVGFibGVSZWNvcmRzIiwiYXBwTWRyIiwiYXBwVHlwZSIsImRlcF9lbnYiLCJQWVRIT05fUEFUSCIsIlJVTl9FTlYiLCJkZXBsb3ltZW50IiwiZGVwbG95bWVudFRleHQiLCJBc3NldHMiLCJnZXRUZXh0IiwiZGVwIiwiZGVwbG95bWVudF9lbnZpcm9ubWVudCIsImFwcHMiLCJhcHBWZXJzaW9uIiwidmVyc2lvbiIsImFwcFRpdGxlIiwidGl0bGUiLCJidWlsZERhdGUiLCJtZXRhRGF0YVRhYmxlcyIsIm1kdGkiLCJtZXRhRGF0YVJlZiIsImNvdW50IiwiZG9Sb2xlcyIsImRvQXV0aG9yaXphdGlvbiIsImRvQ3JlZGVudGlhbHMiLCJkb0NvbG9yU2NoZW1lIiwiZG9TZXR0aW5ncyIsInJlc3RvcmVGcm9tRmlsZSIsInlwZSIsIndyaXRlRmlsZSIsInJlc3RvcmVGcm9tUGFyYW1ldGVyRmlsZSIsIm8iLCJvbWl0IiwiZm9yRWFjaCIsInNhdmVMYXlvdXQiLCJsYXlvdXQiLCJjdXJ2ZU9wc1VwZGF0ZSIsInNhdmVTZXR0aW5ncyIsInNhdmVBcyIsInBlcm1pc3Npb24iLCJjcmVhdGVkIiwib3duZXIiLCJzYXZlZEF0Iiwic2F2ZWRCeSIsInNldENyZWRlbnRpYWxzIiwiY2xpZW50UmVmcmVzaFRva2VuIiwic2V0U2V0dGluZ3MiLCJsYWJlbFByZWZpeCIsImxpbmVXaWR0aCIsIm51bGxGaWxsU3RyaW5nIiwicmVzZXRGcm9tQ29kZSIsIkxhYmVsUHJlZml4IiwiVGl0bGUiLCJMaW5lV2lkdGgiLCJOdWxsRmlsbFN0cmluZyIsInRlc3RHZXRNZXRhRGF0YVRhYmxlVXBkYXRlcyIsInRlc3RHZXRUYWJsZXMiLCJxdWVyeVdyYXAiLCJ3cmFwIiwiY2FsbGJhY2siLCJjb25uZWN0aW9uIiwiY3JlYXRlQ29ubmVjdGlvbiIsInF1ZXJ5IiwiYSIsIlRhYmxlc19pbl9ydWNfdWFfc3VtczIiLCJ0ZXN0U2V0TWV0YURhdGFUYWJsZVVwZGF0ZXNMYXN0UmVmcmVzaGVkQmFjayIsIm10dSIsIm1hdHNNZXRob2RzIiwibWF0c1Bsb3RVdGlscyIsIm1hdHNQYXJhbVV0aWxzIiwiSW5mbyIsImdyYXBoUmVzdWx0IiwicGxvdCIsIl8xIiwiXzIiLCJfMyIsIl80IiwicHJvdG90eXBlIiwiY2FsbCIsIl81IiwiXzYiLCJfNyIsImdldFBsb3RSZXN1bHREYXRhIiwiU2Vzc2lvbiIsImdldCIsInBsb3RSZXN1bHREYXRhIiwic2V0UGxvdFJlc3VsdERhdGEiLCJzaG93U3Bpbm5lciIsInNldEVycm9yIiwic2V0IiwiaGlkZVNwaW5uZXIiLCJyZXNldFBsb3RSZXN1bHREYXRhIiwiZ2V0R3JhcGhSZXN1bHQiLCJzZXRHcmFwaFJlc3VsdCIsInJlc2V0R3JhcGhSZXN1bHQiLCJnZXRVc2VkTGFiZWxzIiwiZ2V0TmV4dEN1cnZlTGFiZWwiLCJzZXROZXh0Q3VydmVMYWJlbCIsInVzZWRMYWJlbHMiLCJmaWVsZHMiLCJwcmVmaXhMYWJlbHMiLCJsIiwibGFzdEluZGV4T2YiLCJSZWdFeHAiLCJsYXN0VXNlZExhYmVsIiwibGFzdCIsImxhc3RMYWJlbE51bWJlciIsIm1pbnVzUHJlZml4IiwicmVwbGFjZSIsInRyeU51bSIsInBhcnNlSW50IiwiaXNOYU4iLCJuZXdMYWJlbE51bWJlciIsIm5leHRDdXJ2ZUxhYmVsIiwic2V0TmV4dEN1cnZlQ29sb3IiLCJ1c2VkQ29sb3JzIiwibGFzdFVzZWRJbmRleCIsIm5leHRDdXJ2ZUNvbG9yIiwibmV3SW5kZXgiLCJyaW50IiwicmFuZG9tIiwiZ2V0TmV4dEN1cnZlQ29sb3IiLCJjbGVhclVzZWRMYWJlbCIsIm5ld1VzZWRMYWJlbHMiLCJyZWplY3QiLCJjbGVhclVzZWRDb2xvciIsImNvbG9yIiwibmV3VXNlZENvbG9ycyIsImMiLCJjbGVhckFsbFVzZWQiLCJzZXRVc2VkQ29sb3JzIiwiY3VydmVzIiwic2V0VXNlZExhYmVscyIsInNldFVzZWRDb2xvcnNBbmRMYWJlbHMiLCJyZXNldFNjYXR0ZXJBcHBseSIsImdldFBsb3RUeXBlIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImNoZWNrZWQiLCJhZGREaWZmcyIsIm5ld0N1cnZlcyIsImN1cnZlc0xlbmd0aCIsInNldEluZm8iLCJnZXRQbG90Rm9ybWF0IiwiYmFzZUluZGV4IiwibmV3Q3VydmUiLCIkIiwiZXh0ZW5kIiwiZGlmZkZyb20iLCJmaW5kV2hlcmUiLCJiYXNlX2luZGV4IiwicmVtb3ZlRGlmZnMiLCJjdXJ2ZSIsImNoZWNrRGlmZnMiLCJwbG90Rm9ybWF0Iiwic2hvd1RpbWVzZXJpZXNGYWNlIiwiZmFjZU9wdGlvbnMiLCJmYWNlU2VsZWN0b3JzIiwiZWxlbSIsImZpZHgiLCJzdHlsZSIsImRpc3BsYXkiLCJub3ciLCJzaG93UHJvZmlsZUZhY2UiLCJzaG93RGllT2ZmRmFjZSIsInBhcmFtIiwiZ2V0UGFyYW1ldGVyRm9yTmFtZSIsInNldFZhbHVlVGV4dEZvclBhcmFtTmFtZSIsImRlZmF1bHQiLCJzaG93VGhyZXNob2xkRmFjZSIsInNob3dWYWxpZFRpbWVGYWNlIiwic2hvd0RhaWx5TW9kZWxDeWNsZUZhY2UiLCJzaG93UmVsaWFiaWxpdHlGYWNlIiwic2hvd01hcEZhY2UiLCJzaG93SGlzdG9ncmFtRmFjZSIsInNob3dDb250b3VyRmFjZSIsImlzQ29udG91ciIsImlzQ29udG91ckRpZmYiLCJzaG93U2NhdHRlckZhY2UiLCJnZXRfZXJyIiwic1ZhbHMiLCJzU2VjcyIsInN1YlZhbHMiLCJzdWJTZWNzIiwic3VtX2QiLCJzdW0yX2QiLCJzZDIiLCJzcXJ0Iiwic2RfbGltaXQiLCJsYXN0X3NlY3MiLCJNSU5fVkFMVUUiLCJtaW5EZWx0YSIsIm1pblNlY3MiLCJtYXhfc2VjcyIsInNlY3MiLCJkZWx0YSIsImFicyIsImRhdGFfd2ciLCJuX2dhcHMiLCJzdW0iLCJzdW0yIiwibG9vcFRpbWUiLCJsYXN0U2Vjb25kIiwic2VjIiwibGFnIiwibl9pbl9sYWciLCJ0IiwiYmV0c3kiLCJtaW4iLCJtYXgiLCJtYXRzQ3VydmVVdGlscyIsInNldE5vRGF0YUxhYmVscyIsImRhdGFzZXQiLCJjdXJ2ZUlkIiwidmFsdWUiLCJkaXNhYmxlZCIsIm1hcmtlciIsInNldE5vRGF0YUxhYmVsc01hcCIsImxhdCIsIndpZHRoIiwic3F1YXJlV2lkdGhIZWlnaHQiLCJyZWN0YW5nbGVXaWR0aCIsImhlaWdodCIsInJlY3RhbmdsZUhlaWdodCIsInN0YW5kQWxvbmVXaWR0aCIsInZwdyIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsInN0YW5kQWxvbmVIZWlnaHQiLCJ2cGgiLCJjbGllbnRIZWlnaHQiLCJpbm5lckhlaWdodCIsInJlc2l6ZUdyYXBoIiwic2V0VGV4dFZpZXciLCJzZXRHcmFwaFZpZXciLCJzdGFuZEFsb25lU2V0R3JhcGhWaWV3Iiwic2V0RGVmYXVsdFZpZXciLCJkb3dubG9hZEZpbGUiLCJmaWxlVVJMIiwiQWN0aXZlWE9iamVjdCIsInNhdmUiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsInRhcmdldCIsInN1YnN0cmluZyIsImRvd25sb2FkIiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwic2VhcmNoIiwibG9jYXRpb24iLCJldnQiLCJNb3VzZUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIlVSTCIsIndlYmtpdFVSTCIsInJldm9rZU9iamVjdFVSTCIsImV4ZWNDb21tYW5kIiwiX3dpbmRvdyIsIm9wZW4iLCJtYXRzR3JhcGhVdGlscyIsInJlZnJlc2hQZWVyIiwiZXZlbnQiLCJwZWVyTmFtZSIsInRhcmdldFBhcmFtIiwidGFyZ2V0SWQiLCJ0YXJnZXRFbGVtIiwicmVmcmVzaE1hcEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJyZWZFbGVtZW50IiwicmVmcmVzaERlcGVuZGVudHMiLCJkZXBlbmRlbnROYW1lcyIsInNlbGVjdEFsbGJvb2wiLCJyZSIsImVsZW1lbnRzIiwib3B0aW9ucyIsIm11bHRpcGxlIiwiaTEiLCJzZWxlY3RlZCIsInByZXZpb3VzbHlfc2VsZWN0ZWQiLCJpMiIsInRleHQiLCJjaGVja0Rpc2FibGVPdGhlciIsImZpcnN0UmVuZGVyIiwiZGlzYWJsZU90aGVyRm9yIiwiY29udHJvbGxlZFNlbGVjdG9ycyIsImdldElucHV0RWxlbWVudEZvclBhcmFtTmFtZSIsInNlbGVjdGVkT3B0aW9ucyIsInNlbGVjdGVkVGV4dCIsImhpZGVPdGhlckZvciIsImluQXJyYXkiLCJjaGVja0hpZGVPdGhlciIsIm90aGVySW5wdXRFbGVtZW50Iiwic2VsZWN0b3JDb250cm9sRWxlbSIsInNlbGVjdGVkSW5kZXgiLCJzY3JvbGxJbnRvVmlldyIsIm1hdHNTZWxlY3RVdGlscyIsInBhcmFtTmFtZSIsImRpc2FibGVkT3B0aW9ucyIsImdldERpc2FibGVkT3B0aW9uc0ZvclBhcmFtTmFtZSIsIm9wdGlvbnNHcm91cHMiLCJvcHRpb25zTWFwIiwic3VwZXJpb3JOYW1lcyIsInN1cGVyaW9yRGltZW5zaW9uYWxpdHkiLCJzdXBlcmlvcnMiLCJzTmFtZXMiLCJzbiIsInN1cGVyaW9yRWxlbWVudCIsInNlbGVjdGVkU3VwZXJpb3JWYWx1ZSIsInNOYW1lSW5kZXgiLCJlbGVtcyIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJ2YWwiLCJicm90aGVycyIsIm15T3B0aW9ucyIsInNlbGVjdGVkU3VwZXJpb3JWYWx1ZXMiLCJmaXJzdFN1cGVyaW9yT3B0aW9ucyIsInRoZXNlU3VwZXJpb3JzIiwidGhlc2VTdXBlcmlvcnNJbmRleCIsInN1cGVyaW9yIiwibmV4dFN1cGVyaW9yT3B0aW9ucyIsImludGVyc2VjdGlvbiIsIm9wdGlvbnNHcm91cHNLZXlzIiwiayIsImNvbmNhdCIsInNvcnQiLCJvcHRpb25zQXNTdHJpbmciLCJmaXJzdEdyb3VwIiwiZEluZGV4IiwiZW1wdHkiLCJhcHBlbmQiLCJzZWxlY3RlZE9wdGlvbkluZGV4Iiwic3ZpVGV4dCIsInN2aSIsImdldENvbnRyb2xFbGVtZW50Rm9yUGFyYW1OYW1lIiwib2Zmc2V0UGFyZW50IiwiYmVsZW0iLCJiZWxlbVNlbGVjdGVkT3B0aW9ucyIsIk9wdGlvbiIsImlzQ2xpZW50Iiwic3Vic2NyaWJlIiwiQWNjb3VudHMiLCJ1aSIsImNvbmZpZyIsInJlcXVlc3RPZmZsaW5lVG9rZW4iLCJyZWYiLCJwYXRoQXJyYXkiLCJwcm90b2NvbCIsImhvc3Rwb3J0IiwiaG9zdE5hbWUiLCJtYXRzUmVmIiwiaGVscFJlZiIsImVuZHNXaXRoIiwibWF0c3JlZiIsImFwcHJlZiIsImhlbHByZWYiLCJjb2xsZWN0aW9ucyIsIkZsb3dSb3V0ZXIiLCJhY3Rpb24iLCJyZW5kZXIiLCJhcmVPYmplY3RzRXF1YWwiLCJhcnJheUNvbnRhaW5zQXJyYXkiLCJzdXBlckFycmF5Iiwic3ViQXJyYXkiLCJiIiwiaiIsImFycmF5Q29udGFpbnNTdWJBcnJheSIsImN1cnJlbnQiLCJhcnJheXNFcXVhbCIsImFycmF5VW5pcXVlIiwiYXJyIiwiaW5jbHVkZXMiLCJmaW5kQXJyYXlJblN1YkFycmF5Iiwib2JqZWN0Q29udGFpbnNPYmplY3QiLCJzdXBlck9iamVjdCIsInN1Yk9iamVjdCIsInN1cGVyT2JqZWN0S2V5cyIsImN1cnJlbnRPYmplY3QiLCJhdmciLCJzcXVhcmVEaWZmcyIsImRpZmYiLCJhdmdTcXVhcmVEaWZmIiwic3RkRGV2IiwiZGF0ZUNvbnZlcnQiLCJkU3RyIiwiZGF0ZSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsInlyIiwiZGF5IiwibW9udGgiLCJob3VyIiwibWludXRlIiwiZGF0ZVBhcnRzIiwiZGF0ZUFycmF5IiwidGltZUFycmF5IiwiZ2V0RGF0ZVJhbmdlIiwiZGF0ZXMiLCJmcm9tRGF0ZVN0ciIsImZyb21EYXRlIiwidG9EYXRlU3RyIiwidG9EYXRlIiwiZnJvbVNlY3MiLCJzZWNzQ29udmVydCIsInRvU2VjcyIsImZyb21TZWNvbmRzIiwidG9TZWNvbmRzIiwiZ2V0VGltZSIsIm15X2RhdGUiLCJVVEMiLCJkYXRlX2luX3NlY3MiLCJkZXBsb3ltZW50Um9sZXMiLCJzZXR0aW5nc0lkIiwiZ2V0UGxvdFBhcmFtc0Zyb21TdGFjayIsImNhcHR1cmVTdGFja1RyYWNlIiwiYXJndW1lbnRzIiwiY2FsbGVlIiwic3RhY2siLCJzdGFja0VsZW1zIiwic0VsZW0iLCJ0cmltIiwic3RhcnRzV2l0aCIsImRhdGFGdW5jdGlvbk5hbWUiLCJub0pveSIsInNMZXZzIiwiYXV0b2NvcnJfbGltaXQiLCJoYXNMZXZlbHMiLCJvdXRsaWVyUUNQYXJhbSIsInN1YkxldnMiLCJxYUNvcnJlY3RlZCIsImxhc3RQcmVzc3VyZSIsIm5fcHJlc3N1cmVzIiwibGFnMV90IiwibGFnMV9wIiwicjFfdCIsInIxX3AiLCJuX2RlbHRhcyIsImxldiIsImxhZ19ieV9yIiwibGFnMV9tYXgiLCJyX3N1bSIsIm5fciIsInNldEhpc3RvZ3JhbVBhcmFtZXRlcnMiLCJ5QXhpc0Zvcm1hdCIsImJpblR5cGUiLCJiaW5OdW0iLCJiaW5TdGFydCIsImJpblN0cmlkZSIsInBpdm90VmFsIiwiYmluQm91bmRzIiwiaXRlbSIsImNhbGN1bGF0ZUhpc3RvZ3JhbUJpbnMiLCJjdXJ2ZVN1YlN0YXRzIiwiY3VydmVTdWJTZWNzIiwiYmluUGFyYW1zIiwiYmluU3RhdHMiLCJiaW5VcEJvdW5kcyIsImJpbkxvd0JvdW5kcyIsImJpbk1lYW5zIiwiZ2xvYmFsU3RhdHMiLCJmdWxsTG93Qm91bmQiLCJmdWxsVXBCb3VuZCIsImZ1bGxSYW5nZSIsImJpbkludGVydmFsIiwiYl9pZHgiLCJjbG9zZXN0Qm91bmRUb1Bpdm90IiwiYmluTGFiZWxzIiwibG93U2RGcm9tTWVhbiIsInVwU2RGcm9tTWVhbiIsInRvRml4ZWQiLCJwcmVzY3JpYmVIaXN0b2dyYW1CaW5zIiwiYmluSW50ZXJ2YWxTdW0iLCJiaW5JbnRlcnZhbEF2ZXJhZ2UiLCJzb3J0SGlzdG9ncmFtQmlucyIsImN1cnZlU3ViTGV2cyIsIm1hc3RlckJpblN0YXRzIiwiYmluU3ViU3RhdHMiLCJiaW5TdWJTZWNzIiwiYmluU3ViTGV2cyIsImRfaWR4IiwieW1pbiIsInltYXgiLCJ4bWluIiwieG1heCIsImdldERpZmZDb250b3VyQ3VydmVQYXJhbXMiLCJjdXJ2ZUtleXMiLCJjdXJyS2V5IiwiY2tpZHgiLCJzb3J0RnVuY3Rpb24iLCJnZXRNb2RlbENhZGVuY2UiLCJkYXRhU291cmNlIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImN5Y2xlcyIsImN5Y2xlc19yYXciLCJjeWNsZV9zZWNvbmRzIiwiY3ljbGVzX2tleXMiLCJuZXdUaW1lIiwiY2hvc2VuU3RhcnRUaW1lIiwiY2hvc2VuRW5kVGltZSIsImNob3NlblN0YXJ0SWR4IiwiY2hvc2VuRW5kSWR4IiwiZm91bmRTdGFydCIsImZvdW5kRW5kIiwic3RhcnRDeWNsZXMiLCJlbmRDeWNsZXMiLCJ1bmlvbiIsIm1pZGRsZUN5Y2xlcyIsImN1cnJDeWNsZXMiLCJnZXRUaW1lSW50ZXJ2YWwiLCJhdlRpbWUiLCJ0aW1lX2ludGVydmFsIiwiZm9yZUNhc3RPZmZzZXQiLCJkYXlJbk1pbGxpU2Vjb25kcyIsIm1pbkN5Y2xlVGltZSIsInRoaXNDYWRlbmNlIiwidGhpc0NhZGVuY2VJZHgiLCJuZXh0Q2FkZW5jZUlkeCIsInN0YXRlbWVudCIsInF1ZXJ5REJUaW1lU2VyaWVzIiwiZm9yZWNhc3RPZmZzZXQiLCJhdmVyYWdlU3RyIiwidmFsaWRUaW1lcyIsImZvcmNlUmVndWxhckNhZGVuY2UiLCJjb21wbGV0ZW5lc3NRQ1BhcmFtIiwidnRDeWNsZXMiLCJyZWd1bGFyIiwiZXJyb3JfeCIsImVycm9yX3kiLCJOMCIsInBhcnNlZERhdGEiLCJwYXJzZVF1ZXJ5RGF0YVRpbWVTZXJpZXMiLCJxdWVyeURCU3BlY2lhbHR5Q3VydmUiLCJwYXJzZVF1ZXJ5RGF0YVNwZWNpYWx0eUN1cnZlIiwicGFyc2VRdWVyeURhdGFIaXN0b2dyYW0iLCJxdWVyeU1hcERCIiwidmFyaWFibGUiLCJ2YXJVbml0cyIsInNpdGVNYXAiLCJsb24iLCJkQmx1ZSIsImRCbGFjayIsImRSZWQiLCJwRnV0dXJlIiwicm93SW5kZXgiLCJzdGFfbmFtZSIsIm1vZGVsX29iX2RpZmYiLCJ0b29sdGlwcyIsInRoaXNTaXRlIiwib2JqIiwicG9pbnQiLCJ0ZXh0TWFya2VyIiwiZGF0YUJsdWUiLCJkYXRhQmxhY2siLCJkYXRhUmVkIiwicXVlcnlEQkNvbnRvdXIiLCJ6Iiwiem1pbiIsInptYXgiLCJwYXJzZVF1ZXJ5RGF0YUNvbnRvdXIiLCJjdXJ2ZVRpbWUiLCJjdXJ2ZVN0YXRzIiwiYXZ0aW1lIiwiYXZTZWNvbmRzIiwic3RhdCIsInRpbWVfZGlmZiIsInN1Yl92YWx1ZXMiLCJzdWJfc2VjcyIsInN1Yl9sZXZzIiwic3ViX2RhdGEiLCJjdXJyX3N1Yl9kYXRhIiwic2RfaWR4IiwiTmFOIiwiTjBfbWF4IiwiTl90aW1lc19tYXgiLCJ0aGlzX04wIiwidGhpc19OX3RpbWVzIiwiZmlsdGVyZWR4IiwiZmlsdGVyZWR5IiwiY3VydmVJbmRlcGVuZGVudFZhcnMiLCJpbmRlcGVuZGVudFZhciIsImhyX29mX2RheSIsImF2VmFsIiwic3ViX3N0YXRzIiwiY3ljbGVzX21pc3NpbmciLCJtaXNzaW5nSWR4IiwiZFNvcnRlZCIsImRpZHgiLCJjdXJ2ZVN1YlN0YXRzUmF3IiwiY3VydmVTdWJTZWNzUmF3IiwiY3VydmVTdWJMZXZzUmF3IiwiYXBwbHkiLCJjdXJ2ZVN0YXRMb29rdXAiLCJjdXJ2ZU5Mb29rdXAiLCJyb3dYVmFsIiwieFZhbCIsInJvd1lWYWwiLCJ5VmFsIiwic3RhdEtleSIsIm1pbl9zZWNzIiwiY3VyclgiLCJjdXJyWSIsImN1cnJTdGF0IiwiY3Vyck4iLCJjdXJyU3RhdEtleSIsImN1cnJZU3RhdEFycmF5IiwiY3VycllOQXJyYXkiLCJuUG9pbnRzIiwiZmlsdGVyZWR6IiwiZmlsdGVyZWRNaW5EYXRlIiwiZmlsdGVyZWRNYXhEYXRlIiwiZ2V0TGFyZ2VJbnRlcnZhbEN1cnZlRGF0YSIsImluZGVwZW5kZW50VmFyTmFtZSIsImRhdGFNYXhJbnRlcnZhbCIsImxhcmdlSW50ZXJ2YWxDdXJ2ZURhdGEiLCJnZXREYXRhRm9yRGlmZkN1cnZlIiwic3RhdFZhck5hbWUiLCJtaW51ZW5kRGF0YSIsInN1YnRyYWhlbmREYXRhIiwic3VidHJhaGVuZEluZGV4IiwibWludWVuZEluZGV4IiwibGFyZ2VJbnRlcnZhbEN1cnZlSW5kZXgiLCJzdWJ0cmFoZW5kSW5kZXBlbmRlbnRWYXIiLCJtaW51ZW5kSW5kZXBlbmRlbnRWYXIiLCJsYXJnZUludGVydmFsSW5kZXBlbmRlbnRWYXIiLCJtaW51ZW5kQ2hhbmdlZCIsInN1YnRyYWhlbmRDaGFuZ2VkIiwiZGlmZlZhbHVlIiwidGVtcFN1YlZhbHNBcnJheSIsInRlbXBTdWJTZWNzQXJyYXkiLCJ0ZW1wU3ViTGV2c0FycmF5IiwibWludWVuZERhdGFTdWJWYWx1ZXMiLCJtaW51ZW5kRGF0YVN1YlNlY29uZHMiLCJtaW51ZW5kRGF0YVN1YkxldmVscyIsInN1YnRyYWhlbmREYXRhU3ViVmFsdWVzIiwic3VidHJhaGVuZERhdGFTdWJTZWNvbmRzIiwic3VidHJhaGVuZERhdGFTdWJMZXZlbHMiLCJtdmFsSWR4Iiwic3ZhbElkeCIsImJpbkxhYmVsIiwiZ2V0RGF0YUZvckRpZmZDb250b3VyIiwiZGlmZkRhdGFzZXQiLCJ4QXhpc0tleSIsInlBeGlzS2V5IiwidmlzaWJsZSIsIm1pbnVlbmRZSW5kZXgiLCJzdWJ0cmFoZW5kWUluZGV4IiwiZGlmZkRhdGFZSW5kZXgiLCJkaWZmRGF0YVkiLCJtaW51ZW5kWSIsInN1YnRyYWhlbmRZIiwibWludWVuZFhJbmRleCIsInN1YnRyYWhlbmRYSW5kZXgiLCJkaWZmRGF0YVhJbmRleCIsImRpZmZEYXRhWCIsIm1pbnVlbmRYIiwic3VidHJhaGVuZFgiLCJkaWZmTnVtYmVyIiwiZGlmZk1pbkRhdGUiLCJkaWZmTWF4RGF0ZSIsInRvUHJlY2lzaW9uIiwiY29sb3JiYXIiLCJyZXZlcnNlc2NhbGUiLCJjb250b3VycyIsIm1heFoiLCJtYXRzRGF0YURpZmZVdGlscyIsImdldE1hdGNoZWREYXRhU2V0Iiwic3ViVmFsdWVzIiwibmV3U3ViU2VjcyIsIm5ld1N1YlZhbHVlcyIsImluZGVwZW5kZW50VmFyR3JvdXBzIiwiaW5kZXBlbmRlbnRWYXJIYXNQb2ludCIsImN1cnJJbmRlcGVuZGVudFZhciIsImN1cnZlSW5kZXgiLCJmaSIsIm1hdGNoaW5nSW5kZXBlbmRlbnRWYXJzIiwibWF0Y2hpbmdJbmRlcGVuZGVudEhhc1BvaW50Iiwic3ViU2VjSW50ZXJzZWN0aW9uIiwiY3VyclN1YlNlY0ludGVyc2VjdGlvbiIsImRhdGFMZW5ndGgiLCJuZXdWYWwiLCJuZXdTZWMiLCJnZXRNYXRjaGVkRGF0YVNldFdpdGhMZXZlbHMiLCJuZXdTdWJMZXZzIiwic3ViSW50ZXJzZWN0aW9ucyIsImN1cnJTdWJJbnRlcnNlY3Rpb25zIiwidGVtcFN1YkludGVyc2VjdGlvbnMiLCJ0ZW1wUGFpciIsIm5ld0xldiIsImdldE1hdGNoZWREYXRhU2V0SGlzdG9ncmFtIiwic3ViU3RhdHNSYXciLCJzdWJTZWNzUmF3Iiwic3ViU3RhdHMiLCJuZXdTdWJTdGF0cyIsIm5ld0N1cnZlRGF0YSIsIm5ld1N0YXQiLCJuZXdDdXJ2ZURhdGFLZXlzIiwiZ2V0TWF0Y2hlZERhdGFTZXRIaXN0b2dyYW1XaXRoTGV2ZWxzIiwic3ViTGV2c1JhdyIsIm1hdHNEYXRhTWF0Y2hVdGlscyIsImdldEhvcml6b250YWxWYWx1ZUxpbmUiLCJ5VmFsdWUiLCJjTGFiZWwiLCJ2YWx1ZUxpbmUiLCJnZXRWZXJ0aWNhbFZhbHVlTGluZSIsInhWYWx1ZSIsImdldExpbmVhclZhbHVlTGluZSIsImdlbmVyYXRlU2VyaWVzQ3VydmVPcHRpb25zIiwiYXhpc01hcCIsImRhdGFTZXJpZXMiLCJheGlzS2V5IiwiYXhpc0xhYmVsIiwiYXhpc051bWJlciIsImVycm9yX3lfdGVtcCIsInRoaWNrbmVzcyIsImN1cnZlT3B0aW9ucyIsInhheGlzIiwieWF4aXMiLCJhbm5vdGF0ZUNvbG9yIiwibW9kZSIsInN5bWJvbCIsInNpemUiLCJsaW5lIiwiZGFzaCIsImdlbmVyYXRlUHJvZmlsZUN1cnZlT3B0aW9ucyIsImRhdGFQcm9maWxlIiwiZXJyb3JfeF90ZW1wIiwiZ2VuZXJhdGVSZWxpYWJpbGl0eUN1cnZlT3B0aW9ucyIsImdlbmVyYXRlQmFyQ2hhcnRDdXJ2ZU9wdGlvbnMiLCJkYXRhQmFycyIsImdlbmVyYXRlTWFwQ3VydmVPcHRpb25zIiwibWFya2VyU2l6ZXMiLCJjZWlsIiwib3BhY2l0eSIsImdlbmVyYXRlTWFwQ29sb3JUZXh0T3B0aW9ucyIsInRleHRmb250IiwiZmFtaWx5IiwiaG92ZXJpbmZvIiwiZ2VuZXJhdGVDb250b3VyQ3VydmVPcHRpb25zIiwidW5pdEtleSIsImF1dG9jb250b3VyIiwibmNvbnRvdXJzIiwic2hvd2xhYmVscyIsImNvbG9yc2NhbGUiLCJ0aXRsZXNpZGUiLCJ0aXRsZWZvbnQiLCJtYXRzRGF0YUN1cnZlT3BzVXRpbHMiLCJnZW5lcmF0ZVNlcmllc1Bsb3RPcHRpb25zIiwiZXJyb3JNYXgiLCJtYXJnaW4iLCJwYWQiLCJ6ZXJvbGluZSIsImhvdmVybW9kZSIsImhvdmVybGFiZWwiLCJzaG93bGVnZW5kIiwidGlja2ZvbnQiLCJheGlzQW5jaG9yIiwiYXhpc1NpZGUiLCJheGlzUG9zaXRpb24iLCJ5QXhpc051bWJlciIsImF4aXNJZHgiLCJ5UGFkIiwiYXhpc09iamVjdEtleSIsInJhbmdlIiwiYW5jaG9yIiwib3ZlcmxheWluZyIsInNpZGUiLCJwb3NpdGlvbiIsInhQYWQiLCJnZW5lcmF0ZVByb2ZpbGVQbG90T3B0aW9ucyIsInhBeGlzTnVtYmVyIiwidGlja1ZhbHMiLCJ0aWNrVGV4dCIsInRpY2t2YWxzIiwidGlja3RleHQiLCJhdXRvcmFuZ2UiLCJnZW5lcmF0ZURpZW9mZlBsb3RPcHRpb25zIiwiZ2VuZXJhdGVUaHJlc2hvbGRQbG90T3B0aW9ucyIsImdlbmVyYXRlVmFsaWRUaW1lUGxvdE9wdGlvbnMiLCJnZW5lcmF0ZVJlbGlhYmlsaXR5UGxvdE9wdGlvbnMiLCJwZXJmZWN0TGluZSIsImdlbmVyYXRlTWFwUGxvdE9wdGlvbnMiLCJhdXRvc2l6ZSIsIm1hcGJveCIsImJlYXJpbmciLCJjZW50ZXIiLCJwaXRjaCIsInpvb20iLCJhY2Nlc3N0b2tlbiIsImdlbmVyYXRlSGlzdG9ncmFtUGxvdE9wdGlvbnMiLCJwbG90QmlucyIsImJhcmdhcCIsImJhcm1vZGUiLCJnZW5lcmF0ZUNvbnRvdXJQbG90T3B0aW9ucyIsIm1hdHNEYXRhUGxvdE9wc1V0aWxzIiwicHJvY2Vzc0RhdGFYWUN1cnZlIiwiYXBwUGFyYW1zIiwiY3VydmVJbmZvUGFyYW1zIiwiYm9va2tlZXBpbmdQYXJhbXMiLCJheGlzTGltaXRSZXByb2Nlc3NlZCIsInN0YXRpc3RpY1NlbGVjdCIsImluZFZhcnMiLCJtZWFucyIsInJhd1N0YXQiLCJlcnJvclJlc3VsdCIsImVycm9yQmFyIiwiZmhyIiwidXRjQ3ljbGVTdGFydHMiLCJmaWx0ZXJlZE1lYW5zIiwibWlueSIsIm1heHkiLCJtaW54IiwibWF4eCIsInplcm9MaW5lIiwiaWRlYWxWYWx1ZUxpbmUiLCJpZGVhbExhYmVsIiwiaXZJZHgiLCJpZGVhbFZhbHVlcyIsInJlc3VsdE9wdGlvbnMiLCJ0b3RhbFByb2Nlc3NpbmdGaW5pc2giLCJkYXRhUmVxdWVzdHMiLCJiZWdpbiIsInRvdGFsUHJvY2Vzc2luZ1N0YXJ0IiwiZmluaXNoIiwiZHVyYXRpb24iLCJhc1NlY29uZHMiLCJxdWVyaWVzIiwicHJvY2Vzc0RhdGFQcm9maWxlIiwibGV2ZWxzIiwicmV2ZXJzZSIsInByb2Nlc3NEYXRhUmVsaWFiaWxpdHkiLCJza2lsbG1pbiIsInNraWxsbWF4Iiwibm9Ta2lsbExpbmUiLCJ4Q2xpbW9MaW5lIiwieUNsaW1vTGluZSIsInByb2Nlc3NEYXRhSGlzdG9ncmFtIiwiYWxsUmV0dXJuZWRTdWJTdGF0cyIsImFsbFJldHVybmVkU3ViU2VjcyIsImFsbFJldHVybmVkU3ViTGV2cyIsImN1cnZlc0xlbmd0aFNvRmFyIiwic29ydGVkRGF0YSIsInBvc3RRdWVyeVN0YXJ0TW9tZW50IiwiZGF0YUZvdW5kRm9yQ3VydmUiLCJhbHJlYWR5TWF0Y2hlZCIsImRpZmZSZXN1bHQiLCJjT3B0aW9ucyIsInBvc3RRdWVyeUZpbmlzaE1vbWVudCIsInByb2Nlc3NEYXRhQ29udG91ciIsImN1cnJUZXh0IiwiY3VycllUZXh0QXJyYXkiLCJtYXRzRGF0YVByb2Nlc3NVdGlscyIsInN0YXRNdlRyYW5zbGF0aW9uIiwieG1sQnVpbGRlciIsIl9wYWQiLCJudW0iLCJzIiwiX3RpdGxlIiwic29tZUVycm9yIiwiX3Bsb3RUZXh0IiwiX2NvbXBvbmVudFRvSGV4IiwiaGV4IiwiX3JnYlRvSGV4IiwiY1BhcnRzIiwiZyIsIl9nZXRVbmlxRGF0ZXMiLCJtb2RlbCIsInJlZ2lvbiIsImZvcmVjYXN0TGVuZ3RoIiwicmVnaW9uc0NsYXVzZSIsInJlZ2lvbnMiLCJqb2luIiwiZm9yZWNhc3RMZW5ndGhzQ2xhdXNlIiwiZm9yZWNhc3RWYWx1ZU1hcCIsInZhbHVlc01hcCIsImZvcmVjYXN0TGVuZ3RocyIsImZsIiwibWV0YWRhdGFQb29sIiwiZHN0ck1vbWVudCIsImRzdHIiLCJ2YWxpZCIsIm1vbWVudFNkaUhvdXIiLCJ2dGkiLCJ0aGlzdnQiLCJfZ2V0U29ydGVkRGF0ZXNGb3JJbmRlcFJhbmdlIiwic29ydGVkRGF0ZXMiLCJfZ2V0U29ydGVkSG91cnNGb3JJbmRlcFJhbmdlIiwiaG91cnMiLCJTZXQiLCJhZGQiLCJfZ2V0U29ydGVkRGF0ZXNGb3JEZXBSYW5nZSIsImFkZEluZGVwVW5ncm91cGVkRGF0ZUVsZW1lbnRzQmV0d2VlbiIsInNkaSIsImVsZSIsImFkZERhdGFiYXNlRWxlbWVudCIsImRhdGFiYXNlcyIsImRhdGFiYXNlc1N0ciIsImFkZEZvbGRlcnMiLCJNVl9SU0NSSVBUIiwiZm9sZGVycyIsInN0YXJ0UGxvdFNwZWMiLCJjcmVhdGUiLCJlbmNvZGluZyIsInN0YW5kYWxvbmUiLCJzdW1Qb29sIiwiY29ubmVjdGlvbkNvbmZpZyIsInBvcnQiLCJtYW5hZ2VtZW50X3N5c3RlbSIsIk1WX0RCX01BTkFHRU1FTlRfU1lTVEVNIiwiYWRkUGxvdENpIiwiY0xpc3QiLCJjTGlzdFN0ciIsImFkZFNob3dTaWduaWYiLCJhZGRQbG90RGlzcCIsImFkZENvbG9ycyIsImNoIiwiYWRkUGNoIiwiYWRkVHlwZSIsImFkZEx0eSIsImFkZEx3ZCIsImFkZENvblNlcmllcyIsImFkZE9yZGVyU2VyaWVzIiwiYWRkTGVnZW5kIiwiYWRkU2VyaWVzIiwiZGVwZW5kZW50QXhlcyIsImhpZGRlbkN1cnZlcyIsInNWYXJzIiwic2VyaWVzQXhpc01hcCIsInNlcmllcyIsIm1vZGVscyIsInZ4X21hc2tzIiwiZmNzdF9sZWFkcyIsImZjc3RfbGV2bHMiLCJzZXJpZXNFbGVtIiwiYXhpcyIsImluaXRIb3VycyIsInNlcmllc0VsZW1lbnRzIiwic2VyaWVzRWxlbWVudFZhbHVlcyIsImRhY2kiLCJzVmFyIiwic1ZhbHVlcyIsInBhZGRlZFYiLCJzVmFsdWVzU3RyIiwidGhpc1ZhciIsImhhcyIsInNFbGVtZW50S2V5cyIsInNlaSIsInNlVmFyIiwic3ZhcnMiLCJnZXREZXBlbmRlbnRBeGlzIiwieWF4ZXNEZWZhdWx0IiwiZGVwZW5kZW50QXhlc1ZhcmlhYmxlcyIsInlheGVzIiwiYWRkRGVwcyIsImRlcHMiLCJkZXBLZXkiLCJkZXBBeGlzIiwic3ViRGVwIiwidmFyaWFibGVTdGF0aXN0aWNQYWlycyIsInZhcnMiLCJkZXBFbGVtIiwiYWRkQW5vbWFseWNvcnJEZXBzIiwidmFyaWFibGVzIiwiX2FkZFNlcmllc0xhYmVscyIsInkxdmFycyIsInkxaSIsInkydmFycyIsInkyaSIsImFkZFRlbXBsYXRlIiwidGVtcGxhdGVTdHIiLCJhZGRJbmRlcERhdGVzIiwiaW5kZXAiLCJhZGRJbmRlcExldmVscyIsImx2bFNldCIsImxldmVsVmFscyIsImx2bHMiLCJsaSIsImF0dCIsImFkZEluZGVwVmFsaWRIb3VycyIsImhpIiwiYWRkSW5kZXBGb3JlY2FzdEhvdXJzIiwibGVhZFNldCIsImxlYWRzIiwiYWRkVG1wbCIsInRtcGwiLCJwbG90QWN0aW9uIiwiYWRkUGxvdEZpeCIsImFkZFBsb3RDb25kIiwiYWRkQ2FsY1N0YXQiLCJzdGF0VHlwZSIsImFkZFBsb3RTdGF0IiwiYWRkUGxvdENtZCIsImFkZFkxTGltIiwiYWRkWTFCdWZyIiwiYWRkWTJMaW0iLCJhZGRNaXNjZWxsYW5lb3VzIiwiZW5kUGxvdFNwZWMiLCJwcmV0dHkiLCJtYXRzUGxvdFNwZWNVdGlscyIsInB1Ymxpc2giLCJyZWFkeSIsIlJlc3VsdHMiLCJsaWZlIiwiZXhwaXJlIiwiZ2F1c3NpYW5FbGltaW5hdGlvbiIsIm1heHJvdyIsInRtcCIsIm1ldGhvZHMiLCJncmFkaWVudCIsImludGVyY2VwdCIsImxlbiIsImNvb3JkaW5hdGUiLCJzdHJpbmciLCJlcXVhdGlvbiIsInBvaW50cyIsImRlbm9taW5hdG9yIiwiQSIsInBvdyIsIkUiLCJCIiwicG9seW5vbWlhbCIsIm9yZGVyIiwibGhzIiwicmhzIiwiYW5zd2VyIiwidyIsImxhc3R2YWx1ZSIsInJlZ3Jlc3Npb24iLCJtZXRob2QiLCJnZXRDb250cm9sQnV0dG9uSWRGb3JQYXJhbU5hbWUiLCJwbmFtZSIsImdldFZhbHVlRWxlbWVudEZvclBhcmFtTmFtZSIsImdldFZhbHVlSWRGb3JQYXJhbU5hbWUiLCJnZXRWYWx1ZUZvclBhcmFtTmFtZSIsInRleHRDb250ZW50Iiwic2VsZWN0aW9uIiwiZ2V0SW5wdXRJZEZvclBhcmFtTmFtZSIsInNldElucHV0Rm9yUGFyYW1OYW1lIiwiaWRTZWxlY3RvclN0ciIsImlkU2VsZWN0b3IiLCJwcm9wIiwiZ2V0RWxlbWVudFZhbHVlcyIsImN1cnZlUGFyYW1zIiwic2NhdHRlclBhcmFtcyIsInNlbGVjdG9yIiwiZWwiLCJpZFNlbGVjdCIsImF4aXNTdHIiLCJleHBhbmRQYXJhbXMiLCJkYXRhRWxlbSIsImNvbGxhcHNlUGFyYW1zIiwiY29sbGFwc2VQYXJhbSIsInR5cGVTb3J0Iiwic2V0RGVmYXVsdEZvclBhcmFtTmFtZSIsImRlZmF1bHRWYWx1ZSIsImdldERlZmF1bHREYXRlUmFuZ2UiLCJkYXRlUGFyYW0iLCJzdGFydEluaXQiLCJzdG9wSW5pdCIsInN0b3BEYXRlIiwiZ2V0TWluTWF4RGF0ZXMiLCJtaW5Nb21lbnQiLCJtYXhNb21lbnQiLCJzdWJ0cmFjdCIsInNldEFsbFBhcmFtc1RvRGVmYXVsdCIsIm5vbkRlcGVuZGVudHMiLCJyZXNldE1hcEV2ZW50IiwiaXNJbnB1dEVsZW1lbnRWaXNpYmxlIiwiaW5wdXRFbGVtZW50IiwiaXMiLCJpc1BhcmFtVmlzaWJsZSIsInBhcmFtUmVmIiwiaXNDb250cm9sQnV0dG9uVmlzaWJsZSIsInNldElucHV0VmFsdWVGb3JQYXJhbUFuZHRyaWdnZXJDaGFuZ2UiLCJ0cmlnZ2VyIiwiZ2V0T3B0aW9uc01hcEZvclBhcmFtIiwiZ2V0T3B0aW9uc0ZvclBhcmFtIiwiZ2V0QXBwTmFtZSIsImdldEN1cnZlSXRlbVZhbHVlRm9yUGFyYW1OYW1lIiwiY3VydmVOdW1iZXIiLCJ2aXNpYmlsaXR5Q29udHJvbGxlckZvclBhcmFtIiwiZm91bmQiLCJzb21lIiwicEtleXMiLCJnZXRBeGlzVGV4dCIsInNjYXR0ZXJBeGlzVGV4dFBhdHRlcm4iLCJ0ZXh0UGF0dGVybiIsInBOYW1lIiwiZGVsaW1pdGVyIiwiZ2V0Q3VydmVUZXh0IiwiY3VydmVUZXh0UGF0dGVybiIsImJ1dHRvbnMiLCJnZXRFbGVtZW50c0J5TmFtZSIsInBsb3RGb3JtYXRQYXJhbSIsImdldEJlc3RGaXQiLCJjb250YWluc1BvaW50IiwicG9pbnRBcnJheSIsInBMYXQiLCJwTG9uIiwiZGlzYWJsZUFjdGlvbkJ1dHRvbnMiLCJlbmFibGVBY3Rpb25CdXR0b25zIiwiaXNOdW0iLCJhcmdzIiwicGFyc2VGbG9hdCIsInZhcmlhbmNlIiwibWVkaWFuIiwibWF0c01hdGhVdGlscyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQUEsTUFBTSxDQUFDQyxJQUFQLENBQVksb0NBQVo7QUFBa0RELE1BQU0sQ0FBQ0MsSUFBUCxDQUFZLGtDQUFaO0FBQWdELElBQUlDLG9CQUFKO0FBQXlCRixNQUFNLENBQUNDLElBQVAsQ0FBWSw4QkFBWixFQUEyQztBQUFDQyxzQkFBb0IsQ0FBQ0MsQ0FBRCxFQUFHO0FBQUNELHdCQUFvQixHQUFDQyxDQUFyQjtBQUF1Qjs7QUFBaEQsQ0FBM0MsRUFBNkYsQ0FBN0Y7O0FBVzNILElBQUlDLGFBQWEsR0FBRyxZQUFZO0FBQzVCOzs7O0FBSUEsTUFBSUMsTUFBTSxDQUFDQyxRQUFYLEVBQXFCO0FBQ2pCLFFBQUlDLEVBQUUsR0FBR0MsR0FBRyxDQUFDQyxPQUFKLENBQVksSUFBWixDQUFUOztBQUNBLFFBQUlDLFFBQVEsR0FBR0gsRUFBRSxDQUFDRyxRQUFILEVBQWY7QUFDQSxRQUFJQyxHQUFHLEdBQUcsRUFBVjtB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QixHQUFMLENBQVMsWUFBVCxFQUF1QixJQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsVUFBVCxFQUFxQixJQUFyQjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixJQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsS0FBVCxFQUFnQixZQUFoQjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsS0FBVCxFQUFnQixVQUFoQjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsS0FBVCxFQUFnQixHQUFoQjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsY0FBVCxFQUF5QixHQUF6QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixLQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsY0FBVCxFQUF5QixJQUF6QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixLQUF4QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsY0FBVCxFQUF5QixHQUF6QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixPQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixLQUF4QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixHQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixHQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixHQUF4QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsV0FBVCxFQUFzQixHQUF0QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixHQUF4QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixLQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsY0FBVCxFQUF5QixHQUF6QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixLQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixLQUF4QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixHQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixHQUF4QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsV0FBVCxFQUFzQixHQUF0QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixJQUF4QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixLQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsVUFBVCxFQUFxQixHQUFyQjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsVUFBVCxFQUFxQixTQUFyQjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsVUFBVCxFQUFxQixHQUFyQjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsUUFBVCxFQUFtQixPQUFuQjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsZUFBVCxFQUEwQixHQUExQjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixHQUF4QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsY0FBVCxFQUF5QixLQUF6QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixLQUF4QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsWUFBVCxFQUF1QixLQUF2QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsY0FBVCxFQUF5QixNQUF6QjtBQUNBM3pCLE1BQUksQ0FBQzJ6QixHQUFMLENBQVMsYUFBVCxFQUF3QixL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QUcsQ0FBQzdDLElBQUosQ0FBUyxVQUFTeFEsQ0FBVCxFQUFXK1MsQ0FBWCxFQUFhO0FBQUMsV0FBTy9TLENBQUMsR0FBQytTLENBQVQ7QUFBVyxHQUFsQztBQUVBLE1BQUl5dUIsTUFBTSxHQUFHLENBQWI7O0FBRUEsTUFBSW51QixHQUFHLENBQUNqc0IsTUFBSixHQUFhLENBQWIsSUFBa0IsQ0FBdEIsRUFDQTtBQUNJbzZDLFVBQU0sR0FBR251QixHQUFHLENBQUMsQ0FBQ0EsR0FBRyxDQUFDanNCLE1BQUosR0FBVyxDQUFaLElBQWUsQ0FBZixHQUFtQixDQUFwQixDQUFaO0FBQ0gsR0FIRCxNQUtBO0FBQ0lvNkMsVUFBTSxHQUFHLENBQUMsSUFBSW51QixHQUFHLENBQUNBLEdBQUcsQ0FBQ2pzQixNQUFKLEdBQVcsQ0FBWCxHQUFlLENBQWhCLENBQVAsR0FBNEIsSUFBSWlzQixHQUFHLENBQUNBLEdBQUcsQ0FBQ2pzQixNQUFKLEdBQVcsQ0FBWixDQUFwQyxJQUFxRCxDQUE5RDtBQUNIOztBQUVELFNBQU9vNkMsTUFBUDtBQUNILENBaEJEOztBQTVGQXJvRCxNQUFNLENBQUM0SCxhQUFQLENBOEdlMGdELGFBQWEsR0FBRztBQUMzQkwsT0FBSyxFQUFDQSxLQURxQjtBQUUzQnR5QyxNQUFJLEVBQUNBLElBRnNCO0FBRzNCeXlDLFVBQVEsRUFBQ0EsUUFIa0I7QUFJM0JDLFFBQU0sRUFBQ0E7QUFKb0IsQ0E5Ry9CLEUiLCJmaWxlIjoiL3BhY2thZ2VzL3JhbmR5cF9tYXRzLWNvbW1vbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgQ29sb3JhZG8gU3RhdGUgVW5pdmVyc2l0eSBhbmQgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZWQgYnkgcGllcmNlIG9uIDgvMzEvMTYuXG4gKi9cbmltcG9ydCAnLi4vaW1wb3J0cy9zdGFydHVwL3NlcnZlci9pbmRleC5qcyc7XG5pbXBvcnQgJy4uL2ltcG9ydHMvc3RhcnR1cC9ib3RoL2luZGV4LmpzJztcbmltcG9ydCB7U2VydmljZUNvbmZpZ3VyYXRpb259IGZyb20gJ21ldGVvci9zZXJ2aWNlLWNvbmZpZ3VyYXRpb24nO1xuXG52YXIgc2V0R29vZ2xlQ3JlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKlxuICAgICBmcm9tIGRldmVsb3BlciBjb25zb2xlOlxuICAgICBjb25zb2xlLmRldmVsb3BlcnMuZ29vZ2xlLmFwaXNcbiAgICAgKi9cbiAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgIHZhciBvcyA9IE5wbS5yZXF1aXJlKCdvcycpO1xuICAgICAgICB2YXIgaG9zdG5hbWUgPSBvcy5ob3N0bmFtZSgpO1xuICAgICAgICB2YXIgY2lkID0gXCJcIjtcbiAgICAgICAgdmFyIGNTZWNyZXQgPSBcIlwiO1xuICAgICAgICB2YXIgZ2lkID0gXCJcIjtcbiAgICAgICAgdmFyIGdTZWNyZXQgPSBcIlwiO1xuICAgICAgICB2YXIgX2lkID0gXCJcIjtcbiAgICAgICAgdmFyIGNyZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjcmVkID0gU2VydmljZUNvbmZpZ3VyYXRpb24uY29uZmlndXJhdGlvbnMuZmluZE9uZSh7c2VydmljZTonZ29vZ2xlJ30pO1xuICAgICAgICAgICAgaWYgKGNyZWQpIHtcbiAgICAgICAgICAgICAgICBjaWQgPSBjcmVkLmNsaWVudElkO1xuICAgICAgICAgICAgICAgIGNTZWNyZXQgPSBjcmVkLnNlY3JldDtcbiAgICAgICAgICAgICAgICBfaWQgPSBjcmVkLl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChob3N0bmFtZS5zcGxpdCgnLicpWzBdKSB7XG4gICAgICAgICAgICBjYXNlIFwibWF0c1wiOlxuICAgICAgICAgICAgICAgIGdpZCA9IFwiNDk5MTgwMjY2NzIyLWQ0cm42MTVzNHM4dGVucmE0dGRpc2JsMWkzNHV2dTgyLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tXCI7XG4gICAgICAgICAgICAgICAgZ1NlY3JldCA9IFwiVTBRdUZvRmtNblp3TmNrMW5KZlBLMVV2XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0cy1kZXZcIjpcbiAgICAgICAgICAgICAgICBnaWQgPSBcIjQ5OTE4MDI2NjcyMi1tOHF1c2xsMm41c2M1N3UwaGRlZmFuczM1bm9xa3QxMy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbVwiO1xuICAgICAgICAgICAgICAgIGdTZWNyZXQgPSBcIlJhMXhDU0Ruci1aWlgxd2d5QUhIU2JJVVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hdHMtaW50XCI6XG4gICAgICAgICAgICAgICAgZ2lkID0gXCI0OTkxODAyNjY3MjItMzFlaWtqcHJuMmxlazJqbXY4cTMxYWRoZGJpNWNjNGIuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb21cIjtcbiAgICAgICAgICAgICAgICBnU2VjcmV0ID0gXCJXTGFQYVlxNE1kVTRuRVVTaF9QdzNNREpcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsb2NhbGhvc3RcIjpcbiAgICAgICAgICAgICAgICBnaWQgPSBcIjQ5OTE4MDI2NjcyMi1iNGo2NGJzbzduY2ZpY2syY2drdTdpaWI1MTZ0a2hzaC5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbVwiO1xuICAgICAgICAgICAgICAgIGdTZWNyZXQgPSBcImo0RVp2T2RBZ09yREhfTGtnODJ1ZWJwdVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBnaWQgPSBcIjQ5OTE4MDI2NjcyMi1tdTVoM3NoZTYxZmdpY3VybzFranJsdjBtNHJkN2JydC5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbVwiO1xuICAgICAgICAgICAgICAgIGdTZWNyZXQgPSBcIm9WVmlCaTlUZ0xyTFBXdDZaVHY3TTk1a1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnaWQgIT0gY2lkIHx8IGdTZWNyZXQgIT0gY1NlY3JldCkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZ2lkIGFuZCBnU2VjcmV0XG4gICAgICAgICAgICBpZiAoY3JlZCkge1xuICAgICAgICAgICAgICAgIFNlcnZpY2VDb25maWd1cmF0aW9uLmNvbmZpZ3VyYXRpb25zLnVwZGF0ZShfaWQsIHskc2V0OiB7c2VjcmV0OiBnU2VjcmV0LCBjbGllbnRJZDogZ2lkfX0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTZXJ2aWNlQ29uZmlndXJhdGlvbi5jb25maWd1cmF0aW9ucy5pbnNlcnQoe3NlcnZpY2U6IFwiZ29vZ2xlXCIsbG9naW5TdHlsZTogXCJwb3B1cFwiLCBzZWNyZXQ6IGdTZWNyZXQsIGNsaWVudElkOiBnaWR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnNldEdvb2dsZUNyZWQoKTsiLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IENvbG9yYWRvIFN0YXRlIFVuaXZlcnNpdHkgYW5kIFJlZ2VudHMgb2YgdGhlIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHBpZXJjZSBvbiA4LzMxLzE2LlxuICovXG5pbXBvcnQgJy4vbWF0cy1jb2xsZWN0aW9ucy5qcyc7XG5pbXBvcnQgJy4vbWF0cy10eXBlcy5qcyc7XG5pbXBvcnQgJy4uL2FwaS9tYXRzTWV0aG9kcy5qcyc7IiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qKlxuICogQ3JlYXRlZCBieSBwaWVyY2Ugb24gOC8zMS8xNi5cbiAqL1xudmFyIERhdGFiYXNlUm9sZXMgPSB7XG4gICAgTU9ERUxfREFUQTogJ21vZGVsX2RhdGEnLFxuICAgIE1FVEFfREFUQTogJ21ldGFfZGF0YScsXG4gICAgU1VNU19EQVRBOiAnc3Vtc19kYXRhJyxcbiAgICBTSVRFX0RBVEE6ICdzaXRlX2RhdGEnXG59O1xuXG52YXIgQXBwVHlwZXMgPSB7XG4gICAgbWF0czogJ21hdHMnLFxuICAgIG1ldGV4cHJlc3M6ICdtZXRleHByZXNzJyxcbiAgICBtYXRzNG1ldDogJ21hdHM0bWV0J1xufTtcblxudmFyIElucHV0VHlwZXMgPSB7XG4gICAgdGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgICBzZWxlY3Q6ICdzZWxlY3QnLFxuICAgIHNlbGVjdE9yZGVyRW5mb3JjZWQ6ICdzZWxlY3RPcmRlckVuZm9yY2VkJyxcbiAgICBudW1iZXJTcGlubmVyOiAnbnVtYmVyU3Bpbm5lcicsXG4gICAgZGF0ZVJhbmdlOiAnZGF0ZVJhbmdlJyxcbiAgICByYWRpb0dyb3VwOiAncmFkaW9Hcm91cCcsXG4gICAgY2hlY2tCb3hHcm91cDogJ2NoZWNrQm94R3JvdXAnLFxuICAgIHJlc2V0QnV0dG9uOiAncmVzZXRCdXR0b24nLFxuICAgIGNvbnRyb2xCdXR0b246ICdjb250cm9sQnV0dG9uJyxcbiAgICBlbGVtZW50OiAnZWxlbWVudCcsXG4gICAgc2VsZWN0TWFwOiAnc2VsZWN0TWFwJyxcbiAgICBjdXN0b206ICdjdXN0b20nLFxuICAgIHVudXNlZDogXCJ1bnVzZWRcIixcbiAgICBmb3JlY2FzdFNpbmdsZUN5Y2xlOiAnZm9yZWNhc3RzIHNpbmdsZSBjeWNsZScsXG4gICAgZm9yZWNhc3RNdWx0aUN5Y2xlOiAnZm9yZWNhc3RzIG11bHRpIGN5Y2xlJ1xufTtcblxudmFyIFBsb3RUeXBlcyA9IHtcbiAgICB0aW1lU2VyaWVzOiBcIlRpbWVTZXJpZXNcIixcbiAgICBwcm9maWxlOiBcIlByb2ZpbGVcIixcbiAgICBkaWVvZmY6IFwiRGllT2ZmXCIsXG4gICAgdGhyZXNob2xkOiBcIlRocmVzaG9sZFwiLFxuICAgIHZhbGlkdGltZTogXCJWYWxpZFRpbWVcIixcbiAgICBkYWlseU1vZGVsQ3ljbGU6IFwiRGFpbHlNb2RlbEN5Y2xlXCIsXG4gICAgcmVsaWFiaWxpdHk6IFwiUmVsaWFiaWxpdHlcIixcbiAgICBtYXA6IFwiTWFwXCIsXG4gICAgaGlzdG9ncmFtOiBcIkhpc3RvZ3JhbVwiLFxuICAgIGNvbnRvdXI6IFwiQ29udG91clwiLFxuICAgIGNvbnRvdXJEaWZmOiBcIkNvbnRvdXJEaWZmXCIsXG4gICAgc2NhdHRlcjJkOiBcIlNjYXR0ZXIyZFwiXG59O1xuXG52YXIgRm9yZWNhc3RUeXBlcyA9IHtcbiAgICBkaWVvZmY6IFwiZGllb2ZmXCIsXG4gICAgdXRjQ3ljbGU6IFwidXRjIGN5Y2xlXCIsXG4gICAgc2luZ2xlQ3ljbGU6IFwic2luZ2xlIGN5Y2xlXCJcbn07XG5cbnZhciBQbG90Rm9ybWF0cyA9IHtcbiAgICBub25lOiBcIm5vbmVcIixcbiAgICBtYXRjaGluZzogXCJtYXRjaGluZ1wiLFxuICAgIHBhaXJ3aXNlOiBcInBhaXJ3aXNlXCIsXG4gICAgYWJzb2x1dGU6IFwiYWJzb2x1dGVcIlxufTtcblxudmFyIFBsb3RBY3Rpb25zID0ge1xuICAgIG1hdGNoZWQ6IFwibWF0Y2hlZFwiLFxuICAgIHVubWF0Y2hlZDogXCJ1bm1hdGNoZWRcIlxufTtcblxudmFyIEJlc3RGaXRzID0ge1xuICAgIG5vbmU6ICdub25lJyxcbiAgICBsaW5lYXI6ICdsaW5lYXInLFxuICAgIGxpbmVhclRocm91Z2hPcmlnaW46ICdsaW5lYXJUaHJvdWdoT3JpZ2luJyxcbiAgICBleHBvbmVudGlhbDogJ2V4cG9uZW50aWFsJyxcbiAgICBsb2dhcml0aG1pYzogJ2xvZ2FyaXRobWljJyxcbiAgICBwb3dlcjogJ3Bvd2VyJ1xufTtcblxudmFyIE1hdGNoRm9ybWF0cyA9IHtcbiAgICBub25lOiBcIm5vbmVcIixcbiAgICB0aW1lOiBcInRpbWVcIixcbiAgICBsZXZlbDogXCJsZXZlbFwiLFxuICAgIHNpdGU6IFwic2l0ZVwiXG59O1xuXG52YXIgUGxvdEF4aXNGaWx0ZXJzID0ge1xuICAgIG5vbmU6IFwibm9uZVwiLFxuICAgIGxldmVsOiBcImxldmVsXCIsXG4gICAgc2l0ZTogXCJzaXRlXCJcbn07XG5cbnZhciBQbG90VmlldyA9IHtcbiAgICBncmFwaDogXCJncmFwaFwiLFxuICAgIHRleHRTZXJpZXM6IFwidGV4dFwiLFxufTtcblxudmFyIFJlc2VydmVkV29yZHMgPSB7XG4gICAgWmVybzogXCJaZXJvXCIsXG4gICAgemVybzogXCJ6ZXJvXCIsXG4gICAgaWRlYWwwOiBcImlkZWFsMFwiLFxuICAgIGlkZWFsMTogXCJpZGVhbDFcIixcbiAgICBpZGVhbDI6IFwiaWRlYWwyXCIsXG4gICAgaWRlYWwzOiBcImlkZWFsM1wiLFxuICAgIGlkZWFsNDogXCJpZGVhbDRcIixcbiAgICBpZGVhbDU6IFwiaWRlYWw1XCIsXG4gICAgaWRlYWw2OiBcImlkZWFsNlwiLFxuICAgIGlkZWFsNzogXCJpZGVhbDdcIixcbiAgICBpZGVhbDg6IFwiaWRlYWw4XCIsXG4gICAgaWRlYWw5OiBcImlkZWFsOVwiLFxuICAgIHBlcmZlY3RSZWxpYWJpbGl0eTogXCJQZXJmZWN0IFJlbGlhYmlsaXR5XCIsXG4gICAgbm9Ta2lsbDogXCJObyBTa2lsbFwiLFxuICAgIGJsdWVDdXJ2ZVRleHQ6IFwiYmx1ZUN1cnZlVGV4dFwiLFxuICAgIGJsYWNrQ3VydmVUZXh0OiBcImJsYWNrQ3VydmVUZXh0XCIsXG4gICAgcmVkQ3VydmVUZXh0OiBcInJlZEN1cnZlVGV4dFwiXG59O1xuXG52YXIgTWVzc2FnZXMgPSB7XG4gICAgTk9fREFUQV9GT1VORDogXCJJTkZPOjAgZGF0YSByZWNvcmRzIGZvdW5kXCJcbn07XG5cbi8vaGlkZSBub24tdGltZXNlcmllcyBzZWxlY3RvcnMgYXQgc3RhcnR1cFxudmFyIHNlbGVjdG9yc1RvSGlkZSA9IFsnZGllb2ZmLXR5cGUnLCAndXRjLWN5Y2xlLXN0YXJ0JywgJ2hpc3RvZ3JhbS1iaW4tY29udHJvbHMnLCAnaGlzdG9ncmFtLXlheGlzLWNvbnRyb2xzJywgJ2Jpbi1udW1iZXInLCAnYmluLXBpdm90JywgJ2Jpbi1zdGFydCcsICdiaW4tc3RyaWRlJywgJ2Jpbi1ib3VuZHMnLCAneC1heGlzLXBhcmFtZXRlcicsICd5LWF4aXMtcGFyYW1ldGVyJ107XG5cbi8qXG5DbGFzcyBmb3IgaG9sZGluZyBtZXRhRGF0YSByZWNvcmRzLiBUaGVzZSBhcmUgc3RvcmVkIGluIGFuIGFycmF5LiBBbiBhcHAgY2FuIGhhdmUgbXVsdGlwbGUgbWV0YWRhdGEgZGF0YWJhc2VzIGFuZCBlYWNoIGRhdGFiYXNlIGhhcyBhIHBvb2wgZm9yIGNvbm5lY3Rpb25zLlxuVGhlc2UgcG9vbHMgYXJlIGdsb2JhbCAoYWx0aG91Z2ggZm9yIGZ1dHVyZSByZWZlcmVuY2UgdGhlIGFjY2VzcyBtaWdodCBiZSBmcm9tIHRoaXMgY29sbGVjdGlvbi4pLiBUaGV5IGFyZSByZWZlbmNlZCBpbiB0aGlzIHNjcmlwdCB2aWEgdGhlIHBvb2wgbmFtZS5cblRoaXMgY2xhc3MgZW5mb3JjZXMgdGhlIHR5cGVzIG9mIHRoZSBwb29sTmFtZSAoaW4gY2FzZSBzb21lb25lIGFjY2lkZW50YWxseSB0cmllcyB0byBzdG9yZSB0aGUgd2hvbGUgcG9vbCBvYmplY3QpLCBhbmQgdGhlIGRhdGFiYXNlIG5hbWUgYW5kIGEgbGlzdFxub2YgdGFibGUgbmFtZXMuIFRoZSBpbnRlcm5hbCBsaXN0IGNhbiBiZSBhcHBlbmRlZC4gVGhlIGdldFJlY29yZHMgcmV0dXJucyB0aGUgaW50ZXJuYWwgbGlzdC5cbiAqL1xuY2xhc3MgTWV0YURhdGFEQlJlY29yZCB7XG4gICAgY29uc3RydWN0b3IocG9vbE5hbWUsIGRiTmFtZSwgdGFibGVzKSB7XG4gICAgICAgIGlmICghdHlwZW9mIHBvb2xOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRhRGF0YURCUmVjb3JkLmNvbnN0cnVjdG9yIDogcG9vbE5hbWUgaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHlwZW9mIGRiTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0YURhdGFEQlJlY29yZC5jb25zdHJ1Y3RvciA6IGRiTmFtZSBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YWJsZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0YURhdGFEQlJlY29yZC5jb25zdHJ1Y3RvciA6IHRhYmxlcyBpcyBub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjb3JkcyA9IFtdO1xuICAgICAgICB2YXIgcmVjb3JkID0geydwb29sJzogcG9vbE5hbWUsICduYW1lJzogZGJOYW1lLCAndGFibGVzJzogdGFibGVzfTtcbiAgICAgICAgdGhpcy5fcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgfVxuXG4gICAgYWRkUmVjb3JkKHBvb2xOYW1lLCBkYk5hbWUsIHRhYmxlcykge1xuICAgICAgICBpZiAoIXR5cGVvZiBwb29sTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0YURhdGFEQlJlY29yZC5jb25zdHJ1Y3RvciA6IHBvb2xOYW1lIGlzIG5vdCBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGVvZiBkYk5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGFEYXRhREJSZWNvcmQuY29uc3RydWN0b3IgOiBkYk5hbWUgaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFibGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGFEYXRhREJSZWNvcmQuY29uc3RydWN0b3IgOiB0YWJsZXMgaXMgbm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWNvcmQgPSB7J3Bvb2wnOiBwb29sTmFtZSwgJ25hbWUnOiBkYk5hbWUsICd0YWJsZXMnOiB0YWJsZXN9O1xuICAgICAgICB0aGlzLl9yZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICB9XG5cbiAgICBnZXRSZWNvcmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjb3JkcztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hdHNUeXBlcyA9IHtcbiAgICBJbnB1dFR5cGVzOiBJbnB1dFR5cGVzLFxuICAgIFBsb3RUeXBlczogUGxvdFR5cGVzLFxuICAgIFBsb3RGb3JtYXRzOiBQbG90Rm9ybWF0cyxcbiAgICBQbG90QWN0aW9uczogUGxvdEFjdGlvbnMsXG4gICAgQmVzdEZpdHM6IEJlc3RGaXRzLFxuICAgIE1hdGNoRm9ybWF0czogTWF0Y2hGb3JtYXRzLFxuICAgIFBsb3RBeGlzRmlsdGVyczogUGxvdEF4aXNGaWx0ZXJzLFxuICAgIFBsb3RWaWV3OiBQbG90VmlldyxcbiAgICBNZXNzYWdlczogTWVzc2FnZXMsXG4gICAgRm9yZWNhc3RUeXBlczogRm9yZWNhc3RUeXBlcyxcbiAgICBSZXNlcnZlZFdvcmRzOiBSZXNlcnZlZFdvcmRzLFxuICAgIHNlbGVjdG9yc1RvSGlkZTogc2VsZWN0b3JzVG9IaWRlLFxuICAgIE1ldGFEYXRhREJSZWNvcmQ6IE1ldGFEYXRhREJSZWNvcmQsXG4gICAgQXBwVHlwZXM6IEFwcFR5cGVzLFxuICAgIERhdGFiYXNlUm9sZXM6IERhdGFiYXNlUm9sZXNcbn1cblxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qKlxuICogQ3JlYXRlZCBieSBwaWVyY2Ugb24gOC8zMS8xNi5cbiAqL1xuaW1wb3J0IHsgTW9uZ28gfSBmcm9tICdtZXRlb3IvbW9uZ28nO1xudmFyIEN1cnZlUGFyYW1zID0gbmV3IE1vbmdvLkNvbGxlY3Rpb24oXCJDdXJ2ZVBhcmFtc1wiKTtcbnZhciBTY2F0dGVyMmRQYXJhbXMgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIlNjYXR0ZXIyZFBhcmFtc1wiKTtcbnZhciBDdXJ2ZVRleHRQYXR0ZXJucyA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiQ3VydmVUZXh0UGF0dGVybnNcIik7XG52YXIgU2NhdHRlckF4aXNUZXh0UGF0dGVybiA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiU2NhdHRlckF4aXNUZXh0UGF0dGVyblwiKTtcbnZhciBTYXZlZEN1cnZlUGFyYW1zID0gbmV3IE1vbmdvLkNvbGxlY3Rpb24oXCJTYXZlZEN1cnZlUGFyYW1zXCIpO1xudmFyIFBsb3RQYXJhbXMgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIlBsb3RQYXJhbXNcIik7XG52YXIgU2F2ZWRQbG90UGFyYW1zID0gbmV3IE1vbmdvLkNvbGxlY3Rpb24oXCJTYXZlZFBsb3RQYXJhbXNcIik7XG52YXIgUGxvdEdyYXBoRnVuY3Rpb25zID0gbmV3IE1vbmdvLkNvbGxlY3Rpb24oXCJQbG90R3JhcGhGdW5jdGlvbnNcIik7XG52YXIgU2F2ZWRQbG90R3JhcGhGdW5jdGlvbnMgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIlNhdmVkUGxvdEdyYXBoRnVuY3Rpb25zXCIpO1xudmFyIFJlZ2lvbnNQZXJNb2RlbCA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiUmVnaW9uc1Blck1vZGVsXCIpO1xudmFyIFNpdGVzUGVyTW9kZWwgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIlNpdGVzUGVyTW9kZWxcIik7XG52YXIgUmVnaW9uRGVzY3JpcHRpb25zID0gbmV3IE1vbmdvLkNvbGxlY3Rpb24oXCJSZWdpb25EZXNjcmlwdGlvbnNcIik7XG52YXIgTW9kZWxzID0gbmV3IE1vbmdvLkNvbGxlY3Rpb24oXCJNb2RlbHNcIik7XG52YXIgSW5zdHJ1bWVudHMgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIkluc3RydW1lbnRzXCIpO1xudmFyIEZjc3RMZW5zUGVyTW9kZWwgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIkZjc3RMZW5zUGVyTW9kZWxcIik7XG52YXIgQ3VydmVTZXR0aW5ncyA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiQ3VydmVTZXR0aW5nc1wiKTtcbnZhciBTZXR0aW5ncyA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiU2V0dGluZ3NcIik7XG52YXIgQ29sb3JTY2hlbWUgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIkNvbG9yU2NoZW1lXCIpO1xudmFyIFNlbnRBZGRyZXNzZXMgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIlNlbnRBZGRyZXNzZXNcIik7XG52YXIgQXV0aG9yaXphdGlvbiA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiQXV0aG9yaXphdGlvblwiKTtcbnZhciBSb2xlcyA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiUm9sZXNcIik7XG52YXIgU2F2ZWRSb2xlcyA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiU2F2ZWRSb2xlc1wiKTtcbnZhciBEYXRhYmFzZXMgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIkRhdGFiYXNlc1wiKTtcbnZhciBTYXZlZERhdGFiYXNlcyA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiU2F2ZWREYXRhYmFzZXNcIik7XG52YXIgQ3JlZGVudGlhbHMgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIkNyZWRlbnRpYWxzXCIpO1xudmFyIFNhdmVkQ3JlZGVudGlhbHMgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcIlNhdmVkQ3JlZGVudGlhbHNcIik7XG52YXIgU2l0ZU1hcCA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiU2l0ZU1hcFwiKTtcbnZhciBTdGF0aW9uTWFwID0gbmV3IE1vbmdvLkNvbGxlY3Rpb24oXCJTdGF0aW9uTWFwXCIpO1xudmFyIGFwcE5hbWUgPSBuZXcgTW9uZ28uQ29sbGVjdGlvbihcImFwcE5hbWVcIik7XG5cbmV4cG9ydCBkZWZhdWx0IG1hdHNDb2xsZWN0aW9ucyA9IHtcbiAgICBDdXJ2ZVBhcmFtczpDdXJ2ZVBhcmFtcyxcbiAgICBTY2F0dGVyMmRQYXJhbXM6U2NhdHRlcjJkUGFyYW1zLFxuICAgIEN1cnZlVGV4dFBhdHRlcm5zOkN1cnZlVGV4dFBhdHRlcm5zLFxuICAgIFNjYXR0ZXJBeGlzVGV4dFBhdHRlcm46U2NhdHRlckF4aXNUZXh0UGF0dGVybixcbiAgICBTYXZlZEN1cnZlUGFyYW1zOlNhdmVkQ3VydmVQYXJhbXMsXG4gICAgUGxvdFBhcmFtczpQbG90UGFyYW1zLFxuICAgIFNhdmVkUGxvdFBhcmFtczpTYXZlZFBsb3RQYXJhbXMsXG4gICAgUGxvdEdyYXBoRnVuY3Rpb25zOlBsb3RHcmFwaEZ1bmN0aW9ucyxcbiAgICBTYXZlZFBsb3RHcmFwaEZ1bmN0aW9uczpTYXZlZFBsb3RHcmFwaEZ1bmN0aW9ucyxcbiAgICBSZWdpb25zUGVyTW9kZWw6UmVnaW9uc1Blck1vZGVsLFxuICAgIFNpdGVzUGVyTW9kZWw6U2l0ZXNQZXJNb2RlbCxcbiAgICBSZWdpb25EZXNjcmlwdGlvbnM6UmVnaW9uRGVzY3JpcHRpb25zLFxuICAgIE1vZGVsczpNb2RlbHMsXG4gICAgSW5zdHJ1bWVudHM6SW5zdHJ1bWVudHMsXG4gICAgRmNzdExlbnNQZXJNb2RlbDpGY3N0TGVuc1Blck1vZGVsLFxuICAgIEN1cnZlU2V0dGluZ3M6Q3VydmVTZXR0aW5ncyxcbiAgICBTZXR0aW5nczpTZXR0aW5ncyxcbiAgICBDb2xvclNjaGVtZTpDb2xvclNjaGVtZSxcbiAgICBTZW50QWRkcmVzc2VzOlNlbnRBZGRyZXNzZXMsXG4gICAgQXV0aG9yaXphdGlvbjpBdXRob3JpemF0aW9uLFxuICAgIFJvbGVzOlJvbGVzLFxuICAgIFNhdmVkUm9sZXM6U2F2ZWRSb2xlcyxcbiAgICBEYXRhYmFzZXM6RGF0YWJhc2VzLFxuICAgIFNhdmVkRGF0YWJhc2VzOlNhdmVkRGF0YWJhc2VzLFxuICAgIENyZWRlbnRpYWxzOkNyZWRlbnRpYWxzLFxuICAgIFNhdmVkQ3JlZGVudGlhbHM6U2F2ZWRDcmVkZW50aWFscyxcbiAgICBTaXRlTWFwOlNpdGVNYXAsXG4gICAgU3RhdGlvbk1hcDpTdGF0aW9uTWFwLFxuICAgIGFwcE5hbWU6YXBwTmFtZVxufTsiLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IENvbG9yYWRvIFN0YXRlIFVuaXZlcnNpdHkgYW5kIFJlZ2VudHMgb2YgdGhlIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHtNZXRlb3J9IGZyb20gXCJtZXRlb3IvbWV0ZW9yXCI7XG5pbXBvcnQge1ZhbGlkYXRlZE1ldGhvZH0gZnJvbSAnbWV0ZW9yL21kZzp2YWxpZGF0ZWQtbWV0aG9kJztcbmltcG9ydCB7U2ltcGxlU2NoZW1hfSBmcm9tICdtZXRlb3IvYWxkZWVkOnNpbXBsZS1zY2hlbWEnO1xuaW1wb3J0IHttYXRzQ2FjaGUsIG1hdHNDb2xsZWN0aW9ucywgbWF0c0RhdGFRdWVyeVV0aWxzLCBtYXRzRGF0YVV0aWxzLCBtYXRzVHlwZXN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaW1wb3J0IHtteXNxbH0gZnJvbSAnbWV0ZW9yL3BjZWw6bXlzcWwnO1xuaW1wb3J0IHt1cmx9IGZyb20gJ3VybCc7XG5pbXBvcnQge01vbmdvfSBmcm9tICdtZXRlb3IvbW9uZ28nO1xuXG4vLyBQUklWQVRFXG5cbi8vIGxvY2FsIGNvbGxlY3Rpb24gdXNlZCB0byBrZWVwIHRoZSB0YWJsZSB1cGRhdGUgdGltZXMgZm9yIHJlZnJlc2ggLSB3b24ndCBldmVyIGJlIHN5bmNocm9uaXplZCBvciBwZXJzaXN0ZWQuXG5jb25zdCBtZXRhRGF0YVRhYmxlVXBkYXRlcyA9IG5ldyBNb25nby5Db2xsZWN0aW9uKG51bGwpO1xuY29uc3QgTGF5b3V0U3RvcmVDb2xsZWN0aW9uID0gbmV3IE1vbmdvLkNvbGxlY3Rpb24oXCJMYXlvdXRTdG9yZUNvbGxlY3Rpb25cIik7IC8vIGluaXRpYWxpemUgY29sbGVjdGlvbiB1c2VkIGZvciBwb3Atb3V0IHdpbmRvdyBmdW5jdGlvbmFsaXR5XG5jb25zdCBEb3duU2FtcGxlUmVzdWx0cyA9IG5ldyBNb25nby5Db2xsZWN0aW9uKFwiRG93blNhbXBsZVJlc3VsdHNcIik7XG5cbnZhciBNVl9ESVJTID0ge307XG4vLyBEZWZpbmUgcm91dGVzIGZvciBzZXJ2ZXJcbmlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICBpZiAoTWV0ZW9yLnNldHRpbmdzLnByaXZhdGUgIT09IHVuZGVmaW5lZCAmJiBNZXRlb3Iuc2V0dGluZ3MucHJpdmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBfTVZfT1VUID0gTWV0ZW9yLnNldHRpbmdzLnByaXZhdGUuTVZfT1VUUFVUO1xuICAgICAgICBjb25zdCBfTVZfSE9NRSA9IE1ldGVvci5zZXR0aW5ncy5wcml2YXRlLk1WX0hPTUU7XG4gICAgICAgIGNvbnN0IF9NVl9MT0dESVIgPSBfTVZfT1VUICsgXCIveG1sL1wiO1xuICAgICAgICBjb25zdCBfTVZfRVJSRElSID0gX01WX09VVCArIFwiL3htbC9cIjtcbiAgICAgICAgY29uc3QgX01WX0RBVEFESVIgPSBfTVZfT1VUICsgXCIvZGF0YS9cIjtcbiAgICAgICAgY29uc3QgX01WX1NRTERJUiA9IF9NVl9PVVQgKyBcIi94bWwvXCI7ICAvLyBzcWwgb3V0cHV0IGdvZXMgd2l0aCB0aGUgeG1sIG91dHB1dFxuICAgICAgICBjb25zdCBfTVZfWE1MRElSID0gX01WX09VVCArIFwiL3htbC9cIjtcbiAgICAgICAgY29uc3QgX01WX1NDUklQVFNESVIgPSBfTVZfT1VUICsgXCIvc2NyaXB0cy9cIjtcbiAgICAgICAgY29uc3QgX01WX1BMT1RTU0RJUiA9IF9NVl9PVVQgKyBcIi9wbG90cy9cIjtcbiAgICAgICAgcHJvY2Vzcy5lbnYuSkFWQV9IT01FID0gTWV0ZW9yLnNldHRpbmdzLnByaXZhdGUuSkFWQV9IT01FO1xuICAgICAgICBwcm9jZXNzLmVudi5NVl9IT01FID0gTWV0ZW9yLnNldHRpbmdzLnByaXZhdGUuTVZfSE9NRTtcblxuICAgICAgICBNVl9ESVJTID0ge1xuICAgICAgICAgICAgTE9HRElSOiBfTVZfTE9HRElSLFxuICAgICAgICAgICAgRVJSRElSOiBfTVZfRVJSRElSLFxuICAgICAgICAgICAgREFUQURJUjogX01WX0RBVEFESVIsXG4gICAgICAgICAgICBTUUxESVI6IF9NVl9TUUxESVIsXG4gICAgICAgICAgICBYTUxESVI6IF9NVl9YTUxESVIsXG4gICAgICAgICAgICBTQ1JJUFRTRElSOiBfTVZfU0NSSVBUU0RJUixcbiAgICAgICAgICAgIFBMT1RTRElSOiBfTVZfUExPVFNTRElSLFxuICAgICAgICAgICAgSE9NRTogX01WX0hPTUVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBhZGQgaW5kZXhlcyB0byByZXN1bHQgYW5kIGF4ZXMgY29sbGVjdGlvbnNcbiAgICBEb3duU2FtcGxlUmVzdWx0cy5yYXdDb2xsZWN0aW9uKCkuY3JlYXRlSW5kZXgoe1wiY3JlYXRlZEF0XCI6IDF9LCB7ZXhwaXJlQWZ0ZXJTZWNvbmRzOiAzNjAwICogOH0pOyAvLyA4IGhvdXIgZXhwaXJhdGlvblxuICAgIExheW91dFN0b3JlQ29sbGVjdGlvbi5yYXdDb2xsZWN0aW9uKCkuY3JlYXRlSW5kZXgoe1wiY3JlYXRlZEF0XCI6IDF9LCB7ZXhwaXJlQWZ0ZXJTZWNvbmRzOiA5MDB9KTsgLy8gMTUgbWluIGV4cGlyYXRpb25cbiAgICAvLyBzZXQgdGhlIGRlZmF1bHQgcHJveHkgcHJlZml4IHBhdGggdG8gXCJcIlxuICAgIGlmIChNZXRlb3Iuc2V0dGluZ3MucHVibGljICE9IG51bGwgJiYgTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCAgPT0gbnVsbCkge1xuICAgICAgICBNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoID0gXCJcIjtcbiAgICB9XG5cbiAgICBQaWNrZXIucm91dGUoJy9fZ2V0Q1NWLzprZXknLCBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgICAgICBQaWNrZXIubWlkZGxld2FyZShfZ2V0Q1NWKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy9fZ2V0Q1NWLzprZXknLCBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgICAgICBQaWNrZXIubWlkZGxld2FyZShfZ2V0Q1NWKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy9hcHA6L19nZXRDU1YvOmtleScsIGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIFBpY2tlci5taWRkbGV3YXJlKF9nZXRDU1YocGFyYW1zLCByZXEsIHJlcywgbmV4dCkpO1xuICAgIH0pO1xuXG4gICAgUGlja2VyLnJvdXRlKCcvQ1NWLzpmLzprZXkvOm0vOmEnLCBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgICAgICBQaWNrZXIubWlkZGxld2FyZShfZ2V0Q1NWKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy9DU1YvOmYvOmtleS86bS86YScsIGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIFBpY2tlci5taWRkbGV3YXJlKF9nZXRDU1YocGFyYW1zLCByZXEsIHJlcywgbmV4dCkpO1xuICAgIH0pO1xuXG4gICAgUGlja2VyLnJvdXRlKE1ldGVvci5zZXR0aW5ncy5wdWJsaWMucHJveHlfcHJlZml4X3BhdGggKyAnLzphcHAvQ1NWLzpmLzprZXkvOm0vOmEnLCBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgICAgICBQaWNrZXIubWlkZGxld2FyZShfZ2V0Q1NWKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZSgnL19nZXRKU09OLzprZXknLCBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgICAgICBQaWNrZXIubWlkZGxld2FyZShfZ2V0SlNPTihwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSk7XG4gICAgfSk7XG5cbiAgICBQaWNrZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvX2dldEpTT04vOmtleScsIGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIFBpY2tlci5taWRkbGV3YXJlKF9nZXRKU09OKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy9hcHA6L19nZXRKU09OLzprZXknLCBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgICAgICBQaWNrZXIubWlkZGxld2FyZShfZ2V0SlNPTihwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSk7XG4gICAgfSk7XG5cbiAgICBQaWNrZXIucm91dGUoJy9KU09OLzpmLzprZXkvOm0vOmEnLCBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgICAgICBQaWNrZXIubWlkZGxld2FyZShfZ2V0SlNPTihwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSk7XG4gICAgfSk7XG5cbiAgICBQaWNrZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvSlNPTi86Zi86a2V5LzptLzphJywgZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgUGlja2VyLm1pZGRsZXdhcmUoX2dldEpTT04ocGFyYW1zLCByZXEsIHJlcywgbmV4dCkpO1xuICAgIH0pO1xuXG4gICAgUGlja2VyLnJvdXRlKE1ldGVvci5zZXR0aW5ncy5wdWJsaWMucHJveHlfcHJlZml4X3BhdGggKyAnLzphcHAvSlNPTi86Zi86a2V5LzptLzphJywgZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgUGlja2VyLm1pZGRsZXdhcmUoX2dldEpTT04ocGFyYW1zLCByZXEsIHJlcywgbmV4dCkpO1xuICAgIH0pO1xuXG4gICAgUGlja2VyLnJvdXRlKCcvY2xlYXJDYWNoZScsIGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIFBpY2tlci5taWRkbGV3YXJlKF9jbGVhckNhY2hlKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy9jbGVhckNhY2hlJywgZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgUGlja2VyLm1pZGRsZXdhcmUoX2NsZWFyQ2FjaGUocGFyYW1zLCByZXEsIHJlcywgbmV4dCkpO1xuICAgIH0pO1xuXG4gICAgUGlja2VyLnJvdXRlKE1ldGVvci5zZXR0aW5ncy5wdWJsaWMucHJveHlfcHJlZml4X3BhdGggKyAnLzphcHAvY2xlYXJDYWNoZScsIGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIFBpY2tlci5taWRkbGV3YXJlKF9jbGVhckNhY2hlKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZSgnL3JlZnJlc2hNZXRhZGF0YScsIGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIFBpY2tlci5taWRkbGV3YXJlKF9yZWZyZXNoTWV0YWRhdGFNV2x0RGF0YShwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSk7XG4gICAgfSk7XG5cbiAgICBQaWNrZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvcmVmcmVzaE1ldGFkYXRhJywgZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgUGlja2VyLm1pZGRsZXdhcmUoX3JlZnJlc2hNZXRhZGF0YU1XbHREYXRhKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy86YXBwL3JlZnJlc2hNZXRhZGF0YScsIGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIFBpY2tlci5taWRkbGV3YXJlKF9yZWZyZXNoTWV0YWRhdGFNV2x0RGF0YShwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSk7XG4gICAgfSk7XG5cbi8vIGNyZWF0ZSBwaWNrZXIgcm91dGVzIGZvciBtZXR2aWV3ZXIgbWlkZGxld2FyZSBzdGF0aWMgZmlsZXNcbiAgICBQaWNrZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvOmFwcC9tdmRhdGEvOmtleScsIGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIFBpY2tlci5taWRkbGV3YXJlKF9tdkdldERhdGEocGFyYW1zLCByZXEsIHJlcywgbmV4dCkpO1xuICAgIH0pO1xuXG4gICAgUGlja2VyLnJvdXRlKE1ldGVvci5zZXR0aW5ncy5wdWJsaWMucHJveHlfcHJlZml4X3BhdGggKyAnLzphcHAvbXZwb2ludHMxLzprZXknLCBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgICAgICBQaWNrZXIubWlkZGxld2FyZShfbXZHZXRQb2ludHMxKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy86YXBwL212cG9pbnRzMi86a2V5JywgZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgUGlja2VyLm1pZGRsZXdhcmUoX212R2V0UG9pbnRzMihwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSk7XG4gICAgfSk7XG5cbiAgICBQaWNrZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvOmFwcC9tdnhtbC86a2V5JywgZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgUGlja2VyLm1pZGRsZXdhcmUoX212R2V0WG1sKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy86YXBwL212cGxvdC86a2V5JywgZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgUGlja2VyLm1pZGRsZXdhcmUoX212R2V0UGxvdChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSk7XG4gICAgfSk7XG5cbiAgICBQaWNrZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvOmFwcC9tdnNjcmlwdC86a2V5JywgZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgUGlja2VyLm1pZGRsZXdhcmUoX212R2V0U2NyaXB0KHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcblxuICAgIFBpY2tlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy86YXBwL212c3FsLzprZXknLCBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgICAgICBQaWNrZXIubWlkZGxld2FyZShfbXZHZXRTcWwocGFyYW1zLCByZXEsIHJlcywgbmV4dCkpO1xuICAgIH0pO1xuXG4gICAgUGlja2VyLnJvdXRlKE1ldGVvci5zZXR0aW5ncy5wdWJsaWMucHJveHlfcHJlZml4X3BhdGggKyAnLzphcHAvbXZsb2cvOmtleScsIGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIFBpY2tlci5taWRkbGV3YXJlKF9tdkdldExvZyhwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSk7XG4gICAgfSk7XG5cbiAgICBQaWNrZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvOmFwcC9tdmVyci86a2V5JywgZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgUGlja2VyLm1pZGRsZXdhcmUoX212R2V0RXJyKHBhcmFtcywgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcbn1cblxuLy8gcHJpdmF0ZSAtIHVzZWQgdG8gc2VlIGlmIHRoZSBtYWluIHBhZ2UgbmVlZHMgdG8gdXBkYXRlIGl0cyBzZWxlY3RvcnNcbmNvbnN0IF9jaGVja01ldGFEYXRhUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIHJvdXRpbmUgY29tcGFyZXMgdGhlIGN1cnJlbnQgbGFzdCBtb2RpZmllZCB0aW1lIG9mIHRoZSB0YWJsZXMgdXNlZCBmb3IgY3VydmVQYXJhbWV0ZXIgbWV0YWRhdGFcbiAgICAvLyB3aXRoIHRoZSBsYXN0IHVwZGF0ZSB0aW1lIHRvIGRldGVybWluZSBpZiBhbiB1cGRhdGUgaXMgbmVjZXNzYXJ5LiBXZSByZWFsbHkgb25seSBkbyB0aGlzIGZvciBDdXJ2ZXBhcmFtc1xuICAgIC8qXG4gICAgICAgIG1ldGFEYXRhVGFibGVVcGRhdGVzOlxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBkYXRhQmFzZU5hbWUsXG4gICAgICAgICAgICB0YWJsZXM6IFt0YWJsZU5hbWUxLCB0YWJsZU5hbWUyIC4uXSxcbiAgICAgICAgICAgIGxhc3RSZWZyZXNoZWQgOiB0aW1lc3RhbXBcbiAgICAgICAgfVxuICAgICAqL1xuICAgIHZhciByZWZyZXNoID0gZmFsc2U7XG4gICAgY29uc3QgdGFibGVVcGRhdGVzID0gbWV0YURhdGFUYWJsZVVwZGF0ZXMuZmluZCh7fSkuZmV0Y2goKTtcbiAgICBmb3IgKHZhciB0dWkgPSAwOyB0dWkgPCB0YWJsZVVwZGF0ZXMubGVuZ3RoOyB0dWkrKykge1xuICAgICAgICB2YXIgaWQgPSB0YWJsZVVwZGF0ZXNbdHVpXS5faWQ7XG4gICAgICAgIHZhciBwb29sTmFtZSA9IHRhYmxlVXBkYXRlc1t0dWldLnBvb2w7XG4gICAgICAgIHZhciBkYk5hbWUgPSB0YWJsZVVwZGF0ZXNbdHVpXS5uYW1lO1xuICAgICAgICB2YXIgdGFibGVOYW1lcyA9IHRhYmxlVXBkYXRlc1t0dWldLnRhYmxlcztcbiAgICAgICAgdmFyIGxhc3RSZWZyZXNoZWQgPSB0YWJsZVVwZGF0ZXNbdHVpXVsnbGFzdFJlZnJlc2hlZCddO1xuICAgICAgICB2YXIgdXBkYXRlZEVwb2NoID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRhYmxlTmFtZXMubGVuZ3RoOyB0aSsrKSB7XG4gICAgICAgICAgICB2YXIgdE5hbWUgPSB0YWJsZU5hbWVzW3RpXTtcbiAgICAgICAgICAgIHZhciByb3dzID0gbWF0c0RhdGFRdWVyeVV0aWxzLnNpbXBsZVBvb2xRdWVyeVdyYXBTeW5jaHJvbm91cyhnbG9iYWxbcG9vbE5hbWVdLCBcIlNFTEVDVCBVTklYX1RJTUVTVEFNUChVUERBVEVfVElNRSlcIiArXG4gICAgICAgICAgICAgICAgXCIgICAgRlJPTSAgIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXNcIiArXG4gICAgICAgICAgICAgICAgXCIgICAgV0hFUkUgIFRBQkxFX1NDSEVNQSA9ICdcIiArIGRiTmFtZSArIFwiJ1wiICtcbiAgICAgICAgICAgICAgICBcIiAgICBBTkQgVEFCTEVfTkFNRSA9ICdcIiArIHROYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEVwb2NoID0gcm93c1tpXVsnVU5JWF9USU1FU1RBTVAoVVBEQVRFX1RJTUUpJ107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX2NoZWNrTWV0YURhdGFSZWZyZXNoIC0gY2Fubm90IGZpbmQgbGFzdCB1cGRhdGUgdGltZSBmb3IgZGF0YWJhc2U6IFwiICsgZGJOYW1lICsgXCIgYW5kIHRhYmxlOiBcIiArIHROYW1lICsgXCIgRVJST1I6XCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZEVwb2NoID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9jaGVja01ldGFEYXRhUmVmcmVzaCAtIGNhbm5vdCBmaW5kIGxhc3QgdXBkYXRlIHRpbWUgZm9yIGRhdGFiYXNlOiBcIiArIGRiTmFtZSArIFwiIGFuZCB0YWJsZTogXCIgKyB0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFzdFJlZnJlc2hlZEVwb2NoID0gbW9tZW50KGxhc3RSZWZyZXNoZWQpLnZhbHVlT2YoKSAvIDEwMDA7XG4gICAgICAgICAgICBpZiAobGFzdFJlZnJlc2hlZEVwb2NoIDwgdXBkYXRlZEVwb2NoKSB7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZWZyZXNoaW5nIHRoZSBtZXRhZGF0YSBpbiB0aGUgYXBwIHNlbGVjdG9ycyBiZWNhdXNlIHRhYmxlIFwiICsgZGJOYW1lICsgXCIuXCIgKyB0TmFtZSArIFwiIHdhcyB1cGRhdGVkIGF0IFwiICsgbW9tZW50LnV0Yyh1cGRhdGVkRXBvY2ggKiAxMDAwKS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzXCIpICsgXCIgd2hpbGUgdGhlIG1ldGFkYXRhIHdhcyBsYXN0IHJlZnJlc2hlZCBhdCBcIiArIG1vbWVudC51dGMobGFzdFJlZnJlc2hlZEVwb2NoICogMTAwMCkuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzc1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZnJlc2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIGFwcCBtZXRhZGF0YVxuICAgICAgICAgICAgLy8gYXBwIHNwZWNpZmljIHJvdXRpbmVzXG4gICAgICAgICAgICAvL2NvbnN0IGFzcktleXMgPSBPYmplY3Qua2V5cyhhcHBTcGVjaWZpY1Jlc2V0Um91dGluZXMpO1xuICAgICAgICAgICAgY29uc3QgYXNyS2V5cyA9IGFwcFNwZWNpZmljUmVzZXRSb3V0aW5lcztcbiAgICAgICAgICAgIGZvciAodmFyIGFpID0gMDsgYWkgPCBhc3JLZXlzLmxlbmd0aDsgYWkrKykge1xuICAgICAgICAgICAgICAgIGdsb2JhbC5hcHBTcGVjaWZpY1Jlc2V0Um91dGluZXNbYWldKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGF0IHdlIHVwZGF0ZWQgQUxMIHRoZSBtZXRhZGF0YSB0YWJsZXMganVzdCBub3dcbiAgICAgICAgICAgIG1ldGFEYXRhVGFibGVVcGRhdGVzLnVwZGF0ZSh7X2lkOiBpZH0sIHskc2V0OiB7bGFzdFJlZnJlc2hlZDogbW9tZW50KCkuZm9ybWF0KCl9fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBwcml2YXRlIG1pZGRsZXdhcmUgZm9yIGNsZWFyaW5nIHRoZSBjYWNoZVxuY29uc3QgX2NsZWFyQ2FjaGUgPSBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgbWF0c0NhY2hlLmNsZWFyKCk7XG4gICAgICAgIHJlcy5lbmQoXCI8Ym9keT48aDE+Y2xlYXJDYWNoZSBEb25lITwvaDE+PC9ib2R5PlwiKTtcbiAgICB9XG59O1xuXG4vLyBwcml2YXRlIG1pZGRsZXdhcmUgZm9yIF9nZXRDU1Ygcm91dGVcbmNvbnN0IF9nZXRDU1YgPSBmdW5jdGlvbiAocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgdmFyIHN0cmluZ2lmeSA9IHJlcXVpcmUoJ2Nzdi1zdHJpbmdpZnknKTtcbiAgICAgICAgdmFyIGNzdiA9IFwiXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2dldEZsYXR0ZW5lZFJlc3VsdERhdGEocGFyYW1zLmtleSwgMCwgLTEwMDApO1xuICAgICAgICAgICAgdmFyIHN0YXRBcnJheSA9IE9iamVjdC52YWx1ZXMocmVzdWx0LnN0YXRzKTtcbiAgICAgICAgICAgIHZhciBkYXRhQXJyYXkgPSBPYmplY3QudmFsdWVzKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgIHZhciBzdGF0UmVzdWx0QXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHZhciBkYXRhUmVzdWx0QXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzdGF0QXJyYXkubGVuZ3RoOyBzaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RhdFJlc3VsdEFycmF5LnB1c2goT2JqZWN0LmtleXMoc3RhdEFycmF5W3NpXSkpOyAvLyBwdXNoIHRoZSBzdGF0IGhlYWRlciBmb3IgdGhpcyBjdXJ2ZShrZXlzKVxuICAgICAgICAgICAgICAgIHN0YXRSZXN1bHRBcnJheS5wdXNoKHN0YXRBcnJheVtzaV1bJ24nXSA9PT0gMCA/IFtzdGF0QXJyYXlbc2ldLmxhYmVsXSA6IE9iamVjdC52YWx1ZXMoc3RhdEFycmF5W3NpXSkpOyAvLyBwdXNoIHRoZSBzdGF0cyBmb3IgdGhpcyBjdXJ2ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBkaSA9IDA7IGRpIDwgZGF0YUFycmF5Lmxlbmd0aDsgZGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhU3ViQXJyYXkgPSBPYmplY3QudmFsdWVzKGRhdGFBcnJheVtkaV0pO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSGVhZGVyID0gZGF0YVN1YkFycmF5WzBdID09PSB1bmRlZmluZWQgPyBzdGF0QXJyYXlbZGldLmxhYmVsIDogT2JqZWN0LmtleXMoZGF0YVN1YkFycmF5WzBdKTtcbiAgICAgICAgICAgICAgICAvL2RhdGFIZWFkZXJbMF0gPSAnbGFiZWwnO1xuICAgICAgICAgICAgICAgIGRhdGFIZWFkZXJbMF0gPSBkYXRhU3ViQXJyYXlbMF0gPT09IHVuZGVmaW5lZCA/IFwiTk8gREFUQVwiIDogT2JqZWN0LmtleXMoZGF0YVN1YkFycmF5WzBdKS5maWx0ZXIoa2V5ID0+IGtleS5pbmRleE9mKCdDdXJ2ZScpICE9IC0xKVswXTtcbiAgICAgICAgICAgICAgICBkYXRhUmVzdWx0QXJyYXkucHVzaChkYXRhSGVhZGVyKTsgLy8gcHVzaCB0aGlzIGN1cnZlIGRhdGEgaGVhZGVyIChrZXlzKVxuICAgICAgICAgICAgICAgIGlmIChkYXRhU3ViQXJyYXlbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZHNpID0gMDsgZHNpIDwgZGF0YVN1YkFycmF5Lmxlbmd0aDsgZHNpKyspIHsgIC8vIHB1c2ggdGhpcyBjdXJ2ZXMgZGF0YVxuICAgICAgICAgICAgICAgICAgICBkYXRhUmVzdWx0QXJyYXkucHVzaChPYmplY3QudmFsdWVzKGRhdGFTdWJBcnJheVtkc2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gXCJtYXRzcGxvdC1cIiArIG1vbWVudC51dGMoKS5mb3JtYXQoJ1lZWVlNTURELUhILm1tLnNzJykgKyBcIi5jc3ZcIjtcbiAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtZGlzcG9zaXRpb24nLCAnYXR0YWNobWVudDsgZmlsZW5hbWU9JyArIGZpbGVOYW1lKTtcbiAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhdHRhY2htZW50LkNvbnRlbnRUeXBlJyk7XG4gICAgICAgICAgICBzdHJpbmdpZnkoc3RhdFJlc3VsdEFycmF5LCB7aGVhZGVyOiB0cnVlfSwgZnVuY3Rpb24gKGVyciwgb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVycm9yIGluIF9nZXRDU1Y6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy53cml0ZShcImVycm9yLFwiICsgZXJyLnRvTG9jYWxlU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXMuZW5kKFwiPGJvZHk+PGgxPl9nZXRDU1YgRXJyb3IhIFwiICsgZXJyLnRvTG9jYWxlU3RyaW5nKCkgKyBcIjwvaDE+PC9ib2R5PlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMud3JpdGUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZGF0YVJlc3VsdEFycmF5LCB7aGVhZGVyOiB0cnVlfSwgZnVuY3Rpb24gKGVyciwgb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXJyb3IgaW4gX2dldENTVjpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy53cml0ZShcImVycm9yLFwiICsgZXJyLnRvTG9jYWxlU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmVuZChcIjxib2R5PjxoMT5fZ2V0Q1NWIEVycm9yISBcIiArIGVyci50b0xvY2FsZVN0cmluZygpICsgXCI8L2gxPjwvYm9keT5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzLndyaXRlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0UmVzdWx0QXJyYXk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFSZXN1bHRBcnJheTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3IgcmV0cmlldmluZyBkYXRhOiAnLCBlKTtcbiAgICAgICAgICAgIGNzdiA9IFwiZXJyb3IsXCIgKyBlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LWRpc3Bvc2l0aW9uJywgJ2F0dGFjaG1lbnQ7IGZpbGVuYW1lPW1hdHNwbG90LmNzdicpO1xuICAgICAgICAgICAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ2F0dGFjaG1lbnQuQ29udGVudFR5cGUnKTtcbiAgICAgICAgICAgIHJlcy5lbmQoXCI8Ym9keT48aDE+X2dldENTViBFcnJvciEgXCIgKyBjc3YgKyBcIjwvaDE+PC9ib2R5PlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIHByaXZhdGUgbWlkZGxld2FyZSBmb3IgX2dldEpTT04gcm91dGVcbmNvbnN0IF9nZXRKU09OID0gZnVuY3Rpb24gKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgIHZhciBmbGF0SlNPTiA9IFwiXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2dldFBhZ2VuYXRlZERhdGEocGFyYW1zLmtleSwgMCwgLTEwMDApO1xuICAgICAgICAgICAgZmxhdEpTT04gPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3IgcmV0cmlldmluZyBkYXRhOiAnLCBlKTtcbiAgICAgICAgICAgIGZsYXRKU09OID0gSlNPTi5zdHJpbmdpZnkoe2Vycm9yOiBlfSk7XG4gICAgICAgICAgICBkZWxldGUgZmxhdEpTT04uZHNpUmVhbFBhZ2VJbmRleDtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGF0SlNPTi5kc2lUZXh0RGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIHJlcy53cml0ZShmbGF0SlNPTik7XG4gICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgZGVsZXRlIGZsYXRKU09OO1xuICAgICAgICBkZWxldGUgcmVzdWx0O1xuICAgIH1cbn07XG5cbi8vIHByaXZhdGUgbWV0aG9kIGZvciBnZXR0aW5nIHBhZ2VuYXRlZCByZXN1bHRzIGFuZCBmbGF0dGVuaW5nIHRoZW0gaW4gb3JkZXIgdG8gYmUgYXBwcm9wcmlhdGUgZm9yIHRleHQgZGlzcGxheS5cbmNvbnN0IF9nZXRGbGF0dGVuZWRSZXN1bHREYXRhID0gZnVuY3Rpb24gKHJrLCBwLCBucCkge1xuICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgdmFyIHJlc3A7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgciA9IHJrO1xuICAgICAgICAgICAgdmFyIHAgPSBwO1xuICAgICAgICAgICAgdmFyIG5wID0gbnA7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHBhZ2VuYXRlZCBkYXRhXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2dldFBhZ2VuYXRlZERhdGEociwgcCwgbnApO1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgdHlwZVxuICAgICAgICAgICAgdmFyIHBsb3RUeXBlcyA9IHJlc3VsdC5iYXNpcy5wbG90UGFyYW1zLnBsb3RUeXBlcztcbiAgICAgICAgICAgIHZhciBwbG90VHlwZSA9IChfLmludmVydChwbG90VHlwZXMpKVt0cnVlXTtcbiAgICAgICAgICAgIC8vIGV4dHJhY3QgZGF0YVxuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgIHZhciBkc2lSZWFsUGFnZUluZGV4ID0gcmVzdWx0LmRzaVJlYWxQYWdlSW5kZXg7XG4gICAgICAgICAgICB2YXIgZHNpVGV4dERpcmVjdGlvbiA9IHJlc3VsdC5kc2lUZXh0RGlyZWN0aW9uO1xuICAgICAgICAgICAgc3dpdGNoIChwbG90VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy50aW1lU2VyaWVzOlxuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kYWlseU1vZGVsQ3ljbGU6XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5EYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuc3RhdHMgPSB7fTsgICAvLyBtYXAgb2YgbWFwc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhLmRhdGEgPSB7fTsgIC8vIG1hcCBvZiBhcnJheXMgb2YgbWFwc1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhIGlzXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZTA6IHtsYWJlbDpzb21lTGFiZWwsIG1lYW46c29tZU1lYW4sc2Q6c29tZVNkLi4uLn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlMToge2xhYmVsOnNvbWVMYWJlbCwgbWVhbjpzb21lTWVhbixzZDpzb21lU2QuLi4ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlMDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RpbWU6c29tZVRpbWUsIHN0YXQ6IHNvbWVTdGF0LCBzZDogc29tZVNkLC4uLi59LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RpbWU6c29tZVRpbWUsIHN0YXQ6IHNvbWVTdGF0LCBzZDogc29tZVNkLC4uLi59LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUxOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGltZTpzb21lVGltZSwgc3RhdDogc29tZVN0YXQsIHNkOiBzb21lU2QsLi4uLn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGltZTpzb21lVGltZSwgc3RhdDogc29tZVN0YXQsIHNkOiBzb21lU2QsLi4uLn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgZGF0YS5sZW5ndGg7IGNpKyspIHsgLy8gZm9yIGVhY2ggY3VydmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJ2ZSBsYWJlbCBpcyBhIHJlc2VydmVkIHdvcmQgZG8gbm90IHByb2Nlc3MgdGhlIGN1cnZlIChpdHMgYSB6ZXJvIG9yIG1heCBjdXJ2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNlcnZlZFdvcmRzID0gT2JqZWN0LnZhbHVlcyhtYXRzVHlwZXMuUmVzZXJ2ZWRXb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzZXJ2ZWRXb3Jkcy5pbmRleE9mKGRhdGFbY2ldLmxhYmVsKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGRvbid0IHByb2Nlc3MgdGhlIHplcm8gb3IgbWF4IGN1cnZlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1snbGFiZWwnXSA9IGRhdGFbY2ldLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21lYW4nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMuZF9tZWFuO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ3N0YW5kYXJkIGRldmlhdGlvbiddID0gZGF0YVtjaV0uZ2xvYl9zdGF0cy5zZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzWyduJ10gPSBkYXRhW2NpXS5nbG9iX3N0YXRzLm5fZ29vZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzWydzdGFuZGFyZCBlcnJvciddID0gZGF0YVtjaV0uZ2xvYl9zdGF0cy5zdGRlX2JldHN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ2xhZzEnXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMubGFnMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzWydtaW5pbXVtJ10gPSBkYXRhW2NpXS5nbG9iX3N0YXRzLm1pblZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzWydtYXhpbXVtJ10gPSBkYXRhW2NpXS5nbG9iX3N0YXRzLm1heFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuc3RhdHNbZGF0YVtjaV0ubGFiZWxdID0gc3RhdHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJ2ZURhdGEgPSBbXTsgIC8vIG1hcCBvZiBtYXBzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjZGkgPSAwOyBjZGkgPCBkYXRhW2NpXS54Lmxlbmd0aDsgY2RpKyspIHsgLy9mb3IgZWFjaCBkYXRhcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VydmVEYXRhRWxlbWVudCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbZGF0YVtjaV0ubGFiZWwgKyAnIHRpbWUnXSA9IGRhdGFbY2ldLnhbY2RpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50WydyYXcgc3RhdCBmcm9tIHF1ZXJ5J10gPSBkYXRhW2NpXS5zdGF0c1tjZGldLnJhd19zdGF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbJ3Bsb3R0ZWQgc3RhdCddID0gZGF0YVtjaV0ueVtjZGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbJ3N0ZCBkZXYnXSA9IGRhdGFbY2ldLnN0YXRzW2NkaV0uc2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnc3RkIGVycm9yJ10gPSBkYXRhW2NpXS5zdGF0c1tjZGldLnN0ZGVfYmV0c3k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnbGFnMSddID0gZGF0YVtjaV0uc3RhdHNbY2RpXS5sYWcxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbJ24nXSA9IGRhdGFbY2ldLnN0YXRzW2NkaV0ubl9nb29kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YS5wdXNoKGN1cnZlRGF0YUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5kYXRhW2RhdGFbY2ldLmxhYmVsXSA9IGN1cnZlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMucHJvZmlsZTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybkRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5zdGF0cyA9IHt9OyAgIC8vIG1hcCBvZiBtYXBzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuZGF0YSA9IHt9OyAgLy8gbWFwIG9mIGFycmF5cyBvZiBtYXBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGRhdGEubGVuZ3RoOyBjaSsrKSB7ICAvLyBmb3IgZWFjaCBjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2VydmVkV29yZHMgPSBPYmplY3QudmFsdWVzKG1hdHNUeXBlcy5SZXNlcnZlZFdvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNlcnZlZFdvcmRzLmluZGV4T2YoZGF0YVtjaV0ubGFiZWwpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gZG9uJ3QgcHJvY2VzcyB0aGUgemVybyBvciBtYXggY3VydmVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzWydsYWJlbCddID0gZGF0YVtjaV0ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1snbWVhbiddID0gZGF0YVtjaV0uZ2xvYl9zdGF0cy5kX21lYW47XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1snc3RhbmRhcmQgZGV2aWF0aW9uJ10gPSBkYXRhW2NpXS5nbG9iX3N0YXRzLnNkO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ24nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMubl9nb29kO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ3N0YW5kYXJkIGVycm9yJ10gPSBkYXRhW2NpXS5nbG9iX3N0YXRzLnN0ZGVfYmV0c3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1snbGFnMSddID0gZGF0YVtjaV0uZ2xvYl9zdGF0cy5sYWcxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21pbmltdW0nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMubWluVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21heGltdW0nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMubWF4VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5zdGF0c1tkYXRhW2NpXS5sYWJlbF0gPSBzdGF0cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkYXRhID0gZGF0YVtjaV0uZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJ2ZURhdGEgPSBbXTsgIC8vIGFycmF5IG9mIG1hcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNkaSA9IDA7IGNkaSA8IGRhdGFbY2ldLngubGVuZ3RoOyBjZGkrKykgeyAgLy8gZm9yIGVhY2ggZGF0YXBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnZlRGF0YUVsZW1lbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50W2RhdGFbY2ldLmxhYmVsICsgJyBsZXZlbCddID0gZGF0YVtjaV0ueVtjZGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbJ3JhdyBzdGF0IGZyb20gcXVlcnknXSA9IGRhdGFbY2ldLnN0YXRzW2NkaV0ucmF3X3N0YXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsncGxvdHRlZCBzdGF0J10gPSBkYXRhW2NpXS54W2NkaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnc3RkIGRldiddID0gZGF0YVtjaV0uc3RhdHNbY2RpXS5zZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50WydzdGQgZXJyb3InXSA9IGRhdGFbY2ldLnN0YXRzW2NkaV0uc3RkZV9iZXRzeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50WydsYWcxJ10gPSBkYXRhW2NpXS5zdGF0c1tjZGldLmxhZzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnbiddID0gZGF0YVtjaV0uc3RhdHNbY2RpXS5uX2dvb2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhLnB1c2goY3VydmVEYXRhRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhLmRhdGFbZGF0YVtjaV0ubGFiZWxdID0gY3VydmVEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kaWVvZmY6XG4gICAgICAgICAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRocmVzaG9sZDpcbiAgICAgICAgICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMudmFsaWR0aW1lOlxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxTdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGxvdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kaWVvZmY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxTdWZmaXggPSBcIiBmb3JlY2FzdCBsZWFkIHRpbWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy52YWxpZHRpbWU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxTdWZmaXggPSBcIiBob3VyIG9mIGRheVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRocmVzaG9sZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFN1ZmZpeCA9IFwiIHRocmVzaG9sZCAoaW4pXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybkRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5zdGF0cyA9IHt9OyAgIC8vIG1hcCBvZiBtYXBzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuZGF0YSA9IHt9OyAgLy8gbWFwIG9mIGFycmF5cyBvZiBtYXBzXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGRhdGEubGVuZ3RoOyBjaSsrKSB7ICAvLyBmb3IgZWFjaCBjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2VydmVkV29yZHMgPSBPYmplY3QudmFsdWVzKG1hdHNUeXBlcy5SZXNlcnZlZFdvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNlcnZlZFdvcmRzLmluZGV4T2YoZGF0YVtjaV0ubGFiZWwpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gZG9uJ3QgcHJvY2VzcyB0aGUgemVybyBvciBtYXggY3VydmVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzWydsYWJlbCddID0gZGF0YVtjaV0ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1snbWVhbiddID0gZGF0YVtjaV0uZ2xvYl9zdGF0cy5kX21lYW47XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1snc3RhbmRhcmQgZGV2aWF0aW9uJ10gPSBkYXRhW2NpXS5nbG9iX3N0YXRzLnNkO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ24nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMubl9nb29kO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21pbmltdW0nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMubWluVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21heGltdW0nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMubWF4VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5zdGF0c1tkYXRhW2NpXS5sYWJlbF0gPSBzdGF0cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnZlRGF0YSA9IFtdOyAgLy8gbWFwIG9mIG1hcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNkaSA9IDA7IGNkaSA8IGRhdGFbY2ldLngubGVuZ3RoOyBjZGkrKykgeyAgLy8gZm9yIGVhY2ggZGF0YXBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnZlRGF0YUVsZW1lbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50W2RhdGFbY2ldLmxhYmVsICsgbGFiZWxTdWZmaXhdID0gZGF0YVtjaV0ueFtjZGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbJ3JhdyBzdGF0IGZyb20gcXVlcnknXSA9IGRhdGFbY2ldLnN0YXRzW2NkaV0ucmF3X3N0YXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsncGxvdHRlZCBzdGF0J10gPSBkYXRhW2NpXS55W2NkaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnc3RkIGRldiddID0gZGF0YVtjaV0uc3RhdHNbY2RpXS5zZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50WyduJ10gPSBkYXRhW2NpXS5zdGF0c1tjZGldLm5fZ29vZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGEucHVzaChjdXJ2ZURhdGFFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuZGF0YVtkYXRhW2NpXS5sYWJlbF0gPSBjdXJ2ZURhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnJlbGlhYmlsaXR5OlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuRGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhLnN0YXRzID0ge307ICAgLy8gbWFwIG9mIG1hcHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5kYXRhID0ge307ICAvLyBtYXAgb2YgYXJyYXlzIG9mIG1hcFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgZGF0YS5sZW5ndGg7IGNpKyspIHsgIC8vIGZvciBlYWNoIGN1cnZlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzZXJ2ZWRXb3JkcyA9IE9iamVjdC52YWx1ZXMobWF0c1R5cGVzLlJlc2VydmVkV29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2VydmVkV29yZHMuaW5kZXhPZihkYXRhW2NpXS5sYWJlbCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBkb24ndCBwcm9jZXNzIHRoZSB6ZXJvIG9yIG1heCBjdXJ2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ2xhYmVsJ10gPSBkYXRhW2NpXS5sYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzWydzYW1wbGUgY2xpbW8nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMuc2FtcGxlX2NsaW1vO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5zdGF0c1tkYXRhW2NpXS5sYWJlbF0gPSBzdGF0cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkYXRhID0gZGF0YVtjaV0uZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJ2ZURhdGEgPSBbXTsgIC8vIGFycmF5IG9mIG1hcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNkaSA9IDA7IGNkaSA8IGRhdGFbY2ldLnkubGVuZ3RoOyBjZGkrKykgeyAgLy8gZm9yIGVhY2ggZGF0YXBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnZlRGF0YUVsZW1lbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50W2RhdGFbY2ldLmxhYmVsICsgJyBwcm9iYWJpbGl0eSBiaW4nXSA9IGRhdGFbY2ldLnN0YXRzW2NkaV0ucHJvYl9iaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnaGl0IHJhdGUnXSA9IGRhdGFbY2ldLnN0YXRzW2NkaV0uaGl0X3JhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnb3knXSA9IGRhdGFbY2ldLnN0YXRzW2NkaV0ub2JzX3k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnb24nXSA9IGRhdGFbY2ldLnN0YXRzW2NkaV0ub2JzX247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhLnB1c2goY3VydmVEYXRhRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhLmRhdGFbZGF0YVtjaV0ubGFiZWxdID0gY3VydmVEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5tYXA6XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5EYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuc3RhdHMgPSB7fTsgICAvLyBtYXAgb2YgbWFwc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhLmRhdGEgPSB7fTsgIC8vIG1hcCBvZiBhcnJheXMgb2YgbWFwc1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBzdGF0c1snbGFiZWwnXSA9IGRhdGFbMF0ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzWyd0b3RhbCBudW1iZXIgb2Ygb2JzJ10gPSBkYXRhWzBdLnN0YXRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBjdXJyLk5fdGltZXM7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICBzdGF0c1snbWVhbiBkaWZmZXJlbmNlJ10gPSBtYXRzRGF0YVV0aWxzLmF2ZXJhZ2UoZGF0YVswXS5xdWVyeVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzWydzdGFuZGFyZCBkZXZpYXRpb24nXSA9IG1hdHNEYXRhVXRpbHMuc3RkZXYoZGF0YVswXS5xdWVyeVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzWydtaW5pbXVtIHRpbWUnXSA9IGRhdGFbMF0uc3RhdHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHByZXYgPCBjdXJyLm1pbl90aW1lID8gcHJldiA6IGN1cnIubWluX3RpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21pbmltdW0gdGltZSddID0gbW9tZW50LnV0YyhzdGF0c1snbWluaW11bSB0aW1lJ10gKiAxMDAwKS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW0nKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21heGltdW0gdGltZSddID0gZGF0YVswXS5zdGF0cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocHJldiA+IGN1cnIubWF4X3RpbWUgPyBwcmV2IDogY3Vyci5tYXhfdGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0c1snbWF4aW11bSB0aW1lJ10gPSBtb21lbnQudXRjKHN0YXRzWydtYXhpbXVtIHRpbWUnXSAqIDEwMDApLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbScpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuc3RhdHNbZGF0YVswXS5sYWJlbF0gPSBzdGF0cztcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VydmVEYXRhID0gW107ICAvLyBtYXAgb2YgbWFwc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgZGF0YVswXS5zaXRlTmFtZS5sZW5ndGg7IHNpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJ2ZURhdGFFbGVtZW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50WydTaXRlIE5hbWUnXSA9IGRhdGFbMF0uc2l0ZU5hbWVbc2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnTnVtYmVyIG9mIFRpbWVzJ10gPSBkYXRhWzBdLnN0YXRzW3NpXS5OX3RpbWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnU3RhcnQgRGF0ZSddID0gbW9tZW50LnV0YygoZGF0YVswXS5zdGF0c1tzaV0ubWluX3RpbWUpICogMTAwMCkuZm9ybWF0KCdZWVlZLU1NLUREIEhIOm1tJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50WydFbmQgRGF0ZSddID0gbW9tZW50LnV0YygoZGF0YVswXS5zdGF0c1tzaV0ubWF4X3RpbWUpICogMTAwMCkuZm9ybWF0KCdZWVlZLU1NLUREIEhIOm1tJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50WydBdmVyYWdlIERpZmZlcmVuY2UnXSA9IGRhdGFbMF0ucXVlcnlWYWxbc2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhLnB1c2goY3VydmVEYXRhRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5kYXRhW2RhdGFbMF0ubGFiZWxdID0gY3VydmVEYXRhO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMuaGlzdG9ncmFtOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuRGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhLnN0YXRzID0ge307ICAgLy8gbWFwIG9mIG1hcHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5kYXRhID0ge307ICAvLyBtYXAgb2YgYXJyYXlzIG9mIG1hcHNcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgZGF0YS5sZW5ndGg7IGNpKyspIHsgLy8gZm9yIGVhY2ggY3VydmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNlcnZlZFdvcmRzID0gT2JqZWN0LnZhbHVlcyhtYXRzVHlwZXMuUmVzZXJ2ZWRXb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzZXJ2ZWRXb3Jkcy5pbmRleE9mKGRhdGFbY2ldLmxhYmVsKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGRvbid0IHByb2Nlc3MgdGhlIHplcm8gb3IgbWF4IGN1cnZlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1snbGFiZWwnXSA9IGRhdGFbY2ldLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21lYW4nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMuZ2xvYl9tZWFuO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ3N0YW5kYXJkIGRldmlhdGlvbiddID0gZGF0YVtjaV0uZ2xvYl9zdGF0cy5nbG9iX3NkO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ24nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMuZ2xvYl9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21pbmltdW0nXSA9IGRhdGFbY2ldLmdsb2Jfc3RhdHMuZ2xvYl9taW47XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1snbWF4aW11bSddID0gZGF0YVtjaV0uZ2xvYl9zdGF0cy5nbG9iX21heDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuc3RhdHNbZGF0YVtjaV0ubGFiZWxdID0gc3RhdHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJ2ZURhdGEgPSBbXTsgIC8vIG1hcCBvZiBtYXBzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjZGkgPSAwOyBjZGkgPCBkYXRhW2NpXS54Lmxlbmd0aDsgY2RpKyspIHsgICAvLyBmb3IgZWFjaCBkYXRhcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VydmVEYXRhRWxlbWVudCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbZGF0YVtjaV0ubGFiZWwgKyAnIGJpbiByYW5nZSddID0gZGF0YVtjaV0uYmluX3N0YXRzW2NkaV1bJ2JpbkxhYmVsJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnbiddID0gZGF0YVtjaV0uYmluX3N0YXRzW2NkaV0uYmluX247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnYmluIHJlbCBmcmVxJ10gPSBkYXRhW2NpXS5iaW5fc3RhdHNbY2RpXS5iaW5fcmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnYmluIGxvd2VyIGJvdW5kJ10gPSBkYXRhW2NpXS5iaW5fc3RhdHNbY2RpXS5iaW5Mb3dCb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50WydiaW4gdXBwZXIgYm91bmQnXSA9IGRhdGFbY2ldLmJpbl9zdGF0c1tjZGldLmJpblVwQm91bmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnYmluIG1lYW4nXSA9IGRhdGFbY2ldLmJpbl9zdGF0c1tjZGldLmJpbl9tZWFuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbJ2JpbiBzdGQgZGV2J10gPSBkYXRhW2NpXS5iaW5fc3RhdHNbY2RpXS5iaW5fc2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhLnB1c2goY3VydmVEYXRhRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhLmRhdGFbZGF0YVtjaV0ubGFiZWxdID0gY3VydmVEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5jb250b3VyOlxuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5jb250b3VyRGlmZjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybkRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5zdGF0cyA9IHt9OyAgIC8vIG1hcCBvZiBtYXBzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuZGF0YSA9IHt9OyAgLy8gbWFwIG9mIGFycmF5cyBvZiBtYXBzXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBzdGF0c1snbGFiZWwnXSA9IGRhdGFbMF0ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzWyd0b3RhbCBudW1iZXIgb2YgcG9pbnRzJ10gPSBkYXRhWzBdLmdsb2Jfc3RhdHMubjtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21lYW4gc3RhdCddID0gZGF0YVswXS5nbG9iX3N0YXRzLm1lYW47XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzWydtaW5pbXVtIHRpbWUnXSA9IGRhdGFbMF0uZ2xvYl9zdGF0cy5taW5EYXRlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0c1snbWluaW11bSB0aW1lJ10gPSBtb21lbnQudXRjKHN0YXRzWydtaW5pbXVtIHRpbWUnXSAqIDEwMDApLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbScpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0c1snbWF4aW11bSB0aW1lJ10gPSBkYXRhWzBdLmdsb2Jfc3RhdHMubWF4RGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHNbJ21heGltdW0gdGltZSddID0gbW9tZW50LnV0YyhzdGF0c1snbWF4aW11bSB0aW1lJ10gKiAxMDAwKS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW0nKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhLnN0YXRzW2RhdGFbMF0ubGFiZWxdID0gc3RhdHM7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnZlRGF0YSA9IFtdOyAgLy8gbWFwIG9mIG1hcHNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IGRhdGFbMF0ueFRleHRPdXRwdXQubGVuZ3RoOyBzaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VydmVEYXRhRWxlbWVudCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsneFZhbCddID0gZGF0YVswXS54VGV4dE91dHB1dFtzaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50Wyd5VmFsJ10gPSBkYXRhWzBdLnlUZXh0T3V0cHV0W3NpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbJ3N0YXQnXSA9IGRhdGFbMF0uelRleHRPdXRwdXRbc2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVEYXRhRWxlbWVudFsnTiddID0gZGF0YVswXS5uVGV4dE91dHB1dFtzaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZURhdGFFbGVtZW50WydTdGFydCBEYXRlJ10gPSBtb21lbnQudXRjKChkYXRhWzBdLm1pbkRhdGVUZXh0T3V0cHV0W3NpXSkgKiAxMDAwKS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YUVsZW1lbnRbJ0VuZCBEYXRlJ10gPSBtb21lbnQudXRjKChkYXRhWzBdLm1heERhdGVUZXh0T3V0cHV0W3NpXSkgKiAxMDAwKS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlRGF0YS5wdXNoKGN1cnZlRGF0YUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEuZGF0YVtkYXRhWzBdLmxhYmVsXSA9IGN1cnZlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybkRhdGEgPSB7fTsgLy8gcmV0dXJucyBhIG1hcCBvZiBhcnJheXMgb2YgbWFwc1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUwOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4dmFsOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5dmFsOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0Zml0OiBudW1iZXIgfHwgbm9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh2YWw6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHl2YWw6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RmaXQ6IG51bWJlciB8fCBub25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlMTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeHZhbDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeXZhbDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdGZpdDogbnVtYmVyIHx8IG5vbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4dmFsOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5dmFsOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0Zml0OiBudW1iZXIgfHwgbm9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RCZXN0Rml0SW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlc3RGaXRJbmRleGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBkYXRhLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNpID09IGZpcnN0QmVzdEZpdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJlc3QgZml0IGN1cnZlcyBhcmUgYXQgdGhlIGVuZCBzbyBkbyBub3QgZG8gZnVydGhlciBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VydmVEYXRhID0gZGF0YVtjaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29rIGZvciBhIGJlc3QgZml0IGN1cnZlIC0gb25seSBoYXZlIHRvIGxvb2sgYXQgY3VydmVzIHdpdGggaGlnaGVyIGluZGV4IHRoYW4gdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZXN0Rml0SW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNiaSA9IGNpICsgMTsgY2JpIDwgZGF0YS5sZW5ndGg7IGNiaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoZGF0YVtjYmldLmxhYmVsKS5pbmRleE9mKGN1cnZlRGF0YS5sYWJlbCkgIT09IC0xKSAmJiAoKGRhdGFbY2JpXS5sYWJlbCkuaW5kZXhPZihcIi1iZXN0IGZpdFwiKSAhPSAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZpdEluZGV4ZXNbY2ldID0gY2JpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RCZXN0Rml0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0QmVzdEZpdEluZGV4ID0gY2JpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJ2ZVRleHREYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjZGkgPSAwOyBjZGkgPCBjdXJ2ZURhdGEuZGF0YS5sZW5ndGg7IGNkaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Wyd4QXhpcyddID0gY3VydmVEYXRhLmRhdGFbY2RpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Wyd5QXhpcyddID0gY3VydmVEYXRhLmRhdGFbY2RpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdEZpdEluZGV4ZXNbY2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFsnYmVzdCBmaXQnXSA9IFwibm9uZTtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbJ2Jlc3QgZml0J10gPSBkYXRhW2Jlc3RGaXRJbmRleGVzW2NpXV0uZGF0YVtjZGldWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZVRleHREYXRhLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhW2N1cnZlRGF0YS5sYWJlbF0gPSBjdXJ2ZVRleHREYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5EYXRhLmRzaVJlYWxQYWdlSW5kZXggPSBkc2lSZWFsUGFnZUluZGV4O1xuICAgICAgICAgICAgcmV0dXJuRGF0YS5kc2lUZXh0RGlyZWN0aW9uID0gZHNpVGV4dERpcmVjdGlvbjtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5EYXRhO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKFwiRXJyb3IgaW4gX2dldEZsYXR0ZW5lZFJlc3VsdERhdGEgZnVuY3Rpb246IFwiICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBwcml2YXRlIG1ldGhvZCBmb3IgZ2V0dGluZyBwYWdlbmF0ZWQgZGF0YVxuLy8gYSBuZXdQYWdlSW5kZXggb2YgLTEwMDAgbWVhbnMgZ2V0IGFsbCB0aGUgZGF0YSAodXNlZCBmb3IgZXhwb3J0KVxuLy8gYSBuZXdQYWdlSW5kZXggb2YgLTIwMDAgbWVhbnMgZ2V0IGp1c3QgdGhlIGxhc3QgcGFnZVxuY29uc3QgX2dldFBhZ2VuYXRlZERhdGEgPSBmdW5jdGlvbiAocmt5LCBwLCBucCkge1xuICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgdmFyIGtleSA9IHJreTtcbiAgICAgICAgdmFyIG15UGFnZUluZGV4ID0gcDtcbiAgICAgICAgdmFyIG5ld1BhZ2VJbmRleCA9IG5wO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICB2YXIgcmF3UmV0dXJuO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbWF0c0NhY2hlLmdldFJlc3VsdChrZXkpO1xuICAgICAgICAgICAgcmF3UmV0dXJuID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZXN1bHQucmVzdWx0OyAvLyBnZXRSZXN1bHQgc3RydWN0dXJlIGlzIHtrZXk6c29tZXRoaW5nLCByZXN1bHQ6cmVzdWx0T2JqZWN0fVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIl9nZXRQYWdlbmF0ZWREYXRhOiBFcnJvciAtIFwiLCBlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gcmF3UmV0dXJuID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJhd1JldHVybikpO1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAxO1xuICAgICAgICBpZiAobmV3UGFnZUluZGV4ID09PSAtMTAwMCkge1xuICAgICAgICAgICAgLy8gYWxsIHRoZSBkYXRhXG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICBlbmQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9IGVsc2UgaWYgKG5ld1BhZ2VJbmRleCA9PT0gLTIwMDApIHtcbiAgICAgICAgICAgIC8vIGp1c3QgdGhlIGxhc3QgcGFnZVxuICAgICAgICAgICAgc3RhcnQgPSAtMjAwMDtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKG15UGFnZUluZGV4IDw9IG5ld1BhZ2VJbmRleCkge1xuICAgICAgICAgICAgLy8gcHJvY2VlZCBmb3J3YXJkXG4gICAgICAgICAgICBzdGFydCA9IChuZXdQYWdlSW5kZXggLSAxKSAqIDEwMDtcbiAgICAgICAgICAgIGVuZCA9IG5ld1BhZ2VJbmRleCAqIDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1vdmUgYmFja1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICBzdGFydCA9IG5ld1BhZ2VJbmRleCAqIDEwMDtcbiAgICAgICAgICAgIGVuZCA9IChuZXdQYWdlSW5kZXggKyAxKSAqIDEwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkc2lTdGFydDtcbiAgICAgICAgdmFyIGRzaUVuZDtcbiAgICAgICAgZm9yICh2YXIgY3NpID0gMDsgY3NpIDwgcmV0LmRhdGEubGVuZ3RoOyBjc2krKykge1xuICAgICAgICAgICAgaWYgKHJldC5kYXRhW2NzaV0ueCA9PSBudWxsIHx8IHJldC5kYXRhW2NzaV0ueC5sZW5ndGggPD0gMTAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIGRvbid0IGJvdGhlciBwYWdlbmF0aW5nIGRhdGFzZXRzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBhIHBhZ2UgLSByZXQgaXMgcmF3UmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkc2lTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgZHNpRW5kID0gZW5kO1xuICAgICAgICAgICAgaWYgKGRzaVN0YXJ0ID4gcmV0LmRhdGFbY3NpXS54Lmxlbmd0aCB8fCBkc2lTdGFydCA9PT0gLTIwMDApIHtcbiAgICAgICAgICAgICAgICAvLyBzaG93IHRoZSBsYXN0IHBhZ2UgaWYgd2UgZWl0aGVyIHJlcXVlc3RlZCBpdCBzcGVjaWZpY2FsbHkgb3IgYXJlIHRyeWluZyB0byBuYXZpZ2F0ZSBwYXN0IGl0XG4gICAgICAgICAgICAgICAgZHNpU3RhcnQgPSBNYXRoLmZsb29yKHJhd1JldHVybi5kYXRhW2NzaV0ueC5sZW5ndGggLyAxMDApICogMTAwO1xuICAgICAgICAgICAgICAgIGRzaUVuZCA9IHJhd1JldHVybi5kYXRhW2NzaV0ueC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGRzaUVuZCA9PT0gZHNpU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBsYXN0IHBhZ2UgaXNuJ3QgZW1wdHktLWlmIHJhd1JldHVybi5kYXRhW2NzaV0uZGF0YS5sZW5ndGgvMTAwIHByb2R1Y2VzIGEgd2hvbGUgbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAvLyBkc2lTdGFydCBhbmQgZHNpRW5kIHdvdWxkIGJlIHRoZSBzYW1lLiBUaGlzIG1ha2VzIHN1cmUgdGhhdCB0aGUgbGFzdCBmdWxsIHBhZ2UgaXMgaW5kZWVkIHRoZSBsYXN0IHBhZ2UsIHdpdGhvdXQgYSBwaGFudG9tIGVtcHR5IHBhZ2UgYWZ0ZXJ3YXJkc1xuICAgICAgICAgICAgICAgICAgICBkc2lTdGFydCA9IGRzaUVuZCAtIDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHNpU3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdyB0aGUgZmlyc3QgcGFnZSBpZiB3ZSBhcmUgdHJ5aW5nIHRvIG5hdmlnYXRlIGJlZm9yZSBpdFxuICAgICAgICAgICAgICAgIGRzaVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBkc2lFbmQgPSAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHNpRW5kIDwgZHNpU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgZW5kIGlzIGFmdGVyIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgIGRzaUVuZCA9IGRzaVN0YXJ0ICsgMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRzaUVuZCA+IHJldC5kYXRhW2NzaV0ueC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgcmVxdWVzdCBwYXN0IHRoZSBlbmQgLS0gaWYgcmVzdWx0cyBhcmUgb25lIHBhZ2UsIHRoaXMgc2hvdWxkIGNvbnZlcnQgdGhlXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYW5kIGVuZCBmcm9tIDAgYW5kIDEwMCB0byAwIGFuZCB3aGF0ZXZlciB0aGUgZW5kIGlzLlxuICAgICAgICAgICAgICAgIGRzaUVuZCA9IHJldC5kYXRhW2NzaV0ueC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQuZGF0YVtjc2ldLnggPSByYXdSZXR1cm4uZGF0YVtjc2ldLnguc2xpY2UoZHNpU3RhcnQsIGRzaUVuZCk7XG4gICAgICAgICAgICByZXQuZGF0YVtjc2ldLnkgPSByYXdSZXR1cm4uZGF0YVtjc2ldLnkuc2xpY2UoZHNpU3RhcnQsIGRzaUVuZCk7XG4gICAgICAgICAgICByZXQuZGF0YVtjc2ldLnN0YXRzID0gcmF3UmV0dXJuLmRhdGFbY3NpXS5zdGF0cy5zbGljZShkc2lTdGFydCwgZHNpRW5kKTtcbiAgICAgICAgICAgIHJldC5kYXRhW2NzaV0uZ2xvYl9zdGF0cyA9IHJhd1JldHVybi5kYXRhW2NzaV0uZ2xvYl9zdGF0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSByYXdSZXR1cm47XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgIHJldC5kc2lSZWFsUGFnZUluZGV4ID0gTWF0aC5mbG9vcihkc2lFbmQgLyAxMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0LmRzaVJlYWxQYWdlSW5kZXggPSBNYXRoLmZsb29yKGRzaVN0YXJ0IC8gMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXQuZHNpVGV4dERpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59O1xuXG4vL3ByaXZhdGUgbWlkZGxld2FyZSBmb3IgZ2V0dGluZyBtZXR2aWV3ZXIgZGF0YSBmaWxlXG5jb25zdCBfbXZHZXREYXRhID0gZnVuY3Rpb24ocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgIGNvbnN0IGZzZSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IE1WX0RJUlMuREFUQURJUjtcbiAgICBjb25zdCBiYXNlTmFtZSA9IHBhcmFtcy5rZXkgKyBcIi5kYXRhXCI7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBmaWxlUGF0aCArICcvJyArIGJhc2VOYW1lO1xuICAgIHRyeSB7XG4gICAgICAgIGZzZS5yZWFkRmlsZShmaWxlTmFtZSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpXG4gICAgICAgICAgICBpZiAoZXJyKSB7Y29uc29sZS5sb2coZXJyKTt9IC8vIEZhaWwgaWYgdGhlIGZpbGUgY2FuJ3QgYmUgcmVhZC5cbiAgICAgICAgICAgIHJlcy5lbmQoZGF0YSk7IC8vIFNlbmQgdGhlIGZpbGUgZGF0YSB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpO1xuICAgICAgICByZXMud3JpdGUoXCJFcnJvciBFcnJvciBnZXR0aW5nIGRhdGEgZmlsZSA6XCIgKyBiYXNlTmFtZSk7XG4gICAgICAgIHJlcy5lbmQoKTtcbiAgICB9XG59XG5cbi8vcHJpdmF0ZSBtaWRkbGV3YXJlIGZvciBnZXR0aW5nIG1ldHZpZXdlciBwb2ludHMxIGZpbGVcbmNvbnN0IF9tdkdldFBvaW50czEgPSBmdW5jdGlvbihwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgY29uc3QgZnNlID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gTVZfRElSUy5EQVRBRElSO1xuICAgIGNvbnN0IGJhc2VOYW1lID0gcGFyYW1zLmtleSArIFwiLnBvaW50czFcIjtcbiAgICBjb25zdCBmaWxlTmFtZSA9IGZpbGVQYXRoICsgJy8nICsgYmFzZU5hbWU7XG4gICAgdHJ5IHtcbiAgICAgICAgZnNlLnJlYWRGaWxlKGZpbGVOYW1lLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJylcbiAgICAgICAgICAgIGlmIChlcnIpIHtjb25zb2xlLmxvZyhlcnIpO30gLy8gRmFpbCBpZiB0aGUgZmlsZSBjYW4ndCBiZSByZWFkLlxuICAgICAgICAgICAgcmVzLmVuZChkYXRhKTsgLy8gU2VuZCB0aGUgZmlsZSBkYXRhIHRvIHRoZSBicm93c2VyLlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgICAgIHJlcy53cml0ZShcIkVycm9yIEVycm9yIGdldHRpbmcgZGF0YSBmaWxlIDpcIiArIGJhc2VOYW1lKTtcbiAgICAgICAgcmVzLmVuZCgpO1xuICAgIH1cbn1cblxuXG4vL3ByaXZhdGUgbWlkZGxld2FyZSBmb3IgZ2V0dGluZyBtZXR2aWV3ZXIgcG9pbnRzMSBmaWxlXG5jb25zdCBfbXZHZXRQb2ludHMyID0gZnVuY3Rpb24ocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgIGNvbnN0IGZzZSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IE1WX0RJUlMuREFUQURJUjtcbiAgICBjb25zdCBiYXNlTmFtZSA9IHBhcmFtcy5rZXkgKyBcIi5wb2ludHMyXCI7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBmaWxlUGF0aCArICcvJyArIGJhc2VOYW1lO1xuICAgIHRyeSB7XG4gICAgICAgIGZzZS5yZWFkRmlsZShmaWxlTmFtZSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpXG4gICAgICAgICAgICBpZiAoZXJyKSB7Y29uc29sZS5sb2coZXJyKTt9IC8vIEZhaWwgaWYgdGhlIGZpbGUgY2FuJ3QgYmUgcmVhZC5cbiAgICAgICAgICAgIHJlcy5lbmQoZGF0YSk7IC8vIFNlbmQgdGhlIGZpbGUgZGF0YSB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpO1xuICAgICAgICByZXMud3JpdGUoXCJFcnJvciBFcnJvciBnZXR0aW5nIGRhdGEgZmlsZSA6XCIgKyBiYXNlTmFtZSk7XG4gICAgICAgIHJlcy5lbmQoKTtcbiAgICB9XG59XG5cbi8vcHJpdmF0ZSBtaWRkbGV3YXJlIGZvciBnZXR0aW5nIG1ldHZpZXdlciB4bWwgZmlsZVxuY29uc3QgX212R2V0WG1sID0gZnVuY3Rpb24ocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgIGNvbnN0IGZzZSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IE1WX0RJUlMuWE1MRElSO1xuICAgIGNvbnN0IGJhc2VOYW1lID0gcGFyYW1zLmtleSArIFwiLnhtbFwiO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZVBhdGggKyAnLycgKyBiYXNlTmFtZTtcbiAgICB0cnkge1xuICAgICAgICBmc2UucmVhZEZpbGUoZmlsZU5hbWUsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtjb25zb2xlLmxvZyhlcnIpO30gLy8gRmFpbCBpZiB0aGUgZmlsZSBjYW4ndCBiZSByZWFkLlxuICAgICAgICAgICAgcmVzLmVuZChkYXRhKTsgLy8gU2VuZCB0aGUgZmlsZSBkYXRhIHRvIHRoZSBicm93c2VyLlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgICAgIHJlcy53cml0ZShcIkVycm9yIEVycm9yIGdldHRpbmcgeG1sIGZpbGUgOlwiICsgYmFzZU5hbWUpO1xuICAgICAgICByZXMuZW5kKCk7XG4gICAgfVxufVxuLy9wcml2YXRlIG1pZGRsZXdhcmUgZm9yIGdldHRpbmcgbWV0dmlld2VyIHBsb3QgZmlsZVxuY29uc3QgX212R2V0UGxvdCA9IGZ1bmN0aW9uKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICBjb25zdCBmc2UgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG4gICAgY29uc3QgZmlsZVBhdGggPSBNVl9ESVJTLlBMT1RTRElSO1xuICAgIGNvbnN0IGJhc2VOYW1lID0gcGFyYW1zLmtleSArIFwiLnBuZ1wiO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZVBhdGggKyAnLycgKyBiYXNlTmFtZTtcbiAgICB0cnkge1xuICAgICAgICBmc2UucmVhZEZpbGUoZmlsZU5hbWUsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgaWYgKGVycikge2NvbnNvbGUubG9nKGVycik7fSAvLyBGYWlsIGlmIHRoZSBmaWxlIGNhbid0IGJlIHJlYWQuXG4gICAgICAgICAgICByZXMuZW5kKGRhdGEpOyAvLyBTZW5kIHRoZSBmaWxlIGRhdGEgdG8gdGhlIGJyb3dzZXIuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3R4dCcpO1xuICAgICAgICByZXMud3JpdGUoXCJFcnJvciBFcnJvciBnZXR0aW5nIHBsb3QgZmlsZSA6XCIgKyBiYXNlTmFtZSk7XG4gICAgICAgIHJlcy5lbmQoKTtcbiAgICB9XG59XG4vL3ByaXZhdGUgbWlkZGxld2FyZSBmb3IgZ2V0dGluZyBtZXR2aWV3ZXIgc2NyaXB0IGZpbGVcbmNvbnN0IF9tdkdldFNjcmlwdCA9IGZ1bmN0aW9uKHBhcmFtcywgcmVxLCByZXMsIG5leHQpIHtcbiAgICBjb25zdCBmc2UgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG4gICAgY29uc3QgZmlsZVBhdGggPSBNVl9ESVJTLlNDUklQVFNESVI7XG4gICAgY29uc3QgYmFzZU5hbWUgPSBwYXJhbXMua2V5ICsgXCIuUlwiO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZVBhdGggKyAnLycgKyBiYXNlTmFtZTtcbiAgICB0cnkge1xuICAgICAgICBmc2UucmVhZEZpbGUoZmlsZU5hbWUsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtjb25zb2xlLmxvZyhlcnIpO30gLy8gRmFpbCBpZiB0aGUgZmlsZSBjYW4ndCBiZSByZWFkLlxuICAgICAgICAgICAgcmVzLmVuZChkYXRhKTsgLy8gU2VuZCB0aGUgZmlsZSBkYXRhIHRvIHRoZSBicm93c2VyLlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgICAgIHJlcy53cml0ZShcIkVycm9yIEVycm9yIGdldHRpbmcgc2NyaXB0IGZpbGUgOlwiICsgYmFzZU5hbWUpO1xuICAgICAgICByZXMuZW5kKCk7XG4gICAgfX1cbi8vcHJpdmF0ZSBtaWRkbGV3YXJlIGZvciBnZXR0aW5nIG1ldHZpZXdlciBzcWwgZmlsZVxuY29uc3QgX212R2V0U3FsID0gZnVuY3Rpb24ocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgIGNvbnN0IGZzZSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IE1WX0RJUlMuU1FMRElSO1xuICAgIGNvbnN0IGJhc2VOYW1lID0gcGFyYW1zLmtleSArIFwiLnNxbFwiO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZVBhdGggKyAnLycgKyBiYXNlTmFtZTtcbiAgICB0cnkge1xuICAgICAgICBmc2UucmVhZEZpbGUoZmlsZU5hbWUsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvc3FsJyk7XG4gICAgICAgICAgICBpZiAoZXJyKSB7Y29uc29sZS5sb2coZXJyKTt9IC8vIEZhaWwgaWYgdGhlIGZpbGUgY2FuJ3QgYmUgcmVhZC5cbiAgICAgICAgICAgIHJlcy5lbmQoZGF0YSk7IC8vIFNlbmQgdGhlIGZpbGUgZGF0YSB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpO1xuICAgICAgICByZXMud3JpdGUoXCJFcnJvciBFcnJvciBnZXR0aW5nIHNxbCBmaWxlIDpcIiArIGJhc2VOYW1lKTtcbiAgICAgICAgcmVzLmVuZCgpO1xuICAgIH1cbn1cbi8vcHJpdmF0ZSBtaWRkbGV3YXJlIGZvciBnZXR0aW5nIG1ldHZpZXdlciBsb2cgZmlsZVxuY29uc3QgX212R2V0TG9nID0gZnVuY3Rpb24ocGFyYW1zLCByZXEsIHJlcywgbmV4dCkge1xuICAgIGNvbnN0IGZzZSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IE1WX0RJUlMuTE9HRElSO1xuICAgIGNvbnN0IGJhc2VOYW1lID0gcGFyYW1zLmtleSArIFwiLmxvZ1wiO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZVBhdGggKyAnLycgKyBiYXNlTmFtZTtcbiAgICB0cnkge1xuICAgICAgICBmc2UucmVhZEZpbGUoZmlsZU5hbWUsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtjb25zb2xlLmxvZyhlcnIpO30gLy8gRmFpbCBpZiB0aGUgZmlsZSBjYW4ndCBiZSByZWFkLlxuICAgICAgICAgICAgcmVzLmVuZChkYXRhKTsgLy8gU2VuZCB0aGUgZmlsZSBkYXRhIHRvIHRoZSBicm93c2VyLlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgICAgIHJlcy53cml0ZShcIkVycm9yIEVycm9yIGdldHRpbmcgbG9nIGZpbGUgOlwiICsgYmFzZU5hbWUpO1xuICAgICAgICByZXMuZW5kKCk7XG4gICAgfVxufVxuLy9wcml2YXRlIG1pZGRsZXdhcmUgZm9yIGdldHRpbmcgbWV0dmlld2VyIGVyciBmaWxlXG5jb25zdCBfbXZHZXRFcnIgPSBmdW5jdGlvbihwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgY29uc3QgZnNlID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gTVZfRElSUy5FUlJESVI7XG4gICAgY29uc3QgYmFzZU5hbWUgPSBwYXJhbXMua2V5ICsgXCIuZXJyXCI7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBmaWxlUGF0aCArICcvJyArIGJhc2VOYW1lO1xuICAgIHRyeSB7XG4gICAgICAgIGZzZS5yZWFkRmlsZShmaWxlTmFtZSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlKFwiRXJyb3IgRXJyb3IgZ2V0dGluZyBlcnIgZmlsZSA6XCIgKyBiYXNlTmFtZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZW5kKGRhdGEpOyAvLyBTZW5kIHRoZSBmaWxlIGRhdGEgdG8gdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgcmVzLndyaXRlKFwiRXJyb3IgRXJyb3IgZ2V0dGluZyBwbG90IGZpbGUgOlwiICsgYmFzZU5hbWUpO1xuICAgICAgICByZXMuZW5kKCk7XG4gICAgfVxufVxuXG5cbi8vIHByaXZhdGUgZGVmaW5lIGEgbWlkZGxld2FyZSBmb3IgcmVmcmVzaGluZyB0aGUgbWV0YWRhdGFcbmNvbnN0IF9yZWZyZXNoTWV0YWRhdGFNV2x0RGF0YSA9IGZ1bmN0aW9uIChwYXJhbXMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICBfY2hlY2tNZXRhRGF0YVJlZnJlc2goKTtcbiAgICAgICAgcmVzLmVuZChcIjxib2R5PjxoMT5yZWZyZXNoTWV0YWRhdGEgRG9uZSE8L2gxPjwvYm9keT5cIik7XG4gICAgfVxufTtcblxuLy8gcHJpdmF0ZSBzYXZlIHRoZSByZXN1bHQgZnJvbSB0aGUgcXVlcnkgaW50byBtb25nbyBhbmQgZG93bnNhbXBsZSBpZiB0aGF0IHJlc3VsdCdzIHNpemUgaXMgZ3JlYXRlciB0aGFuIDFNYlxuY29uc3QgX3NhdmVSZXN1bHREYXRhID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgdmFyIHNpemVvZiA9IHJlcXVpcmUoJ29iamVjdC1zaXplb2YnKTtcbiAgICAgICAgdmFyIGhhc2ggPSByZXF1aXJlKCdvYmplY3QtaGFzaCcpO1xuICAgICAgICB2YXIga2V5ID0gaGFzaChyZXN1bHQuYmFzaXMucGxvdFBhcmFtcyk7XG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSAxMDAwMDAwO1xuICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZFNpemUgPSBzaXplb2YocmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInJlc3VsdC5iYXNpcy5kYXRhIHNpemUgaXMgXCIsIGRTaXplKTtcbiAgICAgICAgICAgIC8vIFRpbWVTZXJpZXMgYW5kIERhaWx5TW9kZWxDeWNsZSBhcmUgdGhlIG9ubHkgcGxvdCB0eXBlcyB0aGF0IHJlcXVpcmUgZG93blNhbXBsaW5nXG4gICAgICAgICAgICBpZiAoZFNpemUgPiB0aHJlc2hvbGQgJiYgKHJlc3VsdC5iYXNpcy5wbG90UGFyYW1zLnBsb3RUeXBlcy5UaW1lU2VyaWVzIHx8IHJlc3VsdC5iYXNpcy5wbG90UGFyYW1zLnBsb3RUeXBlcy5EYWlseU1vZGVsQ3ljbGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JlYXRlciB0aGFuIHRocmVzaG9sZCBuZWVkIHRvIGRvd25zYW1wbGVcbiAgICAgICAgICAgICAgICAvLyBkb3duc2FtcGxlIGFuZCBzYXZlIGl0IGluIERvd25TYW1wbGVSZXN1bHRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRvd25TYW1wbGluZ1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgZG93bnNhbXBsZXIgPSByZXF1aXJlKFwiZG93bnNhbXBsZS1sdHRiXCIpO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbFBvaW50cyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGkgPSAwOyBkaSA8IHJlc3VsdC5kYXRhLmxlbmd0aDsgZGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFBvaW50cyArPSByZXN1bHQuZGF0YVtkaV0ueF9lcG9jaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhbGxvd2VkTnVtYmVyT2ZQb2ludHMgPSAodGhyZXNob2xkIC8gZFNpemUpICogdG90YWxQb2ludHM7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25TYW1wbGVSZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IHJlc3VsdC5kYXRhLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHNEYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgIHZhciB4eURhdGFzZXQgPSByZXN1bHQuZGF0YVtjaV0ueF9lcG9jaC5tYXAoZnVuY3Rpb24gKGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Jlc3VsdC5kYXRhW2NpXS54X2Vwb2NoW2luZGV4XSwgcmVzdWx0LmRhdGFbY2ldLnlbaW5kZXhdXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXRpb1RvdGFsUG9pbnRzID0geHlEYXRhc2V0Lmxlbmd0aCAvIHRvdGFsUG9pbnRzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlBbGxvd2VkUG9pbnRzID0gTWF0aC5yb3VuZChyYXRpb1RvdGFsUG9pbnRzICogYWxsb3dlZE51bWJlck9mUG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG93bnNhbXBsZSB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvd25zYW1wbGVkU2VyaWVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXlBbGxvd2VkUG9pbnRzIDwgeHlEYXRhc2V0Lmxlbmd0aCAmJiB4eURhdGFzZXQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bnNhbXBsZWRTZXJpZXMgPSBkb3duc2FtcGxlci5wcm9jZXNzRGF0YSh4eURhdGFzZXQsIG15QWxsb3dlZFBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSB5IGF0dHJpYnV0ZXMgKHRvb2x0aXBzIGV0Yy4pIHdpdGggdGhlIHkgYXR0cmlidXRlcyBmcm9tIHRoZSBuZWFyZXN0IHhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhyb3VnaCB0aGUgb3JpZ2luYWwgZGF0YXNldCBjYXB0dXJpbmcgZWFjaCBkb3duU2FtcGxlZCBkYXRhIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlLZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9uQXJyYXlLZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlc3VsdC5kYXRhW2NpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBraSA9IDA7IGtpIDwga2V5cy5sZW5ndGg7IGtpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1traV0gIT09ICd4X2Vwb2NoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQuZGF0YVtjaV1ba2V5c1traV1dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlLZXlzLnB1c2goa2V5c1traV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHNEYXRhW2tleXNba2ldXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uQXJyYXlLZXlzLnB1c2goa2V5c1traV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBldmVyIGRvd25zYW1wbGUgc2VyaWVzIHBsb3RzIC0gbmV2ZXIgcHJvZmlsZXMgYW5kIHNlcmllcyBwbG90cyBvbmx5IGV2ZXIgaGF2ZSBlcnJvcl95IGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsaXR0bGUgaGFja3kgYnV0IHdoYXQgaXMgaGFwcGVuaW5nIGlzIHdlIHB1dHRpbmcgZXJyb3JfeS5hcnJheSBvbiB0aGUgYXJyYXlLZXlzIGxpc3Qgc28gdGhhdCBpdCBnZXRzIGl0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG93bnNhbXBsZWQgZXF1aXZhbGVudCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtpID0gMDsga2kgPCBub25BcnJheUtleXMubGVuZ3RoOyBraSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHNEYXRhW25vbkFycmF5S2V5c1traV1dID0gcmVzdWx0LmRhdGFbY2ldW25vbkFycmF5S2V5c1traV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvcmlnaW5hbCBlcnJvcl95IGFycmF5IGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICBkc0RhdGFbJ2Vycm9yX3knXS5hcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZHNpID0gMDsgZHNpIDwgZG93bnNhbXBsZWRTZXJpZXMubGVuZ3RoOyBkc2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbEluZGV4IDwgcmVzdWx0LmRhdGFbY2ldLnhfZXBvY2gubGVuZ3RoICYmIChyZXN1bHQuZGF0YVtjaV0ueF9lcG9jaFtvcmlnaW5hbEluZGV4XSA8IGRvd25zYW1wbGVkU2VyaWVzW2RzaV1bMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FwdHVyZSB0aGUgc3R1ZmYgcmVsYXRlZCB0byB0aGlzIGRvd25TYW1wbGVkIGRhdGEgcG9pbnQgKGRvd25TYW1wbGVkIGRhdGEgcG9pbnRzIGFyZSBhbHdheXMgYSBzdWJzZXQgb2Ygb3JpZ2luYWwgZGF0YSBwb2ludHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChraSA9IDA7IGtpIDwgYXJyYXlLZXlzLmxlbmd0aDsga2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc0RhdGFbYXJyYXlLZXlzW2tpXV1bZHNpXSA9IHJlc3VsdC5kYXRhW2NpXVthcnJheUtleXNba2ldXVtvcmlnaW5hbEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHNEYXRhWydlcnJvcl95J11bJ2FycmF5J11bZHNpXSA9IHJlc3VsdC5kYXRhW2NpXVsnZXJyb3JfeSddWydhcnJheSddW29yaWdpbmFsSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGRvd25zYW1wbGVkIGFubm90YXRpb24gdG8gY3VydmUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93blNhbXBsZVJlc3VsdFtjaV0gPSBkc0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duU2FtcGxlUmVzdWx0W2NpXS5hbm5vdGF0aW9uICs9IFwiICAgKipET1dOU0FNUExFRCoqXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duU2FtcGxlUmVzdWx0W2NpXSA9IHJlc3VsdC5kYXRhW2NpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb3duU2FtcGxlUmVzdWx0LmRhdGFbY2ldID0gZG93blNhbXBsZVJlc3VsdFtjaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIERvd25TYW1wbGVSZXN1bHRzLnJhd0NvbGxlY3Rpb24oKS5pbnNlcnQoe1wiY3JlYXRlZEF0XCI6IG5ldyBEYXRlKCksIGtleToga2V5LCByZXN1bHQ6IGRvd25TYW1wbGVSZXN1bHR9KTsvLyBjcmVhdGVkQXQgZW5zdXJlcyBleHBpcmF0aW9uIHNldCBpbiBtYXRzLWNvbGxlY3Rpb25zXG4gICAgICAgICAgICAgICAgcmV0ID0ge2tleToga2V5LCByZXN1bHQ6IGRvd25TYW1wbGVSZXN1bHR9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSB7a2V5OiBrZXksIHJlc3VsdDogcmVzdWx0fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNhdmUgb3JpZ2luYWwgZGF0YXNldCBpbiB0aGUgbWF0c0NhY2hlXG4gICAgICAgICAgICBpZiAocmVzdWx0LmJhc2lzLnBsb3RQYXJhbXMucGxvdFR5cGVzLlRpbWVTZXJpZXMgfHwgcmVzdWx0LmJhc2lzLnBsb3RQYXJhbXMucGxvdFR5cGVzLkRhaWx5TW9kZWxDeWNsZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCByZXN1bHQuZGF0YS5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIChyZXN1bHQuZGF0YVtjaV1bJ3hfZXBvY2gnXSk7ICAgICAvLyB3ZSBvbmx5IG5lZWRlZCB0aGlzIGFzIGFuIGluZGV4IGZvciBkb3duc2FtcGxpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRzQ2FjaGUuc3RvcmVSZXN1bHQoa2V5LCB7a2V5OiBrZXksIHJlc3VsdDogcmVzdWx0fSk7IC8vIGxpZmVzcGFuIGlzIGhhbmRsZWQgYnkgbG93RGIgKGludGVybmFsbHkpIGluIG1hdHNjYWNoZVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLnRvTG9jYWxlU3RyaW5nKCkuaW5kZXhPZihcImxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHNpemVcIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKCtcIjogUmVxdWVzdGluZyB0b28gbXVjaCBkYXRhLi4uIHRyeSBhdmVyYWdpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59O1xuXG4vLyBQVUJMSUMgTUVUSE9EU1xuLy9hZG1pbmlzdHJhdGlvbiB0b29sc1xuY29uc3QgYWRkU2VudEFkZHJlc3MgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMuYWRkU2VudEFkZHJlc3MnLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHtcbiAgICAgICAgdG9BZGRyZXNzOiB7dHlwZTogU3RyaW5nfVxuICAgIH0pLnZhbGlkYXRvcigpLFxuICAgIHJ1bih0b0FkZHJlc3MpIHtcbiAgICAgICAgaWYgKCFNZXRlb3IudXNlcklkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZXRlb3IuRXJyb3IoNDAxLCBcIm5vdC1sb2dnZWQtaW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLlNlbnRBZGRyZXNzZXMudXBzZXJ0KHthZGRyZXNzOiB0b0FkZHJlc3N9LCB7YWRkcmVzczogdG9BZGRyZXNzLCB1c2VySWQ6IE1ldGVvci51c2VySWQoKX0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSk7XG5cblxuLy8gIGFkbWluaXN0YXRpb24gdG9vbFxuY29uc3QgYXBwbHlBdXRob3JpemF0aW9uID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLmFwcGx5QXV0aG9yaXphdGlvbicsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe1xuICAgICAgICBzZXR0aW5nczoge3R5cGU6IE9iamVjdCwgYmxhY2tib3g6IHRydWV9XG4gICAgfSkudmFsaWRhdG9yKCksXG4gICAgcnVuKHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciByb2xlcztcbiAgICAgICAgICAgIHZhciByb2xlTmFtZTtcbiAgICAgICAgICAgIHZhciBhdXRob3JpemF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgdXNlclJvbGVOYW1lID0gc2V0dGluZ3MudXNlclJvbGVOYW1lO1xuICAgICAgICAgICAgdmFyIHVzZXJSb2xlRGVzY3JpcHRpb24gPSBzZXR0aW5ncy51c2VyUm9sZURlc2NyaXB0aW9uO1xuICAgICAgICAgICAgdmFyIGF1dGhvcml6YXRpb25Sb2xlID0gc2V0dGluZ3MuYXV0aG9yaXphdGlvblJvbGU7XG4gICAgICAgICAgICB2YXIgbmV3VXNlckVtYWlsID0gc2V0dGluZ3MubmV3VXNlckVtYWlsO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVXNlckVtYWlsID0gc2V0dGluZ3MuZXhpc3RpbmdVc2VyRW1haWw7XG5cbiAgICAgICAgICAgIGlmIChhdXRob3JpemF0aW9uUm9sZSkge1xuICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIHJvbGUgLSB0aGUgcm9sZSByb2xlTmFtZSAtIG5vIG5lZWQgdG8gdmVyaWZ5IGFzIHRoZSBzZWxlY3Rpb24gbGlzdCBjYW1lIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgICAgICAgICAgcm9sZU5hbWUgPSBhdXRob3JpemF0aW9uUm9sZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlclJvbGVOYW1lICYmIHVzZXJSb2xlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBwb3NzaWJsZSBuZXcgcm9sZSAtIHNlZSBpZiBpdCBoYXBwZW5zIHRvIGFscmVhZHkgZXhpc3RcbiAgICAgICAgICAgICAgICB2YXIgcm9sZSA9IG1hdHNDb2xsZWN0aW9ucy5Sb2xlcy5maW5kT25lKHtuYW1lOiB1c2VyUm9sZU5hbWV9KTtcbiAgICAgICAgICAgICAgICBpZiAocm9sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYWRkIG5ldyByb2xlIHVzaW5nIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5Sb2xlcy51cHNlcnQoe25hbWU6IHVzZXJSb2xlTmFtZX0sIHskc2V0OiB7ZGVzY3JpcHRpb246IHVzZXJSb2xlRGVzY3JpcHRpb259fSk7XG4gICAgICAgICAgICAgICAgICAgIHJvbGVOYW1lID0gdXNlclJvbGVOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVzY3JpcHRpb24gbWF0Y2hlcy4uLlxuICAgICAgICAgICAgICAgICAgICByb2xlTmFtZSA9IHJvbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gcm9sZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9IHVzZXJSb2xlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gdXBkYXRlIHRoZSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0c0NvbGxlY3Rpb25zLlJvbGVzLnVwc2VydCh7bmFtZTogdXNlclJvbGVOYW1lfSwgeyRzZXQ6IHtkZXNjcmlwdGlvbjogdXNlclJvbGVEZXNjcmlwdGlvbn19KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vdyB3ZSBoYXZlIGEgcm9sZSByb2xlTmFtZSAtIG5vdyB3ZSBuZWVkIGFuIGVtYWlsXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdVc2VyRW1haWwpIHtcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyB1c2VyIC0gIG5vIG5lZWQgdG8gdmVyaWZ5IGFzIHRoZSBzZWxlY3Rpb24gbGlzdCBjYW1lIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIGl0IGFscmVhZHkgaGFzIHRoZSByb2xlXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbiA9IG1hdHNDb2xsZWN0aW9ucy5BdXRob3JpemF0aW9uLmZpbmRPbmUoe2VtYWlsOiBleGlzdGluZ1VzZXJFbWFpbH0pO1xuICAgICAgICAgICAgICAgIHJvbGVzID0gYXV0aG9yaXphdGlvbi5yb2xlcztcbiAgICAgICAgICAgICAgICBpZiAocm9sZXMuaW5kZXhPZihyb2xlTmFtZSkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBhZGQgdGhlIHJvbGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlcy5wdXNoKHJvbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuQXV0aG9yaXphdGlvbi51cHNlcnQoe2VtYWlsOiBleGlzdGluZ1VzZXJFbWFpbH0sIHskc2V0OiB7cm9sZXM6IHJvbGVzfX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3VXNlckVtYWlsKSB7XG4gICAgICAgICAgICAgICAgLy8gcG9zc2libGUgbmV3IGF1dGhvcml6YXRpb24gLSBzZWUgaWYgaXQgaGFwcGVucyB0byBleGlzdFxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24gPSBtYXRzQ29sbGVjdGlvbnMuQXV0aG9yaXphdGlvbi5maW5kT25lKHtlbWFpbDogbmV3VXNlckVtYWlsfSk7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGhvcml6YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhdXRob3JpemF0aW9uIGV4aXN0cyAtIGFkZCByb2xlIHRvIHJvbGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICByb2xlcyA9IGF1dGhvcml6YXRpb24ucm9sZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb2xlcy5pbmRleE9mKHJvbGVOYW1lKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBhZGQgdGhlIHJvbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb2xlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGVzLnB1c2gocm9sZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24udXBzZXJ0KHtlbWFpbDogZXhpc3RpbmdVc2VyRW1haWx9LCB7JHNldDoge3JvbGVzOiByb2xlc319KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgYSBuZXcgYXV0aG9yaXphdGlvblxuICAgICAgICAgICAgICAgICAgICByb2xlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm9sZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGVzLnB1c2gocm9sZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdVc2VyRW1haWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5BdXRob3JpemF0aW9uLnVwc2VydCh7ZW1haWw6IG5ld1VzZXJFbWFpbH0sIHskc2V0OiB7cm9sZXM6IHJvbGVzfX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8vIGRhdGFiYXNlIGNvbnRyb2xzXG5jb25zdCBhcHBseURhdGFiYXNlU2V0dGluZ3MgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMuYXBwbHlEYXRhYmFzZVNldHRpbmdzJyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYSh7XG4gICAgICAgIHNldHRpbmdzOiB7dHlwZTogT2JqZWN0LCBibGFja2JveDogdHJ1ZX1cbiAgICB9KS52YWxpZGF0b3IoKSxcblxuICAgIHJ1bihzZXR0aW5ncykge1xuICAgICAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubmFtZSkge1xuICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5EYXRhYmFzZXMudXBzZXJ0KHtuYW1lOiBzZXR0aW5ncy5uYW1lfSwge1xuICAgICAgICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZXR0aW5ncy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogc2V0dGluZ3Mucm9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc2V0dGluZ3Muc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogc2V0dGluZ3MuaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBzZXR0aW5ncy5kYXRhYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IHNldHRpbmdzLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogc2V0dGluZ3MucGFzc3dvcmRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuLy9hZG1pbmlzdHJhdGlvbiB0b29sc1xuY29uc3QgZGVsZXRlU2V0dGluZ3MgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMuZGVsZXRlU2V0dGluZ3MnLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHtcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH1cbiAgICB9KS52YWxpZGF0b3IoKSxcbiAgICBydW4ocGFyYW1zKSB7XG4gICAgICAgIGlmICghTWV0ZW9yLnVzZXJJZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKFwibm90LWxvZ2dlZC1pblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuQ3VydmVTZXR0aW5ncy5yZW1vdmUoe25hbWU6IHBhcmFtcy5uYW1lfSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLy9hZG1pbmlzdHJhdGlvbiB0b29sc1xuY29uc3QgZW1haWxJbWFnZSA9IG5ldyBWYWxpZGF0ZWRNZXRob2Qoe1xuICAgIG5hbWU6ICdtYXRzTWV0aG9kcy5lbWFpbEltYWdlJyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYSh7XG4gICAgICAgIGltYWdlU3RyOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgICAgdG9BZGRyZXNzOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgICAgc3ViamVjdDoge3R5cGU6IFN0cmluZ31cbiAgICB9KS52YWxpZGF0b3IoKSxcbiAgICBydW4ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpbWFnZVN0ciA9IHBhcmFtcy5pbWFnZVN0cjtcbiAgICAgICAgdmFyIHRvQWRkcmVzcyA9IHBhcmFtcy50b0FkZHJlc3M7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gcGFyYW1zLnN1YmplY3Q7XG4gICAgICAgIGlmICghTWV0ZW9yLnVzZXJJZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKDQwMSwgXCJub3QtbG9nZ2VkLWluXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tQWRkcmVzcyA9IE1ldGVvci51c2VyKCkuc2VydmljZXMuZ29vZ2xlLmVtYWlsO1xuICAgICAgICAvLyB0aGVzZSBjb21lIGZyb20gZ29vZ2xlIC0gc2VlXG4gICAgICAgIC8vIGh0dHA6Ly9tYXNhc2hpLWsuYmxvZ3Nwb3QuZnIvMjAxMy8wNi9zZW5kaW5nLW1haWwtd2l0aC1nbWFpbC11c2luZy14b2F1dGgyLmh0bWxcbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0MDk4NDYxL25vZGVtYWlsZXItZ21haWwtd2hhdC1leGFjdGx5LWlzLWEtcmVmcmVzaC10b2tlbi1hbmQtaG93LWRvLWktZ2V0LW9uZS8yNDEyMzU1MFxuXG4gICAgICAgIC8vIHRoZSBnbWFpbCBhY2NvdW50IGZvciB0aGUgY3JlZGVudGlhbHMgaXMgbWF0cy5tYWlsLmRhZW1vbkBnbWFpbC5jb20gLSBwd2QgbWF0czIwMTUhXG4gICAgICAgIC8vdmFyIGNsaWVudElkID0gXCIzMzkzODk3MzUzODAtMzgyc2YxMWFpY21nZGduN2U3MnA0ZW5kNWdubTlzYWQuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb21cIjtcbiAgICAgICAgLy92YXIgY2xpZW50U2VjcmV0ID0gXCI3Q2ZOTi10Umw1UUFMNTk1SlRXMlRrUmxcIjtcbiAgICAgICAgLy92YXIgcmVmcmVzaF90b2tlbiA9IFwiMS9QRHFsN0ZSMDFOMmdtcTVOaVRmbnJULU9sQ1lDM1U2N0tKWVlETlBlR25BXCI7XG4gICAgICAgIHZhciBjcmVkZW50aWFscyA9IG1hdHNDb2xsZWN0aW9ucy5DcmVkZW50aWFscy5maW5kT25lKHtuYW1lOiBcIm9hdXRoX2dvb2dsZVwifSwge1xuICAgICAgICAgICAgY2xpZW50SWQ6IDEsXG4gICAgICAgICAgICBjbGllbnRTZWNyZXQ6IDEsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiAxXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2xpZW50SWQgPSBjcmVkZW50aWFscy5jbGllbnRJZDtcbiAgICAgICAgdmFyIGNsaWVudFNlY3JldCA9IGNyZWRlbnRpYWxzLmNsaWVudFNlY3JldDtcbiAgICAgICAgdmFyIHJlZnJlc2hfdG9rZW4gPSBjcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuO1xuXG4gICAgICAgIHZhciBzbXRwVHJhbnNwb3J0ZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzbXRwVHJhbnNwb3J0ZXIgPSBOb2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydChcIlNNVFBcIiwge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IFwiR21haWxcIixcbiAgICAgICAgICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIFhPQXV0aDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IFwibWF0cy5nc2RAbm9hYS5nb3ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBjbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFNlY3JldDogY2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuOiByZWZyZXNoX3Rva2VuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKDQwMSwgXCJUcmFuc3BvcnQgZXJyb3IgXCIgKyBlLm1lc3NhZ2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtYWlsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBzZW5kZXI6IGZyb21BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHJlcGx5VG86IGZyb21BZGRyZXNzLFxuICAgICAgICAgICAgICAgIGZyb206IGZyb21BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHRvOiB0b0FkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3ViamVjdDogc3ViamVjdCxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogXCJncmFwaC5wbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBuZXcgQnVmZmVyKGltYWdlU3RyLnNwbGl0KFwiYmFzZTY0LFwiKVsxXSwgXCJiYXNlNjRcIilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNtdHBUcmFuc3BvcnRlci5zZW5kTWFpbChtYWlsT3B0aW9ucywgZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNtdHBUcmFuc3BvcnRlciBlcnJvciBcIiArIGVycm9yICsgXCIgZnJvbTpcIiArIGZyb21BZGRyZXNzICsgXCIgdG86XCIgKyB0b0FkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlICsgXCIgZnJvbTpcIiArIGZyb21BZGRyZXNzICsgXCIgdG86XCIgKyB0b0FkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzbXRwVHJhbnNwb3J0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKDQwMSwgXCJTZW5kIGVycm9yIFwiICsgZS5tZXNzYWdlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KTtcblxuLy8gYWRtaW5pc3RhdGlvbiB0b29sXG5jb25zdCBnZXRBdXRob3JpemF0aW9ucyA9IG5ldyBWYWxpZGF0ZWRNZXRob2Qoe1xuICAgIG5hbWU6ICdtYXRzTWV0aG9kcy5nZXRBdXRob3JpemF0aW9ucycsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe30pLnZhbGlkYXRvcigpLFxuICAgIHJ1bigpIHtcbiAgICAgICAgdmFyIHJvbGVzID0gW107XG4gICAgICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciB1c2VyRW1haWwgPSBNZXRlb3IudXNlcigpLnNlcnZpY2VzLmdvb2dsZS5lbWFpbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcm9sZXMgPSBtYXRzQ29sbGVjdGlvbnMuQXV0aG9yaXphdGlvbi5maW5kT25lKHtlbWFpbDogdXNlckVtYWlsfSkucm9sZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvbGVzO1xuICAgIH1cbn0pO1xuXG4vLyBhZG1pbmlzdHJhdGlvbiB0b29sXG5jb25zdCBnZXREYXRhRnVuY3Rpb25GaWxlTGlzdCA9IG5ldyBWYWxpZGF0ZWRNZXRob2Qoe1xuICAgIG5hbWU6ICdtYXRzTWV0aG9kcy5nZXREYXRhRnVuY3Rpb25GaWxlTGlzdCcsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe30pLnZhbGlkYXRvcigpLFxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuLy8gcmV0cmlldmVzIHRoZSBzYXZlZCBxdWVyeSByZXN1bHRzIChvciBkb3duc2FtcGxlZCByZXN1bHRzKVxuY29uc3QgZ2V0R3JhcGhEYXRhID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLmdldEdyYXBoRGF0YScsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe1xuICAgICAgICBwbG90UGFyYW1zOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBibGFja2JveDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwbG90VHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGV4cGlyZUtleToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhblxuICAgICAgICB9XG4gICAgfSkudmFsaWRhdG9yKCksXG4gICAgcnVuKHBhcmFtcykge1xuICAgICAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgICAgICB2YXIgcGxvdEdyYXBoRnVuY3Rpb24gPSBtYXRzQ29sbGVjdGlvbnMuUGxvdEdyYXBoRnVuY3Rpb25zLmZpbmRPbmUoe3Bsb3RUeXBlOiBwYXJhbXMucGxvdFR5cGV9KTtcbiAgICAgICAgICAgIHZhciBkYXRhRnVuY3Rpb24gPSBwbG90R3JhcGhGdW5jdGlvbi5kYXRhRnVuY3Rpb247XG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IHJlcXVpcmUoJ29iamVjdC1oYXNoJyk7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGhhc2gocGFyYW1zLnBsb3RQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiIHx8IHBhcmFtcy5leHBpcmVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0c0NhY2hlLmV4cGlyZUtleShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IG1hdHNDYWNoZS5nZXRSZXN1bHQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgYXJlbid0IGluIHRoZSBjYWNoZSAtIG5lZWQgdG8gcHJvY2VzcyBkYXRhIHJvdXRpbmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgRnV0dXJlID0gcmVxdWlyZSgnZmliZXJzL2Z1dHVyZScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxbZGF0YUZ1bmN0aW9uXShwYXJhbXMucGxvdFBhcmFtcywgZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IF9zYXZlUmVzdWx0RGF0YShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1dHVyZVtcInJldHVyblwiXShyZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1dHVyZS53YWl0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gcmVzdWx0cyB3ZXJlIGFscmVhZHkgaW4gdGhlIG1hdHNDYWNoZSAoc2FtZSBwYXJhbXMgYW5kIG5vdCB5ZXQgZXhwaXJlZClcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHJlc3VsdHMgaW4gdGhlIGRvd25zYW1wbGVkIGNvbGxlY3Rpb24/XG4gICAgICAgICAgICAgICAgICAgIHZhciBkc1Jlc3VsdHMgPSBEb3duU2FtcGxlUmVzdWx0cy5maW5kT25lKHtrZXk6IGtleX0sIHt9LCB7ZGlzYWJsZU9wbG9nOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkc1Jlc3VsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0cyBhcmUgaW4gdGhlIG1vbmdvIGNhY2hlIGRvd25zYW1wbGVkIGNvbGxlY3Rpb24gLSByZXR1cm5lZCB0aGUgZG93bnNhbXBsZWQgZ3JhcGggZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gZHNSZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBleHBpcmUgdGltZSBpbiB0aGUgZG93bnNhbXBsZWQgY29sbGVjdGlvbiAtIHRoaXMgcmVxdWlyZXMgYSBuZXcgRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgRG93blNhbXBsZVJlc3VsdHMucmF3Q29sbGVjdGlvbigpLnVwZGF0ZSh7a2V5OiBrZXl9LCB7JHNldDoge1wiY3JlYXRlZEF0XCI6IG5ldyBEYXRlKCl9fSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSByZXN1bHRzOyAgLy8ge2tleTpzb21lS2V5LCByZXN1bHQ6cmVzdWx0T2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmcmVzaCBleHBpcmUgdGltZS4gVGhlIG9ubHkgd2F5IHRvIHBlcmZvcm0gYSByZWZyZXNoIG9uIG1hdHNDYWNoZSBpcyB0byByZS1zYXZlIHRoZSByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRzQ2FjaGUuc3RvcmVSZXN1bHQocmVzdWx0cy5rZXksIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplb2YgPSByZXF1aXJlKCdvYmplY3Qtc2l6ZW9mJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzdWx0LmRhdGEgc2l6ZSBpcyBcIiwgc2l6ZW9mKHJlc3VsdHMpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChkYXRhRnVuY3Rpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhRnVuY3Rpb25FcnJvci50b0xvY2FsZVN0cmluZygpLmluZGV4T2YoXCJJTkZPOlwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1ldGVvci5FcnJvcihkYXRhRnVuY3Rpb25FcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKFwiRXJyb3IgaW4gZ2V0R3JhcGhEYXRhIGZ1bmN0aW9uOlwiICsgZGF0YUZ1bmN0aW9uICsgXCIgOiBcIiArIGRhdGFGdW5jdGlvbkVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIHByb2JhYmx5IHdvbid0IGdldCBoZXJlXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLy8gcmV0cmlldmVzIHRoZSBzYXZlZCBxdWVyeSByZXN1bHRzIChvciBkb3duc2FtcGxlZCByZXN1bHRzKSBmb3IgYSBzcGVjaWZpYyBrZXlcbmNvbnN0IGdldEdyYXBoRGF0YUJ5S2V5ID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLmdldEdyYXBoRGF0YUJ5S2V5JyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYSh7XG4gICAgICAgIHJlc3VsdEtleToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH1cbiAgICB9KS52YWxpZGF0b3IoKSxcbiAgICBydW4ocGFyYW1zKSB7XG4gICAgICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICB2YXIga2V5ID0gcGFyYW1zLnJlc3VsdEtleTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRzUmVzdWx0cyA9IERvd25TYW1wbGVSZXN1bHRzLmZpbmRPbmUoe2tleToga2V5fSwge30sIHtkaXNhYmxlT3Bsb2c6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBpZiAoZHNSZXN1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZHNSZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG1hdHNDYWNoZS5nZXRSZXN1bHQoa2V5KTsgLy8ge2tleTpzb21lS2V5LCByZXN1bHQ6cmVzdWx0T2JqZWN0fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2l6ZW9mID0gcmVxdWlyZSgnb2JqZWN0LXNpemVvZicpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0R3JhcGhEYXRhQnlLZXkgcmVzdWx0cyBzaXplIGlzIFwiLCBzaXplb2YoZHNSZXN1bHRzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1ldGVvci5FcnJvcihcIkVycm9yIGluIGdldEdyYXBoRGF0YUJ5S2V5IGZ1bmN0aW9uOlwiICsga2V5ICsgXCIgOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vLyBhZG1pbmlzdHJhdGlvbiB0b29sXG5jb25zdCBnZXRHcmFwaEZ1bmN0aW9uRmlsZUxpc3QgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMuZ2V0R3JhcGhGdW5jdGlvbkZpbGVMaXN0JyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYSh7fSkudmFsaWRhdG9yKCksXG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgZ2V0TGF5b3V0ID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLmdldExheW91dCcsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe1xuICAgICAgICByZXN1bHRLZXk6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9XG4gICAgfSkudmFsaWRhdG9yKCksXG4gICAgcnVuKHBhcmFtcykge1xuICAgICAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgdmFyIGtleSA9IHBhcmFtcy5yZXN1bHRLZXk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldCA9IExheW91dFN0b3JlQ29sbGVjdGlvbi5yYXdDb2xsZWN0aW9uKCkuZmluZE9uZSh7a2V5OiBrZXl9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKFwiRXJyb3IgaW4gZ2V0TGF5b3V0IGZ1bmN0aW9uOlwiICsga2V5ICsgXCIgOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vLyByZXRyaWV2ZXMgdGhlIHNhdmVkIGFydGlmYWN0cyAoZmlsZSB1cmxzKSB0aGF0IHdlcmUgZ2VuZXJhdGVkIGJ5IG52QmF0Y2ggZm9yIGEgc3BlY2lmaWMga2V5XG5jb25zdCBnZXRNdkFydGlmYWN0c0J5S2V5ID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLmdldE12QXJ0aWZhY3RzQnlLZXknLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHtcbiAgICAgICAga2V5OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfVxuICAgIH0pLnZhbGlkYXRvcigpLFxuICAgIHJ1bihwYXJhbXMpIHtcbiAgICAgICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwYXJhbXMua2V5O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQgPSBtYXRzQ2FjaGUuZ2V0UmVzdWx0KGtleSk7IC8vIHtrZXk6c29tZUtleSwgcmVzdWx0OnJlc3VsdE9iamVjdH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKFwiRXJyb3IgaW4gZ2V0TXZBcnRpZmFjdHNCeUtleSBmdW5jdGlvbjpcIiArIGtleSArIFwiIDogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLypcbmdldFBsb3RSZXN1bHQgaXMgdXNlZCBieSB0aGUgZ3JhcGgvdGV4dF8qX291dHB1dCB0ZW1wbGF0ZXMgd2hpY2ggYXJlIHVzZWQgdG8gZGlzcGxheSB0ZXh0dWFsIHJlc3VsdHMuXG5CZWNhdXNlIHRoZSBkYXRhIGlzbid0IGJlaW5nIHJlbmRlcmVkIGdyYXBoaWNhbGx5IHRoaXMgZGF0YSBpcyBhbHdheXMgZnVsbCBzaXplLCBpLmUuIE5PVCBkb3duc2FtcGxlZC5cblRoYXQgaXMgd2h5IGl0IG9ubHkgZmluZHMgaXQgaW4gdGhlIFJlc3VsdCBmaWxlIGNhY2hlLCBuZXZlciB0aGUgRG93blNhbXBsZVJlc3VsdCBjb2xsZWN0aW9uLlxuXG5CZWNhdXNlIHRoZSBkYXRhc2V0IGNhbiBiZSBzbyBsYXJnZSAuLi4gZS5nLiBtZWdhYnl0ZXMgdGhlIGRhdGEgcmV0cmlldmFsIGlzIHBhZ2VuYXRlZC4gVGhlIGluZGV4IGlzXG5hcHBsaWVkIHRvIHRoZSB1bmRlcmx5aW5nIGRhdGFzZXRzLlRoZSBkYXRhIGdldHMgc3RyaXBwZWQgZG93biBhbmQgZmxhdHRlbmVkIHRvIG9ubHkgY29udGFpbiB0aGUgZGF0YSBuZWNjZXNhcnkgZm9yIHRleHQgcHJlc2VudGF0aW9uLlxuQSBuZXcgcGFnZSBpbmRleCBvZiAtMTAwMCBtZWFucyBnZXQgYWxsIHRoZSBkYXRhIGkuZS4gbm8gcGFnZW5hdGlvbi5cbiAqL1xuY29uc3QgZ2V0UGxvdFJlc3VsdCA9IG5ldyBWYWxpZGF0ZWRNZXRob2Qoe1xuICAgIG5hbWU6ICdtYXRzTWV0aG9kcy5nZXRQbG90UmVzdWx0JyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYSh7XG4gICAgICAgIHJlc3VsdEtleToge3R5cGU6IFN0cmluZ30sXG4gICAgICAgIHBhZ2VJbmRleDoge3R5cGU6IE51bWJlcn0sXG4gICAgICAgIG5ld1BhZ2VJbmRleDoge3R5cGU6IE51bWJlcn1cbiAgICB9KS52YWxpZGF0b3IoKSxcbiAgICBydW4ocGFyYW1zKSB7XG4gICAgICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciByS2V5ID0gcGFyYW1zLnJlc3VsdEtleTtcbiAgICAgICAgICAgIHZhciBwaSA9IHBhcmFtcy5wYWdlSW5kZXg7XG4gICAgICAgICAgICB2YXIgbnBpID0gcGFyYW1zLm5ld1BhZ2VJbmRleDtcbiAgICAgICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gX2dldEZsYXR0ZW5lZFJlc3VsdERhdGEocktleSwgcGksIG5waSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuY29uc3QgZ2V0UmVsZWFzZU5vdGVzID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLmdldFJlbGVhc2VOb3RlcycsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe30pLnZhbGlkYXRvcigpLFxuICAgIHJ1bigpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiBBc3NldHMuZ2V0VGV4dCgncHVibGljL01BVFNSZWxlYXNlTm90ZXMuaHRtbCcpO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciBmdXR1cmUgPSByZXF1aXJlKCdmaWJlcnMvZnV0dXJlJyk7XG4gICAgICAgICAgICB2YXIgZnNlID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbiAgICAgICAgICAgIHZhciBkRnV0dXJlID0gbmV3IGZ1dHVyZSgpO1xuICAgICAgICAgICAgdmFyIGZEYXRhO1xuICAgICAgICAgICAgY29uc29sZS5sb2cocHJvY2Vzcy5lbnYuUFdEKTtcbiAgICAgICAgICAgIHZhciBmaWxlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgICAgICBmaWxlID0gcHJvY2Vzcy5lbnYuUFdEICsgXCIvLi4vLi4vbWV0ZW9yX3BhY2thZ2VzL21hdHMtY29tbW9uL3B1YmxpYy9NQVRTUmVsZWFzZU5vdGVzLmh0bWxcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsZSA9IHByb2Nlc3MuZW52LlBXRCArIFwiL3Byb2dyYW1zL3NlcnZlci9hc3NldHMvcGFja2FnZXMvcmFuZHlwX21hdHMtY29tbW9uL3B1YmxpYy9NQVRTUmVsZWFzZU5vdGVzLmh0bWxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnNlLnJlYWRGaWxlKGZpbGUsICd1dGY4JywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmRGF0YSA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZEZ1dHVyZVtcInJldHVyblwiXSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZkRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZEZ1dHVyZVtcInJldHVyblwiXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZkRhdGEgPSBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZEZ1dHVyZVtcInJldHVyblwiXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZEZ1dHVyZS53YWl0KCk7XG4gICAgICAgICAgICByZXR1cm4gZkRhdGE7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBhZG1pbmlzdHJhdGlvbiB0b29sXG5jb25zdCBnZXRVc2VyQWRkcmVzcyA9IG5ldyBWYWxpZGF0ZWRNZXRob2Qoe1xuICAgIG5hbWU6ICdtYXRzTWV0aG9kcy5nZXRVc2VyQWRkcmVzcycsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe30pLnZhbGlkYXRvcigpLFxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICAgICAgcmV0dXJuIE1ldGVvci51c2VyKCkuc2VydmljZXMuZ29vZ2xlLmVtYWlsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLy8gYXBwIHV0aWxpdHlcbmNvbnN0IGluc2VydENvbG9yID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLmluc2VydENvbG9yJyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYSh7XG4gICAgICAgIG5ld0NvbG9yOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgICAgaW5zZXJ0QWZ0ZXJJbmRleDoge3R5cGU6IE51bWJlcn1cbiAgICB9KS52YWxpZGF0b3IoKSxcbiAgICBydW4ocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMubmV3Q29sb3IgPT0gXCJyZ2IoMjU1LDI1NSwyNTUpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sb3JTY2hlbWUgPSBtYXRzQ29sbGVjdGlvbnMuQ29sb3JTY2hlbWUuZmluZE9uZSh7fSk7XG4gICAgICAgIGNvbG9yU2NoZW1lLmNvbG9ycy5zcGxpY2UocGFyYW1zLmluc2VydEFmdGVySW5kZXgsIDAsIG5ld0NvbG9yKTtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLnVwZGF0ZSh7fSwgY29sb3JTY2hlbWUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSk7XG5cblxuLy8gY2hlY2tzIHRvIHNlZSBpZiB0aGUgbXYgYXJ0aWZhY3RzIGFyZSBjYWNoZWQgKGJhc2VkIG9uIHBsb3RzcGVjIGhhc2gpIGlmIG5vdCBleGVjcyBhbiBtdmJhdGNoIGFuZCBjYWNoZXMgdGhlIHJlc3VsdHNcbmNvbnN0IG12QmF0Y2ggPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMubXZCYXRjaCcsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe1xuICAgICAgICBwbG90UGFyYW1zOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBibGFja2JveDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwbG90VHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH1cbiAgICB9KS52YWxpZGF0b3IoKSxcbiAgICBydW4ocGFyYW1zKSB7XG4gICAgICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciBtdmJhdGNoID0gTVZfRElSUy5IT01FICsgXCIvYmluL212X2JhdGNoLnNoXCI7XG4gICAgICAgICAgICB2YXIgcGxvdEdyYXBoRnVuY3Rpb24gPSBtYXRzQ29sbGVjdGlvbnMuUGxvdEdyYXBoRnVuY3Rpb25zLmZpbmRPbmUoe3Bsb3RUeXBlOiBwYXJhbXMucGxvdFR5cGV9KTtcbiAgICAgICAgICAgIHZhciBwbG90U3BlY0Z1bmN0aW9uID0gcGxvdEdyYXBoRnVuY3Rpb24ucGxvdFNwZWNGdW5jdGlvbjtcbiAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICBjb25zdCBhcHBOYW1lID0gbWF0c0NvbGxlY3Rpb25zLmFwcE5hbWUuZmluZE9uZSh7fSkuYXBwO1xuICAgICAgICAgICAgY29uc3QgZnNlID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBrZXkgZnJvbSB0aGUgcGFyYW1zXG4gICAgICAgICAgICBjb25zdCBoYXNoID0gcmVxdWlyZSgnb2JqZWN0LWhhc2gnKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGhhc2gocGFyYW1zLnBsb3RQYXJhbXMpO1xuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIHNlcnZlciByb3V0ZXIgKFBpY2tlcikgdXJscyBhY2NvcmRpbmcgdG8gdGhlIGhhc2gga2V5LlxuICAgICAgICAgICAgdmFyIGFydGlmYWN0cyA9IHt9O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgICAgICBhcnRpZmFjdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBuZzogYXBwTmFtZSArIFwiL212cGxvdC9cIiArIGtleSxcbiAgICAgICAgICAgICAgICAgICAgeG1sOiBhcHBOYW1lICsgXCIvbXZ4bWwvXCIgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIHNxbDogYXBwTmFtZSArIFwiL212c3FsL1wiICsga2V5LFxuICAgICAgICAgICAgICAgICAgICBsb2c6IGFwcE5hbWUgKyBcIi9tdmxvZy9cIiArIGtleSxcbiAgICAgICAgICAgICAgICAgICAgZXJyOiBhcHBOYW1lICsgXCIvbXZlcnIvXCIgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIFI6IGFwcE5hbWUgKyBcIi9tdnNjcmlwdC9cIiArIGtleSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYXBwTmFtZSArIFwiL212ZGF0YS9cIiArIGtleSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzMTogYXBwTmFtZSArIFwiL212cG9pbnRzMS9cIiArIGtleSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzMjogYXBwTmFtZSArIFwiL212cG9pbnRzMi9cIiArIGtleSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBwcm9kdWN0aW9uIHRoZSBhcHBOYW1lIGlzIGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgbG9jYXRpb24uaHJlZlxuICAgICAgICAgICAgICAgIC8vIC0gd2hpY2ggaXMgdXNlZCB0byBmb3JtIGEgdXJsIGZvciByZXRyaWV2aW5nIHRoZSBhcnRpZmFjdFxuICAgICAgICAgICAgICAgIGFydGlmYWN0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG5nOiBcIi9tdnBsb3QvXCIgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIHhtbDogXCIvbXZ4bWwvXCIgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIHNxbDogXCIvbXZzcWwvXCIgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIGxvZzogXCIvbXZsb2cvXCIgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIGVycjogXCIvbXZlcnIvXCIgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIFI6IFwiL212c2NyaXB0L1wiICsga2V5LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIi9tdmRhdGEvXCIgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czE6IFwiL212cG9pbnRzMS9cIiArIGtleSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzMjogXCIvbXZwb2ludHMyL1wiICsga2V5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgcmVhbCBmaWxlIHBhdGhzICh0aGVzZSBhcmUgbm90IGV4cG9zZWQgdG8gY2xpZW50cylcbiAgICAgICAgICAgIGNvbnN0IHBsb3RTcGVjRmlsZVBhdGggPSBNVl9ESVJTLlhNTERJUiArIGtleSArIFwiLnhtbFwiO1xuICAgICAgICAgICAgY29uc3QgcG5nRmlsZVBhdGggPSBNVl9ESVJTLlBMT1RTRElSICsga2V5ICsgXCIucG5nXCI7XG4gICAgICAgICAgICBjb25zdCBzcWxGaWxlUGF0aCA9IE1WX0RJUlMuU1FMRElSICsga2V5ICsgXCIuc3FsXCI7XG4gICAgICAgICAgICBjb25zdCBsb2dGaWxlUGF0aCA9IE1WX0RJUlMuTE9HRElSICsga2V5ICsgXCIubG9nXCI7XG4gICAgICAgICAgICBjb25zdCBlcnJGaWxlUGF0aCA9IE1WX0RJUlMuRVJSRElSICsga2V5ICsgXCIuZXJyXCI7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHRGaWxlUGF0aCA9IE1WX0RJUlMuU0NSSVBUU0RJUiArIGtleSArIFwiLlJcIjtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFGaWxlUGF0aCA9IE1WX0RJUlMuREFUQURJUiArIGtleSArIFwiLmRhdGFcIjtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50czFQYXRoID0gTVZfRElSUy5EQVRBRElSICsga2V5ICsgXCIucG9pbnRzMVwiO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzMlBhdGggPSBNVl9ESVJTLkRBVEFESVIgKyBrZXkgKyBcIi5wb2ludHMyXCI7XG4gICAgICAgICAgICAvLyBOT1RFOiB0aGUgcGxvdFBhcmFtcyBzaG91bGQgaW5jbHVkZSBhbiBtdlBsb3Q6dHJ1ZSBwYXJhbWV0ZXIuXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBoYXZlIGJlZW4gc2V0IGluIHRoZSBjYWxsZXIuIFRoaXMgbWFrZXMgdGhlIG12IHBsb3RTcGVjIGNhY2hlIGVudHJ5IHVuaXF1ZSBmcm9tIGEgTUFUUyBwbG90XG4gICAgICAgICAgICBpZiAocGFyYW1zLnBsb3RQYXJhbXMubXZQbG90ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1ldGVvci5FcnJvcihcIkVycm9yIGluIG12QmF0Y2g6IE5vdCBhbiBtdiBwbG90IHJlcXVlc3Q6IG5vIHBsb3RQYXJhbXMubXZQbG90OnRydWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiB8fCBwYXJhbXMuZXhwaXJlS2V5KSB7XG4gICAgICAgICAgICAgICAgbWF0c0NhY2hlLmV4cGlyZUtleShrZXkpO1xuICAgICAgICAgICAgICAgIC8vIGluIGRldmVsb3BtZW50IGp1c3QgYmxvdyBhd2F5IHRoZSBmaWxlcyB0b29cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmc2UudW5saW5rU3luYyhwbG90U3BlY0ZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpe31cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmc2UudW5saW5rU3luYyhwbmdGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKXt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnNlLnVubGlua1N5bmMoc3FsRmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSl7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZzZS51bmxpbmtTeW5jKGxvZ0ZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpe31cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmc2UudW5saW5rU3luYyhlcnJGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKXt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnNlLnVubGlua1N5bmMoc2NyaXB0RmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSl7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZzZS51bmxpbmtTeW5jKGRhdGFGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKXt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnNlLnVubGlua1N5bmMocG9pbnRzMVBhdGgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSl7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZzZS51bmxpbmtTeW5jKHBvaW50czJQYXRoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpe31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyeSB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgdmFyIGFydGlmYWN0UGF0aHMgPSBtYXRzQ2FjaGUuZ2V0UmVzdWx0KGtleSk7XG4gICAgICAgICAgICB2YXIgZmlsZXNFeGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGFydGlmYWN0UGF0aHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGFydGlmYWN0IHBhdGhzIHdlcmUgYWxyZWFkeSBjYWNoZWRcbiAgICAgICAgICAgICAgICAvLyBkbyB0aGUgZmlsZXMgZXhpc3Q/XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGZpbGUgZXhpc3RlbmNlXG4gICAgICAgICAgICAgICAgdmFyIHhtbFNwZWNFeGlzdHMgPSBmc2UuZXhpc3RzU3luYyhwbG90U3BlY0ZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgcGxvdEV4aXN0cyA9IGZzZS5leGlzdHNTeW5jKHBuZ0ZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2NyaXB0RXhpc3RzID0gZnNlLmV4aXN0c1N5bmMoc2NyaXB0RmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhRXhpc3RzID0gZnNlLmV4aXN0c1N5bmMoZGF0YUZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3FsRXhpc3RzID0gZnNlLmV4aXN0c1N5bmMoc3FsRmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIHZhciBsb2dFeGlzdHMgPSBmc2UuZXhpc3RzU3luYyhsb2dGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgZmlsZXNFeGlzdCA9IHhtbFNwZWNFeGlzdHMgJiYgcGxvdEV4aXN0cyAmJiBzY3JpcHRFeGlzdHMgJiYgZGF0YUV4aXN0cyAmJiBzcWxFeGlzdHMgJiYgbG9nRXhpc3RzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWl0aGVyIHRoZSBhcnRpZmFjdHMgd2VyZSBjYWNoZWQgYnV0IHRoZSBmaWxlcyBkb24ndCBleGlzdCBvciB0aGUgYXJ0aWZhY3RzIHdlcmUgbm90IGNhY2hlZFxuICAgICAgICAgICAgaWYgKGFydGlmYWN0UGF0aHMgPT0gbnVsbCB8fCBmaWxlc0V4aXN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIGFydGlmYWN0UGF0aHMgYXJlIG5vdCBpbiB0aGUgY2FjaGUgLSBvciB0aGUgZmlsZXMgYXJlIG5vdCB0aGVyZSAtIG5lZWQgdG8gcHJvY2VzcyBwbG90U3BlY0Z1bmN0aW9uIHJvdXRpbmVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2xhdGUgdGhlIHBsb3RwYXJhbXMgdG8gYSBwbG90U3BlYyBhbmQgdXNlIHRoZSBrZXkgaW4gdGhlIHBsb3RTcGVjIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGdsb2JhbFtwbG90U3BlY0Z1bmN0aW9uXShwYXJhbXMucGxvdFBhcmFtcywga2V5LCBmdW5jdGlvbiAoZXJyLCBwbG90U3BlYykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIsIFwicGxvdHNwZWNGdW5jdGlvbjpcIiwgcGxvdFNwZWNGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKGVyciArIFwicGxvdHNwZWNGdW5jdGlvbjogXCIgKyBwbG90U3BlY0Z1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZXJyb3IgYW5kIHdlIGhhdmUgYSBwbG90IHNwZWNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBpZiB0aGUgYXJ0aWZhY3RzIGV4aXN0IGFzIGZpbGVzLiBUaGV5IG1pZ2h0IGhhdmUgYmVlbiBydW4gYmVmb3JlIGFuZCBhcmUgc3RpbGwgaGFuZ2luZyBhcm91bmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGUgTVZfT1VUUFVUIGFyZW4ndCBjYWNoZWQgYXQgYWxsIChpLmUuIG5vIGV4cGlyYXRpb24pIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSB0aGUgZXhwaXJhdGlvbiBvZiB0aGUgTUFUUyBjYWNoZSBwbG90U3BlYyBhbmQgdGhlIGFjdHVhbCBhcnRpZmFjdHMgaXMgc2xvcHB5LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZmlsZSBleGlzdGVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4bWxTcGVjRXhpc3RzID0gZnNlLmV4aXN0c1N5bmMocGxvdFNwZWNGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxvdEV4aXN0cyA9IGZzZS5leGlzdHNTeW5jKHBuZ0ZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHRFeGlzdHMgPSBmc2UuZXhpc3RzU3luYyhzY3JpcHRGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUV4aXN0cyA9IGZzZS5leGlzdHNTeW5jKGRhdGFGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3FsRXhpc3RzID0gZnNlLmV4aXN0c1N5bmMoc3FsRmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ0V4aXN0cyA9IGZzZS5leGlzdHNTeW5jKGxvZ0ZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlc0V4aXN0ID0geG1sU3BlY0V4aXN0cyAmJiBwbG90RXhpc3RzICYmIHNjcmlwdEV4aXN0cyAmJiBkYXRhRXhpc3RzICYmIHNxbEV4aXN0cyAmJiBsb2dFeGlzdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVzRXhpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtdkJhdGNoQ21kID0gTVZfRElSUy5IT01FICsgXCIvYmluL212X2JhdGNoLnNoIFwiICsgJyAnICsgcGxvdFNwZWNGaWxlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjcCA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBwbG90U3BlY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzZS5vdXRwdXRGaWxlU3luYyhwbG90U3BlY0ZpbGVQYXRoLCBwbG90U3BlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhlYyBtdiBiYXRjaCB3aXRoIHRoaXMgcGxvdFNwZWMgLSB0aGlzIHNob3VsZCBiZSBzeW5jaHJvbm91c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwLmV4ZWNTeW5jKG12QmF0Y2hDbWQsIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnNlLm91dHB1dEZpbGVTeW5jKGVyckZpbGVQYXRoLCBzdGRlcnIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3I6Y291bGRuJ3Qgd3JpdGUgZXJyb3IgZmlsZVwiICsgZXJyKTsgLy9udWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmc2Uub3V0cHV0RmlsZVN5bmMoZXJyRmlsZVBhdGgsIFwibm8gc3RkZXJyIGZvciBrZXk6IFwiICsga2V5LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOmNvdWxkbid0IHdyaXRlIGVycm9yIGZpbGVcIiArIGVycik7IC8vbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGRvdXQubWF0Y2goL0VSUk9SLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmc2Uub3V0cHV0RmlsZVN5bmMoZXJyRmlsZVBhdGgsIHN0ZG91dCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOmNvdWxkbid0IHdyaXRlIGxvZy9lcnIgZmlsZVwiICsgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnNlLm91dHB1dEZpbGVTeW5jKGxvZ0ZpbGVQYXRoLCBzdGRvdXQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3I6Y291bGRuJ3Qgd3JpdGUgbG9nIGZpbGVcIiArIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3Fsb3V0ID0gc3Rkb3V0Lm1hdGNoKC9bXFxzXFxTXSojKihTRUxFQ1RbXFxzXFxTXSopRGF0YWJhc2UvKSA9PSBudWxsID8gbnVsbCA6IHN0ZG91dC5tYXRjaCgvW1xcc1xcU10qIyooU0VMRUNUW1xcc1xcU10qKURhdGFiYXNlLylbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Fsb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmc2Uub3V0cHV0RmlsZVN5bmMoc3FsRmlsZVBhdGgsIFwibm8gc3FsIHN0YXRlbWVudCBmb3VuZCBpbiBvdXRwdXQgZm9yIGtleTogXCIgKyBrZXksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjpjb3VsZG4ndCB3cml0ZSBzcWwgZmlsZVwiICsgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmc2Uub3V0cHV0RmlsZVN5bmMoc3FsRmlsZVBhdGgsIHNxbG91dCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOmNvdWxkbid0IHdyaXRlIHNxbCBmaWxlXCIgKyBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmc2Uub3V0cHV0RmlsZVN5bmMobG9nRmlsZVBhdGgsIFwiTm8gc3Rkb3V0IGNhcHR1cmVkIGZvcjogXCIgKyBrZXksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3I6Y291bGRuJ3Qgd3JpdGUgbG9nIGZpbGVcIiArIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBlcnJvciAtIGNoZWNrIGZvciB0aGUgZmlsZXMgYW5kIGNhY2hlIHRoZSBzcGVjIGFuZCBmaWxlUGF0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhtbFNwZWNFeGlzdHMgPSBmc2UuZXhpc3RzU3luYyhwbG90U3BlY0ZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsb3RFeGlzdHMgPSBmc2UuZXhpc3RzU3luYyhwbmdGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHRFeGlzdHMgPSBmc2UuZXhpc3RzU3luYyhzY3JpcHRGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhRXhpc3RzID0gZnNlLmV4aXN0c1N5bmMoZGF0YUZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNxbEV4aXN0cyA9IGZzZS5leGlzdHNTeW5jKHNxbEZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ0V4aXN0cyA9IGZzZS5leGlzdHNTeW5jKGxvZ0ZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVzRXhpc3QgPSB4bWxTcGVjRXhpc3RzICYmIHBsb3RFeGlzdHMgJiYgc2NyaXB0RXhpc3RzICYmIGRhdGFFeGlzdHMgJiYgc3FsRXhpc3RzICYmIGxvZ0V4aXN0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlc0V4aXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdleGVjIGVycm9yOiBleHBlY3RlZCBmaWxlcyBkbyBub3QgZXhpc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRzQ2FjaGUuc3RvcmVSZXN1bHQoa2V5LCBhcnRpZmFjdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG12YmF0Y2ggc2hvdWxkIGhhdmUgc2F2ZWQgdGhlIHBsb3QgYXJ0aWZhY3RzIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHBsb3RTcGVjIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRhdGFfZmlsZT5rZXkuZGF0YTwvZGF0YV9maWxlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwbG90X2ZpbGU+a2V5LnBuZzwvcGxvdF9maWxlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyX2ZpbGU+a2V5LlI8L3JfZmlsZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlIGtleSBpcyB0aGUgc2FtZSBhcyB0aGUga2V5IGZvciB0aGUgbWF0c0NhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgc3RvcmVkIGFydGlmYWN0cyBzaG91bGtkIGJlIGxpa2UgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTVZfT1VUUFVUL3Bsb3RzL2tleS5wbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNVl9PVVRQVVQveG1sL2tleS54bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNVl9PVVRQVVQveG1sL2tleS5zcWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNVl9PVVRQVVQveG1sL2tleS5sb2dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNVl9PVVRQVVQvc2NyaXB0cy9rZXkuUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1WX09VVFBVVC9kYXRhL2tleS5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTVZfT1VUUFVUL2RhdGEva2V5LnN1bV9zdGF0LmluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNVl9PVVRQVVQvZGF0YS9rZXkuZGF0YS5zdW1fc3RhdFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTVZfT1VUUFVUL3htbC9rZXkueG1sIGlzIHRoZSBwbG90U3BlY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geydrZXknOiBrZXksICdhcnRpZmFjdHMnOmFydGlmYWN0c307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IC8vcmV0ID0ge2tleTprZXksIHJlc3VsdDp7YXJ0aWZhY3RzOmFydGlmYWN0c319XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBrZXkgYW5kIHRoZSBhcnRpZmFjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gIC8vIHBsb3RzcGVjIGRpZCBub3QgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmaWxlcyBhY3R1YWxseSBhbHJlYWR5IGV4aXN0ZWQgYnV0IHdlIG5lZWRlZCB0aGUgcGxvdHNwZWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBqdXN0IHJlZnJlc2ggdGhlIGNhY2hlIGFuZCByZXR1cm4gdGhlIGtleSByaWdodCBhd2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0c0NhY2hlLnN0b3JlUmVzdWx0KGtleSwgYXJ0aWZhY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geydrZXknOiBrZXksICdhcnRpZmFjdHMnOmFydGlmYWN0c307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gLy8gZWl0aGVyIGFydGlmYWN0UGF0aHMgPT0gbnVsbCB8fCBmaWxlc0V4aXN0ID09PSBmYWxzZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXJ0aWZhY3RzIGV4aXN0ZWQgYW5kIHBsb3RzcGVjIGV4aXN0ZWQgLSByZWZyZXNoIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgIG1hdHNDYWNoZS5zdG9yZVJlc3VsdChrZXksIGFydGlmYWN0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsna2V5Jzoga2V5LCAnYXJ0aWZhY3RzJzphcnRpZmFjdHN9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsna2V5Jzoga2V5LCAnYXJ0aWZhY3RzJzphcnRpZmFjdHN9O1xuICAgICAgICB9IC8vIGlmIE1ldGVvciBpcyBTZXJ2ZXJcbiAgICB9IC8vIHJ1blxufSk7XG5cbi8vIGFkbWluaXN0cmF0aW9uIHRvb2xcbmNvbnN0IHJlYWRGdW5jdGlvbkZpbGUgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMucmVhZEZ1bmN0aW9uRmlsZScsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe30pLnZhbGlkYXRvcigpLFxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICAgICAgdmFyIGZ1dHVyZSA9IHJlcXVpcmUoJ2ZpYmVycy9mdXR1cmUnKTtcbiAgICAgICAgICAgIHZhciBmc2UgPSByZXF1aXJlKCdmcy1leHRyYScpO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGZEYXRhO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCIvd2ViL3N0YXRpYy9kYXRhRnVuY3Rpb25zL1wiICsgZmlsZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZXhwb3J0aW5nIGRhdGEgZmlsZTogJyArIHBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwiZ3JhcGhcIikge1xuICAgICAgICAgICAgICAgIHBhdGggPSBcIi93ZWIvc3RhdGljL2Rpc3BsYXlGdW5jdGlvbnMvXCIgKyBmaWxlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdleHBvcnRpbmcgZ3JhcGggZmlsZTogJyArIHBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFwiZXJyb3IgLSB3cm9uZyB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnNlLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgZkRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgZnV0dXJlW1wicmV0dXJuXCJdKGZEYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1dHVyZS53YWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLy8gcmVmcmVzaGVzIHRoZSBtZXRhZGF0YSBmb3IgdGhlIGFwcCB0aGF0J3MgcnVubmluZ1xuY29uc3QgcmVmcmVzaE1ldGFEYXRhID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLnJlZnJlc2hNZXRhRGF0YScsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe30pLnZhbGlkYXRvcigpLFxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQXNrZWQgdG8gcmVmcmVzaCBtZXRhZGF0YVwiKTtcbiAgICAgICAgICAgICAgICBfY2hlY2tNZXRhRGF0YVJlZnJlc2goKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKFwiU2VydmVyIGVycm9yOiBcIiwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YURhdGFUYWJsZVVwZGF0ZXMuZmluZCh7fSkuZmV0Y2goKTtcbiAgICB9XG59KTtcblxuLy8gYWRtaW5pc3RhdGlvbiB0b29sXG5jb25zdCByZW1vdmVBdXRob3JpemF0aW9uID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLnJlbW92ZUF1dGhvcml6YXRpb24nLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHtcbiAgICAgICAgc2V0dGluZ3M6IHt0eXBlOiBPYmplY3QsIGJsYWNrYm94OiB0cnVlfVxuICAgIH0pLnZhbGlkYXRvcigpLFxuICAgIHJ1bihzZXR0aW5ncykge1xuICAgICAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgICAgICB2YXIgZW1haWw7XG4gICAgICAgICAgICB2YXIgcm9sZU5hbWU7XG4gICAgICAgICAgICB2YXIgdXNlclJvbGVOYW1lID0gc2V0dGluZ3MudXNlclJvbGVOYW1lO1xuICAgICAgICAgICAgdmFyIGF1dGhvcml6YXRpb25Sb2xlID0gc2V0dGluZ3MuYXV0aG9yaXphdGlvblJvbGU7XG4gICAgICAgICAgICB2YXIgbmV3VXNlckVtYWlsID0gc2V0dGluZ3MubmV3VXNlckVtYWlsO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVXNlckVtYWlsID0gc2V0dGluZ3MuZXhpc3RpbmdVc2VyRW1haWw7XG4gICAgICAgICAgICBpZiAoYXV0aG9yaXphdGlvblJvbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyByb2xlIC0gdGhlIHJvbGUgcm9sZU5hbWUgLSBubyBuZWVkIHRvIHZlcmlmeSBhcyB0aGUgc2VsZWN0aW9uIGxpc3QgY2FtZSBmcm9tIHRoZSBkYXRhYmFzZVxuICAgICAgICAgICAgICAgIHJvbGVOYW1lID0gYXV0aG9yaXphdGlvblJvbGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVzZXJSb2xlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJvbGVOYW1lID0gdXNlclJvbGVOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVXNlckVtYWlsKSB7XG4gICAgICAgICAgICAgICAgZW1haWwgPSBleGlzdGluZ1VzZXJFbWFpbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW1haWwgPSBuZXdVc2VyRW1haWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHVzZXIgYW5kIHJvbGUgcmVtb3ZlIHRoZSByb2xlIGZyb20gdGhlIHVzZXJcbiAgICAgICAgICAgIGlmIChlbWFpbCAmJiByb2xlTmFtZSkge1xuICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5BdXRob3JpemF0aW9uLnVwZGF0ZSh7ZW1haWw6IGVtYWlsfSwgeyRwdWxsOiB7cm9sZXM6IHJvbGVOYW1lfX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdXNlciBhbmQgbm8gcm9sZSByZW1vdmUgdGhlIHVzZXJcbiAgICAgICAgICAgIGlmIChlbWFpbCAmJiAhcm9sZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuQXV0aG9yaXphdGlvbi5yZW1vdmUoe2VtYWlsOiBlbWFpbH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgcm9sZSBhbmQgbm8gdXNlciByZW1vdmUgcm9sZSBhbmQgcmVtb3ZlIHJvbGUgZnJvbSBhbGwgdXNlcnNcbiAgICAgICAgICAgIGlmIChyb2xlTmFtZSAmJiAhZW1haWwpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHJvbGVcbiAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuUm9sZXMucmVtb3ZlKHtuYW1lOiByb2xlTmFtZX0pO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgcm9sZU5hbWUgcm9sZSBmcm9tIGFsbCB0aGUgYXV0aG9yaXphdGlvbnNcbiAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuQXV0aG9yaXphdGlvbi51cGRhdGUoe3JvbGVzOiByb2xlTmFtZX0sIHskcHVsbDoge3JvbGVzOiByb2xlTmFtZX19LCB7bXVsdGk6IHRydWV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vLyBhcHAgdXRpbGl0eVxuY29uc3QgcmVtb3ZlQ29sb3IgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMucmVtb3ZlQ29sb3InLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHtcbiAgICAgICAgcmVtb3ZlQ29sb3I6IHt0eXBlOiBTdHJpbmd9XG4gICAgfSkudmFsaWRhdG9yKCksXG4gICAgcnVuKHJlbW92ZUNvbG9yKSB7XG4gICAgICAgIHZhciBjb2xvclNjaGVtZSA9IG1hdHNDb2xsZWN0aW9ucy5Db2xvclNjaGVtZS5maW5kT25lKHt9KTtcbiAgICAgICAgdmFyIHJlbW92ZUluZGV4ID0gY29sb3JTY2hlbWUuY29sb3JzLmluZGV4T2YocmVtb3ZlQ29sb3IpO1xuICAgICAgICBjb2xvclNjaGVtZS5jb2xvcnMuc3BsaWNlKHJlbW92ZUluZGV4LCAxKTtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkNvbG9yU2NoZW1lLnVwZGF0ZSh7fSwgY29sb3JTY2hlbWUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSk7XG5cbi8vIGRhdGFiYXNlIGNvbnRyb2xzXG5jb25zdCByZW1vdmVEYXRhYmFzZSA9IG5ldyBWYWxpZGF0ZWRNZXRob2Qoe1xuICAgIG5hbWU6ICdtYXRzTWV0aG9kcy5yZW1vdmVEYXRhYmFzZScsXG4gICAgdmFsaWRhdGU6IG5ldyBTaW1wbGVTY2hlbWEoe1xuICAgICAgICBkYk5hbWU6IHt0eXBlOiBTdHJpbmd9XG4gICAgfSkudmFsaWRhdG9yKCksXG4gICAgcnVuKGRiTmFtZSkge1xuICAgICAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuRGF0YWJhc2VzLnJlbW92ZSh7bmFtZTogZGJOYW1lfSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLy8gbWFrZXMgc3VyZSBhbGwgb2YgdGhlIHBhcmFtZXRlcnMgZGlzcGxheSBhcHByb3ByaWF0ZSBzZWxlY3Rpb25zIGluIHJlbGF0aW9uIHRvIG9uZSBhbm90aGVyXG5jb25zdCByZXNldEFwcCA9IGZ1bmN0aW9uIChhcHBSZWYpIHtcbiAgICB2YXIgZnNlID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbiAgICBjb25zdCBtZXRhRGF0YVRhYmxlUmVjb3JkcyA9IGFwcFJlZi5hcHBNZHI7XG4gICAgY29uc3QgdHlwZSA9IGFwcFJlZi5hcHBUeXBlO1xuICAgIGNvbnN0IGFwcE5hbWUgPSBhcHBSZWYuYXBwO1xuICAgIHZhciBkZXBfZW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlY7XG4gICAgLy8gc2V0IHNvbWUgZGVmYXVsdHMgZm9yIHB5dGhvbiBwcm9jZXNzaW5nIC0gdGhlc2UgY2FuIGJlIG92ZXJyaWRkZW5cbiAgICBpZiAoTWV0ZW9yLnNldHRpbmdzLnByaXZhdGUgIT0gbnVsbCAmJiBNZXRlb3Iuc2V0dGluZ3MucHJpdmF0ZS5QWVRIT05fUEFUSCA9PSBudWxsKSB7XG4gICAgICAgIE1ldGVvci5zZXR0aW5ncy5wcml2YXRlLlBZVEhPTl9QQVRIID0gXCIvdXNyL2Jpbi9weXRob25cIjtcbiAgICB9XG5cbiAgICBpZiAoTWV0ZW9yLnNldHRpbmdzLnByaXZhdGUgIT0gbnVsbCAmJiBNZXRlb3Iuc2V0dGluZ3MucHJpdmF0ZS5wcm9jZXNzICE9IG51bGwgJiYgTWV0ZW9yLnNldHRpbmdzLnByaXZhdGUucHJvY2Vzcy5SVU5fRU5WICE9IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChNZXRlb3Iuc2V0dGluZ3MucHJpdmF0ZS5wcm9jZXNzLlJVTl9FTlYpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZXZlbG9wbWVudFwiOlxuICAgICAgICAgICAgY2FzZSBcImludGVncmF0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIFwicHJvZHVjdGlvblwiOlxuICAgICAgICAgICAgICAgIGRlcF9lbnYgPSBNZXRlb3Iuc2V0dGluZ3MucHJpdmF0ZS5wcm9jZXNzLlJVTl9FTlY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGRlcF9lbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBkZXBsb3ltZW50O1xuICAgIHZhciBkZXBsb3ltZW50VGV4dCA9IEFzc2V0cy5nZXRUZXh0KCdwdWJsaWMvZGVwbG95bWVudC9kZXBsb3ltZW50Lmpzb24nKTtcbiAgICBpZiAoZGVwbG95bWVudFRleHQgPT0gbnVsbCkgeyAgLy8gZXF1aXZpbGVudCB0byBkZXBsb3ltZW50VGV4dCA9PT0gbnVsbCB8fCBkZXBsb3ltZW50VGV4dCA9PT0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGRlcGxveW1lbnQgPSBKU09OLnBhcnNlKGRlcGxveW1lbnRUZXh0KTtcbiAgICB2YXIgYXBwID0ge307XG4gICAgZm9yICh2YXIgYWkgPSAwOyBhaSA8IGRlcGxveW1lbnQubGVuZ3RoOyBhaSsrKSB7XG4gICAgICAgIHZhciBkZXAgPSBkZXBsb3ltZW50W2FpXTtcbiAgICAgICAgaWYgKGRlcC5kZXBsb3ltZW50X2Vudmlyb25tZW50ID09IGRlcF9lbnYpIHtcbiAgICAgICAgICAgIGFwcCA9IGRlcC5hcHBzLmZpbHRlcihmdW5jdGlvbiAoYXBwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcC5hcHAgPT09IGFwcE5hbWU7XG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhcHBWZXJzaW9uID0gYXBwID8gYXBwLnZlcnNpb24gOiBcInVua25vd25cIjtcbiAgICBjb25zdCBhcHBUaXRsZSA9IGFwcCA/IGFwcC50aXRsZSA6IFwidW5rbm93blwiO1xuICAgIGNvbnN0IGJ1aWxkRGF0ZSA9IGFwcCA/IGFwcC5idWlsZERhdGUgOiBcInVua25vd25cIjtcbiAgICBjb25zdCBhcHBUeXBlID0gdHlwZSA/IHR5cGUgOiBtYXRzVHlwZXMuQXBwVHlwZXMubWF0cztcbiAgICBtYXRzQ29sbGVjdGlvbnMuYXBwTmFtZS51cHNlcnQoe2FwcDphcHBOYW1lfSx7JHNldDp7YXBwOmFwcE5hbWV9fSk7XG5cbiAgICAvLyByZW1lbWJlciB0aGF0IHdlIHVwZGF0ZWQgdGhlIG1ldGFkYXRhIHRhYmxlcyBqdXN0IG5vdyAtIGNyZWF0ZSBtZXRhRGF0YVRhYmxlVXBkYXRlc1xuICAgIC8qXG4gICAgICAgIG1ldGFEYXRhVGFibGVVcGRhdGVzOlxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBkYXRhQmFzZU5hbWUsXG4gICAgICAgICAgICB0YWJsZXM6IFt0YWJsZU5hbWUxLCB0YWJsZU5hbWUyIC4uXSxcbiAgICAgICAgICAgIGxhc3RSZWZyZXNoZWQgOiB0aW1lc3RhbXBcbiAgICAgICAgfVxuICAgICAqL1xuICAgIC8vIG9ubHkgY3JlYXRlIG1ldGFkYXRhIHRhYmxlcyBpZiB0aGUgcmVzZXRBcHAgd2FzIGNhbGxlZCB3aXRoIGEgcmVhbCBtZXRhRGF0YVRhYmxlcyBvYmplY3RcbiAgICBpZiAobWV0YURhdGFUYWJsZVJlY29yZHMgaW5zdGFuY2VvZiBtYXRzVHlwZXMuTWV0YURhdGFEQlJlY29yZCkge1xuICAgICAgICB2YXIgbWV0YURhdGFUYWJsZXMgPSBtZXRhRGF0YVRhYmxlUmVjb3Jkcy5nZXRSZWNvcmRzKCk7XG4gICAgICAgIGZvciAodmFyIG1kdGkgPSAwOyBtZHRpIDwgbWV0YURhdGFUYWJsZXMubGVuZ3RoOyBtZHRpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFEYXRhUmVmID0gbWV0YURhdGFUYWJsZXNbbWR0aV07XG4gICAgICAgICAgICBtZXRhRGF0YVJlZi5sYXN0UmVmcmVzaGVkID0gbW9tZW50KCkuZm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAobWV0YURhdGFUYWJsZVVwZGF0ZXMuZmluZCh7bmFtZTogbWV0YURhdGFSZWYubmFtZX0pLmNvdW50KCkgPT0gMCkge1xuICAgICAgICAgICAgICAgIG1ldGFEYXRhVGFibGVVcGRhdGVzLnVwZGF0ZSh7bmFtZTogbWV0YURhdGFSZWYubmFtZX0sIG1ldGFEYXRhUmVmLCB7dXBzZXJ0OiB0cnVlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKFwiU2VydmVyIGVycm9yOiBcIiwgXCJyZXNldEFwcDogYmFkIHBvb2wtZGF0YWJhc2UgZW50cnlcIik7XG4gICAgfVxuXG4gICAgbWF0c0NvbGxlY3Rpb25zLlJvbGVzLnJlbW92ZSh7fSk7XG4gICAgbWF0c0RhdGFVdGlscy5kb1JvbGVzKCk7XG4gICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24ucmVtb3ZlKHt9KTtcbiAgICBtYXRzRGF0YVV0aWxzLmRvQXV0aG9yaXphdGlvbigpO1xuICAgIG1hdHNDb2xsZWN0aW9ucy5DcmVkZW50aWFscy5yZW1vdmUoe30pO1xuICAgIG1hdHNEYXRhVXRpbHMuZG9DcmVkZW50aWFscygpO1xuICAgIG1hdHNDb2xsZWN0aW9ucy5QbG90R3JhcGhGdW5jdGlvbnMucmVtb3ZlKHt9KTtcbiAgICBtYXRzQ29sbGVjdGlvbnMuQ29sb3JTY2hlbWUucmVtb3ZlKHt9KTtcbiAgICBtYXRzRGF0YVV0aWxzLmRvQ29sb3JTY2hlbWUoKTtcbiAgICBtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MucmVtb3ZlKHt9KTtcbiAgICBtYXRzRGF0YVV0aWxzLmRvU2V0dGluZ3MoYXBwVGl0bGUsIGFwcFZlcnNpb24sIGJ1aWxkRGF0ZSwgYXBwVHlwZSk7XG4gICAgbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLnJlbW92ZSh7fSk7XG4gICAgbWF0c0NvbGxlY3Rpb25zLlBsb3RQYXJhbXMucmVtb3ZlKHt9KTtcbiAgICBtYXRzQ29sbGVjdGlvbnMuQ3VydmVUZXh0UGF0dGVybnMucmVtb3ZlKHt9KTtcbi8vIGFwcCBzcGVjaWZpYyByb3V0aW5lc1xuICAgIC8vY29uc3QgYXNyS2V5cyA9IE9iamVjdC5rZXlzKGFwcFNwZWNpZmljUmVzZXRSb3V0aW5lcyk7XG4gICAgY29uc3QgYXNyS2V5cyA9IGFwcFNwZWNpZmljUmVzZXRSb3V0aW5lcztcbiAgICBmb3IgKHZhciBhaSA9IDA7IGFpIDwgYXNyS2V5cy5sZW5ndGg7IGFpKyspIHtcbiAgICAgICAgZ2xvYmFsLmFwcFNwZWNpZmljUmVzZXRSb3V0aW5lc1thaV0oKTtcbiAgICB9XG4gICAgbWF0c0NhY2hlLmNsZWFyKCk7XG59O1xuXG4vLyBhZG1pbmlzdHJhdGlvbiB0b29sXG5jb25zdCByZXN0b3JlRnJvbUZpbGUgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMucmVzdG9yZUZyb21GaWxlJyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYSh7XG4gICAgICAgIHR5cGU6IHt0eXBlOiBTdHJpbmd9LFxuICAgICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgICAgZGF0YToge3R5cGU6IE9iamVjdCwgYmxhY2tib3g6IHRydWV9XG4gICAgfSkudmFsaWRhdG9yKCksXG5cbiAgICBydW4ocGFyYW1zKSB7XG4gICAgICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzdG9yaW5nIFwiICsgcGFyYW1zLnR5cGUgKyBcIiBmaWxlIFwiICsgcGFyYW1zLm5hbWUpO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50eXBlID09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IFwiL3dlYi9zdGF0aWMvZGF0YUZ1bmN0aW9ucy9cIiArIHBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMueXBlID09IFwiZ3JhcGhcIikge1xuICAgICAgICAgICAgICAgIHBhdGggPSBcIi93ZWIvc3RhdGljL2Rpc3BsYXlGdW5jdGlvbnMvXCIgKyBwYXJhbXMubmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcImVycm9yIC0gd3JvbmcgdHlvZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdpbXBvcnRpbmcgJyArIHBhcmFtcy50eXBlICsgJyBmaWxlOiAnICsgcGF0aCk7XG4gICAgICAgICAgICB2YXIgZnNlID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbiAgICAgICAgICAgIGZzZS53cml0ZUZpbGUocGF0aCwgcGFyYW1zLmRhdGEudG9TdHJpbmcoKSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlcnIudG9Mb2NhbGVTdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdpbXBvcnRlZCAnICsgcGFyYW1zLnR5cGUgKyAnIGZpbGU6ICcgKyBwYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8vIGFkbWluaXN0cmF0aW9uIHRvb2xcbmNvbnN0IHJlc3RvcmVGcm9tUGFyYW1ldGVyRmlsZSA9IG5ldyBWYWxpZGF0ZWRNZXRob2Qoe1xuICAgIG5hbWU6ICdtYXRzTWV0aG9kcy5yZXN0b3JlRnJvbVBhcmFtZXRlckZpbGUnLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHtcbiAgICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXG4gICAgICAgIGRhdGE6IHt0eXBlOiBPYmplY3QsIGJsYWNrYm94OiB0cnVlfVxuICAgIH0pLnZhbGlkYXRvcigpLFxuICAgIHJ1bihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgICAgIGlmIChkYXRhLkN1cnZlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLnJlbW92ZSh7fSk7XG4gICAgICAgICAgICAgICAgZCA9IF8ubWFwKGRhdGEuQ3VydmVQYXJhbXMsIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm9taXQobywgJ19pZCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuQ3VydmVQYXJhbXMuaW5zZXJ0KG8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuUGxvdFBhcmFtcykge1xuICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5QbG90UGFyYW1zLnJlbW92ZSh7fSk7XG4gICAgICAgICAgICAgICAgZCA9IF8ubWFwKGRhdGEuUGxvdFBhcmFtcywgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ub21pdChvLCAnX2lkJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5QbG90UGFyYW1zLmluc2VydChvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLlBsb3RHcmFwaEZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5QbG90R3JhcGhGdW5jdGlvbnMucmVtb3ZlKHt9KTtcbiAgICAgICAgICAgICAgICBkID0gXy5tYXAoZGF0YS5QbG90R3JhcGhGdW5jdGlvbnMsIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm9taXQobywgJ19pZCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuUGxvdEdyYXBoRnVuY3Rpb25zLmluc2VydChvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLlNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgbWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzLnJlbW92ZSh7fSk7XG4gICAgICAgICAgICAgICAgZCA9IF8ubWFwKGRhdGEuU2V0dGluZ3MsIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm9taXQobywgJ19pZCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuaW5zZXJ0KG8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuQ29sb3JTY2hlbWUpIHtcbiAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuQ29sb3JTY2hlbWUucmVtb3ZlKHt9KTtcbiAgICAgICAgICAgICAgICBkID0gXy5tYXAoZGF0YS5Db2xvclNjaGVtZSwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ub21pdChvLCAnX2lkJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5Db2xvclNjaGVtZS5pbnNlcnQobyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5BdXRob3JpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24ucmVtb3ZlKHt9KTtcbiAgICAgICAgICAgICAgICBkID0gXy5tYXAoZGF0YS5BdXRob3JpemF0aW9uLCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5vbWl0KG8sICdfaWQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24uaW5zZXJ0KG8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuUm9sZXMpIHtcbiAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuUm9sZXMucmVtb3ZlKHt9KTtcbiAgICAgICAgICAgICAgICBkID0gXy5tYXAoZGF0YS5Sb2xlcywgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ub21pdChvLCAnX2lkJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5Sb2xlcy5pbnNlcnQobyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5EYXRhYmFzZXMpIHtcbiAgICAgICAgICAgICAgICBtYXRzQ29sbGVjdGlvbnMuRGF0YWJhc2VzLnJlbW92ZSh7fSk7XG4gICAgICAgICAgICAgICAgZCA9IF8ubWFwKGRhdGEuRGF0YWJhc2VzLCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5vbWl0KG8sICdfaWQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkRhdGFiYXNlcy5pbnNlcnQobyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5DcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5DcmVkZW50aWFscy5yZW1vdmUoe30pO1xuICAgICAgICAgICAgICAgIGQgPSBfLm1hcChkYXRhLkNyZWRlbnRpYWxzLCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5vbWl0KG8sICdfaWQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkNyZWRlbnRpYWxzLmluc2VydChvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBzYXZlTGF5b3V0ID0gbmV3IFZhbGlkYXRlZE1ldGhvZCh7XG4gICAgbmFtZTogJ21hdHNNZXRob2RzLnNhdmVMYXlvdXQnLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHtcbiAgICAgICAgcmVzdWx0S2V5OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsIGJsYWNrYm94OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGN1cnZlT3BzVXBkYXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsIGJsYWNrYm94OiB0cnVlXG4gICAgICAgIH1cbiAgICB9KS52YWxpZGF0b3IoKSxcbiAgICBydW4ocGFyYW1zKSB7XG4gICAgICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwYXJhbXMucmVzdWx0S2V5O1xuICAgICAgICAgICAgdmFyIGxheW91dCA9IHBhcmFtcy5sYXlvdXQ7XG4gICAgICAgICAgICB2YXIgY3VydmVPcHNVcGRhdGUgPSBwYXJhbXMuY3VydmVPcHNVcGRhdGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIExheW91dFN0b3JlQ29sbGVjdGlvbi51cHNlcnQoe2tleToga2V5fSwgeyRzZXQ6IHtcImNyZWF0ZWRBdFwiOiBuZXcgRGF0ZSgpLCBsYXlvdXQ6IGxheW91dCwgY3VydmVPcHNVcGRhdGU6IGN1cnZlT3BzVXBkYXRlfX0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKFwiRXJyb3IgaW4gc2F2ZUxheW91dCBmdW5jdGlvbjpcIiArIGtleSArIFwiIDogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vL2FkbWluaXN0cmF0aW9uIHRvb2xzXG5jb25zdCBzYXZlU2V0dGluZ3MgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMuc2F2ZVNldHRpbmdzJyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYSh7XG4gICAgICAgIHNhdmVBczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHA6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIGJsYWNrYm94OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBlcm1pc3Npb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9XG4gICAgfSkudmFsaWRhdG9yKCksXG4gICAgcnVuKHBhcmFtcykge1xuICAgICAgICB2YXIgdXNlciA9IFwiYW5vbnltb3VzXCI7XG4gICAgICAgIG1hdHNDb2xsZWN0aW9ucy5DdXJ2ZVNldHRpbmdzLnVwc2VydCh7bmFtZTogcGFyYW1zLnNhdmVBc30sIHtcbiAgICAgICAgICAgIGNyZWF0ZWQ6IG1vbWVudCgpLmZvcm1hdChcIk1NL0REL1lZWVkgSEg6bW06c3NcIiksXG4gICAgICAgICAgICBuYW1lOiBwYXJhbXMuc2F2ZUFzLFxuICAgICAgICAgICAgZGF0YTogcGFyYW1zLnAsXG4gICAgICAgICAgICBvd25lcjogTWV0ZW9yLnVzZXJJZCgpID09IG51bGwgPyBcImFub255bW91c1wiIDogTWV0ZW9yLnVzZXJJZCgpLFxuICAgICAgICAgICAgcGVybWlzc2lvbjogcGFyYW1zLnBlcm1pc3Npb24sXG4gICAgICAgICAgICBzYXZlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgc2F2ZWRCeTogTWV0ZW9yLnVzZXIoKSA9PSBudWxsID8gXCJhbm9ueW1vdXNcIiA6IHVzZXJcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8vIGFkbWluaXN0YXRpb24gdG9vbFxuY29uc3Qgc2V0Q3JlZGVudGlhbHMgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMuc2V0Q3JlZGVudGlhbHMnLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHtcbiAgICAgICAgc2V0dGluZ3M6IHt0eXBlOiBPYmplY3QsIGJsYWNrYm94OiB0cnVlfVxuICAgIH0pLnZhbGlkYXRvcigpLFxuICAgIHJ1bihzZXR0aW5ncykge1xuICAgICAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHNldHRpbmdzLm5hbWU7XG4gICAgICAgICAgICB2YXIgY2xpZW50SWQgPSBzZXR0aW5ncy5jbGllbnRJZDtcbiAgICAgICAgICAgIHZhciBjbGllbnRTZWNyZXQgPSBzZXR0aW5ncy5jbGllbnRTZWNyZXQ7XG4gICAgICAgICAgICB2YXIgY2xpZW50UmVmcmVzaFRva2VuID0gc2V0dGluZ3MuY2xpZW50UmVmcmVzaFRva2VuO1xuICAgICAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkNyZWRlbnRpYWxzLnVwZGF0ZSh7fSwge1xuICAgICAgICAgICAgICAgICRzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQ6IGNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRTZWNyZXQ6IGNsaWVudFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogY2xpZW50UmVmcmVzaFRva2VuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3Qgc2V0U2V0dGluZ3MgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMuc2V0U2V0dGluZ3MnLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHtcbiAgICAgICAgc2V0dGluZ3M6IHt0eXBlOiBPYmplY3QsIGJsYWNrYm94OiB0cnVlfVxuICAgIH0pLnZhbGlkYXRvcigpLFxuICAgIHJ1bihwYXJhbXMpIHtcbiAgICAgICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gcGFyYW1zLnNldHRpbmdzO1xuICAgICAgICAgICAgdmFyIGxhYmVsUHJlZml4ID0gc2V0dGluZ3MubGFiZWxQcmVmaXg7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBzZXR0aW5ncy50aXRsZTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzZXR0aW5ncy5saW5lV2lkdGg7XG4gICAgICAgICAgICB2YXIgbnVsbEZpbGxTdHJpbmcgPSBzZXR0aW5ncy5udWxsRmlsbFN0cmluZztcbiAgICAgICAgICAgIHZhciByZXNldEZyb21Db2RlID0gc2V0dGluZ3MucmVzZXRGcm9tQ29kZTtcbiAgICAgICAgICAgIG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy51cGRhdGUoe30sIHtcbiAgICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIExhYmVsUHJlZml4OiBsYWJlbFByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgVGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBMaW5lV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgTnVsbEZpbGxTdHJpbmc6IG51bGxGaWxsU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICByZXNldEZyb21Db2RlOiByZXNldEZyb21Db2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pO1xuXG5cbi8qIHRlc3QgbWV0aG9kcyAqL1xuXG5jb25zdCB0ZXN0R2V0TWV0YURhdGFUYWJsZVVwZGF0ZXMgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMudGVzdEdldE1ldGFEYXRhVGFibGVVcGRhdGVzJyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYSh7fSkudmFsaWRhdG9yKCksXG4gICAgcnVuKCkge1xuICAgICAgICByZXR1cm4gbWV0YURhdGFUYWJsZVVwZGF0ZXMuZmluZCh7fSkuZmV0Y2goKTtcbiAgICB9XG59KTtcblxuY29uc3QgdGVzdEdldFRhYmxlcyA9IG5ldyBWYWxpZGF0ZWRNZXRob2Qoe1xuICAgIG5hbWU6ICdtYXRzTWV0aG9kcy50ZXN0R2V0VGFibGVzJyxcbiAgICB2YWxpZGF0ZTogbmV3IFNpbXBsZVNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgICAgaG9zdDoge3R5cGU6IFN0cmluZ30sXG4gICAgICAgICAgICB1c2VyOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgICAgICAgIGRhdGFiYXNlOiB7dHlwZTogU3RyaW5nfVxuICAgICAgICB9KS52YWxpZGF0b3IoKSxcbiAgICBydW4ocGFyYW1zKSB7XG4gICAgICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IEZ1dHVyZSA9IHJlcXVpcmUoJ2ZpYmVycy9mdXR1cmUnKTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5V3JhcCA9IEZ1dHVyZS53cmFwKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBteXNxbC5jcmVhdGVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogcGFyYW1zLmhvc3QsXG4gICAgICAgICAgICAgICAgICAgIHVzZXI6IHBhcmFtcy51c2VyLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhYmFzZTogcGFyYW1zLmRhdGFiYXNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5xdWVyeShcInNob3cgdGFibGVzO1wiLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVzID0gcmVzdWx0Lm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuVGFibGVzX2luX3J1Y191YV9zdW1zMjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHRhYmxlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5lbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlc3RHZXRUYWJsZXMgY2Fubm90IGVuZCBjb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeVdyYXAoKS53YWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgdGVzdFNldE1ldGFEYXRhVGFibGVVcGRhdGVzTGFzdFJlZnJlc2hlZEJhY2sgPSBuZXcgVmFsaWRhdGVkTWV0aG9kKHtcbiAgICBuYW1lOiAnbWF0c01ldGhvZHMudGVzdFNldE1ldGFEYXRhVGFibGVVcGRhdGVzTGFzdFJlZnJlc2hlZEJhY2snLFxuICAgIHZhbGlkYXRlOiBuZXcgU2ltcGxlU2NoZW1hKHt9KS52YWxpZGF0b3IoKSxcbiAgICBydW4oKSB7XG4gICAgICAgIHZhciBtdHUgPSBtZXRhRGF0YVRhYmxlVXBkYXRlcy5maW5kKHt9KS5mZXRjaCgpO1xuICAgICAgICB2YXIgaWQgPSBtdHVbMF0uX2lkO1xuICAgICAgICBtZXRhRGF0YVRhYmxlVXBkYXRlcy51cGRhdGUoe19pZDogaWR9LCB7JHNldDoge2xhc3RSZWZyZXNoZWQ6IDB9fSk7XG4gICAgICAgIHJldHVybiBtZXRhRGF0YVRhYmxlVXBkYXRlcy5maW5kKHt9KS5mZXRjaCgpO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtYXRzTWV0aG9kcyA9IHtcbiAgICBhZGRTZW50QWRkcmVzczogYWRkU2VudEFkZHJlc3MsXG4gICAgYXBwbHlBdXRob3JpemF0aW9uOiBhcHBseUF1dGhvcml6YXRpb24sXG4gICAgYXBwbHlEYXRhYmFzZVNldHRpbmdzOiBhcHBseURhdGFiYXNlU2V0dGluZ3MsXG4gICAgZGVsZXRlU2V0dGluZ3M6IGRlbGV0ZVNldHRpbmdzLFxuICAgIGVtYWlsSW1hZ2U6IGVtYWlsSW1hZ2UsXG4gICAgZ2V0QXV0aG9yaXphdGlvbnM6IGdldEF1dGhvcml6YXRpb25zLFxuICAgIGdldERhdGFGdW5jdGlvbkZpbGVMaXN0OiBnZXREYXRhRnVuY3Rpb25GaWxlTGlzdCxcbiAgICBnZXRHcmFwaERhdGE6IGdldEdyYXBoRGF0YSxcbiAgICBnZXRHcmFwaERhdGFCeUtleTogZ2V0R3JhcGhEYXRhQnlLZXksXG4gICAgZ2V0R3JhcGhGdW5jdGlvbkZpbGVMaXN0OiBnZXRHcmFwaEZ1bmN0aW9uRmlsZUxpc3QsXG4gICAgZ2V0TGF5b3V0OiBnZXRMYXlvdXQsXG4gICAgZ2V0TXZBcnRpZmFjdHNCeUtleTpnZXRNdkFydGlmYWN0c0J5S2V5LFxuICAgIGdldFBsb3RSZXN1bHQ6IGdldFBsb3RSZXN1bHQsXG4gICAgZ2V0UmVsZWFzZU5vdGVzOiBnZXRSZWxlYXNlTm90ZXMsXG4gICAgZ2V0VXNlckFkZHJlc3M6IGdldFVzZXJBZGRyZXNzLFxuICAgIGluc2VydENvbG9yOiBpbnNlcnRDb2xvcixcbiAgICBtdkJhdGNoOiBtdkJhdGNoLFxuICAgIHJlYWRGdW5jdGlvbkZpbGU6IHJlYWRGdW5jdGlvbkZpbGUsXG4gICAgcmVmcmVzaE1ldGFEYXRhOiByZWZyZXNoTWV0YURhdGEsXG4gICAgcmVtb3ZlQXV0aG9yaXphdGlvbjogcmVtb3ZlQXV0aG9yaXphdGlvbixcbiAgICByZW1vdmVDb2xvcjogcmVtb3ZlQ29sb3IsXG4gICAgcmVtb3ZlRGF0YWJhc2U6IHJlbW92ZURhdGFiYXNlLFxuICAgIHJlc2V0QXBwOiByZXNldEFwcCxcbiAgICByZXN0b3JlRnJvbUZpbGU6IHJlc3RvcmVGcm9tRmlsZSxcbiAgICByZXN0b3JlRnJvbVBhcmFtZXRlckZpbGU6IHJlc3RvcmVGcm9tUGFyYW1ldGVyRmlsZSxcbiAgICBzYXZlTGF5b3V0OiBzYXZlTGF5b3V0LFxuICAgIHNhdmVTZXR0aW5nczogc2F2ZVNldHRpbmdzLFxuICAgIHNldENyZWRlbnRpYWxzOiBzZXRDcmVkZW50aWFscyxcbiAgICBzZXRTZXR0aW5nczogc2V0U2V0dGluZ3MsXG4gICAgdGVzdEdldE1ldGFEYXRhVGFibGVVcGRhdGVzOiB0ZXN0R2V0TWV0YURhdGFUYWJsZVVwZGF0ZXMsXG4gICAgdGVzdEdldFRhYmxlczogdGVzdEdldFRhYmxlcyxcbiAgICB0ZXN0U2V0TWV0YURhdGFUYWJsZVVwZGF0ZXNMYXN0UmVmcmVzaGVkQmFjazogdGVzdFNldE1ldGFEYXRhVGFibGVVcGRhdGVzTGFzdFJlZnJlc2hlZEJhY2ssXG4gICAgTVZfRElSUzogTVZfRElSU1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgQ29sb3JhZG8gU3RhdGUgVW5pdmVyc2l0eSBhbmQgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5pbXBvcnQge21hdHNUeXBlc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNDb2xsZWN0aW9uc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNQbG90VXRpbHN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaW1wb3J0IHttYXRzUGFyYW1VdGlsc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge0luZm99IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaW1wb3J0IHttYXRzTWV0aG9kc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5cblxuLypcbiBnbG9iYWwgZGF0YXNldCB2YXJpYWJsZSAtIGNvbnRhaW5lciBmb3IgZ3JhcGggZGF0YXNldC5cbiBUaGlzIChwbG90UmVzdWx0KSBpcyB2ZXJ5IGltcG9ydGFudC4gSXQgaXNuJ3QgXCJ2YXJcIiBiZWNhdXNlIGl0IG5lZWRzIHRvIGJlIGEgbWV0ZW9yIGdsb2JhbCBzY29wZS5cbiBUaGUgcGFnZSBpcyByZW5kZXJlZCB3aGUgdGhlIGdyYXBoIHBhZ2UgY29tZXMgdXAsIGJ1dCB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhIHByb2Nlc3NpbmcgY2FsbGJhY2tcbiBpbiBwbG90TGlzdC5qcyBvciBjdXJ2ZUxpc3QuanMgbWF5IG5vdCBoYXZlIHNldCB0aGUgZ2xvYmFsIHZhcmlhYmxlXG4gUGxvdFJlc3VsdC5cbiAqL1xuXG4vL3ZhciBwbG90UmVzdWx0RGF0YSA9IG51bGw7IC0tIHRoaXMgd2FzIHRoZSBnbG9iYWwgdmFyaWFibGUgZm9yIHRoZSB0ZXh0IG91dHB1dCBkYXRhLCBidXQgbm93IGl0IGlzIHNldCBlbHNld2hlcmVcbnZhciBncmFwaFJlc3VsdCA9IG51bGw7ICAgICAvLyB0aGlzIGlzIHRoZSBnbG9iYWwgdmFyaWFibGUgZm9yIHRoZSBkYXRhIG9uIHRoZSBncmFwaFxudmFyIHBsb3Q7XG5cbmNvbnN0IHNpemVvZiA9IGZ1bmN0aW9uIChfMSkge1xuICAgIHZhciBfMiA9IFtfMV07XG4gICAgdmFyIF8zID0gMDtcbiAgICBmb3IgKHZhciBfNCA9IDA7IF80IDwgXzIubGVuZ3RoOyBfNCsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIF8yW180XSkge1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBfMyArPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIF8zICs9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgXzMgKz0gMiAqIF8yW180XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChfMltfNF0pICE9IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfNSBpbiBfMltfNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8zICs9IDIgKiBfNS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgXzUgaW4gXzJbXzRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfNiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfNyA9IDA7IF83IDwgXzIubGVuZ3RoOyBfNysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXzJbXzddID09PSBfMltfNF1bXzVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXzYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghXzYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8yLnB1c2goXzJbXzRdW181XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF8zO1xufTtcblxuLy8gUmV0cmlldmVzIHRoZSBnbG9iYWxseSBzdG9yZWQgcGxvdFJlc3VsdERhdGEgZm9yIHRoZSB0ZXh0IG91dHB1dCBhbmQgb3RoZXIgdGhpbmdzLlxuLy8gUmUtc2V0cyB0aGUgcGxvdFJlc3VsdERhdGEgaWYgdGhlIHJlcXVlc3RlZCBwYWdlIHJhbmdlIGhhcyBjaGFuZ2VkLCBvciBpZiBpdCBoYXMgbm90IGJlZW4gcHJldmlvdXNseSBzZXQuXG5jb25zdCBnZXRQbG90UmVzdWx0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFnZUluZGV4ID0gU2Vzc2lvbi5nZXQoXCJwYWdlSW5kZXhcIik7XG4gICAgdmFyIG5ld1BhZ2VJbmRleCA9IFNlc3Npb24uZ2V0KFwibmV3UGFnZUluZGV4XCIpO1xuICAgIGlmIChwbG90UmVzdWx0RGF0YSA9PT0gdW5kZWZpbmVkIHx8IHBsb3RSZXN1bHREYXRhID09PSBudWxsIHx8IFNlc3Npb24uZ2V0KCd0ZXh0UmVmcmVzaE5lZWRlZCcpID09PSB0cnVlKSB7XG4gICAgICAgIHNldFBsb3RSZXN1bHREYXRhKCk7XG4gICAgfVxuICAgIHJldHVybiBwbG90UmVzdWx0RGF0YTtcbn07XG5cbi8vIFNldHMgdGhlIGdsb2JhbCBwbG90UmVzdWx0RGF0YSB2YXJpYWJsZSBmb3IgdGhlIHRleHQgb3V0cHV0IHRvIHRoZSByZXF1ZXN0ZWQgcmFuZ2UgZnJvbSB0aGUgUmVzdWx0cyBkYXRhIHN0b3JlZCBpbiBtb25nbywgdmlhIGEgTWF0c01ldGhvZC5cbmNvbnN0IHNldFBsb3RSZXN1bHREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYWdlSW5kZXggPSBTZXNzaW9uLmdldChcInBhZ2VJbmRleFwiKTtcbiAgICB2YXIgbmV3UGFnZUluZGV4ID0gU2Vzc2lvbi5nZXQoXCJuZXdQYWdlSW5kZXhcIik7XG5cbiAgICBpZiAoU2Vzc2lvbi5nZXQoJ3RleHRSZWZyZXNoTmVlZGVkJykgPT09IHRydWUpIHtcbiAgICAgICAgc2hvd1NwaW5uZXIoKTtcbiAgICAgICAgbWF0c01ldGhvZHMuZ2V0UGxvdFJlc3VsdC5jYWxsKHtcbiAgICAgICAgICAgIHJlc3VsdEtleTogU2Vzc2lvbi5nZXQoXCJwbG90UmVzdWx0S2V5XCIpLFxuICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICBuZXdQYWdlSW5kZXg6IG5ld1BhZ2VJbmRleFxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihuZXcgRXJyb3IoXCJtYXRzTWV0aG9kcy5nZXRQbG90UmVzdWx0IGZhaWxlZCA6IGVycm9yOiBcIiArIGVycm9yKSk7XG4gICAgICAgICAgICAgICAgU2Vzc2lvbi5zZXQoJ3RleHRSZWZyZXNoTmVlZGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwbG90UmVzdWx0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBTZXNzaW9uLnNldCgndGV4dFJlZnJlc2hOZWVkZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaGlkZVNwaW5uZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbG90UmVzdWx0RGF0YSA9IHJlc3VsdDtcbiAgICAgICAgICAgIFNlc3Npb24uc2V0KFwicGFnZUluZGV4XCIsIHJlc3VsdC5kc2lSZWFsUGFnZUluZGV4KTtcbiAgICAgICAgICAgIFNlc3Npb24uc2V0KFwicGFnZVRleHREaXJlY3Rpb25cIiwgcmVzdWx0LmRzaVRleHREaXJlY3Rpb24pO1xuICAgICAgICAgICAgU2Vzc2lvbi5zZXQoJ3RleHRMb2FkZWQnLCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2l6ZSBvZiBwbG90UmVzdWx0RGF0YSBpcyBcIiwgc2l6ZW9mKHBsb3RSZXN1bHREYXRhKSk7XG4gICAgICAgICAgICBTZXNzaW9uLnNldCgndGV4dFJlZnJlc2hOZWVkZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICBoaWRlU3Bpbm5lcigpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vLyByZXNldHMgdGhlIGdsb2JhbCBwbG90UmVzdWx0RGF0YSB2YXJpYWJsZSBmb3IgdGhlIHRleHQgb3V0cHV0IHRvIG51bGxcbmNvbnN0IHJlc2V0UGxvdFJlc3VsdERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGxvdFJlc3VsdERhdGEgPSBudWxsO1xuICAgIFNlc3Npb24uc2V0KCd0ZXh0TG9hZGVkJywgbmV3IERhdGUoKSk7XG59O1xuXG4vLyBnZXRzIHRoZSBnbG9iYWwgZ3JhcGhSZXN1bHQgdmFyaWFibGUsIHdoaWNoIGlzIHRoZSBkYXRhIG9iamVjdCBmb3IgdGhlIChwb3NzaWJseSBkb3duc2FtcGxlZCkgZGF0YSBvbiB0aGUgZ3JhcGhcbmNvbnN0IGdldEdyYXBoUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChncmFwaFJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IGdyYXBoUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYXBoUmVzdWx0O1xufTtcblxuLy8gc2V0cyB0aGUgZ2xvYmFsIGdyYXBoUmVzdWx0IHZhcmlhYmxlIHRvIHRoZSAocG9zc2libHkgZG93bnNhbXBsZWQpIGRhdGEgb2JqZWN0IHJldHVybmVkIGZyb20gTWF0c01ldGhvZHMsIGluIG9yZGVyIHRvIG1ha2UgdGhlIGdyYXBoXG5jb25zdCBzZXRHcmFwaFJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBncmFwaFJlc3VsdCA9IHJlc3VsdDtcbiAgICBTZXNzaW9uLnNldCgnZ3JhcGhEYXRhTG9hZGVkJywgbmV3IERhdGUoKSk7XG4gICAgY29uc29sZS5sb2coXCJzaXplIG9mIGdyYXBoUmVzdWx0RGF0YSBpc1wiLCBzaXplb2YoZ3JhcGhSZXN1bHQpKTtcbn07XG5cbi8vIHJlc2V0cyB0aGUgZ2xvYmFsIGdyYXBoUmVzdWx0IHZhcmlhYmxlIHRvIG51bGxcbmNvbnN0IHJlc2V0R3JhcGhSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZ3JhcGhSZXN1bHQgPSBudWxsO1xuICAgIFNlc3Npb24uc2V0KCdncmFwaERhdGFMb2FkZWQnLCBuZXcgRGF0ZSgpKTtcbn07XG5cbi8qXG4gQ3VydmUgdXRpbGl0aWVzIC0gdXNlZCB0byBkZXRlcm1pbmUgY3VydmUgbGFiZWxzIGFuZCBjb2xvcnMgZXRjLlxuICovXG5jb25zdCBnZXRVc2VkTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChTZXNzaW9uLmdldCgnVXNlZExhYmVscycpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gU2Vzc2lvbi5nZXQoJ1VzZWRMYWJlbHMnKTtcbn07XG5cbmNvbnN0IGdldE5leHRDdXJ2ZUxhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChTZXNzaW9uLmdldCgnTmV4dEN1cnZlTGFiZWwnKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldE5leHRDdXJ2ZUxhYmVsKCk7XG4gICAgfVxuICAgIHJldHVybiBTZXNzaW9uLmdldCgnTmV4dEN1cnZlTGFiZWwnKTtcbn07XG5cbi8vIGRldGVybWluZSB0aGUgbmV4dCBjdXJ2ZSBMYWJlbCBhbmQgc2V0IGl0IGluIHRoZSBzZXNzaW9uXG4vLyBwcml2YXRlLCBub3QgZXhwb3J0ZWRcbmNvbnN0IHNldE5leHRDdXJ2ZUxhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHVzZWRMYWJlbHMgPSBTZXNzaW9uLmdldCgnVXNlZExhYmVscycpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gbWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzLmZpbmRPbmUoe30sIHtmaWVsZHM6IHtMYWJlbFByZWZpeDogMX19KTtcbiAgICBpZiAoc2V0dGluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsUHJlZml4ID0gc2V0dGluZ3MuTGFiZWxQcmVmaXg7XG4gICAgLy8gZmluZCBhbGwgdGhlIGxhYmVscyB0aGF0IHN0YXJ0IHdpdGggb3VyIHByZWZpeCAoc29tZSBjb3VsZCBiZSBjdXN0b20pXG4gICAgY29uc3QgcHJlZml4TGFiZWxzID0gXy5maWx0ZXIodXNlZExhYmVscywgZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIChsICYmIChsLmxhc3RJbmRleE9mKGxhYmVsUHJlZml4LCAwKSA9PT0gMCkgJiYgKGwubWF0Y2gobmV3IFJlZ0V4cChsYWJlbFByZWZpeCwgJ2cnKSkubGVuZ3RoKSA9PSAxKTtcbiAgICB9KTtcbiAgICBjb25zdCBsYXN0VXNlZExhYmVsID0gXy5sYXN0KHByZWZpeExhYmVscyk7XG4gICAgdmFyIGxhc3RMYWJlbE51bWJlciA9IC0xO1xuXG4gICAgaWYgKGxhc3RVc2VkTGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBtaW51c1ByZWZpeCA9IGxhc3RVc2VkTGFiZWwucmVwbGFjZShsYWJlbFByZWZpeCwgJycpO1xuICAgICAgICBjb25zdCB0cnlOdW0gPSBwYXJzZUludChtaW51c1ByZWZpeCwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKHRyeU51bSkpIHtcbiAgICAgICAgICAgIGxhc3RMYWJlbE51bWJlciA9IHRyeU51bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3TGFiZWxOdW1iZXIgPSBsYXN0TGFiZWxOdW1iZXIgKyAxO1xuICAgIHZhciBuZXh0Q3VydmVMYWJlbCA9IGxhYmVsUHJlZml4ICsgbmV3TGFiZWxOdW1iZXI7XG4gICAgLy8gdGhlIGxhYmVsIG1pZ2h0IGJlIG9uZSBmcm9tIGEgcmVtb3ZlZCBjdXJ2ZSBzbyB0aGUgbmV4dCBvbmVzIG1pZ2h0IGJlIHVzZWRcbiAgICB3aGlsZSAoXy5pbmRleE9mKHVzZWRMYWJlbHMsIG5leHRDdXJ2ZUxhYmVsKSAhPSAtMSkge1xuICAgICAgICBuZXdMYWJlbE51bWJlcisrO1xuICAgICAgICBuZXh0Q3VydmVMYWJlbCA9IGxhYmVsUHJlZml4ICsgbmV3TGFiZWxOdW1iZXI7XG4gICAgfVxuICAgIFNlc3Npb24uc2V0KCdOZXh0Q3VydmVMYWJlbCcsIG5leHRDdXJ2ZUxhYmVsKTtcbn07XG5cbi8vIGRldGVybWluZSB0aGUgbmV4dCBjdXJ2ZSBjb2xvciBhbmQgc2V0IGl0IGluIHRoZSBzZXNzaW9uXG4vLyBwcml2YXRlIC0gbm90IGV4cG9ydGVkXG5jb25zdCBzZXROZXh0Q3VydmVDb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlZENvbG9ycyA9IFNlc3Npb24uZ2V0KCdVc2VkQ29sb3JzJyk7XG4gICAgdmFyIGNvbG9ycyA9IG1hdHNDb2xsZWN0aW9ucy5Db2xvclNjaGVtZS5maW5kT25lKHt9LCB7ZmllbGRzOiB7Y29sb3JzOiAxfX0pLmNvbG9ycztcbiAgICB2YXIgbGFzdFVzZWRJbmRleCA9IC0xO1xuICAgIGlmICh1c2VkQ29sb3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGFzdFVzZWRJbmRleCA9IF8uaW5kZXhPZihjb2xvcnMsIF8ubGFzdCh1c2VkQ29sb3JzKSk7XG4gICAgfVxuICAgIHZhciBuZXh0Q3VydmVDb2xvcjtcbiAgICBpZiAobGFzdFVzZWRJbmRleCAhPT0gdW5kZWZpbmVkICYmIGxhc3RVc2VkSW5kZXggIT0gLTEpIHtcbiAgICAgICAgaWYgKGxhc3RVc2VkSW5kZXggPCBjb2xvcnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gbGFzdFVzZWRJbmRleCArIDE7XG4gICAgICAgICAgICBuZXh0Q3VydmVDb2xvciA9IGNvbG9yc1tuZXdJbmRleF07XG4gICAgICAgICAgICAvLyB0aGUgY29sb3IgbWlnaHQgYmUgb25lIGZyb20gYSByZW1vdmVkIGN1cnZlIHNvIHRoZSBuZXh0IG9uZXMgbWlnaHQgYmUgdXNlZFxuICAgICAgICAgICAgd2hpbGUgKF8uaW5kZXhPZih1c2VkQ29sb3JzLCBuZXh0Q3VydmVDb2xvcikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCsrO1xuICAgICAgICAgICAgICAgIG5leHRDdXJ2ZUNvbG9yID0gY29sb3JzW25ld0luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG91dCBvZiBkZWZhdWx0c1xuICAgICAgICAgICAgdmFyIHJpbnQgPSBNYXRoLnJvdW5kKDB4ZmZmZmZmICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICBuZXh0Q3VydmVDb2xvciA9ICdyZ2IoJyArIChyaW50ID4+IDE2KSArICcsJyArIChyaW50ID4+IDggJiAyNTUpICsgJywnICsgKHJpbnQgJiAyNTUpICsgJyknO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEN1cnZlQ29sb3IgPSBjb2xvcnNbMF07XG4gICAgfVxuICAgIFNlc3Npb24uc2V0KCdOZXh0Q3VydmVDb2xvcicsIG5leHRDdXJ2ZUNvbG9yKTtcbn07XG5cbi8vIGdldCB0aGUgbmV4dCBjdXJ2ZSBjb2xvciBmcm9tIHRoZSBzZXNzaW9uXG4vLyBwcml2YXRlIC0gbm90IGV4cG9ydGVkXG5jb25zdCBnZXROZXh0Q3VydmVDb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoU2Vzc2lvbi5nZXQoJ05leHRDdXJ2ZUNvbG9yJykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXROZXh0Q3VydmVDb2xvcigpO1xuICAgIH1cbiAgICByZXR1cm4gU2Vzc2lvbi5nZXQoJ05leHRDdXJ2ZUNvbG9yJyk7XG59O1xuXG4vLyBjbGVhciBhIHVzZWQgbGFiZWwgYW5kIHNldCB0aGUgbmV4dEN1cnZlTGFiZWwgdG8gdGhlIG9uZSBqdXN0IGNsZWFyZWRcbmNvbnN0IGNsZWFyVXNlZExhYmVsID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgdmFyIHVzZWRMYWJlbHMgPSBTZXNzaW9uLmdldCgnVXNlZExhYmVscycpO1xuICAgIHZhciBuZXdVc2VkTGFiZWxzID0gXy5yZWplY3QodXNlZExhYmVscywgZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIGwgPT0gbGFiZWw7XG4gICAgfSk7XG4gICAgU2Vzc2lvbi5zZXQoJ1VzZWRMYWJlbHMnLCBuZXdVc2VkTGFiZWxzKTtcbiAgICBTZXNzaW9uLnNldCgnTmV4dEN1cnZlTGFiZWwnLCBsYWJlbCk7XG59O1xuXG4vLyBjbGVhciBhIHVzZWQgY29sb3IgYW5kIHNldCB0aGUgbmV4dEN1cnZlQ29sb3IgdG8gdGhlIG9uZSBqdXN0IGNsZWFyZWRcbmNvbnN0IGNsZWFyVXNlZENvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIHVzZWRDb2xvcnMgPSBTZXNzaW9uLmdldCgnVXNlZENvbG9ycycpO1xuICAgIHZhciBuZXdVc2VkQ29sb3JzID0gXy5yZWplY3QodXNlZENvbG9ycywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT0gY29sb3I7XG4gICAgfSk7XG4gICAgU2Vzc2lvbi5zZXQoJ1VzZWRDb2xvcnMnLCBuZXdVc2VkQ29sb3JzKTtcbiAgICBTZXNzaW9uLnNldCgnTmV4dEN1cnZlQ29sb3InLCBjb2xvcik7XG59O1xuXG4vLyBjbGVhciBhbGwgdGhlIHVzZWQgY29sb3JzIGFuZCBsYWJlbHMgYW5kIHNldCB0aGUgbmV4dEN1cnZlIHZhbHVlc1xuLy8gdG8gdGhlIGZpcnN0IGluIHRoZSBzY2hlbWUgYW5kIHRoZSBmaXJzdCBvZiB0aGUgbGFiZWxQcmVmaXguXG4vLyBUaGlzIGlzIHVzZWQgYnkgdGhlIHJlbW92ZUFsbFxuY29uc3QgY2xlYXJBbGxVc2VkID0gZnVuY3Rpb24gKCkge1xuICAgIFNlc3Npb24uc2V0KCdVc2VkQ29sb3JzJywgdW5kZWZpbmVkKTtcbiAgICB2YXIgY29sb3JzID0gbWF0c0NvbGxlY3Rpb25zLkNvbG9yU2NoZW1lLmZpbmRPbmUoe30sIHtmaWVsZHM6IHtjb2xvcnM6IDF9fSkuY29sb3JzO1xuICAgIFNlc3Npb24uc2V0KCdOZXh0Q3VydmVDb2xvcicsIGNvbG9yc1swXSk7XG4gICAgU2Vzc2lvbi5zZXQoJ1VzZWRMYWJlbHMnLCB1bmRlZmluZWQpO1xuICAgIHZhciBsYWJlbFByZWZpeCA9IG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy5maW5kT25lKHt9LCB7ZmllbGRzOiB7TGFiZWxQcmVmaXg6IDF9fSkuTGFiZWxQcmVmaXg7XG4gICAgU2Vzc2lvbi5zZXQoJ05leHRDdXJ2ZUxhYmVsJywgbGFiZWxQcmVmaXggKyAwKTtcbiAgICBTZXNzaW9uLnNldCgnQ3VydmVzJywgW10pO1xufTtcblxuLy8gdXNlIGN1cnZlcyBpbiBzZXNzaW9uIHRvIGRldGVybWluZSB3aGljaCBkZWZhdWx0cyBhcmUgYWxyZWFkeSB1c2VkXG4vLyBhbmQgdG8gc2V0IHRoZSB1c2VkQ29sb3JzIGluIHRoZSBzZXNzaW9uXG4vLyB0aGlzIGlzIHVzZWQgb24gcmVzdG9yZSBzZXR0aW5ncyB0byBzZXQgdXAgdGhlIHVzZWRDb2xvcnNcbi8vIHByaXZhdGUgLSBub3QgZXhwb3J0ZWRcbi8vc2V0VXNlZERlZmF1bHRzID0gZnVuY3Rpb24oKSB7XG5jb25zdCBzZXRVc2VkQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJ2ZXMgPSBTZXNzaW9uLmdldCgnQ3VydmVzJyk7XG4gICAgdmFyIHVzZWRDb2xvcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29sb3IgPSBjdXJ2ZXNbaV0uY29sb3I7XG4gICAgICAgIHVzZWRDb2xvcnMucHVzaChjb2xvcik7XG4gICAgfVxuICAgIFNlc3Npb24uc2V0KCdVc2VkQ29sb3JzJywgdXNlZENvbG9ycyk7XG4gICAgc2V0TmV4dEN1cnZlQ29sb3IoKTtcbn07XG5cbi8vIHByaXZhdGUgLSBub3QgZXhwb3J0ZWRcbmNvbnN0IHNldFVzZWRMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnZlcyA9IFNlc3Npb24uZ2V0KCdDdXJ2ZXMnKTtcbiAgICB2YXIgdXNlZExhYmVscyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGN1cnZlc1tpXS5sYWJlbDtcbiAgICAgICAgdXNlZExhYmVscy5wdXNoKGxhYmVsKTtcbiAgICB9XG4gICAgU2Vzc2lvbi5zZXQoJ1VzZWRMYWJlbHMnLCB1c2VkTGFiZWxzKTtcbiAgICBzZXROZXh0Q3VydmVMYWJlbCgpO1xufTtcblxuY29uc3Qgc2V0VXNlZENvbG9yc0FuZExhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRVc2VkQ29sb3JzKCk7XG4gICAgc2V0VXNlZExhYmVscygpO1xufTtcblxuY29uc3QgcmVzZXRTY2F0dGVyQXBwbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hdHNQbG90VXRpbHMuZ2V0UGxvdFR5cGUoKSA9PSBtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCkge1xuICAgICAgICBTZXNzaW9uLnNldCgnYXhpc0N1cnZlSWNvbicsICdmYS1hc3RlcmlzaycpO1xuICAgICAgICBTZXNzaW9uLnNldCgneGF4aXNDdXJ2ZVRleHQnLCAnWEFYSVMgTk9UIFlFVCBBUFBMSUVEJyk7XG4gICAgICAgIFNlc3Npb24uc2V0KCd5YXhpc0N1cnZlVGV4dCcsICdZQVhJUyBOT1QgWUVUIEFQUExJRUQnKTtcbiAgICAgICAgU2Vzc2lvbi5zZXQoJ3hheGlzQ3VydmVDb2xvcicsICdyZWQnKTtcbiAgICAgICAgU2Vzc2lvbi5zZXQoJ3lheGlzQ3VydmVDb2xvcicsICdyZWQnKTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdGaXQtVHlwZS1yYWRpb0dyb3VwLW5vbmUnKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ0ZpdC1UeXBlLXJhZGlvR3JvdXAtbm9uZScpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gYWRkIHRoZSBkaWZmZXJlbmNlIGN1cnZlc1xuLy8gcHJpdmF0ZSAtIG5vdCBleHBvcnRlZFxuY29uc3QgYWRkRGlmZnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnZlcyA9IFNlc3Npb24uZ2V0KCdDdXJ2ZXMnKTtcbiAgICB2YXIgbmV3Q3VydmVzID0gU2Vzc2lvbi5nZXQoJ0N1cnZlcycpO1xuICAgIC8vIGRpZmZzIGlzIGNoZWNrZWQgLS0gaGF2ZSB0byBhZGQgZGlmZiBjdXJ2ZXNcbiAgICB2YXIgY3VydmVzTGVuZ3RoID0gY3VydmVzLmxlbmd0aDtcbiAgICBpZiAoY3VydmVzTGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgc2V0SW5mbyhcIllvdSBjYW5ub3QgZGlmZmVyZW5jZSBsZXNzIHRoYW4gdHdvIGN1cnZlcyFcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG1hdHNQbG90VXRpbHMuZ2V0UGxvdEZvcm1hdCgpKSB7XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RGb3JtYXRzLm1hdGNoaW5nOlxuICAgICAgICAgICAgdmFyIGJhc2VJbmRleCA9IDA7IC8vIFRoaXMgd2lsbCBwcm9iYWJseSBub3QgZGVmYXVsdCB0byBjdXJ2ZSAwIGluIHRoZSBmdXR1cmVcbiAgICAgICAgICAgIGZvciAodmFyIGNpID0gMTsgY2kgPCBjdXJ2ZXMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0N1cnZlID0gJC5leHRlbmQodHJ1ZSwge30sIGN1cnZlc1tjaV0pO1xuICAgICAgICAgICAgICAgIG5ld0N1cnZlLmxhYmVsID0gY3VydmVzW2NpXS5sYWJlbCArIFwiLVwiICsgY3VydmVzWzBdLmxhYmVsO1xuICAgICAgICAgICAgICAgIG5ld0N1cnZlLmNvbG9yID0gZ2V0TmV4dEN1cnZlQ29sb3IoKTtcbiAgICAgICAgICAgICAgICBuZXdDdXJ2ZS5kaWZmRnJvbSA9IFtjaSwgYmFzZUluZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgY3JlYXRlIGV4dHJhIGRpZmYgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAoXy5maW5kV2hlcmUoY3VydmVzLCB7bGFiZWw6IG5ld0N1cnZlLmxhYmVsfSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDdXJ2ZXMucHVzaChuZXdDdXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgIFNlc3Npb24uc2V0KCdDdXJ2ZXMnLCBuZXdDdXJ2ZXMpO1xuICAgICAgICAgICAgICAgICAgICBzZXRVc2VkQ29sb3JzQW5kTGFiZWxzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RGb3JtYXRzLnBhaXJ3aXNlOlxuICAgICAgICAgICAgdmFyIGJhc2VJbmRleCA9IDA7IC8vIFRoaXMgd2lsbCBwcm9iYWJseSBub3QgZGVmYXVsdCB0byBjdXJ2ZSAwIGluIHRoZSBmdXR1cmVcbiAgICAgICAgICAgIGZvciAodmFyIGNpID0gMTsgY2kgPCBjdXJ2ZXMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNpICUgMiAhPSAwKSB7ICAvLyBvbmx5IGRpZmYgb24gb2RkIGN1cnZlcyBhZ2FpbnN0IHByZXZpb3VzIGN1cnZlXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlX2luZGV4ID0gY2kgLSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDdXJ2ZSA9ICQuZXh0ZW5kKHRydWUsIHt9LCBjdXJ2ZXNbY2ldKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3VydmUubGFiZWwgPSBjdXJ2ZXNbY2ldLmxhYmVsICsgXCItXCIgKyBjdXJ2ZXNbYmFzZV9pbmRleF0ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIG5ld0N1cnZlLmNvbG9yID0gZ2V0TmV4dEN1cnZlQ29sb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3VydmUuZGlmZkZyb20gPSBbY2ksIGJhc2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgZXh0cmEgZGlmZiBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5maW5kV2hlcmUoY3VydmVzLCB7bGFiZWw6IG5ld0N1cnZlLmxhYmVsfSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q3VydmVzLnB1c2gobmV3Q3VydmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgU2Vzc2lvbi5zZXQoJ0N1cnZlcycsIG5ld0N1cnZlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRVc2VkQ29sb3JzQW5kTGFiZWxzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdEZvcm1hdHMuYWJzb2x1dGU6XG4gICAgICAgICAgICB2YXIgYmFzZUluZGV4ID0gMDsgLy8gVGhpcyB3aWxsIHByb2JhYmx5IG5vdCBkZWZhdWx0IHRvIGN1cnZlIDAgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgICAgZm9yICh2YXIgY2kgPSAxOyBjaSA8IGN1cnZlcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q3VydmUgPSAkLmV4dGVuZCh0cnVlLCB7fSwgY3VydmVzW2NpXSk7XG4gICAgICAgICAgICAgICAgbmV3Q3VydmUubGFiZWwgPSBjdXJ2ZXNbY2ldLmxhYmVsICsgXCItXCIgKyBjdXJ2ZXNbMF0ubGFiZWw7XG4gICAgICAgICAgICAgICAgbmV3Q3VydmUuY29sb3IgPSBnZXROZXh0Q3VydmVDb2xvcigpO1xuICAgICAgICAgICAgICAgIG5ld0N1cnZlLmRpZmZGcm9tID0gW2NpLCBiYXNlSW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgZXh0cmEgZGlmZiBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChfLmZpbmRXaGVyZShjdXJ2ZXMsIHtsYWJlbDogbmV3Q3VydmUubGFiZWx9KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0N1cnZlcy5wdXNoKG5ld0N1cnZlKTtcbiAgICAgICAgICAgICAgICAgICAgU2Vzc2lvbi5zZXQoJ0N1cnZlcycsIG5ld0N1cnZlcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldFVzZWRDb2xvcnNBbmRMYWJlbHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5cbi8vIHJlbW92ZSBkaWZmZXJlbmNlIGN1cnZlc1xuLy8gcHJpdmF0ZSAtIG5vdCBleHBvcnRlZFxuY29uc3QgcmVtb3ZlRGlmZnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnZlcyA9IFNlc3Npb24uZ2V0KCdDdXJ2ZXMnKTtcbiAgICB2YXIgbmV3Q3VydmVzID0gXy5yZWplY3QoY3VydmVzLCBmdW5jdGlvbiAoY3VydmUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnZlLmRpZmZGcm9tICE9IG51bGxcbiAgICB9KTtcbiAgICBTZXNzaW9uLnNldCgnQ3VydmVzJywgbmV3Q3VydmVzKTtcbiAgICBzZXRVc2VkQ29sb3JzQW5kTGFiZWxzKCk7XG59O1xuXG4vLyByZXNvbHZlIHRoZSBkaWZmZXJlbmNlIGN1cnZlc1xuLy8gKHVzZWQgYWZ0ZXIgYWRkaW5nIG9yIHJlbW92aW5nIGEgY3VydmUgd2hpbGUgdGhlIHNob3cgZGlmZnMgYm94IGlzIGNoZWNrZWQpXG5jb25zdCBjaGVja0RpZmZzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJ2ZXMgPSBTZXNzaW9uLmdldCgnQ3VydmVzJyk7XG4gICAgaWYgKG1hdHNQbG90VXRpbHMuZ2V0UGxvdFR5cGUoKSA9PSBtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCkge1xuICAgICAgICAvLyBzY2F0dGVyIHBsb3RzIGhhdmUgbm8gY29uY2VwdCBvZiBkaWZmZXJlbmNlIGN1cnZlcy5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGxvdEZvcm1hdCA9IG1hdHNQbG90VXRpbHMuZ2V0UGxvdEZvcm1hdCgpO1xuICAgIGlmIChjdXJ2ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAocGxvdEZvcm1hdCAhPT0gbWF0c1R5cGVzLlBsb3RGb3JtYXRzLm5vbmUpIHtcbiAgICAgICAgICAgIHJlbW92ZURpZmZzKCk7XG4gICAgICAgICAgICBhZGREaWZmcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlRGlmZnMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIG1ldGhvZCB0byBkaXNwbGF5IHRoZSBhcHByb3ByaWF0ZSBzZWxlY3RvcnMgZm9yIGEgdGltZXNlcmllcyBjdXJ2ZVxuY29uc3Qgc2hvd1RpbWVzZXJpZXNGYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIG1vdmUgZGF0ZXMgc2VsZWN0b3IgdG8gcGxvdCBwYXJhbWV0ZXJzIC0gb25lIGRhdGUgcmFuZ2UgZm9yIGFsbCBjdXJ2ZXNcbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3QtdHlwZS0nICsgbWF0c1R5cGVzLlBsb3RUeXBlcy50aW1lU2VyaWVzKS5jaGVja2VkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBmYWNlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICdjdXJ2ZS1kYXRlcyc6ICdub25lJyxcbiAgICAgICAgICAgICdkYXRlcyc6ICdibG9jaycsXG4gICAgICAgICAgICAncmVnaW9uJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdzdGF0aXN0aWMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3RocmVzaG9sZCc6ICdibG9jaycsXG4gICAgICAgICAgICAncHJlcy1sZXZlbCc6ICdibG9jaycsXG4gICAgICAgICAgICAnZm9yZWNhc3QtbGVuZ3RoJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdkaWVvZmYtdHlwZSc6ICdub25lJyxcbiAgICAgICAgICAgICdhdmVyYWdlJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd2YWxpZC10aW1lJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd1dGMtY3ljbGUtc3RhcnQnOiAnbm9uZScsXG4gICAgICAgICAgICAnaGlzdG9ncmFtLWJpbi1jb250cm9scyc6ICdub25lJyxcbiAgICAgICAgICAgICdoaXN0b2dyYW0teWF4aXMtY29udHJvbHMnOiAnbm9uZScsXG4gICAgICAgICAgICAnYmluLW51bWJlcic6ICdub25lJyxcbiAgICAgICAgICAgICdiaW4tYm91bmRzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RydXRoJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdzaXRlcycgOiAnbm9uZScsXG4gICAgICAgICAgICAnc2l0ZXNNYXAnIDogJ25vbmUnLFxuICAgICAgICAgICAgJ3gtYXhpcy1wYXJhbWV0ZXInOiAnbm9uZScsXG4gICAgICAgICAgICAneS1heGlzLXBhcmFtZXRlcic6ICdub25lJ1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmYWNlU2VsZWN0b3JzID0gT2JqZWN0LmtleXMoZmFjZU9wdGlvbnMpO1xuICAgICAgICB2YXIgZWxlbTtcbiAgICAgICAgZm9yICh2YXIgZmlkeCA9IDA7IGZpZHggPCBmYWNlU2VsZWN0b3JzLmxlbmd0aDsgZmlkeCsrKSB7XG4gICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZmFjZVNlbGVjdG9yc1tmaWR4XSArICctaXRlbScpO1xuICAgICAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IGZhY2VPcHRpb25zW2ZhY2VTZWxlY3RvcnNbZmlkeF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCk7XG4gICAgICAgIGlmIChlbGVtICYmIGVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIFNlc3Npb24uc2V0KCdwbG90VHlwZScsIG1hdHNUeXBlcy5QbG90VHlwZXMudGltZVNlcmllcyk7XG4gICAgICAgIC8vIG1hdHNQYXJhbVV0aWxzLnNldEFsbFBhcmFtc1RvRGVmYXVsdCgpO1xuICAgICAgICBTZXNzaW9uLnNldCgnbGFzdFVwZGF0ZScsIERhdGUubm93KCkpO1xuICAgIH1cbn07XG5cbi8vIG1ldGhvZCB0byBkaXNwbGF5IHRoZSBhcHByb3ByaWF0ZSBzZWxlY3RvcnMgZm9yIGEgcHJvZmlsZSBjdXJ2ZVxuY29uc3Qgc2hvd1Byb2ZpbGVGYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIG1vdmUgZGF0ZXMgc2VsZWN0b3IgdG8gY3VydmUgcGFyYW1ldGVycyAtIG9uZSBkYXRlIHJhbmdlIGZvciBlYWNoIGN1cnZlXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbG90LXR5cGUtJyArIG1hdHNUeXBlcy5QbG90VHlwZXMucHJvZmlsZSkuY2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZmFjZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAnY3VydmUtZGF0ZXMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2RhdGVzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3JlZ2lvbic6ICdibG9jaycsXG4gICAgICAgICAgICAnc3RhdGlzdGljJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd0aHJlc2hvbGQnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3ByZXMtbGV2ZWwnOiAnbm9uZScsXG4gICAgICAgICAgICAnZm9yZWNhc3QtbGVuZ3RoJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdkaWVvZmYtdHlwZSc6ICdub25lJyxcbiAgICAgICAgICAgICdhdmVyYWdlJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3ZhbGlkLXRpbWUnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3V0Yy1jeWNsZS1zdGFydCc6ICdub25lJyxcbiAgICAgICAgICAgICdoaXN0b2dyYW0tYmluLWNvbnRyb2xzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2hpc3RvZ3JhbS15YXhpcy1jb250cm9scyc6ICdub25lJyxcbiAgICAgICAgICAgICdiaW4tbnVtYmVyJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2Jpbi1ib3VuZHMnOiAnbm9uZScsXG4gICAgICAgICAgICAndHJ1dGgnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3NpdGVzJyA6ICdub25lJyxcbiAgICAgICAgICAgICdzaXRlc01hcCcgOiAnbm9uZScsXG4gICAgICAgICAgICAneC1heGlzLXBhcmFtZXRlcic6ICdub25lJyxcbiAgICAgICAgICAgICd5LWF4aXMtcGFyYW1ldGVyJzogJ25vbmUnXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZhY2VTZWxlY3RvcnMgPSBPYmplY3Qua2V5cyhmYWNlT3B0aW9ucyk7XG4gICAgICAgIHZhciBlbGVtO1xuICAgICAgICBmb3IgKHZhciBmaWR4ID0gMDsgZmlkeCA8IGZhY2VTZWxlY3RvcnMubGVuZ3RoOyBmaWR4KyspIHtcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmYWNlU2VsZWN0b3JzW2ZpZHhdICsgJy1pdGVtJyk7XG4gICAgICAgICAgICBpZiAoZWxlbSAmJiBlbGVtLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gZmFjZU9wdGlvbnNbZmFjZVNlbGVjdG9yc1tmaWR4XV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1hdHNUeXBlcy5QbG90VHlwZXMuc2NhdHRlcjJkKTtcbiAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgU2Vzc2lvbi5zZXQoJ3Bsb3RUeXBlJywgbWF0c1R5cGVzLlBsb3RUeXBlcy5wcm9maWxlKTtcbiAgICAgICAgLy8gbWF0c1BhcmFtVXRpbHMuc2V0QWxsUGFyYW1zVG9EZWZhdWx0KCk7XG4gICAgICAgIFNlc3Npb24uc2V0KCdsYXN0VXBkYXRlJywgRGF0ZS5ub3coKSk7XG4gICAgfVxufTtcblxuLy8gbWV0aG9kIHRvIGRpc3BsYXkgdGhlIGFwcHJvcHJpYXRlIHNlbGVjdG9ycyBmb3IgYSBkaWVvZmYgY3VydmVcbmNvbnN0IHNob3dEaWVPZmZGYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIG1vdmUgZGF0ZXMgc2VsZWN0b3IgdG8gY3VydmUgcGFyYW1ldGVycyAtIG9uZSBkYXRlIHJhbmdlIGZvciBlYWNoIGN1cnZlXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbG90LXR5cGUtJyArIG1hdHNUeXBlcy5QbG90VHlwZXMuZGllb2ZmKS5jaGVja2VkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBmYWNlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICdjdXJ2ZS1kYXRlcyc6ICdibG9jaycsXG4gICAgICAgICAgICAnZGF0ZXMnOiAnbm9uZScsXG4gICAgICAgICAgICAncmVnaW9uJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdzdGF0aXN0aWMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3RocmVzaG9sZCc6ICdibG9jaycsXG4gICAgICAgICAgICAncHJlcy1sZXZlbCc6ICdibG9jaycsXG4gICAgICAgICAgICAnZm9yZWNhc3QtbGVuZ3RoJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2RpZW9mZi10eXBlJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdhdmVyYWdlJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3ZhbGlkLXRpbWUnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3V0Yy1jeWNsZS1zdGFydCc6ICdub25lJyxcbiAgICAgICAgICAgICdoaXN0b2dyYW0tYmluLWNvbnRyb2xzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2hpc3RvZ3JhbS15YXhpcy1jb250cm9scyc6ICdub25lJyxcbiAgICAgICAgICAgICdiaW4tbnVtYmVyJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2Jpbi1ib3VuZHMnOiAnbm9uZScsXG4gICAgICAgICAgICAndHJ1dGgnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3NpdGVzJyA6ICdub25lJyxcbiAgICAgICAgICAgICdzaXRlc01hcCcgOiAnbm9uZScsXG4gICAgICAgICAgICAneC1heGlzLXBhcmFtZXRlcic6ICdub25lJyxcbiAgICAgICAgICAgICd5LWF4aXMtcGFyYW1ldGVyJzogJ25vbmUnXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZhY2VTZWxlY3RvcnMgPSBPYmplY3Qua2V5cyhmYWNlT3B0aW9ucyk7XG4gICAgICAgIHZhciBlbGVtO1xuICAgICAgICBmb3IgKHZhciBmaWR4ID0gMDsgZmlkeCA8IGZhY2VTZWxlY3RvcnMubGVuZ3RoOyBmaWR4KyspIHtcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmYWNlU2VsZWN0b3JzW2ZpZHhdICsgJy1pdGVtJyk7XG4gICAgICAgICAgICBpZiAoZWxlbSAmJiBlbGVtLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gZmFjZU9wdGlvbnNbZmFjZVNlbGVjdG9yc1tmaWR4XV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgdGhlIHZhbHVlIGZvciBkaWVvZmYtdHlwZSwgc28gdGhhdCB0aGUgY2hlY2tIaWRlT3RoZXIgcm91dGluZSB3aWxsIHdvcmtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBtYXRzUGFyYW1VdGlscy5nZXRQYXJhbWV0ZXJGb3JOYW1lKCdkaWVvZmYtdHlwZScpO1xuICAgICAgICBtYXRzUGFyYW1VdGlscy5zZXRWYWx1ZVRleHRGb3JQYXJhbU5hbWUocGFyYW0ubmFtZSwgcGFyYW0uZGVmYXVsdCk7XG5cbiAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1hdHNUeXBlcy5QbG90VHlwZXMuc2NhdHRlcjJkKTtcbiAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgU2Vzc2lvbi5zZXQoJ3Bsb3RUeXBlJywgbWF0c1R5cGVzLlBsb3RUeXBlcy5kaWVvZmYpO1xuICAgICAgICAvLyBtYXRzUGFyYW1VdGlscy5zZXRBbGxQYXJhbXNUb0RlZmF1bHQoKTtcbiAgICAgICAgU2Vzc2lvbi5zZXQoJ2xhc3RVcGRhdGUnLCBEYXRlLm5vdygpKTtcbiAgICB9XG59O1xuXG4vLyBtZXRob2QgdG8gZGlzcGxheSB0aGUgYXBwcm9wcmlhdGUgc2VsZWN0b3JzIGZvciBhIHRocmVzaG9sZCBjdXJ2ZVxuY29uc3Qgc2hvd1RocmVzaG9sZEZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbW92ZSBkYXRlcyBzZWxlY3RvciB0byBjdXJ2ZSBwYXJhbWV0ZXJzIC0gb25lIGRhdGUgcmFuZ2UgZm9yIGVhY2ggY3VydmVcbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3QtdHlwZS0nICsgbWF0c1R5cGVzLlBsb3RUeXBlcy50aHJlc2hvbGQpLmNoZWNrZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGZhY2VPcHRpb25zID0ge1xuICAgICAgICAgICAgJ2N1cnZlLWRhdGVzJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdkYXRlcyc6ICdub25lJyxcbiAgICAgICAgICAgICdyZWdpb24nOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3N0YXRpc3RpYyc6ICdibG9jaycsXG4gICAgICAgICAgICAndGhyZXNob2xkJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3ByZXMtbGV2ZWwnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2ZvcmVjYXN0LWxlbmd0aCc6ICdibG9jaycsXG4gICAgICAgICAgICAnZGllb2ZmLXR5cGUnOiAnbm9uZScsXG4gICAgICAgICAgICAnYXZlcmFnZSc6ICdub25lJyxcbiAgICAgICAgICAgICd2YWxpZC10aW1lJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd1dGMtY3ljbGUtc3RhcnQnOiAnbm9uZScsXG4gICAgICAgICAgICAnaGlzdG9ncmFtLWJpbi1jb250cm9scyc6ICdub25lJyxcbiAgICAgICAgICAgICdoaXN0b2dyYW0teWF4aXMtY29udHJvbHMnOiAnbm9uZScsXG4gICAgICAgICAgICAnYmluLW51bWJlcic6ICdub25lJyxcbiAgICAgICAgICAgICdiaW4tYm91bmRzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RydXRoJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdzaXRlcycgOiAnbm9uZScsXG4gICAgICAgICAgICAnc2l0ZXNNYXAnIDogJ25vbmUnLFxuICAgICAgICAgICAgJ3gtYXhpcy1wYXJhbWV0ZXInOiAnbm9uZScsXG4gICAgICAgICAgICAneS1heGlzLXBhcmFtZXRlcic6ICdub25lJ1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmYWNlU2VsZWN0b3JzID0gT2JqZWN0LmtleXMoZmFjZU9wdGlvbnMpO1xuICAgICAgICB2YXIgZWxlbTtcbiAgICAgICAgZm9yICh2YXIgZmlkeCA9IDA7IGZpZHggPCBmYWNlU2VsZWN0b3JzLmxlbmd0aDsgZmlkeCsrKSB7XG4gICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZmFjZVNlbGVjdG9yc1tmaWR4XSArICctaXRlbScpO1xuICAgICAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IGZhY2VPcHRpb25zW2ZhY2VTZWxlY3RvcnNbZmlkeF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCk7XG4gICAgICAgIGlmIChlbGVtICYmIGVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIFNlc3Npb24uc2V0KCdwbG90VHlwZScsIG1hdHNUeXBlcy5QbG90VHlwZXMudGhyZXNob2xkKTtcbiAgICAgICAgLy8gbWF0c1BhcmFtVXRpbHMuc2V0QWxsUGFyYW1zVG9EZWZhdWx0KCk7XG4gICAgICAgIFNlc3Npb24uc2V0KCdsYXN0VXBkYXRlJywgRGF0ZS5ub3coKSk7XG4gICAgfVxufTtcblxuLy8gbWV0aG9kIHRvIGRpc3BsYXkgdGhlIGFwcHJvcHJpYXRlIHNlbGVjdG9ycyBmb3IgYSB2YWxpZCB0aW1lIGN1cnZlXG5jb25zdCBzaG93VmFsaWRUaW1lRmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBtb3ZlIGRhdGVzIHNlbGVjdG9yIHRvIGN1cnZlIHBhcmFtZXRlcnMgLSBvbmUgZGF0ZSByYW5nZSBmb3IgZWFjaCBjdXJ2ZVxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdC10eXBlLScgKyBtYXRzVHlwZXMuUGxvdFR5cGVzLnZhbGlkdGltZSkuY2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZmFjZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAnY3VydmUtZGF0ZXMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2RhdGVzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3JlZ2lvbic6ICdibG9jaycsXG4gICAgICAgICAgICAnc3RhdGlzdGljJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd0aHJlc2hvbGQnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3ByZXMtbGV2ZWwnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2ZvcmVjYXN0LWxlbmd0aCc6ICdibG9jaycsXG4gICAgICAgICAgICAnZGllb2ZmLXR5cGUnOiAnbm9uZScsXG4gICAgICAgICAgICAnYXZlcmFnZSc6ICdub25lJyxcbiAgICAgICAgICAgICd2YWxpZC10aW1lJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3V0Yy1jeWNsZS1zdGFydCc6ICdub25lJyxcbiAgICAgICAgICAgICdoaXN0b2dyYW0tYmluLWNvbnRyb2xzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2hpc3RvZ3JhbS15YXhpcy1jb250cm9scyc6ICdub25lJyxcbiAgICAgICAgICAgICdiaW4tbnVtYmVyJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2Jpbi1ib3VuZHMnOiAnbm9uZScsXG4gICAgICAgICAgICAndHJ1dGgnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3NpdGVzJyA6ICdub25lJyxcbiAgICAgICAgICAgICdzaXRlc01hcCcgOiAnbm9uZScsXG4gICAgICAgICAgICAneC1heGlzLXBhcmFtZXRlcic6ICdub25lJyxcbiAgICAgICAgICAgICd5LWF4aXMtcGFyYW1ldGVyJzogJ25vbmUnXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZhY2VTZWxlY3RvcnMgPSBPYmplY3Qua2V5cyhmYWNlT3B0aW9ucyk7XG4gICAgICAgIHZhciBlbGVtO1xuICAgICAgICBmb3IgKHZhciBmaWR4ID0gMDsgZmlkeCA8IGZhY2VTZWxlY3RvcnMubGVuZ3RoOyBmaWR4KyspIHtcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmYWNlU2VsZWN0b3JzW2ZpZHhdICsgJy1pdGVtJyk7XG4gICAgICAgICAgICBpZiAoZWxlbSAmJiBlbGVtLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gZmFjZU9wdGlvbnNbZmFjZVNlbGVjdG9yc1tmaWR4XV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1hdHNUeXBlcy5QbG90VHlwZXMuc2NhdHRlcjJkKTtcbiAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgU2Vzc2lvbi5zZXQoJ3Bsb3RUeXBlJywgbWF0c1R5cGVzLlBsb3RUeXBlcy52YWxpZHRpbWUpO1xuICAgICAgICAvLyBtYXRzUGFyYW1VdGlscy5zZXRBbGxQYXJhbXNUb0RlZmF1bHQoKTtcbiAgICAgICAgU2Vzc2lvbi5zZXQoJ2xhc3RVcGRhdGUnLCBEYXRlLm5vdygpKTtcbiAgICB9XG59O1xuXG4vLyBtZXRob2QgdG8gZGlzcGxheSB0aGUgYXBwcm9wcmlhdGUgc2VsZWN0b3JzIGZvciBhIGRhaWx5IG1vZGVsIGN5Y2xlIGN1cnZlXG5jb25zdCBzaG93RGFpbHlNb2RlbEN5Y2xlRmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBtb3ZlIGRhdGVzIHNlbGVjdG9yIHRvIHBsb3QgcGFyYW1ldGVycyAtIG9uZSBkYXRlIHJhbmdlIGZvciBhbGwgY3VydmVzXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbG90LXR5cGUtJyArIG1hdHNUeXBlcy5QbG90VHlwZXMuZGFpbHlNb2RlbEN5Y2xlKS5jaGVja2VkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBmYWNlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICdjdXJ2ZS1kYXRlcyc6ICdub25lJyxcbiAgICAgICAgICAgICdkYXRlcyc6ICdibG9jaycsXG4gICAgICAgICAgICAncmVnaW9uJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdzdGF0aXN0aWMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3RocmVzaG9sZCc6ICdibG9jaycsXG4gICAgICAgICAgICAncHJlcy1sZXZlbCc6ICdibG9jaycsXG4gICAgICAgICAgICAnZm9yZWNhc3QtbGVuZ3RoJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2RpZW9mZi10eXBlJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiAnbm9uZScsXG4gICAgICAgICAgICAndmFsaWQtdGltZSc6ICdub25lJyxcbiAgICAgICAgICAgICd1dGMtY3ljbGUtc3RhcnQnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2hpc3RvZ3JhbS1iaW4tY29udHJvbHMnOiAnbm9uZScsXG4gICAgICAgICAgICAnaGlzdG9ncmFtLXlheGlzLWNvbnRyb2xzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2Jpbi1udW1iZXInOiAnbm9uZScsXG4gICAgICAgICAgICAnYmluLWJvdW5kcyc6ICdub25lJyxcbiAgICAgICAgICAgICd0cnV0aCc6ICdibG9jaycsXG4gICAgICAgICAgICAnc2l0ZXMnIDogJ25vbmUnLFxuICAgICAgICAgICAgJ3NpdGVzTWFwJyA6ICdub25lJyxcbiAgICAgICAgICAgICd4LWF4aXMtcGFyYW1ldGVyJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3ktYXhpcy1wYXJhbWV0ZXInOiAnbm9uZSdcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmFjZVNlbGVjdG9ycyA9IE9iamVjdC5rZXlzKGZhY2VPcHRpb25zKTtcbiAgICAgICAgdmFyIGVsZW07XG4gICAgICAgIGZvciAodmFyIGZpZHggPSAwOyBmaWR4IDwgZmFjZVNlbGVjdG9ycy5sZW5ndGg7IGZpZHgrKykge1xuICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZhY2VTZWxlY3RvcnNbZmlkeF0gKyAnLWl0ZW0nKTtcbiAgICAgICAgICAgIGlmIChlbGVtICYmIGVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBmYWNlT3B0aW9uc1tmYWNlU2VsZWN0b3JzW2ZpZHhdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWF0c1R5cGVzLlBsb3RUeXBlcy5zY2F0dGVyMmQpO1xuICAgICAgICBpZiAoZWxlbSAmJiBlbGVtLnN0eWxlKSB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICBTZXNzaW9uLnNldCgncGxvdFR5cGUnLCBtYXRzVHlwZXMuUGxvdFR5cGVzLmRhaWx5TW9kZWxDeWNsZSk7XG4gICAgICAgIC8vIG1hdHNQYXJhbVV0aWxzLnNldEFsbFBhcmFtc1RvRGVmYXVsdCgpO1xuICAgICAgICBTZXNzaW9uLnNldCgnbGFzdFVwZGF0ZScsIERhdGUubm93KCkpO1xuICAgIH1cbn07XG5cbi8vIG1ldGhvZCB0byBkaXNwbGF5IHRoZSBhcHByb3ByaWF0ZSBzZWxlY3RvcnMgZm9yIGEgcmVsaWFiaWxpdHkgY3VydmVcbmNvbnN0IHNob3dSZWxpYWJpbGl0eUZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbW92ZSBkYXRlcyBzZWxlY3RvciB0byBjdXJ2ZSBwYXJhbWV0ZXJzIC0gb25lIGRhdGUgcmFuZ2UgZm9yIGVhY2ggY3VydmVcbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3QtdHlwZS0nICsgbWF0c1R5cGVzLlBsb3RUeXBlcy5yZWxpYWJpbGl0eSkuY2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZmFjZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAnY3VydmUtZGF0ZXMnOiAnbm9uZScsXG4gICAgICAgICAgICAnZGF0ZXMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3JlZ2lvbic6ICdibG9jaycsXG4gICAgICAgICAgICAnc3RhdGlzdGljJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd0aHJlc2hvbGQnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3ByZXMtbGV2ZWwnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2ZvcmVjYXN0LWxlbmd0aCc6ICdibG9jaycsXG4gICAgICAgICAgICAnZGllb2ZmLXR5cGUnOiAnbm9uZScsXG4gICAgICAgICAgICAnYXZlcmFnZSc6ICdibG9jaycsXG4gICAgICAgICAgICAndmFsaWQtdGltZSc6ICdibG9jaycsXG4gICAgICAgICAgICAndXRjLWN5Y2xlLXN0YXJ0JzogJ25vbmUnLFxuICAgICAgICAgICAgJ2hpc3RvZ3JhbS1iaW4tY29udHJvbHMnOiAnbm9uZScsXG4gICAgICAgICAgICAnaGlzdG9ncmFtLXlheGlzLWNvbnRyb2xzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2Jpbi1udW1iZXInOiAnbm9uZScsXG4gICAgICAgICAgICAnYmluLWJvdW5kcyc6ICdub25lJyxcbiAgICAgICAgICAgICd0cnV0aCc6ICdub25lJyxcbiAgICAgICAgICAgICdzaXRlcycgOiAnbm9uZScsXG4gICAgICAgICAgICAnc2l0ZXNNYXAnIDogJ25vbmUnLFxuICAgICAgICAgICAgJ3gtYXhpcy1wYXJhbWV0ZXInOiAnbm9uZScsXG4gICAgICAgICAgICAneS1heGlzLXBhcmFtZXRlcic6ICdub25lJ1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmYWNlU2VsZWN0b3JzID0gT2JqZWN0LmtleXMoZmFjZU9wdGlvbnMpO1xuICAgICAgICB2YXIgZWxlbTtcbiAgICAgICAgZm9yICh2YXIgZmlkeCA9IDA7IGZpZHggPCBmYWNlU2VsZWN0b3JzLmxlbmd0aDsgZmlkeCsrKSB7XG4gICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZmFjZVNlbGVjdG9yc1tmaWR4XSArICctaXRlbScpO1xuICAgICAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IGZhY2VPcHRpb25zW2ZhY2VTZWxlY3RvcnNbZmlkeF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCk7XG4gICAgICAgIGlmIChlbGVtICYmIGVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIFNlc3Npb24uc2V0KCdwbG90VHlwZScsIG1hdHNUeXBlcy5QbG90VHlwZXMucmVsaWFiaWxpdHkpO1xuICAgICAgICAvLyBtYXRzUGFyYW1VdGlscy5zZXRBbGxQYXJhbXNUb0RlZmF1bHQoKTtcbiAgICAgICAgU2Vzc2lvbi5zZXQoJ2xhc3RVcGRhdGUnLCBEYXRlLm5vdygpKTtcbiAgICB9XG59O1xuXG4vLyBtZXRob2QgdG8gZGlzcGxheSB0aGUgYXBwcm9wcmlhdGUgc2VsZWN0b3JzIGZvciBhIG1hcFxuY29uc3Qgc2hvd01hcEZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbW92ZSBkYXRlcyBzZWxlY3RvciB0byBwbG90IHBhcmFtZXRlcnMgLSBvbmUgZGF0ZSByYW5nZSBmb3IgYWxsIGN1cnZlc1xuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdC10eXBlLScgKyBtYXRzVHlwZXMuUGxvdFR5cGVzLm1hcCkuY2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZmFjZU9wdGlvbnM7XG4gICAgICAgIGZhY2VPcHRpb25zID0ge1xuICAgICAgICAgICAgJ2N1cnZlLWRhdGVzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2RhdGVzJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdyZWdpb24nOiAnbm9uZScsXG4gICAgICAgICAgICAnc3RhdGlzdGljJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RocmVzaG9sZCc6ICdub25lJyxcbiAgICAgICAgICAgICdwcmVzLWxldmVsJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdmb3JlY2FzdC1sZW5ndGgnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2RpZW9mZi10eXBlJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiAnbm9uZScsXG4gICAgICAgICAgICAndmFsaWQtdGltZSc6ICdibG9jaycsXG4gICAgICAgICAgICAndXRjLWN5Y2xlLXN0YXJ0JzogJ25vbmUnLFxuICAgICAgICAgICAgJ2hpc3RvZ3JhbS1iaW4tY29udHJvbHMnOiAnbm9uZScsXG4gICAgICAgICAgICAnaGlzdG9ncmFtLXlheGlzLWNvbnRyb2xzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2Jpbi1udW1iZXInOiAnbm9uZScsXG4gICAgICAgICAgICAnYmluLWJvdW5kcyc6ICdub25lJyxcbiAgICAgICAgICAgICd0cnV0aCc6ICdub25lJyxcbiAgICAgICAgICAgICdzaXRlcyc6ICdibG9jaycsXG4gICAgICAgICAgICAnc2l0ZXNNYXAnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3gtYXhpcy1wYXJhbWV0ZXInOiAnbm9uZScsXG4gICAgICAgICAgICAneS1heGlzLXBhcmFtZXRlcic6ICdub25lJ1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmYWNlU2VsZWN0b3JzID0gT2JqZWN0LmtleXMoZmFjZU9wdGlvbnMpO1xuICAgICAgICB2YXIgZWxlbTtcbiAgICAgICAgZm9yICh2YXIgZmlkeCA9IDA7IGZpZHggPCBmYWNlU2VsZWN0b3JzLmxlbmd0aDsgZmlkeCsrKSB7XG4gICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZmFjZVNlbGVjdG9yc1tmaWR4XSArICctaXRlbScpO1xuICAgICAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IGZhY2VPcHRpb25zW2ZhY2VTZWxlY3RvcnNbZmlkeF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCk7XG4gICAgICAgIGlmIChlbGVtICYmIGVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIFNlc3Npb24uc2V0KCdwbG90VHlwZScsIG1hdHNUeXBlcy5QbG90VHlwZXMubWFwKTtcbiAgICAgICAgLy8gbWF0c1BhcmFtVXRpbHMuc2V0QWxsUGFyYW1zVG9EZWZhdWx0KCk7XG4gICAgICAgIFNlc3Npb24uc2V0KCdsYXN0VXBkYXRlJywgRGF0ZS5ub3coKSk7XG4gICAgfVxufTtcblxuLy8gbWV0aG9kIHRvIGRpc3BsYXkgdGhlIGFwcHJvcHJpYXRlIHNlbGVjdG9ycyBmb3IgYSBoaXN0b2dyYW1cbmNvbnN0IHNob3dIaXN0b2dyYW1GYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIG1vdmUgZGF0ZXMgc2VsZWN0b3IgdG8gY3VydmUgcGFyYW1ldGVycyAtIG9uZSBkYXRlIHJhbmdlIGZvciBlYWNoIGN1cnZlXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbG90LXR5cGUtJyArIG1hdHNUeXBlcy5QbG90VHlwZXMuaGlzdG9ncmFtKS5jaGVja2VkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBmYWNlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICdjdXJ2ZS1kYXRlcyc6ICdibG9jaycsXG4gICAgICAgICAgICAnZGF0ZXMnOiAnbm9uZScsXG4gICAgICAgICAgICAncmVnaW9uJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdzdGF0aXN0aWMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3RocmVzaG9sZCc6ICdibG9jaycsXG4gICAgICAgICAgICAncHJlcy1sZXZlbCc6ICdibG9jaycsXG4gICAgICAgICAgICAnZm9yZWNhc3QtbGVuZ3RoJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdkaWVvZmYtdHlwZSc6ICdub25lJyxcbiAgICAgICAgICAgICdhdmVyYWdlJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3ZhbGlkLXRpbWUnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3V0Yy1jeWNsZS1zdGFydCc6ICdub25lJyxcbiAgICAgICAgICAgICdoaXN0b2dyYW0tYmluLWNvbnRyb2xzJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdoaXN0b2dyYW0teWF4aXMtY29udHJvbHMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2Jpbi1udW1iZXInOiAnbm9uZScsXG4gICAgICAgICAgICAnYmluLWJvdW5kcyc6ICdub25lJyxcbiAgICAgICAgICAgICd0cnV0aCc6ICdibG9jaycsXG4gICAgICAgICAgICAnc2l0ZXMnIDogJ25vbmUnLFxuICAgICAgICAgICAgJ3NpdGVzTWFwJyA6ICdub25lJyxcbiAgICAgICAgICAgICd4LWF4aXMtcGFyYW1ldGVyJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3ktYXhpcy1wYXJhbWV0ZXInOiAnbm9uZSdcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmFjZVNlbGVjdG9ycyA9IE9iamVjdC5rZXlzKGZhY2VPcHRpb25zKTtcbiAgICAgICAgdmFyIGVsZW07XG4gICAgICAgIGZvciAodmFyIGZpZHggPSAwOyBmaWR4IDwgZmFjZVNlbGVjdG9ycy5sZW5ndGg7IGZpZHgrKykge1xuICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZhY2VTZWxlY3RvcnNbZmlkeF0gKyAnLWl0ZW0nKTtcbiAgICAgICAgICAgIGlmIChlbGVtICYmIGVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBmYWNlT3B0aW9uc1tmYWNlU2VsZWN0b3JzW2ZpZHhdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWF0c1R5cGVzLlBsb3RUeXBlcy5zY2F0dGVyMmQpO1xuICAgICAgICBpZiAoZWxlbSAmJiBlbGVtLnN0eWxlKSB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICBTZXNzaW9uLnNldCgncGxvdFR5cGUnLCBtYXRzVHlwZXMuUGxvdFR5cGVzLmhpc3RvZ3JhbSk7XG4gICAgICAgIC8vIG1hdHNQYXJhbVV0aWxzLnNldEFsbFBhcmFtc1RvRGVmYXVsdCgpO1xuICAgICAgICBTZXNzaW9uLnNldCgnbGFzdFVwZGF0ZScsIERhdGUubm93KCkpO1xuICAgIH1cbn07XG5cbi8vIG1ldGhvZCB0byBkaXNwbGF5IHRoZSBhcHByb3ByaWF0ZSBzZWxlY3RvcnMgZm9yIGEgY29udG91ciBwbG90XG5jb25zdCBzaG93Q29udG91ckZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbW92ZSBkYXRlcyBzZWxlY3RvciB0byBwbG90IHBhcmFtZXRlcnMgLSBvbmUgZGF0ZSByYW5nZSBmb3IgYWxsIGN1cnZlc1xuICAgIGNvbnN0IGlzQ29udG91ciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbG90LXR5cGUtJyArIG1hdHNUeXBlcy5QbG90VHlwZXMuY29udG91cikgIT09IG51bGwgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3QtdHlwZS0nICsgbWF0c1R5cGVzLlBsb3RUeXBlcy5jb250b3VyKS5jaGVja2VkID09PSB0cnVlO1xuICAgIGNvbnN0IGlzQ29udG91ckRpZmYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdC10eXBlLScgKyBtYXRzVHlwZXMuUGxvdFR5cGVzLmNvbnRvdXJEaWZmKSAhPT0gbnVsbCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdC10eXBlLScgKyBtYXRzVHlwZXMuUGxvdFR5cGVzLmNvbnRvdXJEaWZmKS5jaGVja2VkID09PSB0cnVlO1xuICAgIGlmIChpc0NvbnRvdXIgfHwgaXNDb250b3VyRGlmZikge1xuICAgICAgICB2YXIgZmFjZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAnY3VydmUtZGF0ZXMnOiAnbm9uZScsXG4gICAgICAgICAgICAnZGF0ZXMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3JlZ2lvbic6ICdibG9jaycsXG4gICAgICAgICAgICAnc3RhdGlzdGljJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd0aHJlc2hvbGQnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3ByZXMtbGV2ZWwnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2ZvcmVjYXN0LWxlbmd0aCc6ICdibG9jaycsXG4gICAgICAgICAgICAnZGllb2ZmLXR5cGUnOiAnbm9uZScsXG4gICAgICAgICAgICAnYXZlcmFnZSc6ICdub25lJyxcbiAgICAgICAgICAgICd2YWxpZC10aW1lJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd1dGMtY3ljbGUtc3RhcnQnOiAnbm9uZScsXG4gICAgICAgICAgICAnaGlzdG9ncmFtLWJpbi1jb250cm9scyc6ICdub25lJyxcbiAgICAgICAgICAgICdoaXN0b2dyYW0teWF4aXMtY29udHJvbHMnOiAnbm9uZScsXG4gICAgICAgICAgICAnYmluLW51bWJlcic6ICdub25lJyxcbiAgICAgICAgICAgICdiaW4tYm91bmRzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RydXRoJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdzaXRlcycgOiAnbm9uZScsXG4gICAgICAgICAgICAnc2l0ZXNNYXAnIDogJ25vbmUnLFxuICAgICAgICAgICAgJ3gtYXhpcy1wYXJhbWV0ZXInOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3ktYXhpcy1wYXJhbWV0ZXInOiAnYmxvY2snXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZhY2VTZWxlY3RvcnMgPSBPYmplY3Qua2V5cyhmYWNlT3B0aW9ucyk7XG4gICAgICAgIHZhciBlbGVtO1xuICAgICAgICBmb3IgKHZhciBmaWR4ID0gMDsgZmlkeCA8IGZhY2VTZWxlY3RvcnMubGVuZ3RoOyBmaWR4KyspIHtcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmYWNlU2VsZWN0b3JzW2ZpZHhdICsgJy1pdGVtJyk7XG4gICAgICAgICAgICBpZiAoZWxlbSAmJiBlbGVtLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gZmFjZU9wdGlvbnNbZmFjZVNlbGVjdG9yc1tmaWR4XV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLy9uZWVkIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0aGUgeCBhbmQgeSBheGlzICdoaWRlT3RoZXJGb3InIHNldHRpbmdzXG4gICAgICAgIC8vIGNvbnN0IHhBeGlzVmFsID0gbWF0c1BhcmFtVXRpbHMuZ2V0VmFsdWVGb3JQYXJhbU5hbWUoJ3gtYXhpcy1wYXJhbWV0ZXInKTtcbiAgICAgICAgLy8gY29uc3QgeUF4aXNWYWwgPSBtYXRzUGFyYW1VdGlscy5nZXRWYWx1ZUZvclBhcmFtTmFtZSgneS1heGlzLXBhcmFtZXRlcicpO1xuICAgICAgICAvLyBpZiAoeEF4aXNWYWwgPT09ICdGY3N0IGxlYWQgdGltZScgfHwgeUF4aXNWYWwgPT09ICdGY3N0IGxlYWQgdGltZScpIHtcbiAgICAgICAgLy8gICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9yZWNhc3QtbGVuZ3RoLWl0ZW0nKTtcbiAgICAgICAgLy8gICAgIGlmIChlbGVtICYmIGVsZW0uc3R5bGUpIHtcbiAgICAgICAgLy8gICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHhBeGlzVmFsID09PSAnVmFsaWQgVVRDIGhvdXInIHx8IHlBeGlzVmFsID09PSAnVmFsaWQgVVRDIGhvdXInKSB7XG4gICAgICAgIC8vICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZhbGlkLXRpbWUtaXRlbScpO1xuICAgICAgICAvLyAgICAgaWYgKGVsZW0gJiYgZWxlbS5zdHlsZSkge1xuICAgICAgICAvLyAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAoeEF4aXNWYWwgPT09ICdQcmVzc3VyZSBsZXZlbCcgfHwgeUF4aXNWYWwgPT09ICdQcmVzc3VyZSBsZXZlbCcpIHtcbiAgICAgICAgLy8gICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJlcy1sZXZlbC1pdGVtJyk7XG4gICAgICAgIC8vICAgICBpZiAoZWxlbSAmJiBlbGVtLnN0eWxlKSB7XG4gICAgICAgIC8vICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCk7XG4gICAgICAgIGlmIChlbGVtICYmIGVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbnRvdXIpIHtcbiAgICAgICAgICAgIFNlc3Npb24uc2V0KCdwbG90VHlwZScsIG1hdHNUeXBlcy5QbG90VHlwZXMuY29udG91cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTZXNzaW9uLnNldCgncGxvdFR5cGUnLCBtYXRzVHlwZXMuUGxvdFR5cGVzLmNvbnRvdXJEaWZmKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXRzUGFyYW1VdGlscy5zZXRBbGxQYXJhbXNUb0RlZmF1bHQoKTtcbiAgICAgICAgU2Vzc2lvbi5zZXQoJ2xhc3RVcGRhdGUnLCBEYXRlLm5vdygpKTtcbiAgICB9XG59O1xuXG4vLyBtZXRob2QgdG8gZGlzcGxheSB0aGUgYXBwcm9wcmlhdGUgc2VsZWN0b3JzIGZvciBhIHNjYXR0ZXIgcGxvdFxuY29uc3Qgc2hvd1NjYXR0ZXJGYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdC10eXBlLScgKyBtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCkuY2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZmFjZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAnY3VydmUtZGF0ZXMnOiAnbm9uZScsXG4gICAgICAgICAgICAnZGF0ZXMnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3JlZ2lvbic6ICdibG9jaycsXG4gICAgICAgICAgICAnc3RhdGlzdGljJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd0aHJlc2hvbGQnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ3ByZXMtbGV2ZWwnOiAnYmxvY2snLFxuICAgICAgICAgICAgJ2ZvcmVjYXN0LWxlbmd0aCc6ICdibG9jaycsXG4gICAgICAgICAgICAnZGllb2ZmLXR5cGUnOiAnbm9uZScsXG4gICAgICAgICAgICAnYXZlcmFnZSc6ICdub25lJyxcbiAgICAgICAgICAgICd2YWxpZC10aW1lJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd1dGMtY3ljbGUtc3RhcnQnOiAnbm9uZScsXG4gICAgICAgICAgICAnaGlzdG9ncmFtLWJpbi1jb250cm9scyc6ICdub25lJyxcbiAgICAgICAgICAgICdoaXN0b2dyYW0teWF4aXMtY29udHJvbHMnOiAnbm9uZScsXG4gICAgICAgICAgICAnYmluLW51bWJlcic6ICdub25lJyxcbiAgICAgICAgICAgICdiaW4tYm91bmRzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RydXRoJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdzaXRlcycgOiAnbm9uZScsXG4gICAgICAgICAgICAnc2l0ZXNNYXAnIDogJ25vbmUnLFxuICAgICAgICAgICAgJ3gtYXhpcy1wYXJhbWV0ZXInOiAnbm9uZScsXG4gICAgICAgICAgICAneS1heGlzLXBhcmFtZXRlcic6ICdub25lJ1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmYWNlU2VsZWN0b3JzID0gT2JqZWN0LmtleXMoZmFjZU9wdGlvbnMpO1xuICAgICAgICB2YXIgZWxlbTtcbiAgICAgICAgZm9yICh2YXIgZmlkeCA9IDA7IGZpZHggPCBmYWNlU2VsZWN0b3JzLmxlbmd0aDsgZmlkeCsrKSB7XG4gICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZmFjZVNlbGVjdG9yc1tmaWR4XSArICctaXRlbScpO1xuICAgICAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IGZhY2VPcHRpb25zW2ZhY2VTZWxlY3RvcnNbZmlkeF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCk7XG4gICAgICAgIGlmIChlbGVtICYmIGVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICBTZXNzaW9uLnNldCgncGxvdFR5cGUnLCBtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZCk7XG4gICAgICAgIFNlc3Npb24uc2V0KCdsYXN0VXBkYXRlJywgRGF0ZS5ub3coKSk7ICAgLy8gZm9yY2UgY3VydmVQYXJhbXMgdG8gcmUtcmVuZGVyXG4gICAgICAgIC8vIG1hdHNQYXJhbVV0aWxzLnNldEFsbFBhcmFtc1RvRGVmYXVsdCgpO1xuICAgICAgICBTZXNzaW9uLnNldCgnbGFzdFVwZGF0ZScsIERhdGUubm93KCkpO1xuICAgIH1cbn07XG5cbi8vIHRoaXMgaXMgbm8gbG9uZ2VyIHVzZWQsIGJ1dCBpdCB3YXMgb25jZSBlbXBsb3llZCBieSB0aGUgdGV4dCBvdXRwdXQgcm91dGluZXMgdG8gY2FsY3VsYXRlIHRoZSBzdGF0cyBmb3IgdGhlIGVudGlyZSBjdXJ2ZVxuY29uc3QgZ2V0X2VyciA9IGZ1bmN0aW9uIChzVmFscywgc1NlY3MpIHtcbiAgICAvKiBUSElTIElTIERJRkZFUkVOVCBGUk9NIFRIRSBPTkUgSU4gREFUQV9VVElMUyxcbiAgICAgICBUaGlzIG9uZSBkb2VzIG5vdCB0aHJvdyBhd2F5IG91dGxpZXJzIGFuZCBpdCBjYXB0dXJlcyBtaW5WYWwgYW5kIG1heFZhbFxuICAgICAgIHJlZmVyIHRvIHBlcmwgZXJyb3JfbGlicmFyeS5wbCBzdWIgIGdldF9zdGF0c1xuICAgICAgICB0byBzZWUgdGhlIHBlcmwgaW1wbGVtZW50YXRpb24gb2YgdGhlc2Ugc3RhdGljcyBjYWxjdWxhdGlvbnMuXG4gICAgICAgIFRoZXNlIHNob3VsZCBtYXRjaCBleGFjdGx5IHRob3NlLCBleGNlcHQgdGhhdCB0aGV5IGFyZSBwcm9jZXNzZWQgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgKi9cbiAgICB2YXIgc3ViVmFscyA9IFtdO1xuICAgIHZhciBzdWJTZWNzID0gW107XG4gICAgdmFyIHNWYWxzID0gc1ZhbHM7XG4gICAgdmFyIHNTZWNzID0gc1NlY3M7XG4gICAgdmFyIG4gPSBzVmFscy5sZW5ndGg7XG4gICAgdmFyIG5fZ29vZCA9IDA7XG4gICAgdmFyIHN1bV9kID0gMDtcbiAgICB2YXIgc3VtMl9kID0gMDtcbiAgICB2YXIgZXJyb3IgPSBcIlwiO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKHNWYWxzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICBuX2dvb2QgPSBuX2dvb2QgKyAxO1xuICAgICAgICAgICAgc3VtX2QgPSBzdW1fZCArIHNWYWxzW2ldO1xuICAgICAgICAgICAgc3VtMl9kID0gc3VtMl9kICsgc1ZhbHNbaV0gKiBzVmFsc1tpXTtcbiAgICAgICAgICAgIHN1YlZhbHMucHVzaChzVmFsc1tpXSk7XG4gICAgICAgICAgICBzdWJTZWNzLnB1c2goc1NlY3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBkX21lYW4gPSBzdW1fZCAvIG5fZ29vZDtcbiAgICB2YXIgc2QyID0gc3VtMl9kIC8gbl9nb29kIC0gZF9tZWFuICogZF9tZWFuO1xuICAgIHZhciBzZCA9IHNkMiA+IDAgPyBNYXRoLnNxcnQoc2QyKSA6IHNkMjtcbiAgICB2YXIgc2RfbGltaXQgPSAzICogc2Q7XG4gICAgLy9jb25zb2xlLmxvZyhcInNlZSBlcnJvcl9saWJyYXJ5LnBsIGwyMDggVGhlc2UgYXJlIHByb2Nlc3NlZCBpbiByZXZlcnNlIG9yZGVyIHRvIHRoZSBwZXJsIGNvZGUgLSAgXFxubWVhbiBpcyBcIiArIGRfbWVhbiArIFwiIHNkX2xpbWl0IGlzICsvLSBcIiArIHNkX2xpbWl0ICsgXCIgbl9nb29kIGlzIFwiICsgbl9nb29kICsgXCIgc3VtX2QgaXNcIiArIHN1bV9kICsgXCIgc3VtMl9kIGlzIFwiICsgc3VtMl9kKTtcbiAgICAvLyBmaW5kIG1pbmltdW0gZGVsdGFfdGltZSwgaWYgYW55IHZhbHVlIG1pc3NpbmcsIHNldCBudWxsXG4gICAgdmFyIGxhc3Rfc2VjcyA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgdmFyIG1pbkRlbHRhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWluU2VjcyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIG1heF9zZWNzID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICB2YXIgbWluVmFsID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWF4VmFsID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3ViU2Vjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjcyA9IChzdWJTZWNzW2ldKTtcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnMoc2VjcyAtIGxhc3Rfc2Vjcyk7XG4gICAgICAgIGlmIChkZWx0YSA8IG1pbkRlbHRhKSB7XG4gICAgICAgICAgICBtaW5EZWx0YSA9IGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWNzIDwgbWluU2Vjcykge1xuICAgICAgICAgICAgbWluU2VjcyA9IHNlY3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3MgPiBtYXhfc2Vjcykge1xuICAgICAgICAgICAgbWF4X3NlY3MgPSBzZWNzO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfc2VjcyA9IHNlY3M7XG4gICAgfVxuXG4gICAgdmFyIGRhdGFfd2cgPSBbXTtcbiAgICB2YXIgbl9nYXBzID0gMDtcbiAgICBuX2dvb2QgPSAwO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBzdW0yID0gMDtcbiAgICB2YXIgbG9vcFRpbWUgPSBtaW5TZWNzO1xuICAgIGlmIChtaW5EZWx0YSA8IDApIHtcbiAgICAgICAgZXJyb3IgPSAoXCJJbnZhbGlkIHRpbWUgaW50ZXJ2YWwgLSBtaW5EZWx0YTogXCIgKyBtaW5EZWx0YSk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSBkYXRhIG1vcmUgdGhhbiAkc2RfbGltaXQgZnJvbSBtZWFuXG4gICAgZm9yIChpID0gMDsgaSA8IHN1YlZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWluVmFsID0gbWluVmFsIDwgc3ViVmFsc1tpXSA/IG1pblZhbCA6IHN1YlZhbHNbaV07XG4gICAgICAgIG1heFZhbCA9IG1heFZhbCA+IHN1YlZhbHNbaV0gPyBtYXhWYWwgOiBzdWJWYWxzW2ldO1xuICAgICAgICBuX2dvb2QrKztcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhcIm5ldyBtZWFuIGFmdGVyIHRocm93aW5nIGF3YXkgb3V0bGllcnMgaXMgXCIgKyBzZCArIFwiIG5fZ29vZCBpcyBcIiArIG5fZ29vZCArIFwiIHN1bSBpcyBcIiArIHN1bSAgKyBcIiBzdW0yIGlzIFwiICsgc3VtMiArIFwiIGRfbWVhbiBpcyBcIiArIGRfbWVhbik7XG4gICAgLy8gbG9vayBmb3IgZ2Fwcy4uLi4gcGVyIEJpbGwsIHdlIG9ubHkgbmVlZCBvbmUgZ2FwIHBlciBzZXJpZXMgb2YgZ2Fwcy4uLlxuICAgIHZhciBsYXN0U2Vjb25kID0gTnVtYmVyLk1JTl9WQUxVRTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdWJTZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWMgPSBzdWJTZWNzW2ldO1xuICAgICAgICBpZiAobGFzdFNlY29uZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2VjIC0gbGFzdFNlY29uZCA+IG1pbkRlbHRhKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGEgZ2FwXG4gICAgICAgICAgICAgICAgZGF0YV93Zy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIG5fZ2FwcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RTZWNvbmQgPSBzZWM7XG4gICAgICAgIGRhdGFfd2cucHVzaChzdWJWYWxzW2ldKTtcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyAoXCJuX2dhcHM6IFwiICsgbl9nYXBzICsgIFwiIHRpbWUgZ2FwcyBpbiBzdWJzZXJpZXNcIik7XG5cbiAgICAvL2Zyb20gaHR0cDovL3d3dy5pdGwubmlzdC5nb3YvZGl2ODk4L2hhbmRib29rL2VkYS9zZWN0aW9uMy9lZGEzNWMuaHRtXG4gICAgdmFyIHIgPSBbXTtcbiAgICBmb3IgKHZhciBsYWcgPSAwOyBsYWcgPD0gMTsgbGFnKyspIHtcbiAgICAgICAgcltsYWddID0gMDtcbiAgICAgICAgdmFyIG5faW5fbGFnID0gMDtcbiAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCAoKG4gKyBuX2dhcHMpIC0gbGFnKTsgdCsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YV93Z1t0XSAhPSBudWxsICYmIGRhdGFfd2dbdCArIGxhZ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJbbGFnXSArPSArKGRhdGFfd2dbdF0gLSBkX21lYW4pICogKGRhdGFfd2dbdCArIGxhZ10gLSBkX21lYW4pO1xuICAgICAgICAgICAgICAgIG5faW5fbGFnKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5faW5fbGFnID4gMCAmJiBzZCA+IDApIHtcbiAgICAgICAgICAgIHJbbGFnXSAvPSAobl9pbl9sYWcgKiBzZCAqIHNkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJbbGFnXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZygnciBmb3IgbGFnICcgKyBsYWcgKyBcIiBpcyBcIiArIHJbbGFnXSArIFwiIG5faW5fbGFnIGlzIFwiICsgbl9pbl9sYWcgKyBcIiBuX2dvb2QgaXMgXCIgKyBuX2dvb2QpO1xuICAgIH1cbiAgICAvLyBCZXRzeSBXZWF0aGVyaGVhZCdzIGNvcnJlY3Rpb24sIGJhc2VkIG9uIGxhZyAxXG4gICAgaWYgKHJbMV0gPj0gMSkge1xuICAgICAgICByWzFdID0gLjk5OTk5O1xuICAgIH1cbiAgICBjb25zdCBiZXRzeSA9IE1hdGguc3FydCgobl9nb29kIC0gMSkgKiAoMSAtIHJbMV0pKTtcbiAgICB2YXIgc3RkZV9iZXRzeTtcbiAgICBpZiAoYmV0c3kgIT0gMCkge1xuICAgICAgICBzdGRlX2JldHN5ID0gc2QgLyBiZXRzeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdGRlX2JldHN5ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICAgIGRfbWVhbjogZF9tZWFuLFxuICAgICAgICBzdGRlX2JldHN5OiBzdGRlX2JldHN5LFxuICAgICAgICBzZDogc2QsXG4gICAgICAgIG5fZ29vZDogbl9nb29kLFxuICAgICAgICBsYWcxOiByWzFdLFxuICAgICAgICBtaW46IG1pblNlY3MsXG4gICAgICAgIG1heDogbWF4X3NlY3MsXG4gICAgICAgIG1pblZhbDogbWluVmFsLFxuICAgICAgICBtYXhWYWw6IG1heFZhbCxcbiAgICAgICAgc3VtOiBzdW1fZFxuICAgIH07XG4gICAgLy9jb25zb2xlLmxvZyhcInN0YXRzIGFyZSBcIiArIEpTT04uc3RyaW5naWZ5KHN0YXRzKSk7XG4gICAgLy8gc3RkZV9iZXRzeSBpcyBzdGFuZGFyZCBlcnJvciB3aXRoIGF1dG8gY29ycmVsYXRpb25cbiAgICAvL2NvbnNvbGUubG9nKFwiLS0tLS0tLS0tXFxuXFxuXCIpO1xuICAgIHJldHVybiBzdGF0cztcbn07XG5cbmNvbnN0IHNob3dTcGlubmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNwaW5uZXJcIikpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzcGlubmVyXCIpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxufTtcbmNvbnN0IGhpZGVTcGlubmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNwaW5uZXJcIikpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzcGlubmVyXCIpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXRzQ3VydmVVdGlscyA9IHtcbiAgICByZXNldFNjYXR0ZXJBcHBseTogcmVzZXRTY2F0dGVyQXBwbHksXG4gICAgZ2V0VXNlZExhYmVsczogZ2V0VXNlZExhYmVscyxcbiAgICBnZXROZXh0Q3VydmVMYWJlbDogZ2V0TmV4dEN1cnZlTGFiZWwsXG4gICAgZ2V0TmV4dEN1cnZlQ29sb3I6IGdldE5leHRDdXJ2ZUNvbG9yLFxuICAgIGNsZWFyQWxsVXNlZDogY2xlYXJBbGxVc2VkLFxuICAgIGNsZWFyVXNlZExhYmVsOiBjbGVhclVzZWRMYWJlbCxcbiAgICBjbGVhclVzZWRDb2xvcjogY2xlYXJVc2VkQ29sb3IsXG4gICAgc2V0VXNlZExhYmVsczogc2V0VXNlZExhYmVscyxcbiAgICBzZXRVc2VkQ29sb3JzQW5kTGFiZWxzOiBzZXRVc2VkQ29sb3JzQW5kTGFiZWxzLFxuICAgIGFkZERpZmZzOiBhZGREaWZmcyxcbiAgICByZW1vdmVEaWZmczogcmVtb3ZlRGlmZnMsXG4gICAgY2hlY2tEaWZmczogY2hlY2tEaWZmcyxcbiAgICBzaG93U2NhdHRlckZhY2U6IHNob3dTY2F0dGVyRmFjZSxcbiAgICBzaG93VGltZXNlcmllc0ZhY2U6IHNob3dUaW1lc2VyaWVzRmFjZSxcbiAgICBzaG93UHJvZmlsZUZhY2U6IHNob3dQcm9maWxlRmFjZSxcbiAgICBzaG93RGllT2ZmRmFjZTogc2hvd0RpZU9mZkZhY2UsXG4gICAgc2hvd1RocmVzaG9sZEZhY2U6IHNob3dUaHJlc2hvbGRGYWNlLFxuICAgIHNob3dWYWxpZFRpbWVGYWNlOiBzaG93VmFsaWRUaW1lRmFjZSxcbiAgICBzaG93RGFpbHlNb2RlbEN5Y2xlRmFjZTogc2hvd0RhaWx5TW9kZWxDeWNsZUZhY2UsXG4gICAgc2hvd1JlbGlhYmlsaXR5RmFjZTogc2hvd1JlbGlhYmlsaXR5RmFjZSxcbiAgICBzaG93TWFwRmFjZTogc2hvd01hcEZhY2UsXG4gICAgc2hvd0hpc3RvZ3JhbUZhY2U6IHNob3dIaXN0b2dyYW1GYWNlLFxuICAgIHNob3dDb250b3VyRmFjZTogc2hvd0NvbnRvdXJGYWNlLFxuICAgIGdldF9lcnI6IGdldF9lcnIsXG4gICAgZ2V0UGxvdFJlc3VsdERhdGE6IGdldFBsb3RSZXN1bHREYXRhLFxuICAgIC8vc2V0UGxvdFJlc3VsdERhdGE6IHNldFBsb3RSZXN1bHREYXRhLFxuICAgIHJlc2V0UGxvdFJlc3VsdERhdGE6IHJlc2V0UGxvdFJlc3VsdERhdGEsXG4gICAgZ2V0R3JhcGhSZXN1bHQ6IGdldEdyYXBoUmVzdWx0LFxuICAgIHNldEdyYXBoUmVzdWx0OiBzZXRHcmFwaFJlc3VsdCxcbiAgICByZXNldEdyYXBoUmVzdWx0OiByZXNldEdyYXBoUmVzdWx0LFxuICAgIHNob3dTcGlubmVyOiBzaG93U3Bpbm5lcixcbiAgICBoaWRlU3Bpbm5lcjogaGlkZVNwaW5uZXIsXG59O1xuXG4gICAgICAgICAgICAiLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IENvbG9yYWRvIFN0YXRlIFVuaXZlcnNpdHkgYW5kIFJlZ2VudHMgb2YgdGhlIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHttYXRzVHlwZXN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuXG4vLyBzZXQgdGhlIGxhYmVsIGZvciB0aGUgaGlkZSBzaG93IGJ1dHRvbnMgKE5PIERBVEEpIGZvciB0aGUgaW5pdGlhbCB0aW1lIGhlcmVcbmNvbnN0IHNldE5vRGF0YUxhYmVscyA9IGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBkYXRhc2V0Lmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGlmIChkYXRhc2V0W2NdLngubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBTZXNzaW9uLnNldChkYXRhc2V0W2NdLmN1cnZlSWQgKyBcImhpZGVCdXR0b25UZXh0XCIsICdOTyBEQVRBJyk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUnKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlJykudmFsdWUgPSAnTk8gREFUQSc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUnKS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUnKS5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlJykuc3R5bGVbXCJib3JkZXItY29sb3JcIl0gPSBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUnKS5zdHlsZVtcImNvbG9yXCJdID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU2Vzc2lvbi5zZXQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgXCJwb2ludHNCdXR0b25UZXh0XCIsICdOTyBEQVRBJyk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtcG9pbnRzJykpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1wb2ludHMnKS52YWx1ZSA9ICdOTyBEQVRBJztcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1wb2ludHMnKS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtcG9pbnRzJykuc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1wb2ludHMnKS5zdHlsZVtcImJvcmRlci1jb2xvclwiXSA9IFwiYmxhY2tcIjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1wb2ludHMnKS5zdHlsZVtcImNvbG9yXCJdID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU2Vzc2lvbi5zZXQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgXCJlcnJvckJhckJ1dHRvblRleHRcIiwgJ05PIERBVEEnKTtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1lcnJvcmJhcnMnKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWVycm9yYmFycycpLnZhbHVlID0gJ05PIERBVEEnO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWVycm9yYmFycycpLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1lcnJvcmJhcnMnKS5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWVycm9yYmFycycpLnN0eWxlW1wiYm9yZGVyLWNvbG9yXCJdID0gXCJibGFja1wiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWVycm9yYmFycycpLnN0eWxlW1wiY29sb3JcIl0gPSBcIndoaXRlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTZXNzaW9uLnNldChkYXRhc2V0W2NdLmN1cnZlSWQgKyBcImJhckNoYXJ0QnV0dG9uVGV4dFwiLCAnTk8gREFUQScpO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWJhcnMnKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWJhcnMnKS52YWx1ZSA9ICdOTyBEQVRBJztcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1iYXJzJykuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWJhcnMnKS5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWJhcnMnKS5zdHlsZVtcImJvcmRlci1jb2xvclwiXSA9IFwiYmxhY2tcIjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1iYXJzJykuc3R5bGVbXCJjb2xvclwiXSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNlc3Npb24uc2V0KGRhdGFzZXRbY10uY3VydmVJZCArIFwiYW5ub3RhdGVCdXR0b25UZXh0XCIsICdOTyBEQVRBJyk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtYW5ub3RhdGUnKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWFubm90YXRlJykudmFsdWUgPSAnTk8gREFUQSc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtYW5ub3RhdGUnKS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtYW5ub3RhdGUnKS5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWFubm90YXRlJykuc3R5bGVbXCJib3JkZXItY29sb3JcIl0gPSBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtYW5ub3RhdGUnKS5zdHlsZVtcImNvbG9yXCJdID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU2Vzc2lvbi5zZXQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgXCJoaWRlQnV0dG9uVGV4dFwiLCAnaGlkZSBjdXJ2ZScpO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlJykpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZScpLnZhbHVlID0gJ2hpZGUgY3VydmUnO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlJykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZScpLnN0eWxlW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZScpLnN0eWxlW1wiYm9yZGVyLWNvbG9yXCJdID0gZGF0YXNldFtjXS5tYXJrZXIuY29sb3I7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUnKS5zdHlsZVtcImNvbG9yXCJdID0gZGF0YXNldFtjXS5tYXJrZXIuY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTZXNzaW9uLnNldChkYXRhc2V0W2NdLmN1cnZlSWQgKyBcInBvaW50c0J1dHRvblRleHRcIiwgJ2hpZGUgcG9pbnRzJyk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtcG9pbnRzJykpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1wb2ludHMnKS52YWx1ZSA9ICdoaWRlIHBvaW50cyc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtcG9pbnRzJykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1wb2ludHMnKS5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPSBcIndoaXRlXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtcG9pbnRzJykuc3R5bGVbXCJib3JkZXItY29sb3JcIl0gPSBkYXRhc2V0W2NdLm1hcmtlci5jb2xvcjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1wb2ludHMnKS5zdHlsZVtcImNvbG9yXCJdID0gZGF0YXNldFtjXS5tYXJrZXIuY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTZXNzaW9uLnNldChkYXRhc2V0W2NdLmN1cnZlSWQgKyBcImVycm9yQmFyQnV0dG9uVGV4dFwiLCAnaGlkZSBlcnJvciBiYXJzJyk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtZXJyb3JiYXJzJykpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1lcnJvcmJhcnMnKS52YWx1ZSA9ICdoaWRlIGVycm9yIGJhcnMnO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWVycm9yYmFycycpLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtZXJyb3JiYXJzJykuc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWVycm9yYmFycycpLnN0eWxlW1wiYm9yZGVyLWNvbG9yXCJdID0gZGF0YXNldFtjXS5tYXJrZXIuY29sb3I7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtZXJyb3JiYXJzJykuc3R5bGVbXCJjb2xvclwiXSA9IGRhdGFzZXRbY10ubWFya2VyLmNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU2Vzc2lvbi5zZXQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgXCJiYXJDaGFydEJ1dHRvblRleHRcIiwgJ2hpZGUgYmFycycpO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWJhcnMnKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWJhcnMnKS52YWx1ZSA9ICdoaWRlIGJhcnMnO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWJhcnMnKS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWJhcnMnKS5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPSBcIndoaXRlXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtYmFycycpLnN0eWxlW1wiYm9yZGVyLWNvbG9yXCJdID0gZGF0YXNldFtjXS5tYXJrZXIuY29sb3I7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtYmFycycpLnN0eWxlW1wiY29sb3JcIl0gPSBkYXRhc2V0W2NdLm1hcmtlci5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNlc3Npb24uc2V0KGRhdGFzZXRbY10uY3VydmVJZCArIFwiYW5ub3RhdGVCdXR0b25UZXh0XCIsICdoaWRlIGFubm90YXRpb24nKTtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1hbm5vdGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtYW5ub3RhdGUnKS52YWx1ZSA9ICdoaWRlIGFubm90YXRpb24nO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWFubm90YXRlJykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1hbm5vdGF0ZScpLnN0eWxlW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1hbm5vdGF0ZScpLnN0eWxlW1wiYm9yZGVyLWNvbG9yXCJdID0gZGF0YXNldFtjXS5tYXJrZXIuY29sb3I7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtYW5ub3RhdGUnKS5zdHlsZVtcImNvbG9yXCJdID0gZGF0YXNldFtjXS5tYXJrZXIuY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBzZXROb0RhdGFMYWJlbHNNYXAgPSBmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgZGF0YXNldC5sZW5ndGg7IGMrKykge1xuICAgICAgICBpZiAoZGF0YXNldFtjXS5sYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBTZXNzaW9uLnNldChkYXRhc2V0W2NdLmN1cnZlSWQgKyBcImhlYXRNYXBCdXR0b25UZXh0XCIsICdOTyBEQVRBJyk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtaGVhdG1hcCcpKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtaGVhdG1hcCcpLnZhbHVlID0gJ05PIERBVEEnO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWhlYXRtYXAnKS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtaGVhdG1hcCcpLnN0eWxlW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IFwicmVkXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtaGVhdG1hcCcpLnN0eWxlW1wiYm9yZGVyLWNvbG9yXCJdID0gXCJibGFja1wiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWhlYXRtYXAnKS5zdHlsZVtcImNvbG9yXCJdID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU2Vzc2lvbi5zZXQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgXCJoZWF0TWFwQnV0dG9uVGV4dFwiLCAnc2hvdyBoZWF0IG1hcCcpO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWhlYXRtYXAnKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWhlYXRtYXAnKS52YWx1ZSA9ICdzaG93IGhlYXQgbWFwJztcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1oZWF0bWFwJykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhc2V0W2NdLmN1cnZlSWQgKyAnLWN1cnZlLXNob3ctaGlkZS1oZWF0bWFwJykuc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGFzZXRbY10uY3VydmVJZCArICctY3VydmUtc2hvdy1oaWRlLWhlYXRtYXAnKS5zdHlsZVtcImJvcmRlci1jb2xvclwiXSA9IFwicmVkXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0YXNldFtjXS5jdXJ2ZUlkICsgJy1jdXJ2ZS1zaG93LWhpZGUtaGVhdG1hcCcpLnN0eWxlW1wiY29sb3JcIl0gPSBcInJlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gcGxvdCB3aWR0aCBoZWxwZXIgdXNlZCBpbiBtdWx0aXBsZSBwbGFjZXNcbmNvbnN0IHdpZHRoID0gZnVuY3Rpb24gKHBsb3RUeXBlKSB7XG4gICAgc3dpdGNoIChwbG90VHlwZSkge1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMucHJvZmlsZTpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZDpcbiAgICAgICAgICAgIC8vIHNldCB0aGUgd2lkdGggc3F1YXJlXG4gICAgICAgICAgICByZXR1cm4gc3F1YXJlV2lkdGhIZWlnaHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMudGltZVNlcmllczpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLmRhaWx5TW9kZWxDeWNsZTpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLmRpZW9mZjpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRocmVzaG9sZDpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnZhbGlkdGltZTpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnJlbGlhYmlsaXR5OlxuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMubWFwOlxuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMuaGlzdG9ncmFtOlxuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMuY29udG91cjpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLmNvbnRvdXJEaWZmOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gc2V0IHRoZSB3aWR0aCB3aWRlXG4gICAgICAgICAgICByZXR1cm4gcmVjdGFuZ2xlV2lkdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbi8vIHBsb3QgaGVpZ2h0IGhlbHBlciB1c2VkIGluIG11bHRpcGxlIHBsYWNlc1xuY29uc3QgaGVpZ2h0ID0gZnVuY3Rpb24gKHBsb3RUeXBlKSB7XG4gICAgc3dpdGNoIChwbG90VHlwZSkge1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMucHJvZmlsZTpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnNjYXR0ZXIyZDpcbiAgICAgICAgICAgIC8vIHNldCB0aGUgaGVpZ2h0IHNxdWFyZVxuICAgICAgICAgICAgcmV0dXJuIHNxdWFyZVdpZHRoSGVpZ2h0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRpbWVTZXJpZXM6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kYWlseU1vZGVsQ3ljbGU6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kaWVvZmY6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy50aHJlc2hvbGQ6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy52YWxpZHRpbWU6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5yZWxpYWJpbGl0eTpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLm1hcDpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLmhpc3RvZ3JhbTpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLmNvbnRvdXI6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5jb250b3VyRGlmZjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIHNldCB0aGUgaGVpZ2h0IHdpZGVcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVIZWlnaHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbmNvbnN0IHN0YW5kQWxvbmVXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdnB3ID0gTWF0aC5taW4oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICByZXR1cm4gKC45ICogdnB3KS50b1N0cmluZygpICsgXCJweFwiO1xufTtcbmNvbnN0IHN0YW5kQWxvbmVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZwaCA9IE1hdGgubWluKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICByZXR1cm4gKC44MjUgKiB2cGgpLnRvU3RyaW5nKCkgKyBcInB4XCI7XG59O1xuXG5jb25zdCBzcXVhcmVXaWR0aEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdnB3ID0gTWF0aC5taW4oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB2YXIgdnBoID0gTWF0aC5taW4oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbih2cHcsIHZwaCk7XG4gICAgaWYgKG1pbiA8IDQwMCkge1xuICAgICAgICByZXR1cm4gKC45ICogbWluKS50b1N0cmluZygpICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoLjcgKiBtaW4pLnRvU3RyaW5nKCkgKyBcInB4XCI7XG4gICAgfVxufTtcbmNvbnN0IHJlY3RhbmdsZVdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2cHcgPSBNYXRoLm1pbihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIGlmICh2cHcgPCA0MDApIHtcbiAgICAgICAgcmV0dXJuICguOSAqIHZwdykudG9TdHJpbmcoKSArIFwicHhcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKC45ICogdnB3KS50b1N0cmluZygpICsgXCJweFwiO1xuICAgIH1cbn07XG5jb25zdCByZWN0YW5nbGVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZwaCA9IE1hdGgubWluKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICBpZiAodnBoIDwgNDAwKSB7XG4gICAgICAgIHJldHVybiAoLjggKiB2cGgpLnRvU3RyaW5nKCkgKyBcInB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICguNyAqIHZwaCkudG9TdHJpbmcoKSArIFwicHhcIjtcbiAgICB9XG59O1xuXG5jb25zdCByZXNpemVHcmFwaCA9IGZ1bmN0aW9uIChwbG90VHlwZSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbGFjZWhvbGRlcicpLnN0eWxlLndpZHRoID0gd2lkdGgocGxvdFR5cGUpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbGFjZWhvbGRlcicpLnN0eWxlLmhlaWdodCA9IGhlaWdodChwbG90VHlwZSk7XG59O1xuXG4vLyBoZWxwZXIgdG8gYnJpbmcgdXAgdGhlIHRleHQgcGFnZVxuY29uc3Qgc2V0VGV4dFZpZXcgPSBmdW5jdGlvbiAocGxvdFR5cGUpIHtcbiAgICAvL3Nob3dzIHRleHQgcGFnZSBhbmQgcHJvcGVyIHRleHQgb3V0cHV0LCBoaWRlcyBldmVyeXRoaW5nIGVsc2VcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxhY2Vob2xkZXInKS5zdHlsZS53aWR0aCA9IHdpZHRoKHBsb3RUeXBlKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxhY2Vob2xkZXInKS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQocGxvdFR5cGUpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGV4dC1wYWdlLWJ1dHRvbi1ncm91cFwiKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxvdC1wYWdlLWJ1dHRvbi1ncm91cFwiKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJ2ZXNcIikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ3JhcGhWaWV3XCIpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRleHRWaWV3XCIpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3QtY29udHJvbC1idXR0b24tZ3JvdXAnKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG59O1xuXG4vLyBoZWxwZXIgdG8gYnJpbmcgdXAgdGhlIGdyYXBoIHBhZ2VcbmNvbnN0IHNldEdyYXBoVmlldyA9IGZ1bmN0aW9uIChwbG90VHlwZSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbGFjZWhvbGRlcicpLnN0eWxlLndpZHRoID0gd2lkdGgocGxvdFR5cGUpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbGFjZWhvbGRlcicpLnN0eWxlLmhlaWdodCA9IGhlaWdodChwbG90VHlwZSk7XG4gICAgLy9zaG93cyBncmFwaCBwYWdlLCBoaWRlcyBldmVyeXRoaW5nIGVsc2VcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3JhcGgtY29udGFpbmVyJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3RUeXBlJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyYW1MaXN0Jykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdExpc3QnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXJ2ZUxpc3QnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBsb3RUeXBlQ29udGFpbmVyXCIpKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxvdFR5cGVDb250YWluZXJcIikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzY2F0dGVyMmRcIikpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzY2F0dGVyMmRcIikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzY2F0dGVyVmlld1wiKSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNjYXR0ZXJWaWV3XCIpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXh0LXBhZ2UtYnV0dG9uLWdyb3VwXCIpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBsb3QtcGFnZS1idXR0b24tZ3JvdXBcIikuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnZlc1wiKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ3JhcGhWaWV3XCIpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXh0Vmlld1wiKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgaWYgKFNlc3Npb24uZ2V0KCdwbG90VHlwZScpICE9PSBtYXRzVHlwZXMuUGxvdFR5cGVzLm1hcCkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdC1jb250cm9sLWJ1dHRvbi1ncm91cCcpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3QtY29udHJvbC1idXR0b24tZ3JvdXAnKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxufTtcblxuLy8gaGVscGVyIHRvIGJyaW5nIHVwIHRoZSBncmFwaCBwYWdlIGluIGEgcG9wLXVwIHdpbmRvd1xuY29uc3Qgc3RhbmRBbG9uZVNldEdyYXBoVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL3Nob3dzIGdyYXBoIHBhZ2UsIGhpZGVzIGV2ZXJ5dGhpbmcgZWxzZVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbGFjZWhvbGRlcicpLnN0eWxlLndpZHRoID0gc3RhbmRBbG9uZVdpZHRoKCk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BsYWNlaG9sZGVyJykuc3R5bGUuaGVpZ2h0ID0gc3RhbmRBbG9uZUhlaWdodCgpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdncmFwaC1jb250YWluZXInKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnZlc1wiKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ3JhcGhWaWV3XCIpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG59O1xuXG4vLyBoZWxwZXIgdG8gYnJpbmcgdXAgdGhlIG1haW4gc2VsZWN0b3IgcGFnZVxuY29uc3Qgc2V0RGVmYXVsdFZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2hvdyBlbGVtZW50cyBvZiB0aGUgbWFpbiBwYWdlXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJhbUxpc3QnKSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyYW1MaXN0Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdExpc3QnKSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdExpc3QnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXJ2ZUxpc3QnKSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VydmVMaXN0Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBsb3RUeXBlQ29udGFpbmVyXCIpKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxvdFR5cGVDb250YWluZXJcIikuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2NhdHRlclZpZXdcIikpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzY2F0dGVyVmlld1wiKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH1cbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzY2F0dGVyMmRcIikpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzY2F0dGVyMmRcIikuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB9XG4gICAgLy8gaGlkZSBncmFwaCBwYWdlXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdncmFwaC1jb250YWluZXInKSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3JhcGgtY29udGFpbmVyJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwbG90LXBhZ2UtYnV0dG9uLWdyb3VwXCIpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3QtY29udHJvbC1idXR0b24tZ3JvdXAnKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIC8vIGhpZGUgdGV4dCBwYWdlXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXh0Vmlld1wiKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG59O1xuXG5cbmNvbnN0IGRvd25sb2FkRmlsZSA9IGZ1bmN0aW9uIChmaWxlVVJMLCBmaWxlTmFtZSkge1xuICAgIC8vIGZvciBub24tSUVcbiAgICBpZiAoIXdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgIHZhciBzYXZlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBzYXZlLmhyZWYgPSBmaWxlVVJMO1xuICAgICAgICBzYXZlLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBmaWxlVVJMLnN1YnN0cmluZyhmaWxlVVJMLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgICAgc2F2ZS5kb3dubG9hZCA9IGZpbGVOYW1lIHx8IGZpbGVuYW1lO1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oaXBhZHxpcGhvbmV8c2FmYXJpKS8pICYmIG5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiQ2hyb21lXCIpIDwgMCkge1xuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24gPSBzYXZlLmhyZWY7XG4gICAgICAgIC8vIHdpbmRvdyBldmVudCBub3Qgd29ya2luZyBoZXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gbmV3IE1vdXNlRXZlbnQoJ2NsaWNrJywge1xuICAgICAgICAgICAgICAgICd2aWV3Jzogd2luZG93LFxuICAgICAgICAgICAgICAgICdidWJibGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnY2FuY2VsYWJsZSc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNhdmUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICAgICAgKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkucmV2b2tlT2JqZWN0VVJMKHNhdmUuaHJlZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmb3IgSUUgPCAxMVxuICAgIGVsc2UgaWYgKCEhd2luZG93LkFjdGl2ZVhPYmplY3QgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQpIHtcbiAgICAgICAgdmFyIF93aW5kb3cgPSB3aW5kb3cub3BlbihmaWxlVVJMLCAnX2JsYW5rJyk7XG4gICAgICAgIF93aW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgX3dpbmRvdy5kb2N1bWVudC5leGVjQ29tbWFuZCgnU2F2ZUFzJywgdHJ1ZSwgZmlsZU5hbWUgfHwgZmlsZVVSTClcbiAgICAgICAgX3dpbmRvdy5jbG9zZSgpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdHNHcmFwaFV0aWxzID0ge1xuICAgIHNldE5vRGF0YUxhYmVsczogc2V0Tm9EYXRhTGFiZWxzLFxuICAgIHNldE5vRGF0YUxhYmVsc01hcDogc2V0Tm9EYXRhTGFiZWxzTWFwLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBzdGFuZEFsb25lV2lkdGg6IHN0YW5kQWxvbmVXaWR0aCxcbiAgICBzdGFuZEFsb25lSGVpZ2h0OiBzdGFuZEFsb25lSGVpZ2h0LFxuICAgIHJlc2l6ZUdyYXBoOiByZXNpemVHcmFwaCxcbiAgICBzZXRUZXh0Vmlldzogc2V0VGV4dFZpZXcsXG4gICAgc2V0R3JhcGhWaWV3OiBzZXRHcmFwaFZpZXcsXG4gICAgc3RhbmRBbG9uZVNldEdyYXBoVmlldzogc3RhbmRBbG9uZVNldEdyYXBoVmlldyxcbiAgICBzZXREZWZhdWx0Vmlldzogc2V0RGVmYXVsdFZpZXcsXG4gICAgZG93bmxvYWRGaWxlOiBkb3dubG9hZEZpbGVcbn07IiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbmltcG9ydCB7bWF0c0NvbGxlY3Rpb25zLCBtYXRzTWV0aG9kcywgbWF0c1BhcmFtVXRpbHMsIG1hdHNQbG90VXRpbHMsIG1hdHNUeXBlc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5cbi8vIG1ldGhvZCB0byByZWZyZXNoIHRoZSBwZWVycyBvZiB0aGUgY3VycmVudCBzZWxlY3RvclxuY29uc3QgcmVmcmVzaFBlZXIgPSBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGVlck5hbWUgPSBwYXJhbS5wZWVyTmFtZTtcbiAgICAgICAgaWYgKHBlZXJOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIHBlZXJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhcmFtID0gbWF0c1BhcmFtVXRpbHMuZ2V0UGFyYW1ldGVyRm9yTmFtZShwZWVyTmFtZSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHRhcmdldFBhcmFtLm5hbWUgKyAnLScgKyB0YXJnZXRQYXJhbS50eXBlO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldElkKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hNYXBFdmVudCA9IG5ldyBDdXN0b21FdmVudChcInJlZnJlc2hcIiwge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICByZWZFbGVtZW50OiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmRpc3BhdGNoRXZlbnQocmVmcmVzaE1hcEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZWZyZXNoRGVwZW5kZW50cyhldmVudCwgcGFyYW0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZS5tZXNzYWdlID0gXCJJTkZPOiBFcnJvciBpbiBzZWxlY3QuanMgcmVmcmVzaFBlZXI6IFwiICsgZS5tZXNzYWdlO1xuICAgICAgICBzZXRJbmZvKGUubWVzc2FnZSk7XG4gICAgfVxufTtcblxuLy8gbWV0aG9kIHRvIHJlZnJlc2ggdGhlIGRlcGVuZGVudHMgb2YgdGhlIGN1cnJlbnQgc2VsZWN0b3JcbmNvbnN0IHJlZnJlc2hEZXBlbmRlbnRzID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVudE5hbWVzID0gcGFyYW0uZGVwZW5kZW50TmFtZXM7XG4gICAgICAgIGlmIChkZXBlbmRlbnROYW1lcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGVwZW5kZW50TmFtZXMpID09PSAnW29iamVjdCBBcnJheV0nICYmIGRlcGVuZGVudE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIGRlcGVuZGVudHNcbiAgICAgICAgICAgIHZhciBzZWxlY3RBbGxib29sID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGRlcGVuZGVudE5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhcmFtID0gbWF0c1BhcmFtVXRpbHMuZ2V0UGFyYW1ldGVyRm9yTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFBhcmFtLnR5cGUgPT09IG1hdHNUeXBlcy5JbnB1dFR5cGVzLmRhdGVSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IFwiZWxlbWVudC1cIiArIHRhcmdldFBhcmFtLm5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSB0YXJnZXRQYXJhbS5uYW1lICsgJy0nICsgdGFyZ2V0UGFyYW0udHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldElkKTtcblxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VsZWN0QWxsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0QWxsYm9vbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWxlY3RBbGwnKS5jaGVja2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicmVmcmVzaFwiKSlcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChyZSkge1xuICAgICAgICAgICAgICAgICAgICByZS5tZXNzYWdlID0gXCJJTkZPOiByZWZyZXNoRGVwZW5kZW50cyBvZjogXCIgKyBwYXJhbS5uYW1lICsgXCIgZGVwZW5kZW50OiBcIiArIHRhcmdldFBhcmFtLm5hbWUgKyBcIiAtIGVycm9yOiBcIiArIHJlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHNldEluZm8ocmUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGFyZ2V0RWxlbS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsZW0ubXVsdGlwbGUgJiYgZWxlbWVudHMgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RBbGxib29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpMSA9IDA7IGkxIDwgZWxlbWVudHMubGVuZ3RoOyBpMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbaTFdLnNlbGVjdGVkID0gc2VsZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0c1BhcmFtVXRpbHMuc2V0VmFsdWVUZXh0Rm9yUGFyYW1OYW1lKG5hbWUsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNseV9zZWxlY3RlZCA9IFNlc3Npb24uZ2V0KCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGVsZW1lbnRzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmluZGV4T2YocHJldmlvdXNseV9zZWxlY3RlZCwgZWxlbWVudHNbaTJdLnRleHQpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2kyXS5zZWxlY3RlZCA9IHNlbGVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGUubWVzc2FnZSA9IFwiSU5GTzogRXJyb3IgaW4gc2VsZWN0LmpzIHJlZnJlc2hEZXBlbmRlbnRzOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgc2V0SW5mbyhlLm1lc3NhZ2UpO1xuICAgIH1cbn07XG5cbi8vIGNoZWNrIGZvciBlbmFibGUgY29udHJvbGxlZCAtIFRoaXMgc2VsZWN0IG1pZ2h0IGhhdmUgY29udHJvbCBvZiBhbm90aGVyIHNlbGVjdG9yXG5jb25zdCBjaGVja0Rpc2FibGVPdGhlciA9IGZ1bmN0aW9uIChwYXJhbSwgZmlyc3RSZW5kZXIpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAocGFyYW0uZGlzYWJsZU90aGVyRm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgcGFyYW0gY29udHJvbHMgdGhlIGVuYWJsZS9kaXNhYmxlIHByb3BlcnRpZXMgb2YgYXQgbGVhc3Qgb25lIG90aGVyIHBhcmFtLlxuICAgICAgICAgICAgLy8gVXNlIHRoZSBvcHRpb25zIHRvIGVuYWJsZSBkaXNhYmxlIHRoYXQgcGFyYW0uXG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVkU2VsZWN0b3JzID0gT2JqZWN0LmtleXMocGFyYW0uZGlzYWJsZU90aGVyRm9yKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udHJvbGxlZFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBtYXRzUGFyYW1VdGlscy5nZXRJbnB1dEVsZW1lbnRGb3JQYXJhbU5hbWUocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRPcHRpb25zID0gZWxlbS5zZWxlY3RlZE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gc2VsZWN0ZWRPcHRpb25zICYmIHNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPiAwID8gc2VsZWN0ZWRPcHRpb25zWzBdLnRleHQgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGlmICgoZmlyc3RSZW5kZXIgPT0gdHJ1ZSAmJiBwYXJhbS5kZWZhdWx0ID09IHBhcmFtLmhpZGVPdGhlckZvcltjb250cm9sbGVkU2VsZWN0b3JzW2ldXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcmFtLmRpc2FibGVPdGhlckZvcltjb250cm9sbGVkU2VsZWN0b3JzW2ldXSA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMudW51c2VkICYmIHNlbGVjdGVkVGV4dCA9PT0gXCJcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgJC5pbkFycmF5KHNlbGVjdGVkVGV4dCwgcGFyYW0uZGlzYWJsZU90aGVyRm9yW2NvbnRyb2xsZWRTZWxlY3RvcnNbaV1dKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0c1BhcmFtVXRpbHMuZ2V0SW5wdXRFbGVtZW50Rm9yUGFyYW1OYW1lKGNvbnRyb2xsZWRTZWxlY3RvcnNbaV0pLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWF0c1BhcmFtVXRpbHMuc2V0VmFsdWVUZXh0Rm9yUGFyYW1OYW1lKGNvbnRyb2xsZWRTZWxlY3RvcnNbaV0sIG1hdHNUeXBlcy5JbnB1dFR5cGVzLnVudXNlZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0c1BhcmFtVXRpbHMuZ2V0SW5wdXRFbGVtZW50Rm9yUGFyYW1OYW1lKGNvbnRyb2xsZWRTZWxlY3RvcnNbaV0pLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlLm1lc3NhZ2UgPSBcIklORk86IEVycm9yIGluIHNlbGVjdC5qcyBjaGVja0Rpc2FibGVPdGhlcjogXCIgKyBlLm1lc3NhZ2U7XG4gICAgICAgIHNldEluZm8oZS5tZXNzYWdlKTtcbiAgICB9XG59O1xuXG4vLyBjaGVjayBmb3IgaGlkZSBjb250cm9sbGVkIC0gVGhpcyBzZWxlY3QgbWlnaHQgaGF2ZSBjb250cm9sIG9mIGFub3RoZXIgc2VsZWN0b3IncyB2aXNpYmlsaXR5XG5jb25zdCBjaGVja0hpZGVPdGhlciA9IGZ1bmN0aW9uIChwYXJhbSwgZmlyc3RSZW5kZXIpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAocGFyYW0uaGlkZU90aGVyRm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgcGFyYW0gY29udHJvbHMgdGhlIHZpc2liaWxpdHkgb2YgYXQgbGVhc3Qgb25lIG90aGVyIHBhcmFtLlxuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlZFNlbGVjdG9ycyA9IE9iamVjdC5rZXlzKHBhcmFtLmhpZGVPdGhlckZvcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRyb2xsZWRTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gbWF0c1BhcmFtVXRpbHMuZ2V0SW5wdXRFbGVtZW50Rm9yUGFyYW1OYW1lKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IGVsZW0uc2VsZWN0ZWRPcHRpb25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHNlbGVjdGVkT3B0aW9ucyAmJiBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoID4gMCA/IHNlbGVjdGVkT3B0aW9uc1swXS50ZXh0IDogXCJcIjtcblxuICAgICAgICAgICAgICAgIHZhciBvdGhlcklucHV0RWxlbWVudCA9IG1hdHNQYXJhbVV0aWxzLmdldElucHV0RWxlbWVudEZvclBhcmFtTmFtZShjb250cm9sbGVkU2VsZWN0b3JzW2ldKTtcblxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvckNvbnRyb2xFbGVtO1xuICAgICAgICAgICAgICAgIGlmICgoZmlyc3RSZW5kZXIgPT0gdHJ1ZSAmJiBwYXJhbS5kZWZhdWx0ID09IHBhcmFtLmhpZGVPdGhlckZvcltjb250cm9sbGVkU2VsZWN0b3JzW2ldXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcmFtLmhpZGVPdGhlckZvcltjb250cm9sbGVkU2VsZWN0b3JzW2ldXSA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMudW51c2VkICYmIHNlbGVjdGVkVGV4dCA9PT0gXCJcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgJC5pbkFycmF5KHNlbGVjdGVkVGV4dCwgcGFyYW0uaGlkZU90aGVyRm9yW2NvbnRyb2xsZWRTZWxlY3RvcnNbaV1dKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JDb250cm9sRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRyb2xsZWRTZWxlY3RvcnNbaV0gKyAnLWl0ZW0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yQ29udHJvbEVsZW0gJiYgc2VsZWN0b3JDb250cm9sRWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JDb250cm9sRWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0c1BhcmFtVXRpbHMuc2V0VmFsdWVUZXh0Rm9yUGFyYW1OYW1lKGNvbnRyb2xsZWRTZWxlY3RvcnNbaV0sIG1hdHNUeXBlcy5JbnB1dFR5cGVzLnVudXNlZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JDb250cm9sRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRyb2xsZWRTZWxlY3RvcnNbaV0gKyAnLWl0ZW0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yQ29udHJvbEVsZW0gJiYgc2VsZWN0b3JDb250cm9sRWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JDb250cm9sRWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG90aGVySW5wdXRFbGVtZW50ICYmIG90aGVySW5wdXRFbGVtZW50Lm9wdGlvbnMgJiYgb3RoZXJJbnB1dEVsZW1lbnQuc2VsZWN0ZWRJbmRleCA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIG90aGVySW5wdXRFbGVtZW50Lm9wdGlvbnNbb3RoZXJJbnB1dEVsZW1lbnQuc2VsZWN0ZWRJbmRleF0uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRzU2VsZWN0VXRpbHMuY2hlY2tEaXNhYmxlT3RoZXIocGFyYW0pLCBmaXJzdFJlbmRlcjtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZS5tZXNzYWdlID0gXCJJTkZPOiBFcnJvciBpbiBzZWxlY3QuanMgY2hlY2tIaWRlT3RoZXI6IFwiICsgZS5tZXNzYWdlO1xuICAgICAgICBzZXRJbmZvKGUubWVzc2FnZSk7XG4gICAgfVxufTtcblxuLy8gcmVmcmVzaCB0aGUgc2VsZWN0b3IgaW4gcXVlc3Rpb24gdG8gdGhlIGFwcHJvcHJpYXRlIG9wdGlvbnMgaW5kaWNhdGVkIGJ5IHRoZSB2YWx1ZXMgb2YgYW55IHN1cGVyaW9yIHNlbGVjdG9yc1xuY29uc3QgcmVmcmVzaCA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1OYW1lKSB7XG4gICAgaWYgKHBhcmFtTmFtZS5zZWFyY2goJ2F4aXMnKSA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIGEgXCJicm90aGVyXCIgKGhpZGRlbikgc2NhdHRlcnBsb3QgcGFyYW0uIFRoZXJlIGlzIG5vIG5lZWQgdG8gcmVmcmVzaCBpdCBvciBhZGQgZXZlbnQgbGlzdGVuZXJzIGV0Yy5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbSA9IG1hdHNQYXJhbVV0aWxzLmdldFBhcmFtZXRlckZvck5hbWUocGFyYW1OYW1lKTtcbiAgICBjb25zdCBlbGVtID0gbWF0c1BhcmFtVXRpbHMuZ2V0SW5wdXRFbGVtZW50Rm9yUGFyYW1OYW1lKHBhcmFtTmFtZSk7XG5cbiAgICAvKlxuICAgIE9wdGlvbnNHcm91cHMgYXJlIGEgbWVjaGFuaXNtIGZvciBkaXNwbGF5aW5nIHRoZSBzZWxlY3Qgb3B0aW9ucyBpbiBncm91cHMuXG4gICAgQSBkaXNhYmxlZCBvcHRpb24gaXMgdXNlZCBmb3IgdGhlIGdyb3VwIGhlYWRlci4gRGlzYWJsZWQgb3B0aW9ucyBzaW1wbHkgc2hvdyB1cFxuICAgIGluIHRoZSBzZWxlY3RvciBsaXN0IGluIGJvbGQgZm9udCBhbmQgYWN0IGFzIGdyb3VwIHRpdGxlcy4gVGhleSBhcmUgZGlzYWJsZWQgc28gdGhhdFxuICAgIHRoZXkgY2Fubm90IGJlIGNsaWNrZWQuIERpc2FibGVkT3B0aW9ucyBhcmUgdGhlIGhlYWRlcnMgdGhhdCB0aGUgb3B0aW9ucyBhcmUgdG8gYmUgZ3JvdXBlZCB1bmRlci5cbiAgICBkaXNhYmxlZE9wdGlvbnMgYXJlIG9wdGlvbmFsIHNvIGlmIHRoZXJlIGFyZSBkaXNhYmxlZE9wdGlvbnMgdGhleSBhcmUgdGhlIGtleXMgaW4gdGhlIG9wdGlvbnNHcm91cHNcbiAgICBhbmQgdGhleSBhcmUgdGhlIHNvcnQgb3JkZXIgb2YgdGhvc2Uga2V5cy5cbiAgICAqL1xuICAgIGNvbnN0IGRpc2FibGVkT3B0aW9ucyA9IG1hdHNQYXJhbVV0aWxzLmdldERpc2FibGVkT3B0aW9uc0ZvclBhcmFtTmFtZShwYXJhbU5hbWUpO1xuICAgIGNvbnN0IG9wdGlvbnNHcm91cHMgPSBwYXJhbS5vcHRpb25zR3JvdXBzO1xuICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBwYXJhbS5vcHRpb25zTWFwO1xuXG4gICAgY29uc3Qgc3VwZXJpb3JOYW1lcyA9IHBhcmFtLnN1cGVyaW9yTmFtZXM7XG4gICAgY29uc3Qgc3VwZXJpb3JEaW1lbnNpb25hbGl0eSA9IHN1cGVyaW9yTmFtZXMgIT09IHVuZGVmaW5lZCAmJiBzdXBlcmlvck5hbWVzICE9PSBudWxsICYmIHN1cGVyaW9yTmFtZXMubGVuZ3RoID4gMCAmJiBBcnJheS5pc0FycmF5KHN1cGVyaW9yTmFtZXNbMF0pID8gc3VwZXJpb3JOYW1lcy5sZW5ndGggOiAxO1xuICAgIHZhciBzdXBlcmlvcnMgPSBbXTtcbiAgICAvLyBnZXQgYSBsaXN0IG9mIHRoZSBjdXJyZW50IHN1cGVyaW9yIHNlbGVjdGVkIHZhbHVlcyAtIGluIG9yZGVyIG9mIHN1cGVyaW9yaXR5IGkuZS4gW2RhdGFiYXNlVmFsdWUsZGF0YVNvdXJjZVZhbHVlXVxuICAgIHZhciBzTmFtZXM7XG4gICAgaWYgKHN1cGVyaW9yTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3VwZXJpb3JEaW1lbnNpb25hbGl0eSA9PT0gMSkge1xuICAgICAgICAgICAgc05hbWVzID0gc3VwZXJpb3JOYW1lcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNOYW1lcyA9IHN1cGVyaW9yTmFtZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgc24gPSAwOyBzbiA8IHNOYW1lcy5sZW5ndGg7IHNuKyspIHtcbiAgICAgICAgICAgIHZhciBzdXBlcmlvckVsZW1lbnQgPSBtYXRzUGFyYW1VdGlscy5nZXRJbnB1dEVsZW1lbnRGb3JQYXJhbU5hbWUoc05hbWVzW3NuXSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRTdXBlcmlvclZhbHVlID0gc3VwZXJpb3JFbGVtZW50Lm9wdGlvbnNbc3VwZXJpb3JFbGVtZW50LnNlbGVjdGVkSW5kZXhdID09PSB1bmRlZmluZWQgPyBtYXRzUGFyYW1VdGlscy5nZXRQYXJhbWV0ZXJGb3JOYW1lKHNOYW1lc1tzbl0pLmRlZmF1bHQgOiBzdXBlcmlvckVsZW1lbnQub3B0aW9uc1tzdXBlcmlvckVsZW1lbnQuc2VsZWN0ZWRJbmRleF0udGV4dDtcbiAgICAgICAgICAgIHN1cGVyaW9yc1swXSA9IHN1cGVyaW9yc1swXSA9PT0gdW5kZWZpbmVkID8gW10gOiBzdXBlcmlvcnNbMF07XG4gICAgICAgICAgICBzdXBlcmlvcnNbMF0ucHVzaCh7ZWxlbWVudDogc3VwZXJpb3JFbGVtZW50LCB2YWx1ZTogc2VsZWN0ZWRTdXBlcmlvclZhbHVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgc05hbWVJbmRleCA9IDE7IHNOYW1lSW5kZXggPCBzdXBlcmlvckRpbWVuc2lvbmFsaXR5OyBzTmFtZUluZGV4KyspIHtcbiAgICAgICAgICAgIHNOYW1lcyA9IHN1cGVyaW9yTmFtZXNbc05hbWVJbmRleF07XG4gICAgICAgICAgICBmb3IgKHZhciBzbiA9IDA7IHNuIDwgc05hbWVzLmxlbmd0aDsgc24rKykge1xuICAgICAgICAgICAgICAgIHZhciBzdXBlcmlvckVsZW1lbnQgPSBtYXRzUGFyYW1VdGlscy5nZXRJbnB1dEVsZW1lbnRGb3JQYXJhbU5hbWUoc05hbWVzW3NuXSk7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkU3VwZXJpb3JWYWx1ZSA9IHN1cGVyaW9yRWxlbWVudC5vcHRpb25zW3N1cGVyaW9yRWxlbWVudC5zZWxlY3RlZEluZGV4XSA9PT0gdW5kZWZpbmVkID8gbWF0c1BhcmFtVXRpbHMuZ2V0UGFyYW1ldGVyRm9yTmFtZShzTmFtZXNbc25dKS5kZWZhdWx0IDogc3VwZXJpb3JFbGVtZW50Lm9wdGlvbnNbc3VwZXJpb3JFbGVtZW50LnNlbGVjdGVkSW5kZXhdLnRleHQ7XG4gICAgICAgICAgICAgICAgc3VwZXJpb3JzW3NOYW1lSW5kZXhdID0gc3VwZXJpb3JzW3NOYW1lSW5kZXhdID09PSB1bmRlZmluZWQgPyBbXSA6IHN1cGVyaW9yc1tzTmFtZUluZGV4XTtcbiAgICAgICAgICAgICAgICBzdXBlcmlvcnNbc05hbWVJbmRleF0ucHVzaCh7ZWxlbWVudDogc3VwZXJpb3JFbGVtZW50LCB2YWx1ZTogc2VsZWN0ZWRTdXBlcmlvclZhbHVlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICBTbyB3aGF0IGFyZSBzdXBlcmlvcnMgbm93Li4uLi5cbiAgICBzdXBlcmlvcnMgPSBbW3tlbGVtZW50OmFuRWxlbWVudCx2YWx1ZTphVmFsdWV9LHtlbGVtZW50OmFuRWxlbWVudCx2YWx1ZTphVmFsdWV9Li4uXV1cbiAgICBvciB0aGV5IG1pZ2h0IGJlIFtbe2VsZW1lbnQ6YW5FbGVtZW50LHZhbHVlOmFWYWx1ZX0se2VsZW1lbnQ6YW5FbGVtZW50LHZhbHVlOmFWYWx1ZX0uLi5dLFt7ZWxlbWVudDphbkVsZW1lbnQsdmFsdWU6YVZhbHVlfSx7ZWxlbWVudDphbkVsZW1lbnQsdmFsdWU6YVZhbHVlfS4uLl0sLi4uXVxuXG5cbiAgICAgQXhpcy1icm90aGVyczpcbiAgICAgQXhpcy1icm90aGVycyBhcmUgZm9yIHNjYXR0ZXIgcGxvdHMuIFRoZXkgYXJlIGEgc2Vjb25kIGhpZGRlbiBzZXQgb2YgcGFyYW1ldGVycyB0aGF0IGFwcGx5IHRvIGEgZGlmZmVyZW50IGF4aXMuXG4gICAgIEJlY2F1c2UgdGhlcmUgbWF5IGJlIGF4aXMgXCJicm90aGVyc1wiIFRoaXMgcmVmcmVzaCBtdXN0IGdvIGFuZFxuICAgICBzZWUgaWYgdGhlcmUgYXJlIGFueSBicm90aGVyIGVsZW1lbnRzIHRoYXQgYXJlIGVzc2VudGlhbGx5IGhpZGRlbiBjb3BpZXNcbiAgICAgb2YgdGhpcyBvbmUsIGFuZCBhbHNvIHJlZnJlc2ggdGhlaXIgb3B0aW9ucyBsaXN0c1xuXG4gICAgIFN1cGVyaW9yIEhlaXJhcmNoeTpcbiAgICAgVGhlcmUgY2FuIGJlIGEgaGVpcmFyY2h5IG9mIHN1cGVyaW9ycyBhbmQgZGVwZW5kZW50cy4gVGhlIHN1cGVyaW9yTmFtZXMgYXJlIGEgbGlzdCBvZiBwYXJhbU5hbWVzLiBUaGUgbW9zdCBzdXBlcmlvciBoYXMgdGhlIDB0aCBpbmRleCBhbmRcbiAgICAgdGhlIGxlYXN0IHN1cGVyaW9yIGhhcyB0aGUgaGlnaGVzdCBpbmRleC5cbiAgICAgVGhlIFJlZnJlc2ggdXNlcyB0aGUgc3VwZXJpb3JzIHRvIGdldCB0aGUgYXBwcm9wcmlhdGUgb3B0aW9ucyBmb3IgYSBnaXZlbiBvcHRpb25zIG1hcC5cbiAgICAgVGhlIHdheSBpdCB3b3JrcyBpcyB0aGF0IHN1cGVyaW9ycyBhcmUgYWx3YXlzIHJlZnJlc2hlZCBmaXJzdC4gVGhlIHN1cGVyaW9yIGhlaXJhcmNoeSBzZWxlY3Rpb25zIGFyZSB0aGVuIHVzZWQgYnkgYVxuICAgICBkZXBlbmRlbnQgdG8gcmV0cmlldmUgaXRzIGFwcHJvcHJpYXRlIG9wdGlvbnNNYXAgZnJvbSB0aGUgc3VwZXJpb3JPcHRpb25zTWFwLlxuICAgICBzdXBlcmlvcnNPcHRpb25zTWFwID0ge1xuICAgICAgICBtb3N0U3VwZXJpb3JWYWx1ZTA6IHsgIC8vIG9wdGlvbnNNYXAgZm9yIHRoZSBtb3N0IHN1cGVyaW9yIGZpcnN0IHZhbHVlXG4gICAgICAgICAgICBuZXh0U3VwZXJpb3JWYWx1ZTA6IFt2YWx1ZTAsdmFsdWUxLHZhbHVlMix2YWx1ZTMsLi4uXSxcbiAgICAgICAgICAgIG5leHRTdXBlcmlvclZhbHVlMTogW3ZhbHVlMCx2YWx1ZTEsdmFsdWUyLHZhbHVlMywuLi5dLFxuICAgICAgICAgICAgbmV4dFN1cGVyaW9yVmFsdWUyOiBbdmFsdWUwLHZhbHVlMSx2YWx1ZTIsdmFsdWUzLC4uLl0sXG4gICAgICAgICAgICAuLi5cbiAgICAgICAgfSxcbiAgICAgICAgbW9zdFN1cGVyaW9yVmFsdWUxOnsgIC8vIG9wdGlvbnNNYXAgZm9yIHRoZSBtb3N0IHN1cGVyaW9yIHNlY29uZCB2YWx1ZVxuICAgICAgICAgICAgbmV4dFN1cGVyaW9yVmFsdWUwOiBbdmFsdWUwLHZhbHVlMSx2YWx1ZTIsdmFsdWUzLC4uLl0sXG4gICAgICAgICAgICBuZXh0U3VwZXJpb3JWYWx1ZTE6IFt2YWx1ZTAsdmFsdWUxLHZhbHVlMix2YWx1ZTMsLi4uXSxcbiAgICAgICAgICAgIG5leHRTdXBlcmlvclZhbHVlMjogW3ZhbHVlMCx2YWx1ZTEsdmFsdWUyLHZhbHVlMywuLi5dLFxuICAgICAgICAgICAgLi4uXG4gICAgICAgIH0sXG4gICAgICAgIC4uLixcbiAgICAgICAgbW9zdFN1cGVyaW9yVmFsdWUyOnsgIC8vIG9wdGlvbnNNYXAgZm9yIHRoZSBtb3N0IHN1cGVyaW9yIHRoaXJkIHZhbHVlXG4gICAgICAgICAgICBuZXh0U3VwZXJpb3JWYWx1ZTA6IFt2YWx1ZTAsdmFsdWUxLHZhbHVlMix2YWx1ZTMsLi4uXSxcbiAgICAgICAgICAgIG5leHRTdXBlcmlvclZhbHVlMTogW3ZhbHVlMCx2YWx1ZTEsdmFsdWUyLHZhbHVlMywuLi5dLFxuICAgICAgICAgICAgbmV4dFN1cGVyaW9yVmFsdWUyOiBbdmFsdWUwLHZhbHVlMSx2YWx1ZTIsdmFsdWUzLC4uLl0sXG4gICAgICAgICAgICAuLi5cbiAgICAgICAgfSxcbiAgICAgfVxuICAgICAqL1xuXG4gICAgLy8gZmluZCBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgaGF2ZSBpZHMgbGlrZSAuLi4uIFwieHx5fHpcIiArIFwiYXhpcy1cIiArIHRoaXMubmFtZVxuICAgIGNvbnN0IG5hbWUgPSBwYXJhbS5uYW1lO1xuICAgIGNvbnN0IGVsZW1zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRhdGEtaW5wdXRcIikgPT09IHVuZGVmaW5lZCA/IFtdIDogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRhdGEtaW5wdXRcIik7XG4gICAgU2Vzc2lvbi5zZXQoJ3NlbGVjdGVkJywgJChlbGVtKS52YWwoKSk7XG5cbiAgICBpZiAoZWxlbSAmJiBlbGVtLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGVsZW0uc2VsZWN0ZWRJbmRleCA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5kZWZhdWx0ICE9PSBtYXRzVHlwZXMuSW5wdXRUeXBlcy51bnVzZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IGVsZW0uc2VsZWN0ZWRJbmRleCA+PSAwID8gZWxlbS5vcHRpb25zW2VsZW0uc2VsZWN0ZWRJbmRleF0udGV4dCA6IG1hdHNUeXBlcy5JbnB1dFR5cGVzLnVudXNlZDtcbiAgICAgICAgdmFyIGJyb3RoZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlbGVtc1tpXS5pZC5pbmRleE9mKG5hbWUpID49IDAgJiYgZWxlbXNbaV0uaWQgIT09IGVsZW0uaWQpXG4gICAgICAgICAgICAgICAgYnJvdGhlcnMucHVzaChlbGVtc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbXlPcHRpb25zID0gW107XG4gICAgICAgIHZhciBzZWxlY3RlZFN1cGVyaW9yVmFsdWVzID0gW107XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGluZGV4IGRvd24gdGhyb3VnaCB0aGUgb3B0aW9ucyBmb3IgdGhlIGxpc3Qgb2Ygc3VwZXJpb3JzXG4gICAgICAgICAgICAvLyBzdGFydGluZyB3aXRoIHRoZSBtb3N0IHN1cGVyaW9yIGRvd24gdGhyb3VnaCB0aGUgbGVhc3Qgc3VwZXJpb3JcbiAgICAgICAgICAgIC8vIGFuZCBnZXQgdGhlIG9wdGlvbnMgbGlzdCBmb3IgdGhlIGZpcnN0IHNldCBvZiBzdXBlcmlvcnMuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGFuY2VzdHJhbCBvcHRpb25zLlxuICAgICAgICAgICAgaWYgKHBhcmFtLm9wdGlvbnNNYXApIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RTdXBlcmlvck9wdGlvbnMgPSBvcHRpb25zTWFwO1xuICAgICAgICAgICAgICAgIHZhciB0aGVzZVN1cGVyaW9ycyA9IHN1cGVyaW9ycyA9PT0gdW5kZWZpbmVkIHx8IHN1cGVyaW9ycy5sZW5ndGggPT09IDAgPyBbXSA6IHN1cGVyaW9yc1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0aGVzZVN1cGVyaW9yc0luZGV4ID0gMDsgdGhlc2VTdXBlcmlvcnNJbmRleCA8IHRoZXNlU3VwZXJpb3JzLmxlbmd0aDsgdGhlc2VTdXBlcmlvcnNJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdXBlcmlvciA9IHRoZXNlU3VwZXJpb3JzW3RoZXNlU3VwZXJpb3JzSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRTdXBlcmlvclZhbHVlID0gc3VwZXJpb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0U3VwZXJpb3JPcHRpb25zID0gZmlyc3RTdXBlcmlvck9wdGlvbnNbc2VsZWN0ZWRTdXBlcmlvclZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXlPcHRpb25zID0gQXJyYXkuaXNBcnJheShmaXJzdFN1cGVyaW9yT3B0aW9ucykgPyBmaXJzdFN1cGVyaW9yT3B0aW9ucyA6IE9iamVjdC5rZXlzKGZpcnN0U3VwZXJpb3JPcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbXlPcHRpb25zID0gcGFyYW0ub3B0aW9ucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbmVlZCB0byBnZXQgdGhlIGFuY2VzdHJhbCB0cnV0aCBvcHRpb25zIGJlY2F1c2Ugd2UgbWF5IG5lZWQgdG8gaW50ZXJzZWN0IHRoZSBvcHRpb25zXG5cblxuICAgICAgICAgICAgLyogdHJpY2t5IGxpdHRsZSBiaXQgaGVyZTpcbiAgICAgICAgICAgIFN1cGVyaW9yRGltZW5zaW9uYWxpdHk6XG4gICAgICAgICAgICAgSXQgaXMgcG9zc2libGUgdG8gaGF2ZSB0d28gc3VwZXJpb3Igb3B0aW9ucyBtYXBzLi4gaS5lLiBkYXRhc291cmNlIGFuZCB0cnV0aC5cbiAgICAgICAgICAgICBJbiB0aGF0IGNhc2UgdGhlIHN1cGVyaW9yTmFtZXMgd29uJ3QgbG9vayBsaWtlIFtcInNvbWV0aGluZ1wiLFwic29tZXRoaW5nZWxzZVwiXSxcbiAgICAgICAgICAgICBpbnN0ZWFkIGl0IHdpbGwgbG9vayBsaWtlIFtbXCJzb21ldGhpbmdcIixcInNvbWV0aGluZ2Vsc2VcIl0sW1wic29tZW90aGVydGhpbmdcIixcInNvbWVvdGhlcnRoaW5nZWxzZVwiXV1cbiAgICAgICAgICAgICBpLmUuIGl0IHdpbGwgYmUgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5LlxuXG4gICAgICAgICAgICAgSWYgdGhlIGNvbnRyb2xCdXR0b24gZm9yIG9uZSBvZiB0aGVzZSBtdWx0aS1kaW1lbnNpb25hbCBzdXBlcmlvciBlbGVtZW50cyBpcyBoaWRkZW4gLi4uLlxuICAgICAgICAgICAgIG1hdHNQYXJhbVV0aWxzLmdldENvbnRyb2xFbGVtZW50Rm9yUGFyYW1OYW1lKHN1cGVyaW9yLmVsZW1lbnQubmFtZSkub2Zmc2V0UGFyZW50ICE9PSBudWxsXG4gICAgICAgICAgICAgaXQgaGFzIGJlZW4gaGlkZGVuIGJlY2F1c2UgaXQgaGFzIGEgdmlzaWJpbGl0eSBkZXBlbmRlbmN5IG9uIGFub3RoZXIgcGFyYW1cbiAgICAgICAgICAgICBpLmUuIHRydXRoLWRhdGEtc291cmNlIGFuZCB0cnV0aC12YXJpYWJsZSAoZm9yIG1lYW4gdGhlcmUgd291bGQgYmUgbm8gdHJ1dGgsIGJ1dCBmb3IgYmlhc1xuICAgICAgICAgICAgIHRoZXJlIG11c3QgYWx3YXlzIGJlIHRydXRoLi4uKS5cbiAgICAgICAgICAgICBJbiB0aGlzIGNhc2UgdGhlc2UgYXJlIGRlcGVuZGVudCB1cG9uIHN0YXRpc3RpYyBzdWNoIHRoYXQgaWYgdGhlIHN0YXRpc3RpYyBpcyBcIm1lYW5cIiB0aGUgdHJ1dGgtZGF0YS1zb3VyY2UgYW5kIHRydXRoLXZhcmlhYmxlXG4gICAgICAgICAgICAgYXJlIGhpZGRlbi4gU2VlIHRoZSB3ZmlwMiBtYWluLmpzIHN0YXRpc3RpYyBwYXJhbSBhcyBhbiBleGFtcGxlLi4uLlxuICAgICAgICAgICAgIFwiZGlzYWJsZU90aGVyRm9yOnsndHJ1dGgtZGF0YS1zb3VyY2UnOltzdGF0aXN0aWNPcHRpb25zTWFwLm1lYW5dWzBdfSxcIlxuICAgICAgICAgICAgIGFuZFxuICAgICAgICAgICAgIFwiaGlkZU90aGVyRm9yOnsndHJ1dGgtZGF0YS1zb3VyY2UnOltzdGF0aXN0aWNPcHRpb25zTWFwLm1lYW5dWzBdfSxcIlxuICAgICAgICAgICAgIGFyZSB0aGUgZmllbGRzIHRoYXQgY2F1c2UgdGhlIHRydXRoLWRhdGEtc291cmNlIHRvIGJlIGhpZGRlbiB3aGVuIHN0YXRpc3RpYyBpcyBzZXQgdG8gXCJtZWFuXCIuXG4gICAgICAgICAgICAgSW4gdGhhdCBjb25kaXRpb24gKHRoZSBjb250cm9sQnV0dG9uIGlzIGhpZGRlbikgdGhlIHN1cGVyaW9yIHNob3VsZCBub3QgYmUgdXNlZCBhcyBhbiBpbnRlcnNlY3Rpb24gaW4gdGhlIHNlbGVjdGVkIHNpdGVzLlxuICAgICAgICAgICAgIG1hdHNQYXJhbVV0aWxzLmdldENvbnRyb2xFbGVtZW50Rm9yUGFyYW1OYW1lKHN1cGVyaW9yLmVsZW1lbnQubmFtZSkub2Zmc2V0UGFyZW50IHdpbGwgYmUgbnVsbCBpZiB0aGUgY29udHJvbEJ1dHRvblxuICAgICAgICAgICAgIGZvciB0aGlzIGVsZW1lbnQgKHRoaXMgc3VwZXJpb3IpIGlzIGhpZGRlbi4gVGhhdCBpcyB0aGUgdHJpY2t5IHBhcnQgLi4uIGl0IHdpbGwgYmUgbnVsbC5cblxuICAgICAgICAgICAgIEFsc28gdGhlIHVudXNlZCBzdXBlcmlvciBpcyB0ZXN0ZWQgYWdhaW5zdCB0aGUgc3VwZXJpb3IgYWNjb3JkaW5nIHRvIHRoZSB0cnV0aCB0YWJsZS4uLlxuICAgICAgICAgICAgIHVzZWQgJiYgdW51c2VkICAtPiB1c2UgdGhlIHVzZWRcbiAgICAgICAgICAgICB1bnVzZWQgYW5kIHVzZWQgLT4gdXNlIHRoZSB1c2VkXG4gICAgICAgICAgICAgdXNlZCBhbmQgdXNlZCAtPiB1c2UgdGhlIGludGVyc2VjdGlvblxuICAgICAgICAgICAgIHVudXNlZCBhbmQgdW51c2VkIC0gc2V0IHRoZSBvcHRpb25zIHRvIFtdXG5cbiAgICAgICAgICAgICBBIHNlbGVjdCBtYXkgaGF2ZSBhIGxpc3Qgb2YgZGlzYWJsZWRPcHRpb25zLiBUaGVzZSBhcmUgdXNlZCBhcyBvcHRpb25Hcm91cCBtYXJrZXJzLlxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gZ2V0IHRoZSBhY3R1YWwgb3B0aW9ucyBoZXJlXG4gICAgICAgICAgICBmb3IgKHZhciBzTmFtZUluZGV4ID0gMTsgc05hbWVJbmRleCA8IHN1cGVyaW9yRGltZW5zaW9uYWxpdHk7IHNOYW1lSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIC8vIGluZGV4IGRvd24gdGhyb3VnaCB0aGUgb3B0aW9ucyBmb3IgdGhlIGxpc3Qgb2Ygc3VwZXJpb3JzXG4gICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgd2l0aCB0aGUgbW9zdCBzdXBlcmlvciBkb3duIHRocm91Z2ggdGhlIGxlYXN0IHN1cGVyaW9yXG4gICAgICAgICAgICAgICAgLy8gYW5kIGdldCB0aGUgb3B0aW9ucyBsaXN0IGZvciB0aGUgZmlyc3Qgc2V0IG9mIHN1cGVyaW9ycy5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGFuY2VzdHJhbCBvcHRpb25zLlxuICAgICAgICAgICAgICAgIHZhciBuZXh0U3VwZXJpb3JPcHRpb25zID0gb3B0aW9uc01hcDtcbiAgICAgICAgICAgICAgICB2YXIgdGhlc2VTdXBlcmlvcnMgPSBzdXBlcmlvcnMgPT09IHVuZGVmaW5lZCB8fCBzdXBlcmlvcnMubGVuZ3RoID09PSAwID8gW10gOiBzdXBlcmlvcnNbc05hbWVJbmRleF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdGhlc2VTdXBlcmlvcnNJbmRleCA9IDA7IHRoZXNlU3VwZXJpb3JzSW5kZXggPCB0aGVzZVN1cGVyaW9ycy5sZW5ndGg7IHRoZXNlU3VwZXJpb3JzSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VwZXJpb3IgPSB0aGVzZVN1cGVyaW9yc1t0aGVzZVN1cGVyaW9yc0luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkU3VwZXJpb3JWYWx1ZSA9IHN1cGVyaW9yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBuZXh0U3VwZXJpb3JPcHRpb25zID0gbmV4dFN1cGVyaW9yT3B0aW9uc1tzZWxlY3RlZFN1cGVyaW9yVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBub3cgaGF2ZSBtdWx0aXBsZSBvcHRpb25zIHdlIGhhdmUgdG8gaW50ZXJzZWN0IHRoZW1cbiAgICAgICAgICAgICAgICBteU9wdGlvbnMgPSBfLmludGVyc2VjdGlvbihteU9wdGlvbnMsIG5leHRTdXBlcmlvck9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG15T3B0aW9ucyA9PT0gW10pIHsgIC8vIG5vbmUgdXNlZCAtIHNldCB0byBbXVxuICAgICAgICAgICAgICAgIG1hdHNQYXJhbVV0aWxzLnNldFZhbHVlVGV4dEZvclBhcmFtTmFtZShuYW1lLCBtYXRzVHlwZXMuSW5wdXRUeXBlcy51bnVzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIklORk86IEVycm9yIGluIHNlbGVjdC5qcyByZWZyZXNoOiBkZXRlcm1pbmluZyBvcHRpb25zIGZyb20gc3VwZXJpb3JzOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgICAgIHNldEluZm8oZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyByZXNldCB0aGUgb3B0aW9ucyBvZiB0aGUgc2VsZWN0XG4gICAgICAgICAgICAvLyBpZiB0aGUgb3B0aW9ucyBhcmUgbnVsbCBpdCBtaWdodCBiZSB0aGF0IHRoaXMgaXMgdGhlIGluaXRpYWwgc2V0dXAuXG4gICAgICAgICAgICAvLyBzbyB1c2UgdGhlIG9wdGlvbnNtYXAgYW5kIHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBtYXBcbiAgICAgICAgICAgIC8vIGl0IG1pZ2h0IGFsc28gbWVhbiB0aGF0IHRoZXJlIGFyZSBubyBzdXBlcmlvcnMgZm9yIHRoaXMgcGFyYW1cbiAgICAgICAgICAgIGlmIChteU9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uR3JvdXBzIGFyZSBhbiBvcmRlcmVkIG1hcC4gSXQgcHJvYmFibHkgaGFzIG9wdGlvbnMgdGhhdCBhcmUgaW4gdGhlIGRpc2FibGVkT3B0aW9uIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggYXJlIHVzZWQgYXMgbWFya2VycyBpbiB0aGUgc2VsZWN0IG9wdGlvbnMgcHVsbGRvd24uIFRoaXMgaXMgdHlwaWNhbCBmb3IgbW9kZWxzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNHcm91cHNLZXlzID0gT2JqZWN0LmtleXMob3B0aW9uc0dyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3B0aW9uc0dyb3Vwc0tleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChteU9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteU9wdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteU9wdGlvbnMucHVzaChvcHRpb25zR3JvdXBzS2V5c1trXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlPcHRpb25zID0gbXlPcHRpb25zLmNvbmNhdChvcHRpb25zR3JvdXBzW29wdGlvbnNHcm91cHNLZXlzW2tdXSk7IC8vIHRoZSBwcmltYXJ5IGdyb3VwIGRvZXMgbm90IGdldCBzb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlPcHRpb25zLnB1c2gob3B0aW9uc0dyb3Vwc0tleXNba10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15T3B0aW9ucyA9IG15T3B0aW9ucy5jb25jYXQob3B0aW9uc0dyb3Vwc1tvcHRpb25zR3JvdXBzS2V5c1trXV0uc29ydCgpKTsgLy8gbm9uIHByaW1hcnkgIGdyb3VwcyBnZXQgc29ydGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBteU9wdGlvbnMgPSBwYXJhbS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHRpb25zQXNTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG15T3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG15T3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpcnN0R3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBteU9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZEluZGV4ID0gZGlzYWJsZWRPcHRpb25zID09PSB1bmRlZmluZWQgPyAtMSA6IGRpc2FibGVkT3B0aW9ucy5pbmRleE9mKG15T3B0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGRJbmRleCA+PSAwKSB7ICAgLy8gdGhlIG9wdGlvbiB3YXMgZm91bmQgaW4gdGhlIGRpc2FibGVkIG9wdGlvbnMgc28gaXQgbmVlZHMgdG8gYmUgYW4gb3B0Z3JvdXAgbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEdyb3VwID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBpbiBncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0FzU3RyaW5nICs9IFwiPG9wdGdyb3VwIGxhYmVsPVwiICsgbXlPcHRpb25zW2ldICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEdyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXNTdHJpbmcgKz0gXCI8L29wdGdyb3VwPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0FzU3RyaW5nICs9IFwiPG9wdGdyb3VwIGxhYmVsPVwiICsgbXlPcHRpb25zW2ldICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3JlZ3VsYXIgb3B0aW9uIC0gdGhlIG9wdGlvbiB3YXMgbm90IGZvdW5kIGluIHRoZSBkaXNhYmxlZCBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNBc1N0cmluZyArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgbXlPcHRpb25zW2ldICsgXCInPlwiICsgbXlPcHRpb25zW2ldICsgXCI8L29wdGlvbj5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWRPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zQXNTdHJpbmcgKz0gXCI8L29wdGdyb3VwPlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCgnc2VsZWN0W25hbWU9XCInICsgbmFtZSArICdcIl0nKS5lbXB0eSgpLmFwcGVuZChvcHRpb25zQXNTdHJpbmcpO1xuICAgICAgICAgICAgLy9yZXNldCB0aGUgc2VsZWN0ZWQgaW5kZXggaWYgaXQgaGFkIGJlZW4gc2V0IHByaW9yICh0aGUgbGlzdCBtYXkgaGF2ZSBjaGFuZ2VkIHNvIHRoZSBpbmRleCBtYXkgaGF2ZSBjaGFuZ2VkKVxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkT3B0aW9uSW5kZXg7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRUZXh0ID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE9wdGlvbkluZGV4ID0gbXlPcHRpb25zLmluZGV4T2YocGFyYW0uZGVmYXVsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkT3B0aW9uSW5kZXggPSBteU9wdGlvbnMuaW5kZXhPZihzZWxlY3RlZFRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN2aVRleHQgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkT3B0aW9uSW5kZXggPT0gLTEgJiYgZWxlbS5zZWxlY3RlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzdmkgPSAwOyBzdmkgPCBzZWxlY3RlZFN1cGVyaW9yVmFsdWVzLmxlbmd0aDsgc3ZpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJpb3IgPSBzdXBlcmlvcnNbc3ZpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdHNQYXJhbVV0aWxzLmdldENvbnRyb2xFbGVtZW50Rm9yUGFyYW1OYW1lKHN1cGVyaW9yLmVsZW1lbnQubmFtZSkub2Zmc2V0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ZpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2aVRleHQgKz0gXCIgYW5kIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ZpVGV4dCArPSBzZWxlY3RlZFN1cGVyaW9yVmFsdWVzW3N2aV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRJbmZvKFwiSSBjaGFuZ2VkIHlvdXIgc2VsZWN0ZWQgXCIgKyBuYW1lICsgXCI6ICdcIiArIHNlbGVjdGVkVGV4dCArIFwiJyB0byAnXCIgKyBteU9wdGlvbnNbMF0gKyBcIicgYmVjYXVzZSAnXCIgKyBzZWxlY3RlZFRleHQgKyBcIicgaXMgbm8gbG9uZ2VyIGFuIG9wdGlvbiBmb3IgXCIgKyBzdmlUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSBzZWxlY3RlZFRleHQgZXhpc3RlZCBpbiB0aGUgbmV3IG9wdGlvbnMgbGlzdCB0aGVuIHRoZSBzZWxlY3RlZE9wdGlvbkluZGV4IHdvbid0IGJlIC0xIGFuZCB3ZSBoYXZlIHRvIGNob29zZSB0aGUgZGVmYXVsdCBvcHRpb25cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE9wdGlvbkluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJhbSBkZWZhdWx0IGlzIHVudXNlZCBzZXQgaXQgdG8gdW51c2VkXG4gICAgICAgICAgICAgICAgLy8gZWxzZSBqdXN0IGNob29zZSB0aGUgMHRoIGVsZW1lbnQgaW4gdGhlIGVsZW1lbnQgb3B0aW9ucy4gZGVmYXVsdD9cbiAgICAgICAgICAgICAgICBpZiAocGFyYW0uZGVmYXVsdCA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMudW51c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHNQYXJhbVV0aWxzLnNldFZhbHVlVGV4dEZvclBhcmFtTmFtZShuYW1lLCBtYXRzVHlwZXMuSW5wdXRUeXBlcy51bnVzZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gJiYgZWxlbS5vcHRpb25zICYmIGVsZW0uc2VsZWN0ZWRJbmRleCA+PSAwICYmIGVsZW0ub3B0aW9uc1tlbGVtLnNlbGVjdGVkSW5kZXhdLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gJiYgZWxlbS5vcHRpb25zICYmIGVsZW0uc2VsZWN0ZWRJbmRleCA+PSAwICYmIG1hdHNQYXJhbVV0aWxzLnNldFZhbHVlVGV4dEZvclBhcmFtTmFtZShuYW1lLCBlbGVtLm9wdGlvbnNbZWxlbS5zZWxlY3RlZEluZGV4XS50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IHNlbGVjdGVkT3B0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgZWxlbSAmJiBlbGVtLm9wdGlvbnMgJiYgZWxlbS5zZWxlY3RlZEluZGV4ID49IDAgJiYgZWxlbS5vcHRpb25zW2VsZW0uc2VsZWN0ZWRJbmRleF0uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICBlbGVtICYmIGVsZW0ub3B0aW9ucyAmJiBlbGVtLnNlbGVjdGVkSW5kZXggPj0gMCAmJiBtYXRzUGFyYW1VdGlscy5zZXRWYWx1ZVRleHRGb3JQYXJhbU5hbWUobmFtZSwgZWxlbS5vcHRpb25zW2VsZW0uc2VsZWN0ZWRJbmRleF0udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyb3RoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmVsZW0gPSBicm90aGVyc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWxlbVNlbGVjdGVkT3B0aW9ucyA9ICQoYmVsZW0uc2VsZWN0ZWRPcHRpb25zKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUpXG4gICAgICAgICAgICAgICAgfSkuZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGJlbGVtU2VsZWN0ZWRPcHRpb25zID09PSB1bmRlZmluZWQgfHwgYmVsZW1TZWxlY3RlZE9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlbGVtLm9wdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaTEgPSAwOyBpMSA8IG15T3B0aW9ucy5sZW5ndGg7IGkxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlbGVtLm9wdGlvbnNbYmVsZW0ub3B0aW9ucy5sZW5ndGhdID0gbmV3IE9wdGlvbihteU9wdGlvbnNbaTFdLCBteU9wdGlvbnNbaTFdLCBpMSA9PSAwLCBpMSA9PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZS5tZXNzYWdlID0gXCJJTkZPOiBFcnJvciBpbiBzZWxlY3QuanMgcmVmcmVzaDogcmVzZXR0aW5nIHNlbGVjdGVkIG9wdGlvbnM6IFwiICsgZS5tZXNzYWdlO1xuICAgICAgICAgICAgc2V0SW5mbyhlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZnJlc2hQZWVyKGV2ZW50LCBwYXJhbSk7XG59OyAgLy8gcmVmcmVzaCBmdW5jdGlvblxuXG5leHBvcnQgZGVmYXVsdCBtYXRzU2VsZWN0VXRpbHMgPSB7XG4gICAgcmVmcmVzaDogcmVmcmVzaCxcbiAgICByZWZyZXNoUGVlcjogcmVmcmVzaFBlZXIsXG4gICAgcmVmcmVzaERlcGVuZGVudHM6IHJlZnJlc2hEZXBlbmRlbnRzLFxuICAgIGNoZWNrRGlzYWJsZU90aGVyOiBjaGVja0Rpc2FibGVPdGhlcixcbiAgICBjaGVja0hpZGVPdGhlcjogY2hlY2tIaWRlT3RoZXJcbn07XG5cbiAgICAgICAgICAgICIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgQ29sb3JhZG8gU3RhdGUgVW5pdmVyc2l0eSBhbmQgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZWQgYnkgcGllcmNlIG9uIDgvMzEvMTYuXG4gKi9cbmltcG9ydCAnLi9jdXJ2ZV91dGlsLmpzJztcbmltcG9ydCAnLi9ncmFwaF91dGlsLmpzJztcbmltcG9ydCAnLi9zZWxlY3RfdXRpbC5qcyc7XG5pbXBvcnQgJy4vaW5pdC5qcyc7XG5pbXBvcnQgJy4uL2JvdGgnO1xuaW1wb3J0ICcuL3JvdXRlcy5qcyc7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IENvbG9yYWRvIFN0YXRlIFVuaXZlcnNpdHkgYW5kIFJlZ2VudHMgb2YgdGhlIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHsgTWV0ZW9yIH0gZnJvbSAnbWV0ZW9yL21ldGVvcic7XG5pbXBvcnQgbWF0c0NvbGxlY3Rpb25zIGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaWYgKE1ldGVvci5pc0NsaWVudCkge1xuICAgIE1ldGVvci5zdWJzY3JpYmUoXCJDdXJ2ZVBhcmFtc1wiKTtcbiAgICBNZXRlb3Iuc3Vic2NyaWJlKFwiU2NhdHRlcjJkUGFyYW1zXCIpO1xuICAgIE1ldGVvci5zdWJzY3JpYmUoXCJTYXZlZEN1cnZlUGFyYW1zXCIpO1xuICAgIE1ldGVvci5zdWJzY3JpYmUoXCJQbG90UGFyYW1zXCIpO1xuICAgIE1ldGVvci5zdWJzY3JpYmUoXCJQbG90R3JhcGhGdW5jdGlvbnNcIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcIlJlZ2lvbnNQZXJNb2RlbFwiKTtcbiAgICBNZXRlb3Iuc3Vic2NyaWJlKFwiU2l0ZXNQZXJNb2RlbFwiKTtcbiAgICBNZXRlb3Iuc3Vic2NyaWJlKFwiUmVnaW9uRGVzY3JpcHRpb25zXCIpO1xuICAgIE1ldGVvci5zdWJzY3JpYmUoXCJNb2RlbHNcIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcIkZjc3RMZW5zUGVyTW9kZWxcIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcIkNvbG9yU2NoZW1lXCIpO1xuICAgIE1ldGVvci5zdWJzY3JpYmUoXCJTZXR0aW5nc1wiKTtcbiAgICBNZXRlb3Iuc3Vic2NyaWJlKFwiQ3VydmVTZXR0aW5nc1wiKTtcbiAgICBNZXRlb3Iuc3Vic2NyaWJlKFwiU2VudEFkZHJlc3Nlc1wiKTtcbiAgICBNZXRlb3Iuc3Vic2NyaWJlKFwiUm9sZXNcIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcIkF1dGhvcml6YXRpb25cIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcIkNyZWRlbnRpYWxzXCIpO1xuICAgIE1ldGVvci5zdWJzY3JpYmUoXCJEYXRhYmFzZXNcIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcIkN1cnZlVGV4dFBhdHRlcm5zXCIpO1xuICAgIE1ldGVvci5zdWJzY3JpYmUoXCJTY2F0dGVyQXhpc1RleHRQYXR0ZXJuXCIpO1xuICAgIE1ldGVvci5zdWJzY3JpYmUoXCJSYW5nZVBlckRlc2NyaXB0b3JcIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcIlNpdGVNYXBcIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcIlN0YXRpb25NYXBcIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcImFwcE5hbWVcIik7XG4gICAgTWV0ZW9yLnN1YnNjcmliZShcIkxheW91dFN0b3JlQ29sbGVjdGlvblwiKTtcbiAgICBTZXNzaW9uLnNldCgnQ3VydmVzJywgW10pO1xuICAgIFNlc3Npb24uc2V0KCdQbG90UGFyYW1zJywgW10pO1xuXG4gICAgQWNjb3VudHMudWkuY29uZmlnKHtcbiAgICAgICAgcmVxdWVzdE9mZmxpbmVUb2tlbjoge1xuICAgICAgICAgICAgZ29vZ2xlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHJlZiA9IGxvY2F0aW9uLmhyZWY7XG4gICAgY29uc3QgcGF0aEFycmF5ID0gbG9jYXRpb24uaHJlZi5zcGxpdCgnLycpO1xuICAgIGNvbnN0IHByb3RvY29sID0gcGF0aEFycmF5WzBdO1xuICAgIGNvbnN0IGhvc3Rwb3J0ID0gcGF0aEFycmF5WzJdO1xuICAgIGNvbnN0IGhvc3ROYW1lID0gaG9zdHBvcnQuc3BsaXQoJzonKVswXTtcbiAgICBjb25zdCBhcHAgPSBwYXRoQXJyYXlbM10gPT0gXCJcIiA/IFwiL1wiIDogcGF0aEFycmF5WzNdO1xuICAgIGNvbnN0IG1hdHNSZWYgPSBwcm90b2NvbCArIFwiLy9cIiArIGhvc3Rwb3J0O1xuICAgIGNvbnN0IGhlbHBSZWYgPSByZWYuZW5kc1dpdGgoJy8nKSA/IHJlZiArIFwiaGVscFwiIDogcmVmICsgXCIvaGVscFwiO1xuICAgIFNlc3Npb24uc2V0KFwiYXBwXCIsIHthcHBOYW1lOiBhcHAsIG1hdHNyZWY6IG1hdHNSZWYsIGFwcHJlZjogcmVmLCBoZWxwcmVmOiBoZWxwUmVmLCBob3N0TmFtZTogaG9zdE5hbWV9KTtcbiAgICB2YXIgY29sbGVjdGlvbnMgPSBPYmplY3Qua2V5cyhtYXRzQ29sbGVjdGlvbnMpLm1hcChrZXkgPT4gbWF0c0NvbGxlY3Rpb25zW2tleV0pO1xuICAgIFNlc3Npb24uc2V0KFwiTW9uZ29sXCIsIHtcbiAgICAgICAgJ2NvbGxlY3Rpb25zJzogY29sbGVjdGlvbnMsXG4gICAgICAgICdkaXNwbGF5JzogZmFsc2UsXG4gICAgICAgICdvcGFjaXR5X25vcm1hbCc6IFwiLjdcIixcbiAgICAgICAgJ29wYWNpdHlfZXhwYW5kJzogXCIuOVwiLFxuICAgICAgICAnZGlzYWJsZV93YXJuaW5nJzogdHJ1ZVxuICAgIH0pO1xufSIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgQ29sb3JhZG8gU3RhdGUgVW5pdmVyc2l0eSBhbmQgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5pbXBvcnQgeyBNZXRlb3IgfSBmcm9tICdtZXRlb3IvbWV0ZW9yJztcbmltcG9ydCB7IEZsb3dSb3V0ZXIgfSBmcm9tICdtZXRlb3Ivb3N0cmlvOmZsb3ctcm91dGVyLWV4dHJhJztcblxuLy9sb2NhbGhvc3Qgcm91dGVzXG5cbkZsb3dSb3V0ZXIucm91dGUoJy8nLCB7XG4gICAgbmFtZTogJ21haW4nLFxuICAgIGFjdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoJ0hvbWUnKVxuICAgIH1cbn0pO1xuXG5GbG93Um91dGVyLnJvdXRlKCcvQ1NWLzpncmFwaEZ1bmN0aW9uLzprZXkvOm1hdGNoaW5nLzphcHBOYW1lJywge1xuICAgIG5hbWU6ICdjc3YnLFxuICAgIGFjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJpbiBjc3Ygcm91dGVcIik7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmPUZsb3dSb3V0ZXIucGF0aDtcbiAgICB9XG59KTtcblxuRmxvd1JvdXRlci5yb3V0ZSgnL0pTT04vOmdyYXBoRnVuY3Rpb24vOmtleS86bWF0Y2hpbmcvOmFwcE5hbWUnLCB7XG4gICAgbmFtZTogJ2pzb24nLFxuICAgIGFjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJpbiBqc29uIHJvdXRlXCIpO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZj1GbG93Um91dGVyLnBhdGg7XG4gICAgfVxufSk7XG5cblxuRmxvd1JvdXRlci5yb3V0ZSgnL3ByZXZpZXcvOmdyYXBoRnVuY3Rpb24vOmtleS86bWF0Y2hpbmcvOmFwcE5hbWUnLCB7XG4gICAgbmFtZTogJ3ByZXZpZXcnLFxuICAgIGFjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJpbiBwcmV2aWV3IHJvdXRlLSBzZXR0aW5nIHBhcmFtc1wiLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLnJlbmRlcignR3JhcGhTdGFuZEFsb25lJywgcGFyYW1zKTtcbiAgICB9XG59KTtcblxuLy9wcmVmaXggcm91dGVzXG5GbG93Um91dGVyLnJvdXRlKE1ldGVvci5zZXR0aW5ncy5wdWJsaWMucHJveHlfcHJlZml4X3BhdGggKyAnLycsIHtcbiAgICBuYW1lOiAnbWFpbicsXG4gICAgYWN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcignSG9tZScpXG4gICAgfVxufSk7XG5cbkZsb3dSb3V0ZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvQ1NWLzpncmFwaEZ1bmN0aW9uLzprZXkvOm1hdGNoaW5nLzphcHBOYW1lJywge1xuICAgIG5hbWU6ICdjc3YnLFxuICAgIGFjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJpbiBjc3Ygcm91dGVcIik7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmPUZsb3dSb3V0ZXIucGF0aDtcbiAgICB9XG59KTtcblxuRmxvd1JvdXRlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy9KU09OLzpncmFwaEZ1bmN0aW9uLzprZXkvOm1hdGNoaW5nLzphcHBOYW1lJywge1xuICAgIG5hbWU6ICdqc29uJyxcbiAgICBhY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW4ganNvbiByb3V0ZVwiKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWY9Rmxvd1JvdXRlci5wYXRoO1xuICAgIH1cbn0pO1xuXG5cbkZsb3dSb3V0ZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvcHJldmlldy86Z3JhcGhGdW5jdGlvbi86a2V5LzptYXRjaGluZy86YXBwTmFtZScsIHtcbiAgICBuYW1lOiAncHJldmlldycsXG4gICAgYWN0aW9uKHBhcmFtcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImluIHByZXZpZXcgcm91dGUtIHNldHRpbmcgcGFyYW1zXCIsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMucmVuZGVyKCdHcmFwaFN0YW5kQWxvbmUnLCBwYXJhbXMpO1xuICAgIH1cbn0pO1xuXG5cbi8vIGFwcG5hbWUgcm91dGVzXG5GbG93Um91dGVyLnJvdXRlKE1ldGVvci5zZXR0aW5ncy5wdWJsaWMucHJveHlfcHJlZml4X3BhdGggKyAnLzphcHBOYW1lJywge1xuICAgIG5hbWU6ICdtYWluJyxcbiAgICBhY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCdIb21lJylcbiAgICB9XG59KTtcblxuRmxvd1JvdXRlci5yb3V0ZShNZXRlb3Iuc2V0dGluZ3MucHVibGljLnByb3h5X3ByZWZpeF9wYXRoICsgJy8qL0NTVi86Z3JhcGhGdW5jdGlvbi86a2V5LzptYXRjaGluZy86YXBwTmFtZScsIHtcbiAgICBuYW1lOiAnY3N2JyxcbiAgICBhY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW4gY3N2IHJvdXRlXCIpO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZj1GbG93Um91dGVyLnBhdGg7XG4gICAgfVxufSk7XG5cbkZsb3dSb3V0ZXIucm91dGUoTWV0ZW9yLnNldHRpbmdzLnB1YmxpYy5wcm94eV9wcmVmaXhfcGF0aCArICcvKi9KU09OLzpncmFwaEZ1bmN0aW9uLzprZXkvOm1hdGNoaW5nLzphcHBOYW1lJywge1xuICAgIG5hbWU6ICdqc29uJyxcbiAgICBhY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW4ganNvbiByb3V0ZVwiKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWY9Rmxvd1JvdXRlci5wYXRoO1xuICAgIH1cbn0pO1xuXG5GbG93Um91dGVyLnJvdXRlKE1ldGVvci5zZXR0aW5ncy5wdWJsaWMucHJveHlfcHJlZml4X3BhdGggKyAnLyovcHJldmlldy86Z3JhcGhGdW5jdGlvbi86a2V5LzptYXRjaGluZy86YXBwTmFtZScsIHtcbiAgICBuYW1lOiAncHJldmlldycsXG4gICAgYWN0aW9uKHBhcmFtcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImluIHByZXZpZXcgcm91dGUtIHNldHRpbmcgcGFyYW1zXCIsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMucmVuZGVyKCdHcmFwaFN0YW5kQWxvbmUnLCBwYXJhbXMpO1xuICAgIH1cbn0pO1xuXG4vLyBleGNlcHRpb24gcm91dGVzXG5GbG93Um91dGVyLnJvdXRlKE1ldGVvci5zZXR0aW5ncy5wdWJsaWMucHJveHlfcHJlZml4X3BhdGggKyAnLyovJywge1xuICAgIG5hbWU6ICdtYWluJyxcbiAgICBhY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCdub3RGb3VuZCcpXG4gICAgfVxufSk7XG5cbkZsb3dSb3V0ZXIucm91dGUoJyonLCB7XG4gICAgYWN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZyAoJ3JvdXRlOiAnICsgJyBub3QgZm91bmQnICk7XG4gICAgICAgIHRoaXMucmVuZGVyKCdub3RGb3VuZCcpO1xuICAgIH1cbn0pO1xuXG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IENvbG9yYWRvIFN0YXRlIFVuaXZlcnNpdHkgYW5kIFJlZ2VudHMgb2YgdGhlIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHttYXRzVHlwZXN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaW1wb3J0IHttYXRzQ29sbGVjdGlvbnN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaW1wb3J0IHttYXRzUGxvdFV0aWxzfSBmcm9tICdtZXRlb3IvcmFuZHlwOm1hdHMtY29tbW9uJztcblxuLy90aGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0d28gSlNPTiBvYmplY3RzIGFyZSBpZGVudGljYWxcbmNvbnN0IGFyZU9iamVjdHNFcXVhbCA9IGZ1bmN0aW9uIChvLCBwKSB7XG4gICAgaWYgKChvICYmICFwKSB8fCAocCAmJiAhbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkobykgPT09IEpTT04uc3RyaW5naWZ5KHApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vL3RoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHZhbHVlcyBvZiBzdWJBcnJheSBhcmUgYWxzbyBpbiBzdXBlckFycmF5XG5jb25zdCBhcnJheUNvbnRhaW5zQXJyYXkgPSBmdW5jdGlvbiAoc3VwZXJBcnJheSwgc3ViQXJyYXkpIHtcbiAgICBzdXBlckFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcbiAgICB9KTtcbiAgICBzdWJBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoYSkgLSBOdW1iZXIoYik7XG4gICAgfSk7XG4gICAgdmFyIGksIGo7XG4gICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBzdXBlckFycmF5Lmxlbmd0aCAmJiBqIDwgc3ViQXJyYXkubGVuZ3RoOykge1xuICAgICAgICBpZiAoc3VwZXJBcnJheVtpXSA8IHN1YkFycmF5W2pdKSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwZXJBcnJheVtpXSA9PT0gc3ViQXJyYXlbal0pIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN1YkFycmF5W2pdIG5vdCBpbiBzdXBlckFycmF5LCBzbyBzdXBlckFycmF5IGRvZXMgbm90IGNvbnRhaW4gYWxsIGVsZW1lbnRzIG9mIHN1YkFycmF5XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoZXJlIGFyZSBubyBlbGVtZW50cyBsZWZ0IGluIHN1YlxuICAgIHJldHVybiBqID09PSBzdWJBcnJheS5sZW5ndGg7XG59O1xuXG4vL3RoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBlbnRpcmUgYXJyYXkgc3ViQXJyYXkgaXMgY29udGFpbmVkIGluIHN1cGVyQXJyYXlcbmNvbnN0IGFycmF5Q29udGFpbnNTdWJBcnJheSA9IGZ1bmN0aW9uIChzdXBlckFycmF5LCBzdWJBcnJheSkge1xuICAgIHZhciBpLCBqLCBjdXJyZW50O1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdXBlckFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzdWJBcnJheS5sZW5ndGggPT09IHN1cGVyQXJyYXlbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gc3VwZXJBcnJheVtpXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzdWJBcnJheS5sZW5ndGggJiYgc3ViQXJyYXlbal0gPT09IGN1cnJlbnRbal07ICsraikgO1xuICAgICAgICAgICAgaWYgKGogPT09IHN1YkFycmF5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vL3RoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHR3byBhcnJheXMgYXJlIGlkZW50aWNhbFxuY29uc3QgYXJyYXlzRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBhcnJheVVuaXF1ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoIWFyci5pbmNsdWRlcyhhW2ldKSkge1xuICAgICAgICAgICAgYXJyLnB1c2goYVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5cbi8vdGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgcG9zaXRpb24gb2YgdGhlIGFycmF5IHN1YkFycmF5IGluIHN1cGVyQXJyYXlcbmNvbnN0IGZpbmRBcnJheUluU3ViQXJyYXkgPSBmdW5jdGlvbiAoc3VwZXJBcnJheSwgc3ViQXJyYXkpIHtcbiAgICB2YXIgaSwgaiwgY3VycmVudDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3VwZXJBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc3ViQXJyYXkubGVuZ3RoID09PSBzdXBlckFycmF5W2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudCA9IHN1cGVyQXJyYXlbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3ViQXJyYXkubGVuZ3RoICYmIHN1YkFycmF5W2pdID09PSBjdXJyZW50W2pdOyArK2opIDtcbiAgICAgICAgICAgIGlmIChqID09PSBzdWJBcnJheS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuLy90aGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiBhbiBvYmplY3QgaXMgYSB2YWx1ZSBpbiBhbm90aGVyIG9iamVjdFxuY29uc3Qgb2JqZWN0Q29udGFpbnNPYmplY3QgPSBmdW5jdGlvbiAoc3VwZXJPYmplY3QsIHN1Yk9iamVjdCkge1xuICAgIGNvbnN0IHN1cGVyT2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzKHN1cGVyT2JqZWN0KTtcbiAgICB2YXIgY3VycmVudE9iamVjdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cGVyT2JqZWN0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50T2JqZWN0ID0gc3VwZXJPYmplY3Rbc3VwZXJPYmplY3RLZXlzW2ldXTtcbiAgICAgICAgaWYgKGFyZU9iamVjdHNFcXVhbChzdWJPYmplY3QsY3VycmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHRoZSBsb29wIGNvbXBsZXRlcywgdGhlIHN1Yk9iamVjdCB3YXMgbm90IGZvdW5kXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy91dGlsaXR5IGZvciBjYWxjdWxhdGluZyB0aGUgYXZlcmFnZSBvZiBhbiBhcnJheVxuY29uc3QgYXZlcmFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHN1bSA9IGRhdGEucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gc3VtIDogc3VtICsgdmFsdWU7XG4gICAgfSwgMCk7XG4gICAgdmFyIGF2ZyA9IHN1bSAvIGRhdGEubGVuZ3RoO1xuICAgIHJldHVybiBhdmc7XG59O1xuXG4vL3V0aWxpdHkgZm9yIGNhbGN1bGF0aW5nIHRoZSBzdGRldiBvZiBhbiBhcnJheVxuY29uc3Qgc3RkZXYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBhdmcgPSBhdmVyYWdlKGRhdGEpO1xuICAgIHZhciBzcXVhcmVEaWZmcyA9IGRhdGEubWFwKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgdmFyIGRpZmYgPSB2YWx1ZSAtIGF2ZztcbiAgICAgICAgcmV0dXJuIGRpZmYgKiBkaWZmO1xuICAgIH0pO1xuICAgIHZhciBhdmdTcXVhcmVEaWZmID0gYXZlcmFnZShzcXVhcmVEaWZmcyk7XG4gICAgdmFyIHN0ZERldiA9IE1hdGguc3FydChhdmdTcXVhcmVEaWZmKTtcbiAgICByZXR1cm4gc3RkRGV2O1xufTtcblxuLy90aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgZGF0ZSBzdHJpbmdzIGFyZSBpbiB0aGUgY29ycmVjdCBmb3JtYXRcbmNvbnN0IGRhdGVDb252ZXJ0ID0gZnVuY3Rpb24gKGRTdHIpIHtcbiAgICBpZiAoZFN0ciA9PT0gdW5kZWZpbmVkIHx8IGRTdHIgPT09IFwiIFwiKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKG5vdy5nZXRVVENGdWxsWWVhcigpLCBub3cuZ2V0VVRDTW9udGgoKSwgbm93LmdldFVUQ0RhdGUoKSwgbm93LmdldFVUQ0hvdXJzKCksIG5vdy5nZXRVVENNaW51dGVzKCksIG5vdy5nZXRVVENTZWNvbmRzKCkpO1xuICAgICAgICB2YXIgeXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgIHZhciBkYXkgPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICB2YXIgaG91ciA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgdmFyIG1pbnV0ZSA9IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICByZXR1cm4gbW9udGggKyBcIi9cIiArIGRheSArICcvJyArIHlyICsgJyAnICsgaG91ciArIFwiOlwiICsgbWludXRlO1xuICAgIH1cbiAgICB2YXIgZGF0ZVBhcnRzID0gZFN0ci5zcGxpdCgnICcpO1xuICAgIHZhciBkYXRlQXJyYXkgPSBkYXRlUGFydHNbMF0uc3BsaXQoL1tcXC1cXC9dLyk7ICAvLyBzcGxpdCBvbiAtIG9yIC8gICAgMDEtMDEtMjAxNyBPUiAwMS8wMS8yMDE3XG4gICAgdmFyIG1vbnRoID0gZGF0ZUFycmF5WzBdO1xuICAgIHZhciBkYXkgPSBkYXRlQXJyYXlbMV07XG4gICAgdmFyIHlyID0gZGF0ZUFycmF5WzJdO1xuICAgIHZhciBob3VyID0gMDtcbiAgICB2YXIgbWludXRlID0gMDtcbiAgICBpZiAoZGF0ZVBhcnRzWzFdKSB7XG4gICAgICAgIHZhciB0aW1lQXJyYXkgPSBkYXRlUGFydHNbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICBob3VyID0gdGltZUFycmF5WzBdO1xuICAgICAgICBtaW51dGUgPSB0aW1lQXJyYXlbMV07XG4gICAgfVxuICAgIHJldHVybiBtb250aCArIFwiL1wiICsgZGF5ICsgJy8nICsgeXIgKyAnICcgKyBob3VyICsgXCI6XCIgKyBtaW51dGU7XG59O1xuXG4vL3NwbGl0cyB0aGUgZGF0ZSByYW5nZSBzdHJpbmcgZnJvbSB0aGUgZGF0ZSBzZWxlY3RvciBpbnRvIHN0YW5kYXJkaXplZCBmcm9tRGF0ZS90b0RhdGUgc3RyaW5ncyxcbi8vIHBsdXMgdGhlIGVwb2NocyBmb3IgdGhlIGZyb21EYXRlIGFuZCB0b0RhdGVcbmNvbnN0IGdldERhdGVSYW5nZSA9IGZ1bmN0aW9uIChkYXRlUmFuZ2UpIHtcbiAgICB2YXIgZGF0ZXMgPSBkYXRlUmFuZ2Uuc3BsaXQoJyAtICcpO1xuICAgIHZhciBmcm9tRGF0ZVN0ciA9IGRhdGVzWzBdO1xuICAgIHZhciBmcm9tRGF0ZSA9IGRhdGVDb252ZXJ0KGZyb21EYXRlU3RyKTtcbiAgICB2YXIgdG9EYXRlU3RyID0gZGF0ZXNbMV07XG4gICAgdmFyIHRvRGF0ZSA9IGRhdGVDb252ZXJ0KHRvRGF0ZVN0cik7XG4gICAgdmFyIGZyb21TZWNzID0gc2Vjc0NvbnZlcnQoZnJvbURhdGVTdHIpO1xuICAgIHZhciB0b1NlY3MgPSBzZWNzQ29udmVydCh0b0RhdGVTdHIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21EYXRlOiBmcm9tRGF0ZSxcbiAgICAgICAgdG9EYXRlOiB0b0RhdGUsXG4gICAgICAgIGZyb21TZWNvbmRzOiBmcm9tU2VjcyxcbiAgICAgICAgdG9TZWNvbmRzOiB0b1NlY3NcbiAgICB9XG59O1xuXG4vL3RoaXMgZnVuY3Rpb24gY29udmVydHMgYSBkYXRlIHN0cmluZyBpbnRvIGFuIGVwb2NoXG5jb25zdCBzZWNzQ29udmVydCA9IGZ1bmN0aW9uIChkU3RyKSB7XG4gICAgaWYgKGRTdHIgPT09IHVuZGVmaW5lZCB8fCBkU3RyID09PSBcIiBcIikge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIG5vdy5nZXRUaW1lKCkgLyAxMDAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGRhdGVQYXJ0cyA9IGRTdHIuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIGRhdGVBcnJheSA9IGRhdGVQYXJ0c1swXS5zcGxpdCgvW1xcLVxcL10vKTsgIC8vIHNwbGl0IG9uIC0gb3IgLyAgICAwMS0wMS0yMDE3IE9SIDAxLzAxLzIwMTdcbiAgICAgICAgdmFyIG1vbnRoID0gZGF0ZUFycmF5WzBdO1xuICAgICAgICB2YXIgZGF5ID0gZGF0ZUFycmF5WzFdO1xuICAgICAgICB2YXIgeXIgPSBkYXRlQXJyYXlbMl07XG4gICAgICAgIHZhciBob3VyID0gMDtcbiAgICAgICAgdmFyIG1pbnV0ZSA9IDA7XG4gICAgICAgIGlmIChkYXRlUGFydHNbMV0pIHtcbiAgICAgICAgICAgIHZhciB0aW1lQXJyYXkgPSBkYXRlUGFydHNbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgaG91ciA9IHRpbWVBcnJheVswXTtcbiAgICAgICAgICAgIG1pbnV0ZSA9IHRpbWVBcnJheVsxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXlfZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHlyLCBtb250aCAtIDEsIGRheSwgaG91ciwgbWludXRlLCAwKSk7XG4gICAgICAgIC8vIHRvIFVUQyB0aW1lLCBub3QgbG9jYWwgdGltZVxuICAgICAgICB2YXIgZGF0ZV9pbl9zZWNzID0gbXlfZGF0ZS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIC8vIHRvIFVUQyB0aW1lLCBub3QgbG9jYWwgdGltZVxuICAgIC8vcmV0dXJuIGRhdGVfaW5fc2Vjcy8xMDAwIC0zNjAwKjY7XG4gICAgcmV0dXJuIGRhdGVfaW5fc2VjcyAvIDEwMDA7XG59O1xuXG4vL2Z1bmN0aW9uIHRvIG1hbmFnZSBhdXRob3JpemVkIGxvZ2lucyBmb3IgTUFUU1xuY29uc3QgZG9BdXRob3JpemF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuZmluZE9uZSh7fSkgPT09IHVuZGVmaW5lZCB8fCBtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuZmluZE9uZSh7fSkucmVzZXRGcm9tQ29kZSA9PT0gdW5kZWZpbmVkIHx8IG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy5maW5kT25lKHt9KS5yZXNldEZyb21Db2RlID09IHRydWUpIHtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24ucmVtb3ZlKHt9KTtcbiAgICB9XG4gICAgaWYgKG1hdHNDb2xsZWN0aW9ucy5BdXRob3JpemF0aW9uLmZpbmQoKS5jb3VudCgpID09IDApIHtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24uaW5zZXJ0KHtlbWFpbDogXCJyYW5keS5waWVyY2VAbm9hYS5nb3ZcIiwgcm9sZXM6IFtcImFkbWluaXN0cmF0b3JcIl19KTtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24uaW5zZXJ0KHtlbWFpbDogXCJraXJrLmwuaG9sdWJAbm9hYS5nb3ZcIiwgcm9sZXM6IFtcImFkbWluaXN0cmF0b3JcIl19KTtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24uaW5zZXJ0KHtlbWFpbDogXCJqZWZmcmV5LmEuaGFtaWx0b25Abm9hYS5nb3ZcIiwgcm9sZXM6IFtcImFkbWluaXN0cmF0b3JcIl19KTtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24uaW5zZXJ0KHtlbWFpbDogXCJib25ueS5zdHJvbmdAbm9hYS5nb3ZcIiwgcm9sZXM6IFtcImFkbWluaXN0cmF0b3JcIl19KTtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24uaW5zZXJ0KHtlbWFpbDogXCJtb2xseS5iLnNtaXRoQG5vYWEuZ292XCIsIHJvbGVzOiBbXCJhZG1pbmlzdHJhdG9yXCJdfSk7XG4gICAgICAgIG1hdHNDb2xsZWN0aW9ucy5BdXRob3JpemF0aW9uLmluc2VydCh7ZW1haWw6IFwibWF0cy5nc2RAbm9hYS5nb3ZcIiwgcm9sZXM6IFtcImFkbWluaXN0cmF0b3JcIl19KTtcbiAgICB9XG59O1xuXG4vL21hc3RlciBsaXN0IG9mIGNvbG9ycyBmb3IgTUFUUyBjdXJ2ZXNcbmNvbnN0IGRvQ29sb3JTY2hlbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy5maW5kT25lKHt9KSA9PT0gdW5kZWZpbmVkIHx8IG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy5maW5kT25lKHt9KS5yZXNldEZyb21Db2RlID09PSB1bmRlZmluZWQgfHwgbWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzLmZpbmRPbmUoe30pLnJlc2V0RnJvbUNvZGUgPT0gdHJ1ZSkge1xuICAgICAgICBtYXRzQ29sbGVjdGlvbnMuQ29sb3JTY2hlbWUucmVtb3ZlKHt9KTtcbiAgICB9XG4gICAgaWYgKG1hdHNDb2xsZWN0aW9ucy5Db2xvclNjaGVtZS5maW5kKCkuY291bnQoKSA9PSAwKSB7XG4gICAgICAgIG1hdHNDb2xsZWN0aW9ucy5Db2xvclNjaGVtZS5pbnNlcnQoe1xuICAgICAgICAgICAgY29sb3JzOiBbXG4gICAgICAgICAgICAgICAgXCJyZ2IoMjU1LDAsMClcIixcbiAgICAgICAgICAgICAgICBcInJnYigwLDAsMjU1KVwiLFxuICAgICAgICAgICAgICAgIFwicmdiKDI1NSwxNjUsMClcIixcbiAgICAgICAgICAgICAgICBcInJnYigxMjgsMTI4LDEyOClcIixcbiAgICAgICAgICAgICAgICBcInJnYigyMzgsMTMwLDIzOClcIixcblxuICAgICAgICAgICAgICAgIFwicmdiKDIzOCwxMzAsMjM4KVwiLFxuICAgICAgICAgICAgICAgIFwicmdiKDAsMCwxMzkpXCIsXG4gICAgICAgICAgICAgICAgXCJyZ2IoMTQ4LDAsMjExKVwiLFxuICAgICAgICAgICAgICAgIFwicmdiKDEwNSwxMDUsMTA1KVwiLFxuICAgICAgICAgICAgICAgIFwicmdiKDI1NSwxNDAsMClcIixcblxuICAgICAgICAgICAgICAgIFwicmdiKDIzNSw5Miw5MilcIixcbiAgICAgICAgICAgICAgICBcInJnYig4Miw5MiwyNDUpXCIsXG4gICAgICAgICAgICAgICAgXCJyZ2IoMTMzLDE0MywxNDMpXCIsXG4gICAgICAgICAgICAgICAgXCJyZ2IoMjM1LDE0Myw5MilcIixcbiAgICAgICAgICAgICAgICBcInJnYigxOTAsMTIwLDEyMClcIixcblxuICAgICAgICAgICAgICAgIFwicmdiKDIyNSw4Miw5MilcIixcbiAgICAgICAgICAgICAgICBcInJnYig3Miw4MiwyNDUpXCIsXG4gICAgICAgICAgICAgICAgXCJyZ2IoMTIzLDEzMywxNDMpXCIsXG4gICAgICAgICAgICAgICAgXCJyZ2IoMjI1LDEzMyw5MilcIixcbiAgICAgICAgICAgICAgICBcInJnYigxODAsMTIwLDEyMClcIlxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vL3V0aWxpdHkgZm9yIGdvb2dsZSBsb2dpbiBjYXBhYmlsaXRpZXMgaW4gTUFUUyAtLSBicm9rZW4gZm9yIGVzcmwubm9hYS5nb3YvZ3NkL21hdHM/XG5jb25zdCBkb0NyZWRlbnRpYWxzID0gZnVuY3Rpb24gKCkge1xuLy8gdGhlIGdtYWlsIGFjY291bnQgZm9yIHRoZSBjcmVkZW50aWFscyBpcyBtYXRzLm1haWwuZGFlbW9uQGdtYWlsLmNvbSAtIHB3ZCBtYXRzMjAxNSFcbiAgICBpZiAobWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzLmZpbmRPbmUoe30pID09PSB1bmRlZmluZWQgfHwgbWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzLmZpbmRPbmUoe30pLnJlc2V0RnJvbUNvZGUgPT09IHVuZGVmaW5lZCB8fCBtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuZmluZE9uZSh7fSkucmVzZXRGcm9tQ29kZSA9PSB0cnVlKSB7XG4gICAgICAgIG1hdHNDb2xsZWN0aW9ucy5DcmVkZW50aWFscy5yZW1vdmUoe30pO1xuICAgIH1cbiAgICBpZiAobWF0c0NvbGxlY3Rpb25zLkNyZWRlbnRpYWxzLmZpbmQoKS5jb3VudCgpID09IDApIHtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLkNyZWRlbnRpYWxzLmluc2VydCh7XG4gICAgICAgICAgICBuYW1lOiBcIm9hdXRoX2dvb2dsZVwiLFxuICAgICAgICAgICAgY2xpZW50SWQ6IFwiNDk5MTgwMjY2NzIyLWFhaTJ0ZGRvOHM5ZWR2NGttMXBzdDg4dmVicGY5aGVjLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tXCIsXG4gICAgICAgICAgICBjbGllbnRTZWNyZXQ6IFwieGRVMHNjN1NiZE9PRXpTeUlEX1BUSVJFXCIsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBcIjEvM2JoV3l2Q01NZnd3RGRkNEYzZnRsSnMzLXZrc2dnN0c4UE90aU9Cd1luaElnT3JKRHRkdW42eks2WGlBVENLVFwiXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8vYW5vdGhlciB1dGlsaXR5IHRvIGFzc2lzdCBhdCBsb2dnaW5nIGludG8gTUFUU1xuY29uc3QgZG9Sb2xlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzLmZpbmRPbmUoe30pID09PSB1bmRlZmluZWQgfHwgbWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzLmZpbmRPbmUoe30pLnJlc2V0RnJvbUNvZGUgPT09IHVuZGVmaW5lZCB8fCBtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuZmluZE9uZSh7fSkucmVzZXRGcm9tQ29kZSA9PSB0cnVlKSB7XG4gICAgICAgIG1hdHNDb2xsZWN0aW9ucy5Sb2xlcy5yZW1vdmUoe30pO1xuICAgIH1cbiAgICBpZiAobWF0c0NvbGxlY3Rpb25zLlJvbGVzLmZpbmQoKS5jb3VudCgpID09IDApIHtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLlJvbGVzLmluc2VydCh7bmFtZTogXCJhZG1pbmlzdHJhdG9yXCIsIGRlc2NyaXB0aW9uOiBcImFkbWluaXN0cmF0b3IgcHJpdmlsZWdlc1wifSk7XG4gICAgfVxufTtcblxuLy9mb3IgdXNlIGluIG1hdHNNZXRob2RzLnJlc2V0QXBwKCkgdG8gZXN0YWJsaXNoIGRlZmF1bHQgc2V0dGluZ3NcbmNvbnN0IGRvU2V0dGluZ3MgPSBmdW5jdGlvbiAodGl0bGUsIHZlcnNpb24sIGJ1aWxkRGF0ZSwgYXBwVHlwZSkge1xuICAgIGlmIChtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuZmluZE9uZSh7fSkgPT09IHVuZGVmaW5lZCB8fCBtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuZmluZE9uZSh7fSkucmVzZXRGcm9tQ29kZSA9PT0gdW5kZWZpbmVkIHx8IG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy5maW5kT25lKHt9KS5yZXNldEZyb21Db2RlID09IHRydWUpIHtcbiAgICAgICAgbWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzLnJlbW92ZSh7fSk7XG4gICAgfVxuICAgIGlmIChtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuZmluZCgpLmNvdW50KCkgPT0gMCkge1xuICAgICAgICBtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuaW5zZXJ0KHtcbiAgICAgICAgICAgIExhYmVsUHJlZml4OiBcIkN1cnZlXCIsXG4gICAgICAgICAgICBUaXRsZTogdGl0bGUsXG4gICAgICAgICAgICBhcHBWZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgYnVpbGREYXRlOiBidWlsZERhdGUsXG4gICAgICAgICAgICBhcHBUeXBlOiBhcHBUeXBlLFxuICAgICAgICAgICAgTGluZVdpZHRoOiAzLjUsXG4gICAgICAgICAgICBOdWxsRmlsbFN0cmluZzogXCItLS1cIixcbiAgICAgICAgICAgIHJlc2V0RnJvbUNvZGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBhbHdheXMgdXBkYXRlIHRoZSB2ZXJzaW9uLCByb2xlcywgYW5kIHRoZSBob3N0bmFtZSwgbm90IGp1c3QgaWYgaXQgZG9lc24ndCBleGlzdC4uLlxuICAgIHZhciBzZXR0aW5ncyA9IG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy5maW5kT25lKHt9KTtcbiAgICBjb25zdCBkZXBsb3ltZW50Um9sZXMgPSB7XG4gICAgICAgIFwibWF0cy1kZXZcIjogXCJkZXZlbG9wbWVudFwiLFxuICAgICAgICBcIm1hdHMtaW50XCI6IFwiaW50ZWdyYXRpb25cIixcbiAgICAgICAgXCJtYXRzXCI6IFwicHJvZHVjdGlvblwiXG4gICAgfTtcbiAgICB2YXIgc2V0dGluZ3NJZCA9IHNldHRpbmdzLl9pZDtcbiAgICB2YXIgb3MgPSBOcG0ucmVxdWlyZSgnb3MnKTtcbiAgICB2YXIgaG9zdG5hbWUgPSBvcy5ob3N0bmFtZSgpLnNwbGl0KCcuJylbMF07XG4gICAgc2V0dGluZ3NbJ2FwcFZlcnNpb24nXSA9IHZlcnNpb247XG4gICAgc2V0dGluZ3NbJ2hvc3RuYW1lJ10gPSBob3N0bmFtZTtcbiAgICBzZXR0aW5nc1snZGVwbG95bWVudFJvbGVzJ10gPSBKU09OLnN0cmluZ2lmeShkZXBsb3ltZW50Um9sZXMpO1xuICAgIG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy51cGRhdGUoc2V0dGluZ3NJZCwgeyRzZXQ6IHNldHRpbmdzfSk7XG59O1xuXG4vL1V0aWxpdHkgZm9yIHRyYW5zZmVycmluZyBjbGllbnQtc2lkZSBwYXJhbWV0ZXJzIHRvIHRoZSBzZXJ2ZXItc2lkZSBtZXRob2RzIHZpYSB0aGUgXCJQbG90UGFyYW1zXCIgb2JqZWN0IGluIHRoZSBzdGFjay5cbi8vQWRkIHZhbHVlcyB0byB0aGlzIG9iamVjdCBpbiB0aGUgJ2NsaWNrIC5zdWJtaXQtcGFyYW1zJyBldmVudCBoYW5kbGVyIGluIHBsb3RfbGlzdC5qc1xuY29uc3QgZ2V0UGxvdFBhcmFtc0Zyb21TdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYXJndW1lbnRzLmNhbGxlZS5hcmd1bWVudHMuY2FsbGVlKTtcbiAgICBjb25zdCBzdGFjayA9IGVyci5zdGFjaztcbiAgICBjb25zdCBzdGFja0VsZW1zID0gc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgZm9yIChzaSA9IDA7IHNpIDwgc3RhY2tFbGVtcy5sZW5ndGg7IHNpKyspIHtcbiAgICAgICAgY29uc3Qgc0VsZW0gPSBzdGFja0VsZW1zW3NpXS50cmltKCk7XG4gICAgICAgIGlmIChzRWxlbS5pbmRleE9mKCdkYXRhRnVuY3Rpb25zJykgIT09IC0xICYmIHNFbGVtLnN0YXJ0c1dpdGgoXCJhdCBkYXRhXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhRnVuY3Rpb25OYW1lID0gc0VsZW0uc3BsaXQoJ2F0ICcpWzFdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBnbG9iYWxbc0VsZW0uc3BsaXQoJ2F0ICcpWzFdLnNwbGl0KCcgJylbMF1dLmFyZ3VtZW50c1swXVxuICAgICAgICAgICAgfSBjYXRjaCAobm9Kb3kpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59O1xuXG4vL2NhbGN1bGF0ZXMgbWVhbiwgc3RkZXYsIGFuZCBvdGhlciBzdGF0aXN0aWNzIGZvciBjdXJ2ZSBkYXRhIHBvaW50cyBpbiBhbGwgYXBwcyBhbmQgcGxvdCB0eXBlc1xuY29uc3QgZ2V0X2VyciA9IGZ1bmN0aW9uIChzVmFscywgc1NlY3MsIHNMZXZzKSB7XG4gICAgLyogcmVmZXIgdG8gcGVybCBlcnJvcl9saWJyYXJ5LnBsIHN1YiAgZ2V0X3N0YXRzXG4gICAgIHRvIHNlZSB0aGUgcGVybCBpbXBsZW1lbnRhdGlvbiBvZiB0aGVzZSBzdGF0aWNzIGNhbGN1bGF0aW9ucy5cbiAgICAgVGhlc2Ugc2hvdWxkIG1hdGNoIGV4YWN0bHkgdGhvc2UsIGV4Y2VwdCB0aGF0IHRoZXkgYXJlIHByb2Nlc3NlZCBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAqL1xuICAgIGNvbnN0IGF1dG9jb3JyX2xpbWl0ID0gMC45NTtcbiAgICBjb25zdCBoYXNMZXZlbHMgPSBzTGV2cy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHBsb3RQYXJhbXMgPSBnZXRQbG90UGFyYW1zRnJvbVN0YWNrKCk7XG4gICAgdmFyIG91dGxpZXJRQ1BhcmFtO1xuICAgIGlmIChwbG90UGFyYW1zW1wib3V0bGllcnNcIl0gIT09IFwiYWxsXCIpIHtcbiAgICAgICAgb3V0bGllclFDUGFyYW0gPSBOdW1iZXIocGxvdFBhcmFtc1tcIm91dGxpZXJzXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRsaWVyUUNQYXJhbSA9IDEwMDtcbiAgICB9XG5cbiAgICB2YXIgc3ViVmFscyA9IFtdO1xuICAgIHZhciBzdWJTZWNzID0gW107XG4gICAgdmFyIHN1YkxldnMgPSBbXTtcbiAgICB2YXIgbiA9IHNWYWxzLmxlbmd0aDtcbiAgICB2YXIgbl9nb29kID0gMDtcbiAgICB2YXIgc3VtX2QgPSAwO1xuICAgIHZhciBzdW0yX2QgPSAwO1xuICAgIHZhciBlcnJvciA9IFwiXCI7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoc1ZhbHNbaV0gIT09IG51bGwgJiYgIWlzTmFOKHNWYWxzW2ldKSkge1xuICAgICAgICAgICAgbl9nb29kID0gbl9nb29kICsgMTtcbiAgICAgICAgICAgIHN1bV9kID0gc3VtX2QgKyBzVmFsc1tpXTtcbiAgICAgICAgICAgIHN1bTJfZCA9IHN1bTJfZCArIHNWYWxzW2ldICogc1ZhbHNbaV07XG4gICAgICAgICAgICBzdWJWYWxzLnB1c2goc1ZhbHNbaV0pO1xuICAgICAgICAgICAgc3ViU2Vjcy5wdXNoKHNTZWNzW2ldKTtcbiAgICAgICAgICAgIGlmIChoYXNMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICBzdWJMZXZzLnB1c2goc0xldnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBkX21lYW4gPSBzdW1fZCAvIG5fZ29vZDtcbiAgICB2YXIgc2QyID0gc3VtMl9kIC8gbl9nb29kIC0gZF9tZWFuICogZF9tZWFuO1xuICAgIHZhciBzZCA9IHNkMiA+IDAgPyBNYXRoLnNxcnQoc2QyKSA6IHNkMjtcbiAgICB2YXIgc2RfbGltaXQgPSBvdXRsaWVyUUNQYXJhbSAqIHNkO1xuICAgIC8vY29uc29sZS5sb2coXCJzZWUgZXJyb3JfbGlicmFyeS5wbCBsMjA4IFRoZXNlIGFyZSBwcm9jZXNzZWQgaW4gcmV2ZXJzZSBvcmRlciB0byB0aGUgcGVybCBjb2RlIC0gIFxcbm1lYW4gaXMgXCIgKyBkX21lYW4gKyBcIiBzZF9saW1pdCBpcyArLy0gXCIgKyBzZF9saW1pdCArIFwiIG5fZ29vZCBpcyBcIiArIG5fZ29vZCArIFwiIHN1bV9kIGlzXCIgKyBzdW1fZCArIFwiIHN1bTJfZCBpcyBcIiArIHN1bTJfZCk7XG5cbiAgICAvLyBmaW5kIG1pbmltdW0gZGVsdGFfdGltZSwgaWYgYW55IHZhbHVlIG1pc3NpbmcsIHNldCBudWxsXG4gICAgdmFyIGxhc3Rfc2VjcyA9IDA7XG4gICAgdmFyIG1pbkRlbHRhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWluU2VjcyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIG1heF9zZWNzID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICB2YXIgbWluVmFsID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWF4VmFsID0gLTEgKiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBzZWNzO1xuICAgIHZhciBkZWx0YTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3ViU2Vjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWNzID0gKHN1YlNlY3NbaV0pO1xuICAgICAgICBkZWx0YSA9IE1hdGguYWJzKHNlY3MgLSBsYXN0X3NlY3MpO1xuICAgICAgICBpZiAoZGVsdGEgPiAwICYmIGRlbHRhIDwgbWluRGVsdGEpIHtcbiAgICAgICAgICAgIG1pbkRlbHRhID0gZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3MgPCBtaW5TZWNzKSB7XG4gICAgICAgICAgICBtaW5TZWNzID0gc2VjcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjcyA+IG1heF9zZWNzKSB7XG4gICAgICAgICAgICBtYXhfc2VjcyA9IHNlY3M7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9zZWNzID0gc2VjcztcbiAgICB9XG5cbiAgICB2YXIgZGF0YV93ZyA9IFtdO1xuICAgIHZhciBuX2dhcHMgPSAwO1xuICAgIG5fZ29vZCA9IDA7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIHN1bTIgPSAwO1xuICAgIGlmIChtaW5EZWx0YSA8IDApIHtcbiAgICAgICAgZXJyb3IgPSAoXCJJbnZhbGlkIHRpbWUgaW50ZXJ2YWwgLSBtaW5EZWx0YTogXCIgKyBtaW5EZWx0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibWF0c0RhdGFVdGlsLmdldEVycjogSW52YWxpZCB0aW1lIGludGVydmFsIC0gbWluRGVsdGE6IFwiICsgbWluRGVsdGEpXG4gICAgfVxuICAgIC8vIHJlbW92ZSBkYXRhIG1vcmUgdGhhbiAkc2RfbGltaXQgZnJvbSBtZWFuXG4gICAgdmFyIHFhQ29ycmVjdGVkID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHN1YlZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHN1YlZhbHNbaV0gLSBkX21lYW4pID4gc2RfbGltaXQpIHtcbiAgICAgICAgICAgIHFhQ29ycmVjdGVkLnB1c2goXCJyZW1vdmluZyBkYXR1bSBcIiArIGkgKyBcIiB3aXRoIHZhbHVlIFwiICsgc3ViVmFsc1tpXSArIFwiIGJlY2F1c2UgaXQgZXhjZWVkcyBcIiArIG91dGxpZXJRQ1BhcmFtICsgXCIgc3RhbmRhcmQgZGV2aWF0aW9ucyBmcm9tIHRoZSBtZWFuIC0gbWVhbjogXCIgKyBkX21lYW4gKyBcIiBcIiArIG91dGxpZXJRQ1BhcmFtICsgXCIgKiBzZDogXCIgKyBzZF9saW1pdCArIFwiIGRlbHRhOiBcIiArIChzdWJWYWxzW2ldIC0gZF9tZWFuKSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhxYUNvcnJlY3RlZC5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICBzdWJWYWxzW2ldID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pblZhbCA9IG1pblZhbCA8IHN1YlZhbHNbaV0gPyBtaW5WYWwgOiBzdWJWYWxzW2ldO1xuICAgICAgICAgICAgbWF4VmFsID0gbWF4VmFsID4gc3ViVmFsc1tpXSA/IG1heFZhbCA6IHN1YlZhbHNbaV07XG4gICAgICAgICAgICBzdW0gKz0gc3ViVmFsc1tpXTtcbiAgICAgICAgICAgIHN1bTIgKz0gc3ViVmFsc1tpXSAqIHN1YlZhbHNbaV07XG4gICAgICAgICAgICBuX2dvb2QrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobl9nb29kIDwgMSkge1xuICAgICAgICByZXR1cm4ge2RfbWVhbjogbnVsbCwgc3RkZV9iZXRzeTogbnVsbCwgc2Q6IG51bGwsIG5fZ29vZDogbl9nb29kLCBsYWcxOiBudWxsLCBtaW46IG51bGwsIG1heDogbnVsbCwgc3VtOiBudWxsfTtcbiAgICB9XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBpZiB3ZSB0aHJldyBhbnl0aGluZyBhd2F5LlxuICAgIGRfbWVhbiA9IHN1bSAvIG5fZ29vZDtcbiAgICBzZDIgPSBzdW0yIC8gbl9nb29kIC0gZF9tZWFuICogZF9tZWFuO1xuICAgIHNkID0gMDtcbiAgICBpZiAoc2QyID4gMCkge1xuICAgICAgICBzZCA9IE1hdGguc3FydChzZDIpO1xuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwibmV3IG1lYW4gYWZ0ZXIgdGhyb3dpbmcgYXdheSBvdXRsaWVycyBpcyBcIiArIHNkICsgXCIgbl9nb29kIGlzIFwiICsgbl9nb29kICsgXCIgc3VtIGlzIFwiICsgc3VtICArIFwiIHN1bTIgaXMgXCIgKyBzdW0yICsgXCIgZF9tZWFuIGlzIFwiICsgZF9tZWFuKTtcblxuICAgIC8vIGxvb2sgZm9yIGdhcHNcbiAgICB2YXIgbGFzdFNlY29uZCA9IC0xICogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgbGFzdFByZXNzdXJlID0gLTEgKiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBuX3ByZXNzdXJlcztcbiAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgIG5fcHJlc3N1cmVzID0gYXJyYXlVbmlxdWUoc3ViTGV2cykubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5fcHJlc3N1cmVzID0gMTtcbiAgICB9XG4gICAgLy8gc2V0IGxhZzFfdCB0byB0aGUgZmlyc3QgdGltZSB0aGUgdGltZSBjaGFuZ2VzIGZyb20gaXRzIGluaXRpYWwgdmFsdWUgKyAxIChkYXRhIHplcm8gYmFzZWQpXG4gICAgLy8gc2V0IGxhZzFfcCB0byB0aGUgZmlyc3QgdGltZSB0aGUgcHJlc3N1cmUgY2hhbmdlcyBmcm9tIGl0cyBpbml0aWFsIHZhbHVlICsgMSAoZGF0YSB6ZXJvIGJhc2VkKVxuICAgIHZhciBsYWcxX3QgPSAwO1xuICAgIHZhciBsYWcxX3AgPSAwO1xuICAgIHZhciByMV90ID0gMDtcdFx0XHQvLyBhdXRvY29ycmVsYXRpb24gZm9yIHRpbWVcbiAgICB2YXIgcjFfcCA9IDA7XHRcdFx0Ly8gYXV0b2NvcnJlbGF0aW9uIGZvciBwcmVzc3VyZVxuICAgIHZhciBqID0gMDsgICAgICAgICAgICAgIC8vIGkgaXMgbG9vcCBpbmRleCB3aXRob3V0IGdhcHM7IGogaXMgbG9vcCBpbmRleCB3aXRoIGdhcHNcbiAgICB2YXIgbl9kZWx0YXMgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN1YlNlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlYyA9IHN1YlNlY3NbaV07XG4gICAgICAgIHZhciBsZXY7XG4gICAgICAgIGlmIChoYXNMZXZlbHMpIHtcbiAgICAgICAgICAgIGxldiA9IHN1YkxldnNbaV07XG4gICAgICAgICAgICAvLyBmaW5kIGZpcnN0IHRpbWUgdGhlIHByZXNzdXJlIGNoYW5nZXNcbiAgICAgICAgICAgIGlmIChsYWcxX3AgPT09IDAgJiYgbGFzdFByZXNzdXJlID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChsZXYgIT09IGxhc3RQcmVzc3VyZSkge1xuICAgICAgICAgICAgICAgICAgICBsYWcxX3AgPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFNlY29uZCA+PSAwKSB7XG4gICAgICAgICAgICBpZihsYWcxX3QgPT09IDAgJiYgc2VjICE9PSBsYXN0U2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgbGFnMV90ID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzZWMgLSBsYXN0U2Vjb25kKSA+IG1pbkRlbHRhKSB7XG4gICAgICAgICAgICAgICAgbl9kZWx0YXMgPSAoTWF0aC5hYnMoc2VjIC0gbGFzdFNlY29uZCkvbWluRGVsdGEgLSAxKSAqIG5fcHJlc3N1cmVzO1xuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgQXV0b2NvcnJlbGF0aW9uIGF0IGxhZyAxLCBpdCBkb2Vzbid0IG1hdHRlciBob3cgbWFueSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgLy8gZGF0YSB3ZSBwdXQgaW4gd2l0aGluIGdhcHMhIChCdXQgZm9yIHRoZSBvdGhlciBBQydzIGl0IGRvZXMuKVxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIHVzaW5nIG9ubHkgdGhlIEFDIGF0IGxhZyAxIGZvciBjYWxjdWxhdGluZyBzdGQgZXJyLCBsZXQnc1xuICAgICAgICAgICAgICAgIC8vIHNhdmUgY3B1IHRpbWUgYW5kIG9ubHkgcHV0IGluIG9uZSBtaXNzaW5nIGRhdHVtIHBlciBnYXAsIG5vIG1hdHRlclxuICAgICAgICAgICAgICAgIC8vIGhvdyBsb25nLiBXUk0gMi8yMi8yMDE5XG4gICAgICAgICAgICAgICAgLy8gYnV0IGlmIHdlJ3JlIHVzaW5nIGEgZGlmZmVyZW50IGxhZywgd2hpY2ggY291bGQgaGFwcGVuLCB3ZSdsbCBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gaW5zZXJ0IGFsbCB0aGUgbWlzc2luZyBkYXRhIGluIGVhY2ggZ2FwLiBXUk0gMi8yMi8yMDE5XG4gICAgICAgICAgICAgICAgLy8gJG5fZGVsdGFzPTE7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBjb3VudCA9IDA7IGNvdW50IDwgbl9kZWx0YXM7IGNvdW50KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YV93Zy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBuX2dhcHMrKztcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0U2Vjb25kID0gc2VjO1xuICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICBsYXN0UHJlc3N1cmUgPSBsZXY7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YV93Zy5wdXNoKHN1YlZhbHNbaV0pO1xuICAgICAgICBqKys7XG4gICAgfVxuXG4gICAgLy9mcm9tIGh0dHA6Ly93d3cuaXRsLm5pc3QuZ292L2Rpdjg5OC9oYW5kYm9vay9lZGEvc2VjdGlvbjMvZWRhMzVjLmh0bVxuICAgIHZhciByID0gW107XG4gICAgdmFyIGxhZ19ieV9yID0ge307XG4gICAgdmFyIGxhZzFfbWF4ID0gbGFnMV9wID4gbGFnMV90ID8gbGFnMV9wIDogbGFnMV90O1xuICAgIHZhciByX3N1bSA9IDA7XG4gICAgdmFyIG5fciA9IDA7XG4gICAgdmFyIG5faW5fbGFnO1xuICAgIHZhciBsYWc7XG4gICAgdmFyIHQ7XG4gICAgZm9yIChsYWcgPSAwOyBsYWcgPD0gbGFnMV9tYXg7IGxhZysrKSB7XG4gICAgICAgIHJbbGFnXSA9IDA7XG4gICAgICAgIG5faW5fbGFnID0gMDtcbiAgICAgICAgZm9yICh0ID0gMDsgdCA8ICgobiArIG5fZ2FwcykgLSBsYWcpOyB0KyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhX3dnW3RdICE9IG51bGwgJiYgZGF0YV93Z1t0ICsgbGFnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcltsYWddICs9ICsoZGF0YV93Z1t0XSAtIGRfbWVhbikgKiAoZGF0YV93Z1t0ICsgbGFnXSAtIGRfbWVhbik7XG4gICAgICAgICAgICAgICAgbl9pbl9sYWcrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobl9pbl9sYWcgPiAwICYmIHNkID4gMCkge1xuICAgICAgICAgICAgcltsYWddIC89IChuX2luX2xhZyAqIHNkICogc2QpO1xuICAgICAgICAgICAgcl9zdW0gKz0gcltsYWddO1xuICAgICAgICAgICAgbl9yKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByW2xhZ10gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKGxhZyA+PSAxICYmIGxhZyA8IChuICsgbl9nYXBzKSAvIDIpIHtcbiAgICAgICAgICAgIGxhZ19ieV9yW3JbbGFnXV0gPSBsYWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhZzFfdCA+IDApIHtcbiAgICAgICAgcjFfdCA9IHJbbGFnMV90XSAhPT0gdW5kZWZpbmVkID8gcltsYWcxX3RdIDogMDtcbiAgICB9XG4gICAgaWYgKGxhZzFfcCA+IDApIHtcbiAgICAgICAgcjFfcCA9IHJbbGFnMV9wXSAhPT0gdW5kZWZpbmVkID8gcltsYWcxX3BdIDogMDtcbiAgICB9XG5cbiAgICAvLyBCZXRzeSBXZWF0aGVyaGVhZCdzIGNvcnJlY3Rpb24sIGJhc2VkIG9uIGxhZyAxLCBhdWdtZW50ZWQgYnkgdGhlIGhpZ2hlc3RcbiAgICAvLyBsYWcgPiAxIGFuZCA8IG4vMlxuICAgIGlmIChyMV9wID49IGF1dG9jb3JyX2xpbWl0KSB7XG4gICAgICAgIHIxX3AgPSBhdXRvY29ycl9saW1pdDtcbiAgICB9XG4gICAgaWYocjFfdCA+PSBhdXRvY29ycl9saW1pdCkge1xuICAgICAgICByMV90ID0gYXV0b2NvcnJfbGltaXQ7XG4gICAgfVxuXG4gICAgY29uc3QgYmV0c3kgPSBNYXRoLnNxcnQoKG5fZ29vZC0xKSooMS4gLSByMV9wKSooMS4gLSByMV90KSk7XG4gICAgdmFyIHN0ZGVfYmV0c3k7XG4gICAgaWYgKGJldHN5ICE9PSAwKSB7XG4gICAgICAgIHN0ZGVfYmV0c3kgPSBzZCAvIGJldHN5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZGVfYmV0c3kgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IHtcbiAgICAgICAgZF9tZWFuOiBkX21lYW4sXG4gICAgICAgIHN0ZGVfYmV0c3k6IHN0ZGVfYmV0c3ksXG4gICAgICAgIHNkOiBzZCxcbiAgICAgICAgbl9nb29kOiBuX2dvb2QsXG4gICAgICAgIGxhZzE6IHJbMV0sXG4gICAgICAgIG1pbjogbWluU2VjcyxcbiAgICAgICAgbWF4OiBtYXhfc2VjcyxcbiAgICAgICAgbWluVmFsOiBtaW5WYWwsXG4gICAgICAgIG1heFZhbDogbWF4VmFsLFxuICAgICAgICBzdW06IHN1bV9kLFxuICAgICAgICBxYUNvcnJlY3RlZDogcWFDb3JyZWN0ZWRcbiAgICB9O1xuICAgIC8vY29uc29sZS5sb2coXCJzdGF0cyBhcmUgXCIgKyBKU09OLnN0cmluZ2lmeShzdGF0cykpO1xuICAgIC8vIHN0ZGVfYmV0c3kgaXMgc3RhbmRhcmQgZXJyb3Igd2l0aCBhdXRvIGNvcnJlbGF0aW9uXG4gICAgLy9jb25zb2xlLmxvZyhcIi0tLS0tLS0tLVxcblxcblwiKTtcbiAgICByZXR1cm4gc3RhdHM7XG59O1xuXG4vLyB1dGlsaXR5IHRvIHByb2Nlc3MgdGhlIHVzZXItaW5wdXQgaGlzdG9ncmFtIGN1c3RvbWl6YXRpb24gY29udHJvbHNcbmNvbnN0IHNldEhpc3RvZ3JhbVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGxvdFBhcmFtcykge1xuICAgIHZhciB5QXhpc0Zvcm1hdCA9IHBsb3RQYXJhbXNbJ2hpc3RvZ3JhbS15YXhpcy1jb250cm9scyddO1xuICAgIHZhciBiaW5UeXBlID0gcGxvdFBhcmFtc1snaGlzdG9ncmFtLWJpbi1jb250cm9scyddO1xuICAgIHZhciBiaW5OdW0gPSAxMjsgICAgLy8gZGVmYXVsdCBiaW4gbnVtYmVyXG4gICAgdmFyIGJpblN0YXJ0ID0gdW5kZWZpbmVkOyAgICAvLyBkZWZhdWx0IGlzIG5vIG1hbmRhdGVkIGJpbiBzdGFydFxuICAgIHZhciBiaW5TdHJpZGUgPSB1bmRlZmluZWQ7ICAgICAgICAgLy8gZGVmYXVsdCBpcyBubyBtYW5kYXRlZCBzdHJpZGVcbiAgICB2YXIgcGl2b3RWYWwgPSB1bmRlZmluZWQ7ICAgICAgLy8gZGVmYXVsdCBpcyBub3QgdG8gc2hpZnQgdGhlIGJpbnMgb3ZlciB0byBhIHBpdm90XG4gICAgdmFyIGJpbkJvdW5kcyA9IFtdOyAvLyBkZWZhdWx0IGlzIG5vIHNwZWNpZmllZCBiaW4gYm91bmRzIC0tIG91ciBhbGdvcml0aG0gd2lsbCBmaWd1cmUgdGhlbSBvdXQgaWYgdGhpcyBhcnJheSBzdGF5cyBlbXB0eVxuXG4gICAgc3dpdGNoIChiaW5UeXBlKSB7XG4gICAgICAgIGNhc2UgXCJTZXQgbnVtYmVyIG9mIGJpbnNcIjpcbiAgICAgICAgICAgIC8vIGdldCB0aGUgdXNlcidzIGNob3NlbiBudW1iZXIgb2YgYmluc1xuICAgICAgICAgICAgYmluTnVtID0gTnVtYmVyKHBsb3RQYXJhbXNbJ2Jpbi1udW1iZXInXSk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oYmluTnVtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgYmluIG51bWJlcjogcGxlYXNlIGVudGVyIHRoZSBkZXNpcmVkIG51bWJlciBvZiBiaW5zLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJNYWtlIHplcm8gYSBiaW4gYm91bmRcIjpcbiAgICAgICAgICAgIC8vIGxldCB0aGUgaGlzdG9ncmFtIHJvdXRpbmUga25vdyB0aGF0IHdlIHdhbnQgdGhlIGJpbnMgc2hpZnRlZCBvdmVyIHRvIHplcm9cbiAgICAgICAgICAgIHBpdm90VmFsID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJDaG9vc2UgYSBiaW4gYm91bmRcIjpcbiAgICAgICAgICAgIC8vIGxldCB0aGUgaGlzdG9ncmFtIHJvdXRpbmUga25vdyB0aGF0IHdlIHdhbnQgdGhlIGJpbnMgc2hpZnRlZCBvdmVyIHRvIHdoYXRldmVyIHdhcyBpbnB1dFxuICAgICAgICAgICAgcGl2b3RWYWwgPSBOdW1iZXIocGxvdFBhcmFtc1snYmluLXBpdm90J10pO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHBpdm90VmFsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgYmluIHBpdm90OiBwbGVhc2UgZW50ZXIgdGhlIGRlc2lyZWQgYmluIHBpdm90LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJTZXQgbnVtYmVyIG9mIGJpbnMgYW5kIG1ha2UgemVybyBhIGJpbiBib3VuZFwiOlxuICAgICAgICAgICAgLy8gZ2V0IHRoZSB1c2VyJ3MgY2hvc2VuIG51bWJlciBvZiBiaW5zIGFuZCBsZXQgdGhlIGhpc3RvZ3JhbSByb3V0aW5lIGtub3cgdGhhdCB3ZSB3YW50IHRoZSBiaW5zIHNoaWZ0ZWQgb3ZlciB0byB6ZXJvXG4gICAgICAgICAgICBiaW5OdW0gPSBOdW1iZXIocGxvdFBhcmFtc1snYmluLW51bWJlciddKTtcbiAgICAgICAgICAgIGlmIChpc05hTihiaW5OdW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyBiaW4gbnVtYmVyOiBwbGVhc2UgZW50ZXIgdGhlIGRlc2lyZWQgbnVtYmVyIG9mIGJpbnMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGl2b3RWYWwgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlNldCBudW1iZXIgb2YgYmlucyBhbmQgY2hvb3NlIGEgYmluIGJvdW5kXCI6XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHVzZXIncyBjaG9zZW4gbnVtYmVyIG9mIGJpbnMgYW5kIGxldCB0aGUgaGlzdG9ncmFtIHJvdXRpbmUga25vdyB0aGF0IHdlIHdhbnQgdGhlIGJpbnMgc2hpZnRlZCBvdmVyIHRvIHdoYXRldmVyIHdhcyBpbnB1dFxuICAgICAgICAgICAgYmluTnVtID0gTnVtYmVyKHBsb3RQYXJhbXNbJ2Jpbi1udW1iZXInXSk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oYmluTnVtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgYmluIG51bWJlcjogcGxlYXNlIGVudGVyIHRoZSBkZXNpcmVkIG51bWJlciBvZiBiaW5zLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpdm90VmFsID0gTnVtYmVyKHBsb3RQYXJhbXNbJ2Jpbi1waXZvdCddKTtcbiAgICAgICAgICAgIGlmIChpc05hTihwaXZvdFZhbCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBwYXJzaW5nIGJpbiBwaXZvdDogcGxlYXNlIGVudGVyIHRoZSBkZXNpcmVkIGJpbiBwaXZvdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTWFudWFsIGJpbnNcIjpcbiAgICAgICAgICAgIC8vIHRyeSB0byBwYXJzZSB3aGF0ZXZlciB3ZSd2ZSBiZWVuIGdpdmVuIGZvciBiaW4gYm91bmRzLiBUaHJvdyBhbiBlcnJvciBpZiB0aGV5IGRpZG4ndCBmb2xsb3cgZGlyZWN0aW9ucyB0byBlbnRlciBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG51bWJlcnMuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJpbkJvdW5kcyA9IHBsb3RQYXJhbXNbJ2Jpbi1ib3VuZHMnXS5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gTnVtYmVyKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyBiaW4gYm91bmRzOiBwbGVhc2UgZW50ZXIgIGF0IGxlYXN0IHR3byBudW1iZXJzIGRlbGltaXRlZCBieSBjb21tYXMuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmluTnVtID0gYmluQm91bmRzLmxlbmd0aCArIDE7IC8vIGFkZCAxIGJlY2F1c2UgdGhlc2UgYXJlIGlubmVyIGJpbiBib3VuZHNcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBwYXJzaW5nIGJpbiBib3VuZHM6IHBsZWFzZSBlbnRlciAgYXQgbGVhc3QgdHdvIG51bWJlcnMgZGVsaW1pdGVkIGJ5IGNvbW1hcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSd2ZSBiZWVuIGdpdmVuIGF0IGxlYXN0IHR3byBnb29kIGJpbiBib3VuZHMgKGVub3VnaCB0byBtYWtlIG9uZSBiaW4pLlxuICAgICAgICAgICAgaWYgKGJpbk51bSA8IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBwYXJzaW5nIGJpbiBib3VuZHM6IHBsZWFzZSBlbnRlciBhdCBsZWFzdCB0d28gbnVtYmVycyBkZWxpbWl0ZWQgYnkgY29tbWFzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJNYW51YWwgYmluIHN0YXJ0LCBudW1iZXIsIGFuZCBzdHJpZGVcIjpcbiAgICAgICAgICAgIC8vIGdldCB0aGUgYmluIHN0YXJ0LCBudW1iZXIsIGFuZCBzdHJpZGUuXG4gICAgICAgICAgICBiaW5OdW0gPSBOdW1iZXIocGxvdFBhcmFtc1snYmluLW51bWJlciddKTtcbiAgICAgICAgICAgIGlmIChpc05hTihiaW5OdW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyBiaW4gbnVtYmVyOiBwbGVhc2UgZW50ZXIgdGhlIGRlc2lyZWQgbnVtYmVyIG9mIGJpbnMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluU3RhcnQgPSBOdW1iZXIocGxvdFBhcmFtc1snYmluLXN0YXJ0J10pO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGJpblN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgYmluIHN0YXJ0OiBwbGVhc2UgZW50ZXIgdGhlIGRlc2lyZWQgYmluIHN0YXJ0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpblN0cmlkZSA9IE51bWJlcihwbG90UGFyYW1zWydiaW4tc3RyaWRlJ10pO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGJpblN0cmlkZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBwYXJzaW5nIGJpbiBzdHJpZGU6IHBsZWFzZSBlbnRlciB0aGUgZGVzaXJlZCBiaW4gc3RyaWRlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJEZWZhdWx0IGJpbnNcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB5QXhpc0Zvcm1hdDogeUF4aXNGb3JtYXQsXG4gICAgICAgIGJpbk51bTogYmluTnVtLFxuICAgICAgICBiaW5TdGFydDogYmluU3RhcnQsXG4gICAgICAgIGJpblN0cmlkZTogYmluU3RyaWRlLFxuICAgICAgICBwaXZvdFZhbDogcGl2b3RWYWwsXG4gICAgICAgIGJpbkJvdW5kczogYmluQm91bmRzXG4gICAgfTtcbn07XG5cbi8vIHV0aWxpdHkgdGhhdCB0YWtlcyBhcnJheXMgb2Ygc2Vjb25kcyBhbmQgdmFsdWVzIGFuZCBwcm9kdWNlcyBhIGRhdGEgc3RydWN0dXJlIGNvbnRhaW5pbmcgYmluIGluZm9ybWF0aW9uIGZvciBoaXN0b2dyYW0gcGxvdHRpbmdcbmNvbnN0IGNhbGN1bGF0ZUhpc3RvZ3JhbUJpbnMgPSBmdW5jdGlvbiAoY3VydmVTdWJTdGF0cywgY3VydmVTdWJTZWNzLCBiaW5QYXJhbXMpIHtcblxuICAgIC8vIGJpblN0YXJ0IGFuZCBiaW5TdHJpZGUgd2lsbCBvbmx5IGJlIGRlZmluZWQgaWYgdGhlIHVzZXIgd2FudHMgdG8gc3BlY2lmeSB0aGUgYmluIHNwYWNpbmcuXG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSdsbCB1c2UgdGhlIG1lYW4gYW5kIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgZGF0YSB0byBzcGFjZSB0aGUgYmlucy5cblxuICAgIC8vIHBpdm90VmFsIHdpbGwgb25seSBiZSBkZWZpbmVkIGlmIHRoZSB1c2VyIHdhbnRzIHRvIHNoaWZ0IHRoZSBiaW4gbGltaXRzIHRvIGFsaWduIHdpdGggYSBjZXJ0YWluIHZhbHVlLlxuICAgIC8vIG90aGVyd2lzZSwgd2UnbGwga2VlcCBldmVyeXRoaW5nIGFsaWduZWQgd2l0aCB0aGUgZGF0YSBtZWFuLlxuXG4gICAgdmFyIGJpblN0YXRzID0ge307XG4gICAgdmFyIGJpblVwQm91bmRzID0gW107XG4gICAgdmFyIGJpbkxvd0JvdW5kcyA9IFtdO1xuICAgIHZhciBiaW5NZWFucyA9IFtdO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBnbG9iYWwgc3RhdHMgYWNyb3NzIGFsbCBvZiB0aGUgZGF0YVxuICAgIGNvbnN0IGdsb2JhbFN0YXRzID0gZ2V0X2VycihjdXJ2ZVN1YlN0YXRzLCBjdXJ2ZVN1YlNlY3MsIFtdKTsgICAvLyB3ZSBkb24ndCBuZWVkIGxldmVscyBmb3IgdGhlIG1lYW4gb3Igc2QgY2FsY3VsYXRpb25zLCBzbyBqdXN0IHBhc3MgaW4gYW4gZW1wdHkgYXJyYXlcbiAgICBjb25zdCBnbG9iX21lYW4gPSBnbG9iYWxTdGF0cy5kX21lYW47XG4gICAgY29uc3QgZ2xvYl9zZCA9IGdsb2JhbFN0YXRzLnNkO1xuXG4gICAgdmFyIGZ1bGxMb3dCb3VuZDtcbiAgICB2YXIgZnVsbFVwQm91bmQ7XG4gICAgdmFyIGZ1bGxSYW5nZTtcbiAgICB2YXIgYmluSW50ZXJ2YWw7XG5cbiAgICBpZiAoYmluUGFyYW1zLmJpblN0YXJ0ID09PSB1bmRlZmluZWQgfHwgYmluUGFyYW1zLmJpblN0cmlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVzZSB0aGUgZ2xvYmFsIHN0YXRzIHRvIGRldGVybWluZSB0aGUgYmluIGJvdW5kcyAtLSBzaG91bGQgYmUgYmFzZWQgb24gZGl2aWRpbmcgdXAgKy8tIDMqc2QgZnJvbSB0aGUgbWVhbiBpbnRvIHJlcXVlc3RlZCBudW1iZXIgb2YgYmluc1xuICAgICAgICBmdWxsTG93Qm91bmQgPSBnbG9iX21lYW4gLSAzICogZ2xvYl9zZDtcbiAgICAgICAgZnVsbFVwQm91bmQgPSBnbG9iX21lYW4gKyAzICogZ2xvYl9zZDtcbiAgICAgICAgZnVsbFJhbmdlID0gNiAqIGdsb2Jfc2Q7XG4gICAgICAgIGJpbkludGVydmFsID0gZnVsbFJhbmdlIC8gKGJpblBhcmFtcy5iaW5OdW0gLSAyKTsgICAvLyB0YWtlIG9mZiB0d28gYmlucyBmcm9tIHRoZSB0b3RhbCBudW1iZXIgb2YgcmVxdWVzdGVkIGJpbnMgdG8gcmVwcmVzZW50IHZhbHVlcyBlaXRoZXIgbGVzcyB0aGFuIC0gMypzZCBmcm9tIHRoZSBtZWFuIG9yIGdyZWF0ZXIgdGhhbiAzKnNkIGZyb20gdGhlIG1lYW5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgdGhlIHVzZXItZGVmaW5lZCBzdGFydCwgbnVtYmVyLCBhbmQgc3RyaWRlIHRvIGRldGVybWluZSB0aGUgYmluIGJvdW5kc1xuICAgICAgICBmdWxsTG93Qm91bmQgPSBiaW5QYXJhbXMuYmluU3RhcnQ7XG4gICAgICAgIGZ1bGxVcEJvdW5kID0gYmluUGFyYW1zLmJpblN0YXJ0ICsgKGJpblBhcmFtcy5iaW5OdW0gLSAyKSAqIGJpblBhcmFtcy5iaW5TdHJpZGU7ICAvLyB0YWtlIG9mZiB0d28gYmlucyBmcm9tIHRoZSB0b3RhbCBudW1iZXIgb2YgcmVxdWVzdGVkIGJpbnMgdG8gcmVwcmVzZW50IHZhbHVlcyB0aGF0IGZhbGwgb3V0c2lkZSBvZiB0aGUgcHJlc2NyaWJlZCByYW5nZVxuICAgICAgICBmdWxsUmFuZ2UgPSAoYmluUGFyYW1zLmJpbk51bSAtIDIpICogYmluUGFyYW1zLmJpblN0cmlkZTtcbiAgICAgICAgYmluSW50ZXJ2YWwgPSBiaW5QYXJhbXMuYmluU3RyaWRlO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIGFuIGFycmF5IG9mIHRoZSB1cHBlciBhbmQgbG93ZXIgYm91bmRpbmcgdmFsdWVzIGZvciBlYWNoIGJpbi5cbiAgICBiaW5VcEJvdW5kc1swXSA9IGZ1bGxMb3dCb3VuZDsgLy8gdGhlIGZpcnN0IHVwcGVyIGJvdW5kIHNob3VsZCBiZSBleGFjdGx5IC0gMypzZCBmcm9tIHRoZSBtZWFuLCBvciB0aGUgcHJldmlvdXNseSBjYWxjdWxhdGVkIGZ1bGxMb3dCb3VuZFxuICAgIGJpbkxvd0JvdW5kc1swXSA9IC0xICogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBiaW5NZWFuc1swXSA9IGZ1bGxMb3dCb3VuZCAtIGJpbkludGVydmFsIC8gMjtcbiAgICBmb3IgKHZhciBiX2lkeCA9IDE7IGJfaWR4IDwgYmluUGFyYW1zLmJpbk51bSAtIDE7IGJfaWR4KyspIHtcbiAgICAgICAgYmluVXBCb3VuZHNbYl9pZHhdID0gYmluVXBCb3VuZHNbYl9pZHggLSAxXSArIGJpbkludGVydmFsOyAvLyBpbmNyZW1lbnQgZnJvbSBmdWxsTG93Qm91bmQgdG8gZ2V0IHRoZSByZXN0IG9mIHRoZSBiaW4gdXBwZXIgbGltaXRzXG4gICAgICAgIGJpbkxvd0JvdW5kc1tiX2lkeF0gPSBiaW5VcEJvdW5kc1tiX2lkeCAtIDFdO1xuICAgICAgICBiaW5NZWFuc1tiX2lkeF0gPSBiaW5VcEJvdW5kc1tiX2lkeCAtIDFdICsgYmluSW50ZXJ2YWwgLyAyO1xuICAgIH1cbiAgICBiaW5VcEJvdW5kc1tiaW5QYXJhbXMuYmluTnVtIC0gMV0gPSBOdW1iZXIuTUFYX1ZBTFVFOyAvLyB0aGUgbGFzdCBiaW4gc2hvdWxkIGhhdmUgZXZlcnl0aGluZyB0b28gbGFyZ2UgdG8gZml0IGludG8gdGhlIHByZXZpb3VzIGJpbnMsIHNvIG1ha2UgaXRzIHVwcGVyIGJvdW5kIHRoZSBtYXggbnVtYmVyIHZhbHVlXG4gICAgYmluTG93Qm91bmRzW2JpblBhcmFtcy5iaW5OdW0gLSAxXSA9IGZ1bGxVcEJvdW5kO1xuICAgIGJpbk1lYW5zW2JpblBhcmFtcy5iaW5OdW0gLSAxXSA9IGZ1bGxVcEJvdW5kICsgYmluSW50ZXJ2YWwgLyAyO1xuXG4gICAgaWYgKGJpblBhcmFtcy5waXZvdFZhbCAhPT0gdW5kZWZpbmVkICYmICFpc05hTihiaW5QYXJhbXMucGl2b3RWYWwpKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gc2hpZnQgdGhlIGJvdW5kcyBhbmQgbWVhbnMgb3ZlciBzbyB0aGF0IG9uZSBvZiB0aGUgYm91bmRzIGlzIG9uIHRoZSBjaG9zZW4gcGl2b3RcbiAgICAgICAgdmFyIGNsb3Nlc3RCb3VuZFRvUGl2b3QgPSBiaW5Mb3dCb3VuZHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKE1hdGguYWJzKGN1cnIgLSBiaW5QYXJhbXMucGl2b3RWYWwpIDwgTWF0aC5hYnMocHJldiAtIGJpblBhcmFtcy5waXZvdFZhbCkgPyBjdXJyIDogcHJldik7XG4gICAgICAgIH0pO1xuICAgICAgICBiaW5VcEJvdW5kcyA9IGJpblVwQm91bmRzLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsIC0gKGNsb3Nlc3RCb3VuZFRvUGl2b3QgLSBiaW5QYXJhbXMucGl2b3RWYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYmluTG93Qm91bmRzID0gYmluTG93Qm91bmRzLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsIC0gKGNsb3Nlc3RCb3VuZFRvUGl2b3QgLSBiaW5QYXJhbXMucGl2b3RWYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYmluTWVhbnMgPSBiaW5NZWFucy5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCAtIChjbG9zZXN0Qm91bmRUb1Bpdm90IC0gYmluUGFyYW1zLnBpdm90VmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsYWJlbHMgZm9yIGVhY2ggYmluLCBiYXNlZCBvbiB0aGUgZGF0YSBib3VuZGluZyByYW5nZSwgZm9yIHRoZSBncmFwaCB4LWF4aXMgbGF0ZXJcbiAgICB2YXIgYmluTGFiZWxzID0gW107XG4gICAgdmFyIGxvd1NkRnJvbU1lYW47XG4gICAgdmFyIHVwU2RGcm9tTWVhbjtcbiAgICBmb3IgKGJfaWR4ID0gMDsgYl9pZHggPCBiaW5QYXJhbXMuYmluTnVtOyBiX2lkeCsrKSB7XG4gICAgICAgIGxvd1NkRnJvbU1lYW4gPSAoYmluTG93Qm91bmRzW2JfaWR4XSkudG9GaXhlZCgyKTtcbiAgICAgICAgdXBTZEZyb21NZWFuID0gKGJpblVwQm91bmRzW2JfaWR4XSkudG9GaXhlZCgyKTtcbiAgICAgICAgaWYgKGJfaWR4ID09PSAwKSB7XG4gICAgICAgICAgICBiaW5MYWJlbHNbYl9pZHhdID0gXCI8IFwiICsgdXBTZEZyb21NZWFuO1xuICAgICAgICB9IGVsc2UgaWYgKGJfaWR4ID09PSBiaW5QYXJhbXMuYmluTnVtIC0gMSkge1xuICAgICAgICAgICAgYmluTGFiZWxzW2JfaWR4XSA9IFwiPiBcIiArIGxvd1NkRnJvbU1lYW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaW5MYWJlbHNbYl9pZHhdID0gbG93U2RGcm9tTWVhbiArIFwiLVwiICsgdXBTZEZyb21NZWFuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmluU3RhdHNbJ2dsb2JfbWVhbiddID0gZ2xvYl9tZWFuO1xuICAgIGJpblN0YXRzWydnbG9iX3NkJ10gPSBnbG9iX3NkO1xuICAgIGJpblN0YXRzWydiaW5VcEJvdW5kcyddID0gYmluVXBCb3VuZHM7XG4gICAgYmluU3RhdHNbJ2Jpbkxvd0JvdW5kcyddID0gYmluTG93Qm91bmRzO1xuICAgIGJpblN0YXRzWydiaW5NZWFucyddID0gYmluTWVhbnM7XG4gICAgYmluU3RhdHNbJ2JpbkxhYmVscyddID0gYmluTGFiZWxzO1xuXG4gICAgcmV0dXJuIHsnYmluU3RhdHMnOiBiaW5TdGF0c307XG59O1xuXG4vLyB1dGlsaXR5IHRoYXQgdGFrZXMgYW4gYXJyYXkgb2YgdXNlci1kZWZpbmVkIGJpbiBib3VuZHMgYW5kIHByb2R1Y2VzIGEgZGF0YSBzdHJ1Y3R1cmUgY29udGFpbmluZyBiaW4gaW5mb3JtYXRpb24gZm9yIGhpc3RvZ3JhbSBwbG90dGluZ1xuY29uc3QgcHJlc2NyaWJlSGlzdG9ncmFtQmlucyA9IGZ1bmN0aW9uIChjdXJ2ZVN1YlN0YXRzLCBjdXJ2ZVN1YlNlY3MsIGJpblBhcmFtcykge1xuXG4gICAgdmFyIGJpblN0YXRzID0ge307XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGdsb2JhbCBzdGF0cyBhY3Jvc3MgYWxsIG9mIHRoZSBkYXRhXG4gICAgY29uc3QgZ2xvYmFsU3RhdHMgPSBnZXRfZXJyKGN1cnZlU3ViU3RhdHMsIGN1cnZlU3ViU2VjcywgW10pOyAgIC8vIHdlIGRvbid0IG5lZWQgbGV2ZWxzIGZvciB0aGUgbWVhbiBvciBzZCBjYWxjdWxhdGlvbnMsIHNvIGp1c3QgcGFzcyBpbiBhbiBlbXB0eSBhcnJheVxuICAgIGNvbnN0IGdsb2JfbWVhbiA9IGdsb2JhbFN0YXRzLmRfbWVhbjtcbiAgICBjb25zdCBnbG9iX3NkID0gZ2xvYmFsU3RhdHMuc2Q7XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHVzZXItZGVmaW5lZCBiaW5zIGFyZSBpbiBvcmRlciBmcm9tIGxlYXN0IHRvIGdyZWF0ZXN0XG4gICAgYmluUGFyYW1zLmJpbkJvdW5kcyA9IGJpblBhcmFtcy5iaW5Cb3VuZHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGEpIC0gTnVtYmVyKGIpO1xuICAgIH0pO1xuXG4gICAgLy8gc3RvcmUgYW4gYXJyYXkgb2YgdGhlIHVwcGVyIGFuZCBsb3dlciBib3VuZGluZyB2YWx1ZXMgZm9yIGVhY2ggYmluLlxuICAgIHZhciBiaW5VcEJvdW5kcyA9IFtdO1xuICAgIHZhciBiaW5Mb3dCb3VuZHMgPSBbXTtcbiAgICB2YXIgYmluTWVhbnMgPSBbXTtcbiAgICB2YXIgYmluSW50ZXJ2YWxTdW0gPSAwO1xuICAgIGZvciAodmFyIGJfaWR4ID0gMTsgYl9pZHggPCBiaW5QYXJhbXMuYmluTnVtIC0gMTsgYl9pZHgrKykge1xuICAgICAgICBiaW5VcEJvdW5kc1tiX2lkeF0gPSBiaW5QYXJhbXMuYmluQm91bmRzW2JfaWR4XTtcbiAgICAgICAgYmluTG93Qm91bmRzW2JfaWR4XSA9IGJpblBhcmFtcy5iaW5Cb3VuZHNbYl9pZHggLSAxXTtcbiAgICAgICAgYmluTWVhbnNbYl9pZHhdID0gKGJpblVwQm91bmRzW2JfaWR4XSArIGJpbkxvd0JvdW5kc1tiX2lkeF0pIC8gMjtcbiAgICAgICAgYmluSW50ZXJ2YWxTdW0gPSBiaW5JbnRlcnZhbFN1bSArIChiaW5VcEJvdW5kc1tiX2lkeF0gLSBiaW5Mb3dCb3VuZHNbYl9pZHhdKTtcbiAgICB9XG4gICAgY29uc3QgYmluSW50ZXJ2YWxBdmVyYWdlID0gYmluSW50ZXJ2YWxTdW0gLyAoYmluUGFyYW1zLmJpbk51bSAtIDIpO1xuICAgIGJpblVwQm91bmRzWzBdID0gYmluTG93Qm91bmRzWzFdO1xuICAgIGJpbkxvd0JvdW5kc1swXSA9IC0xICogTnVtYmVyLk1BWF9WQUxVRTsgLy8gdGhlIGZpcnN0IGJpbiBzaG91bGQgaGF2ZSBldmVyeXRoaW5nIHRvbyBzbWFsbCB0byBmaXQgaW50byB0aGUgb3RoZXIgYmlucywgc28gbWFrZSBpdHMgbG93ZXIgYm91bmQgLTEgKiB0aGUgbWF4IG51bWJlciB2YWx1ZVxuICAgIGJpbk1lYW5zWzBdID0gYmluTG93Qm91bmRzWzFdIC0gYmluSW50ZXJ2YWxBdmVyYWdlIC8gMjsgLy8gdGhlIGJpbiBtZWFucyBmb3IgdGhlIGVkZ2UgYmlucyBpcyBhIGxpdHRsZSBhcmJpdHJhcnksIHNvIGJhc2UgaXQgb24gdGhlIGF2ZXJhZ2UgYmluIHdpZHRoXG4gICAgYmluVXBCb3VuZHNbYmluUGFyYW1zLmJpbk51bSAtIDFdID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gdGhlIGxhc3QgYmluIHNob3VsZCBoYXZlIGV2ZXJ5dGhpbmcgdG9vIGxhcmdlIHRvIGZpdCBpbnRvIHRoZSBwcmV2aW91cyBiaW5zLCBzbyBtYWtlIGl0cyB1cHBlciBib3VuZCB0aGUgbWF4IG51bWJlciB2YWx1ZVxuICAgIGJpbkxvd0JvdW5kc1tiaW5QYXJhbXMuYmluTnVtIC0gMV0gPSBiaW5VcEJvdW5kc1tiaW5QYXJhbXMuYmluTnVtIC0gMl07XG4gICAgYmluTWVhbnNbYmluUGFyYW1zLmJpbk51bSAtIDFdID0gYmluVXBCb3VuZHNbYmluUGFyYW1zLmJpbk51bSAtIDJdICsgYmluSW50ZXJ2YWxBdmVyYWdlIC8gMjsgLy8gdGhlIGJpbiBtZWFucyBmb3IgdGhlIGVkZ2UgYmlucyBpcyBhIGxpdHRsZSBhcmJpdHJhcnksIHNvIGJhc2UgaXQgb24gdGhlIGF2ZXJhZ2UgYmluIHdpZHRoXG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGxhYmVscyBmb3IgZWFjaCBiaW4sIGJhc2VkIG9uIHRoZSBkYXRhIGJvdW5kaW5nIHJhbmdlLCBmb3IgdGhlIGdyYXBoIHgtYXhpcyBsYXRlclxuICAgIHZhciBiaW5MYWJlbHMgPSBbXTtcbiAgICB2YXIgbG93U2RGcm9tTWVhbjtcbiAgICB2YXIgdXBTZEZyb21NZWFuO1xuICAgIGZvciAoYl9pZHggPSAwOyBiX2lkeCA8IGJpblBhcmFtcy5iaW5OdW07IGJfaWR4KyspIHtcbiAgICAgICAgbG93U2RGcm9tTWVhbiA9IChiaW5Mb3dCb3VuZHNbYl9pZHhdKS50b0ZpeGVkKDIpO1xuICAgICAgICB1cFNkRnJvbU1lYW4gPSAoYmluVXBCb3VuZHNbYl9pZHhdKS50b0ZpeGVkKDIpO1xuICAgICAgICBpZiAoYl9pZHggPT09IDApIHtcbiAgICAgICAgICAgIGJpbkxhYmVsc1tiX2lkeF0gPSBcIjwgXCIgKyB1cFNkRnJvbU1lYW47XG4gICAgICAgIH0gZWxzZSBpZiAoYl9pZHggPT09IGJpblBhcmFtcy5iaW5OdW0gLSAxKSB7XG4gICAgICAgICAgICBiaW5MYWJlbHNbYl9pZHhdID0gXCI+IFwiICsgbG93U2RGcm9tTWVhbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJpbkxhYmVsc1tiX2lkeF0gPSBsb3dTZEZyb21NZWFuICsgXCItXCIgKyB1cFNkRnJvbU1lYW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiaW5TdGF0c1snZ2xvYl9tZWFuJ10gPSBnbG9iX21lYW47XG4gICAgYmluU3RhdHNbJ2dsb2Jfc2QnXSA9IGdsb2Jfc2Q7XG4gICAgYmluU3RhdHNbJ2JpblVwQm91bmRzJ10gPSBiaW5VcEJvdW5kcztcbiAgICBiaW5TdGF0c1snYmluTG93Qm91bmRzJ10gPSBiaW5Mb3dCb3VuZHM7XG4gICAgYmluU3RhdHNbJ2Jpbk1lYW5zJ10gPSBiaW5NZWFucztcbiAgICBiaW5TdGF0c1snYmluTGFiZWxzJ10gPSBiaW5MYWJlbHM7XG5cbiAgICByZXR1cm4geydiaW5TdGF0cyc6IGJpblN0YXRzfTtcbn07XG5cbi8vIHV0aWxpdHkgdGhhdCB0YWtlcyBhcnJheXMgb2Ygc2Vjb25kcywgdmFsdWVzLCBhbmQgb3B0aW9uYWxseSBsZXZlbHMsIGFuZCBwcm9kdWNlcyBhIGRhdGEgc3RydWN0dXJlIGZvciBoaXN0b2dyYW0gZGF0YVxuLy8gcHJvY2Vzc2luZy4gVXNlZCBpbiB0aGUgaW5pdGlhbCBoaXN0b2dyYW0gREIgcXVlcnkgYW5kIGluIG1hdGNoaW5nLlxuY29uc3Qgc29ydEhpc3RvZ3JhbUJpbnMgPSBmdW5jdGlvbiAoY3VydmVTdWJTdGF0cywgY3VydmVTdWJTZWNzLCBjdXJ2ZVN1YkxldnMsIGJpbk51bSwgbWFzdGVyQmluU3RhdHMsIGhhc0xldmVscywgZCkge1xuXG4gICAgLy8gbmVlZCBtYXBzIHRvIGhvbGQgdGhlIHN1YiB2YWx1ZXMgYW5kIHNlY29uZHMgKGFuZCBsZXZlbHMpIGZvciBlYWNoIGJpbiwgYWZ0ZXIgdGhlIGJpbiBib3VuZHMgYXJlIGNhbGN1bGF0ZWQuXG4gICAgdmFyIGJpblN1YlN0YXRzID0ge307XG4gICAgdmFyIGJpblN1YlNlY3MgPSB7fTtcbiAgICB2YXIgYmluU3ViTGV2cyA9IHt9O1xuXG4gICAgZm9yICh2YXIgYl9pZHggPSAwOyBiX2lkeCA8IGJpbk51bTsgYl9pZHgrKykge1xuICAgICAgICBiaW5TdWJTdGF0c1tiX2lkeF0gPSBbXTtcbiAgICAgICAgYmluU3ViU2Vjc1tiX2lkeF0gPSBbXTtcbiAgICAgICAgYmluU3ViTGV2c1tiX2lkeF0gPSBbXTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGdsb2JhbCBzdGF0cyBhY3Jvc3MgYWxsIG9mIHRoZSBkYXRhXG4gICAgdmFyIGdsb2JhbFN0YXRzO1xuICAgIGlmIChoYXNMZXZlbHMpIHtcbiAgICAgICAgZ2xvYmFsU3RhdHMgPSBnZXRfZXJyKGN1cnZlU3ViU3RhdHMsIGN1cnZlU3ViU2VjcywgY3VydmVTdWJMZXZzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbG9iYWxTdGF0cyA9IGdldF9lcnIoY3VydmVTdWJTdGF0cywgY3VydmVTdWJTZWNzLCBbXSk7XG4gICAgfVxuICAgIGNvbnN0IGdsb2JfbWVhbiA9IGdsb2JhbFN0YXRzLmRfbWVhbjtcbiAgICBjb25zdCBnbG9iX3NkID0gZ2xvYmFsU3RhdHMuc2Q7XG4gICAgY29uc3QgZ2xvYl9uID0gZ2xvYmFsU3RhdHMubl9nb29kO1xuICAgIGNvbnN0IGdsb2JfbWF4ID0gZ2xvYmFsU3RhdHMubWF4VmFsO1xuICAgIGNvbnN0IGdsb2JfbWluID0gZ2xvYmFsU3RhdHMubWluVmFsO1xuXG4gICAgLy8gc29ydCBkYXRhIGludG8gYmluc1xuICAgIGNvbnN0IGJpblVwQm91bmRzID0gbWFzdGVyQmluU3RhdHMuYmluVXBCb3VuZHM7XG4gICAgY29uc3QgYmluTG93Qm91bmRzID0gbWFzdGVyQmluU3RhdHMuYmluTG93Qm91bmRzO1xuICAgIGNvbnN0IGJpbk1lYW5zID0gbWFzdGVyQmluU3RhdHMuYmluTWVhbnM7XG4gICAgY29uc3QgYmluTGFiZWxzID0gbWFzdGVyQmluU3RhdHMuYmluTGFiZWxzO1xuXG4gICAgZm9yICh2YXIgZF9pZHggPSAwOyBkX2lkeCA8IGN1cnZlU3ViU3RhdHMubGVuZ3RoOyBkX2lkeCsrKSB7XG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGJpbnMgdW50aWwgd2UgZmluZCBvbmUgd2hlcmUgdGhlIHVwcGVyIGxpbWl0IGlzIGdyZWF0ZXIgdGhhbiBvdXIgZGF0dW0uXG4gICAgICAgIGZvciAoYl9pZHggPSAwOyBiX2lkeCA8IGJpbk51bTsgYl9pZHgrKykge1xuICAgICAgICAgICAgaWYgKGN1cnZlU3ViU3RhdHNbZF9pZHhdIDw9IGJpblVwQm91bmRzW2JfaWR4XSkge1xuICAgICAgICAgICAgICAgIGJpblN1YlN0YXRzW2JfaWR4XS5wdXNoKGN1cnZlU3ViU3RhdHNbZF9pZHhdKTtcbiAgICAgICAgICAgICAgICBiaW5TdWJTZWNzW2JfaWR4XS5wdXNoKGN1cnZlU3ViU2Vjc1tkX2lkeF0pO1xuICAgICAgICAgICAgICAgIGlmIChoYXNMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluU3ViTGV2c1tiX2lkeF0ucHVzaChjdXJ2ZVN1YkxldnNbZF9pZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHN0YXRpc3RpY3MgZm9yIGVhY2ggYmluXG4gICAgLy8gd2UgYXJlIGVzcGVjaWFsbHkgaW50ZXJlc3RlZCBpbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyBpbiBlYWNoIGJpbiwgYXMgdGhhdCBpcyB0aGUgcGxvdHRlZCBzdGF0IGluIGEgaGlzdG9ncmFtXG4gICAgdmFyIGJpblN0YXRzO1xuICAgIHZhciBiaW5fbWVhbjtcbiAgICB2YXIgYmluX3NkO1xuICAgIHZhciBiaW5fbjtcbiAgICB2YXIgYmluX3JmO1xuXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKGJfaWR4ID0gMDsgYl9pZHggPCBiaW5OdW07IGJfaWR4KyspIHtcbiAgICAgICAgaWYgKGhhc0xldmVscykge1xuICAgICAgICAgICAgYmluU3RhdHMgPSBnZXRfZXJyKGJpblN1YlN0YXRzW2JfaWR4XSwgYmluU3ViU2Vjc1tiX2lkeF0sIGJpblN1YkxldnNbYl9pZHhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJpblN0YXRzID0gZ2V0X2VycihiaW5TdWJTdGF0c1tiX2lkeF0sIGJpblN1YlNlY3NbYl9pZHhdLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgYmluX21lYW4gPSBiaW5TdGF0cy5kX21lYW47XG4gICAgICAgIGJpbl9zZCA9IGJpblN0YXRzLnNkO1xuICAgICAgICBiaW5fbiA9IGJpblN0YXRzLm5fZ29vZDtcbiAgICAgICAgYmluX3JmID0gYmluX24gLyBnbG9iX247XG5cbiAgICAgICAgLypcbiAgICAgICAgdmFyIGQgPSB7Ly8gZCB3aWxsIGNvbnRhaW4gdGhlIGN1cnZlIGRhdGFcbiAgICAgICAgICAgIHg6IFtdLCAvL3BsYWNlaG9sZGVyXG4gICAgICAgICAgICB5OiBbXSwgLy9wbGFjZWhvbGRlclxuICAgICAgICAgICAgZXJyb3JfeDogW10sIC8vIHVudXNlZFxuICAgICAgICAgICAgZXJyb3JfeTogW10sIC8vIHVudXNlZFxuICAgICAgICAgICAgc3ViVmFsczogW10sXG4gICAgICAgICAgICBzdWJTZWNzOiBbXSxcbiAgICAgICAgICAgIHN1YkxldnM6IFtdLFxuICAgICAgICAgICAgZ2xvYl9zdGF0czoge30sIC8vIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICBiaW5fc3RhdHM6IFtdLCAvLyBwbGFjZWhvbGRlclxuICAgICAgICAgICAgdGV4dDogW10sIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHhtYXg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICB4bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgeW1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIHltaW46IE51bWJlci5NQVhfVkFMVUVcbiAgICAgICAgfTtcbiAgICAgICAgKi9cblxuICAgICAgICBkLngucHVzaChiaW5NZWFuc1tiX2lkeF0pO1xuICAgICAgICBkLnkucHVzaChiaW5fbik7XG4gICAgICAgIGQuc3ViVmFscy5wdXNoKGJpblN1YlN0YXRzW2JfaWR4XSk7XG4gICAgICAgIGQuc3ViU2Vjcy5wdXNoKGJpblN1YlNlY3NbYl9pZHhdKTtcbiAgICAgICAgZC5iaW5fc3RhdHMucHVzaCh7XG4gICAgICAgICAgICAnYmluX21lYW4nOiBiaW5fbWVhbixcbiAgICAgICAgICAgICdiaW5fc2QnOiBiaW5fc2QsXG4gICAgICAgICAgICAnYmluX24nOiBiaW5fbixcbiAgICAgICAgICAgICdiaW5fcmYnOiBiaW5fcmYsXG4gICAgICAgICAgICAnYmluTG93Qm91bmQnOiBiaW5Mb3dCb3VuZHNbYl9pZHhdLFxuICAgICAgICAgICAgJ2JpblVwQm91bmQnOiBiaW5VcEJvdW5kc1tiX2lkeF0sXG4gICAgICAgICAgICAnYmluTGFiZWwnOiBiaW5MYWJlbHNbYl9pZHhdXG4gICAgICAgIH0pO1xuICAgICAgICBkLnRleHQucHVzaChudWxsKTtcblxuICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICBkLnN1YkxldnMucHVzaChiaW5TdWJMZXZzW2JfaWR4XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgYXhpcyBsaW1pdHMgYmFzZWQgb24gcmV0dXJuZWQgZGF0YVxuICAgICAgICBpZiAoZC55W2JfaWR4XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3VtID0gc3VtICsgZC55W2JfaWR4XTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICBkLnltaW4gPSBkLnltaW4gPCBkLnlbYl9pZHhdID8gZC55bWluIDogZC55W2JfaWR4XTtcbiAgICAgICAgICAgIGQueW1heCA9IGQueW1heCA+IGQueVtiX2lkeF0gPyBkLnltYXggOiBkLnlbYl9pZHhdO1xuICAgICAgICB9XG5cbiAgICB9XG4gICAgZC5nbG9iX3N0YXRzID0ge1xuICAgICAgICAnZ2xvYl9tZWFuJzogZ2xvYl9tZWFuLFxuICAgICAgICAnZ2xvYl9zZCc6IGdsb2Jfc2QsXG4gICAgICAgICdnbG9iX24nOiBnbG9iX24sXG4gICAgICAgICdnbG9iX21heCc6IGdsb2JfbWF4LFxuICAgICAgICAnZ2xvYl9taW4nOiBnbG9iX21pblxuICAgIH07XG4gICAgZC54bWluID0gZC54WzBdO1xuICAgIGQueG1heCA9IGQueFtiaW5OdW0gLSAxXTtcblxuICAgIHJldHVybiB7ZDogZH07XG59O1xuXG4vLyB1dGlsaXR5IHRoYXQgdGFrZXMgdGhlIGN1cnZlIHBhcmFtcyBmb3IgdHdvIGNvbnRvdXIgcGxvdHMgYW5kIGNvbGxhcHNlcyB0aGVtIGludG8gdGhlIGN1cnZlIHBhcmFtcyBmb3Igb25lIGRpZmYgY29udG91ci5cbmNvbnN0IGdldERpZmZDb250b3VyQ3VydmVQYXJhbXMgPSBmdW5jdGlvbiAoY3VydmVzKSB7XG5cbiAgICB2YXIgbmV3Q3VydmUgPSB7fTtcbiAgICBjb25zdCBjdXJ2ZUtleXMgPSBPYmplY3Qua2V5cyhjdXJ2ZXNbMF0pO1xuICAgIHZhciBjdXJyS2V5O1xuICAgIGZvciAodmFyIGNraWR4ID0gMDsgY2tpZHggPCBjdXJ2ZUtleXMubGVuZ3RoOyBja2lkeCsrKSB7XG4gICAgICAgIGN1cnJLZXkgPSBjdXJ2ZUtleXNbY2tpZHhdO1xuICAgICAgICBpZiAoY3VycktleSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgbmV3Q3VydmVbJ2NvbG9yJ10gPSBcInJnYigyNTUsMTY1LDApXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VydmVzWzBdW2N1cnJLZXldID09PSBjdXJ2ZXNbMV1bY3VycktleV0pIHtcbiAgICAgICAgICAgIG5ld0N1cnZlW2N1cnJLZXldID0gY3VydmVzWzBdW2N1cnJLZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q3VydmVbY3VycktleV0gPSBjdXJ2ZXNbMV1bY3VycktleV0gKyBcIi1cIiArIGN1cnZlc1swXVtjdXJyS2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW25ld0N1cnZlXTtcbn07XG5cbi8vdXNlZCBmb3Igc29ydGluZyBhcnJheXNcbmNvbnN0IHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGFbMF0gPT09IGJbMF0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKGFbMF0gPCBiWzBdKSA/IC0xIDogMTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXRzRGF0YVV0aWxzID0ge1xuXG4gICAgYXJlT2JqZWN0c0VxdWFsOiBhcmVPYmplY3RzRXF1YWwsXG4gICAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gICAgYXJyYXlDb250YWluc1N1YkFycmF5OiBhcnJheUNvbnRhaW5zU3ViQXJyYXksXG4gICAgYXJyYXlzRXF1YWw6IGFycmF5c0VxdWFsLFxuICAgIGFycmF5VW5pcXVlOiBhcnJheVVuaXF1ZSxcbiAgICBmaW5kQXJyYXlJblN1YkFycmF5OiBmaW5kQXJyYXlJblN1YkFycmF5LFxuICAgIG9iamVjdENvbnRhaW5zT2JqZWN0OiBvYmplY3RDb250YWluc09iamVjdCxcbiAgICBhdmVyYWdlOiBhdmVyYWdlLFxuICAgIHN0ZGV2OiBzdGRldixcbiAgICBkYXRlQ29udmVydDogZGF0ZUNvbnZlcnQsXG4gICAgZ2V0RGF0ZVJhbmdlOiBnZXREYXRlUmFuZ2UsXG4gICAgc2Vjc0NvbnZlcnQ6IHNlY3NDb252ZXJ0LFxuICAgIGRvQXV0aG9yaXphdGlvbjogZG9BdXRob3JpemF0aW9uLFxuICAgIGRvQ29sb3JTY2hlbWU6IGRvQ29sb3JTY2hlbWUsXG4gICAgZG9DcmVkZW50aWFsczogZG9DcmVkZW50aWFscyxcbiAgICBkb1JvbGVzOiBkb1JvbGVzLFxuICAgIGRvU2V0dGluZ3M6IGRvU2V0dGluZ3MsXG4gICAgZ2V0UGxvdFBhcmFtc0Zyb21TdGFjazogZ2V0UGxvdFBhcmFtc0Zyb21TdGFjayxcbiAgICBnZXRfZXJyOiBnZXRfZXJyLFxuICAgIHNldEhpc3RvZ3JhbVBhcmFtZXRlcnM6IHNldEhpc3RvZ3JhbVBhcmFtZXRlcnMsXG4gICAgY2FsY3VsYXRlSGlzdG9ncmFtQmluczogY2FsY3VsYXRlSGlzdG9ncmFtQmlucyxcbiAgICBwcmVzY3JpYmVIaXN0b2dyYW1CaW5zOiBwcmVzY3JpYmVIaXN0b2dyYW1CaW5zLFxuICAgIHNvcnRIaXN0b2dyYW1CaW5zOiBzb3J0SGlzdG9ncmFtQmlucyxcbiAgICBnZXREaWZmQ29udG91ckN1cnZlUGFyYW1zOiBnZXREaWZmQ29udG91ckN1cnZlUGFyYW1zLFxuICAgIHNvcnRGdW5jdGlvbjogc29ydEZ1bmN0aW9uLFxuXG59IiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbmltcG9ydCB7bWF0c0RhdGFVdGlscywgbWF0c1R5cGVzLCBtYXRzQ29sbGVjdGlvbnN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaW1wb3J0IHtNZXRlb3J9IGZyb20gXCJtZXRlb3IvbWV0ZW9yXCI7XG5cbi8vY29uc3QgRnV0dXJlID0gcmVxdWlyZSgnZmliZXJzL2Z1dHVyZScpO1xuXG4vL3V0aWxpdHkgdG8gZ2V0IHRoZSBjYWRlbmNlIGZvciBhIHBhcnRpY3VsYXIgbW9kZWwsIHNvIHRoYXQgdGhlIHF1ZXJ5IGZ1bmN0aW9uXG4vL2tub3dzIHdoZXJlIHRvIGluY2x1ZGUgbnVsbCBwb2ludHMgZm9yIG1pc3NpbmcgZGF0YS5cbmNvbnN0IGdldE1vZGVsQ2FkZW5jZSA9IGZ1bmN0aW9uIChwb29sLCBkYXRhU291cmNlLCBzdGFydERhdGUsIGVuZERhdGUpIHtcbiAgICB2YXIgcm93cyA9IFtdO1xuICAgIHZhciBjeWNsZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgLy90aGlzIHF1ZXJ5IHNob3VsZCBvbmx5IHJldHVybiBkYXRhIGlmIHRoZSBtb2RlbCBjYWRlbmNlIGlzIGlycmVndWxhci5cbiAgICAgICAgLy9vdGhlcndpc2UsIHRoZSBjYWRlbmNlIHdpbGwgYmUgY2FsY3VsYXRlZCBsYXRlciBieSB0aGUgcXVlcnkgZnVuY3Rpb24uXG4gICAgICAgIHJvd3MgPSBzaW1wbGVQb29sUXVlcnlXcmFwU3luY2hyb25vdXMocG9vbCwgXCJzZWxlY3QgY3ljbGVfc2Vjb25kcyBcIiArXG4gICAgICAgICAgICBcImZyb20gbWF0c19jb21tb24ucHJpbWFyeV9tb2RlbF9vcmRlcnMgXCIgK1xuICAgICAgICAgICAgXCJ3aGVyZSBtb2RlbCA9IFwiICtcbiAgICAgICAgICAgIFwiKHNlbGVjdCBuZXdfbW9kZWwgYXMgZGlzcGxheV90ZXh0IGZyb20gbWF0c19jb21tb24uc3RhbmRhcmRpemVkX21vZGVsX2xpc3Qgd2hlcmUgb2xkX21vZGVsID0gJ1wiICsgZGF0YVNvdXJjZSArIFwiJyk7XCIpO1xuICAgICAgICB2YXIgY3ljbGVzX3JhdyA9IEpTT04ucGFyc2Uocm93c1swXS5jeWNsZV9zZWNvbmRzKTtcbiAgICAgICAgdmFyIGN5Y2xlc19rZXlzID0gT2JqZWN0LmtleXMoY3ljbGVzX3Jhdykuc29ydCgpO1xuICAgICAgICAvL3RoZXJlIGNhbiBiZSBkaWZmZXJlbmNlIGNhZGVuY2VzIGZvciBkaWZmZXJlbnQgdGltZSBwZXJpb2RzIChlYWNoIHRpbWUgcGVyaW9kIGlzIGEga2V5IGluIGN5Y2xlc19rZXlzLFxuICAgICAgICAvL3dpdGggdGhlIGNhZGVuY2VzIGZvciB0aGF0IHBlcmlvZCByZXByZXNlbnRlZCBhcyB2YWx1ZXMgaW4gY3ljbGVzX3JhdyksIHNvIHRoaXMgc2VjdGlvbiBpZGVudGlmaWVzIGFsbFxuICAgICAgICAvL3RpbWUgcGVyaW9kcyByZWxldmFudCB0byB0aGUgcmVxdWVzdGVkIGRhdGUgcmFuZ2UsIGFuZCByZXR1cm5zIHRoZSB1bmlvbiBvZiB0aGVpciBjYWRlbmNlcy5cbiAgICAgICAgaWYgKGN5Y2xlc19rZXlzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIG5ld1RpbWU7XG4gICAgICAgICAgICB2YXIgY2hvc2VuU3RhcnRUaW1lO1xuICAgICAgICAgICAgdmFyIGNob3NlbkVuZFRpbWU7XG4gICAgICAgICAgICB2YXIgY2hvc2VuU3RhcnRJZHg7XG4gICAgICAgICAgICB2YXIgY2hvc2VuRW5kSWR4O1xuICAgICAgICAgICAgdmFyIGZvdW5kU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBmb3VuZEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgdGkgPSBjeWNsZXNfa2V5cy5sZW5ndGggLSAxOyB0aSA+PSAwOyB0aS0tKSB7XG4gICAgICAgICAgICAgICAgbmV3VGltZSA9IGN5Y2xlc19rZXlzW3RpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlID49IE51bWJlcihuZXdUaW1lKSAmJiAhZm91bmRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjaG9zZW5TdGFydFRpbWUgPSBuZXdUaW1lO1xuICAgICAgICAgICAgICAgICAgICBjaG9zZW5TdGFydElkeCA9IHRpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZERhdGUgPj0gTnVtYmVyKG5ld1RpbWUpICYmICFmb3VuZEVuZCkge1xuICAgICAgICAgICAgICAgICAgICBjaG9zZW5FbmRUaW1lID0gbmV3VGltZTtcbiAgICAgICAgICAgICAgICAgICAgY2hvc2VuRW5kSWR4ID0gdGk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kU3RhcnQgJiYgZm91bmRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNob3NlblN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkICYmIGNob3NlbkVuZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIoY2hvc2VuU3RhcnRUaW1lKSA9PT0gTnVtYmVyKGNob3NlbkVuZFRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlcyA9IGN5Y2xlc19yYXdbY2hvc2VuU3RhcnRUaW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNob3NlbkVuZElkeCAtIGNob3NlblN0YXJ0SWR4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q3ljbGVzID0gY3ljbGVzX3Jhd1tjaG9zZW5TdGFydFRpbWVdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRDeWNsZXMgPSBjeWNsZXNfcmF3W2Nob3NlbkVuZFRpbWVdO1xuICAgICAgICAgICAgICAgICAgICBjeWNsZXMgPSBfLnVuaW9uKHN0YXJ0Q3ljbGVzLCBlbmRDeWNsZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaWRkbGVDeWNsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJDeWNsZXM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodGkgPSBjaG9zZW5TdGFydElkeCArIDE7IHRpIDwgY2hvc2VuRW5kSWR4OyB0aSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyQ3ljbGVzID0gY3ljbGVzX3Jhd1tjeWNsZXNfa2V5c1t0aV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkZGxlQ3ljbGVzID0gXy51bmlvbihtaWRkbGVDeWNsZXMsIGN1cnJDeWNsZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q3ljbGVzID0gY3ljbGVzX3Jhd1tjaG9zZW5TdGFydFRpbWVdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRDeWNsZXMgPSBjeWNsZXNfcmF3W2Nob3NlbkVuZFRpbWVdO1xuICAgICAgICAgICAgICAgICAgICBjeWNsZXMgPSBfLnVuaW9uKHN0YXJ0Q3ljbGVzLCBlbmRDeWNsZXMsIG1pZGRsZUN5Y2xlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvL2lnbm9yZSAtIGp1c3QgYSBzYWZldHkgY2hlY2ssIGRvbid0IHdhbnQgdG8gZXhpdCBpZiB0aGVyZSBpc24ndCBhIGN5Y2xlc19wZXJfbW9kZWwgZW50cnlcbiAgICAgICAgLy9pZiB0aGVyZSBpc24ndCBhIGN5Y2xlc19wZXJfbW9kZWwgZW50cnksIGl0IGp1c3QgbWVhbnMgdGhhdCB0aGUgbW9kZWwgaGFzIGEgcmVndWxhciBjYWRlbmNlXG4gICAgfVxuICAgIGlmIChjeWNsZXMgIT09IG51bGwgJiYgY3ljbGVzICE9PSB1bmRlZmluZWQgJiYgY3ljbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjeWNsZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGN5Y2xlc1tjXSA9IGN5Y2xlc1tjXSAqIDEwMDA7ICAgICAgICAgLy8gY29udmVydCB0byBtaWxsaXNlY29uZHNcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGN5Y2xlcyA9IFtdOyAvL3JlZ3VsYXIgY2FkZW5jZSBtb2RlbC0tY3ljbGVzIHdpbGwgYmUgY2FsY3VsYXRlZCBsYXRlciBieSB0aGUgcXVlcnkgZnVuY3Rpb25cbiAgICB9XG4gICAgcmV0dXJuIGN5Y2xlcztcbn07XG5cbi8vdGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZSBjdXJyZW50IHRpbWUgYW5kIHRoZSBuZXh0IHRpbWUgZm9yIGlycmVndWxhciBjYWRlbmNlIG1vZGVscy5cbmNvbnN0IGdldFRpbWVJbnRlcnZhbCA9IGZ1bmN0aW9uIChhdlRpbWUsIHRpbWVfaW50ZXJ2YWwsIGZvcmVDYXN0T2Zmc2V0LCBjeWNsZXMpIHtcbiAgICAvL2hhdmUgdG8gY2FsY3VsYXRlIHRoZSB0aW1lX2ludGVydmFsXG4gICAgdmFyIHRpO1xuICAgIHZhciBkYXlJbk1pbGxpU2Vjb25kcyA9IDI0ICogMzYwMCAqIDEwMDA7XG4gICAgdmFyIG1pbkN5Y2xlVGltZSA9IE1hdGgubWluKC4uLmN5Y2xlcyk7XG5cbiAgICB2YXIgdGhpc0NhZGVuY2UgPSAoYXZUaW1lICUgZGF5SW5NaWxsaVNlY29uZHMpOyAvL2N1cnJlbnQgaG91ciBvZiBkYXkgKHZhbGlkIHRpbWUpXG4gICAgaWYgKE51bWJlcih0aGlzQ2FkZW5jZSkgLSAoTnVtYmVyKGZvcmVDYXN0T2Zmc2V0KSAqIDM2MDAgKiAxMDAwKSA8IDApIHsgLy9jaGVjayB0byBzZWUgaWYgY3ljbGUgdGltZSB3YXMgb24gcHJldmlvdXMgZGF5IC0tIGlmIHNvLCBuZWVkIHRvIHdyYXAgYXJvdW5kIDAwWiB0byBnZXQgY3VycmVudCBob3VyIG9mIGRheSAoY3ljbGUgdGltZSlcbiAgICAgICAgdGhpc0NhZGVuY2UgPSAoTnVtYmVyKHRoaXNDYWRlbmNlKSAtIChOdW1iZXIoZm9yZUNhc3RPZmZzZXQpICogMzYwMCAqIDEwMDApICsgZGF5SW5NaWxsaVNlY29uZHMpOyAvL2N1cnJlbnQgaG91ciBvZiBkYXkgKGN5Y2xlIHRpbWUpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc0NhZGVuY2UgPSAoTnVtYmVyKHRoaXNDYWRlbmNlKSAtIChOdW1iZXIoZm9yZUNhc3RPZmZzZXQpICogMzYwMCAqIDEwMDApKTsgLy9jdXJyZW50IGhvdXIgb2YgZGF5IChjeWNsZSB0aW1lKVxuICAgIH1cblxuICAgIHZhciB0aGlzQ2FkZW5jZUlkeCA9IGN5Y2xlcy5pbmRleE9mKHRoaXNDYWRlbmNlKTsgLy9mbmQgb3VyIHdoZXJlIHRoZSBjdXJyZW50IGhvdXIgb2YgZGF5IGlzIGluIHRoZSBjeWNsZXMgYXJyYXlcbiAgICBpZiAodGhpc0NhZGVuY2VJZHggIT09IC0xKSB7XG4gICAgICAgIHZhciBuZXh0Q2FkZW5jZUlkeCA9IHRoaXNDYWRlbmNlSWR4ICsgMTsgLy9jaG9vc2UgdGhlIG5leHQgaG91ciBvZiB0aGUgZGF5XG4gICAgICAgIGlmIChuZXh0Q2FkZW5jZUlkeCA+PSBjeWNsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aSA9IChkYXlJbk1pbGxpU2Vjb25kcyAtIHRoaXNDYWRlbmNlKSArIG1pbkN5Y2xlVGltZTsgLy9pZiB3ZSB3ZXJlIGF0IHRoZSBsYXN0IGN5Y2xlIGNhZGVuY2UsIHdyYXAgYmFjayBhcm91bmQgdG8gdGhlIGZpcnN0IGN5Y2xlIGNhZGVuY2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpID0gY3ljbGVzW25leHRDYWRlbmNlSWR4XSAtIGN5Y2xlc1t0aGlzQ2FkZW5jZUlkeF07IC8vb3RoZXJ3aXNlIHRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgbmV4dCBob3VycyBvZiB0aGUgZGF5LlxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGkgPSB0aW1lX2ludGVydmFsOyAvL2lmIGZvciBzb21lIHJlYXNvbiB0aGUgY3VycmVudCBob3VyIG9mIHRoZSBkYXkgaXNuJ3QgaW4gdGhlIGN5Y2xlcyBhcnJheSwgZGVmYXVsdCB0byB0aGUgcmVndWxhciBjYWRlbmNlIGludGVydmFsXG4gICAgfVxuXG4gICAgcmV0dXJuIHRpO1xufTtcblxuLy91dGlsaXR5IGZvciBxdWVyeWluZyB0aGUgREJcbmNvbnN0IHNpbXBsZVBvb2xRdWVyeVdyYXBTeW5jaHJvbm91cyA9IGZ1bmN0aW9uIChwb29sLCBzdGF0ZW1lbnQpIHtcbiAgICAvKlxuICAgICBzaW1wbGUgc3luY2hyb25vdXMgcXVlcnkgb2Ygc3RhdGVtZW50IHRvIHRoZSBzcGVjaWZpZWQgcG9vbC5cbiAgICAgcGFyYW1zIDpcbiAgICAgcG9vbCAtIGEgcHJlZGVmaW5lZCBkYiBwb29sICh1c3VhbGx5IGRlZmluZWQgaW4gbWFpbi5qcykuIGkuZS4gd2ZpcDJQb29sID0gbXlzcWwuY3JlYXRlUG9vbCh3ZmlwMlNldHRpbmdzKTtcbiAgICAgc3RhdGVtZW50IC0gU3RyaW5nIC0gYSB2YWxpZCBzcWwgc3RhdGVtZW50XG4gICAgIGFjdGlvbnMgLSBxdWVyaWVzIGRhdGFiYXNlIGFuZCB3aWxsIHdhaXQgdW50aWwgcXVlcnkgcmV0dXJucy5cbiAgICAgcmV0dXJuOiByb3dzZXQgLSBhbiBhcnJheSBvZiByb3dzXG4gICAgIHRocm93czogZXJyb3JcbiAgICAgKi9cbiAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgIGNvbnN0IEZ1dHVyZSA9IHJlcXVpcmUoJ2ZpYmVycy9mdXR1cmUnKTtcbiAgICAgICAgY29uc3QgcXVlcnlXcmFwID0gRnV0dXJlLndyYXAoZnVuY3Rpb24gKHBvb2wsIHN0YXRlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHBvb2wucXVlcnkoc3RhdGVtZW50LCBmdW5jdGlvbiAoZXJyLCByb3dzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcm93cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWVyeVdyYXAocG9vbCwgc3RhdGVtZW50KS53YWl0KCk7XG4gICAgfVxufTtcblxuLy90aGlzIG1ldGhvZCBxdWVyaWVzIHRoZSBkYXRhYmFzZSBmb3IgdGltZXNlcmllcyBwbG90c1xuY29uc3QgcXVlcnlEQlRpbWVTZXJpZXMgPSBmdW5jdGlvbiAocG9vbCwgc3RhdGVtZW50LCBkYXRhU291cmNlLCBmb3JlY2FzdE9mZnNldCwgc3RhcnREYXRlLCBlbmREYXRlLCBhdmVyYWdlU3RyLCB2YWxpZFRpbWVzLCBoYXNMZXZlbHMsIGZvcmNlUmVndWxhckNhZGVuY2UpIHtcbiAgICAvL3VwcGVyIGFpciBpcyBvbmx5IHZlcmlmaWVkIGF0IDAwWiBhbmQgMTJaLCBzbyB5b3UgbmVlZCB0byBmb3JjZSBpcnJlZ3VsYXIgbW9kZWxzIHRvIHZlcmlmeSBhdCB0aGF0IHJlZ3VsYXIgY2FkZW5jZVxuICAgIGNvbnN0IEZ1dHVyZSA9IHJlcXVpcmUoJ2ZpYmVycy9mdXR1cmUnKTtcbiAgICBpZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgICAgIGNvbnN0IHBsb3RQYXJhbXMgPSBtYXRzRGF0YVV0aWxzLmdldFBsb3RQYXJhbXNGcm9tU3RhY2soKTtcbiAgICAgICAgY29uc3QgY29tcGxldGVuZXNzUUNQYXJhbSA9IE51bWJlcihwbG90UGFyYW1zW1wiY29tcGxldGVuZXNzXCJdKSAvIDEwMDtcblxuICAgICAgICB2YXIgY3ljbGVzID0gZ2V0TW9kZWxDYWRlbmNlKHBvb2wsIGRhdGFTb3VyY2UsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7IC8vIGlmIGlycmVndWxhciBtb2RlbCBjYWRlbmNlLCBnZXQgY3ljbGUgdGltZXMuIElmIHJlZ3VsYXIsIGdldCBlbXB0eSBhcnJheS5cbiAgICAgICAgaWYgKHZhbGlkVGltZXMubGVuZ3RoID4gMCAmJiB2YWxpZFRpbWVzICE9PSBtYXRzVHlwZXMuSW5wdXRUeXBlcy51bnVzZWQpIHtcbiAgICAgICAgICAgIHZhciB2dEN5Y2xlcyA9IHZhbGlkVGltZXMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoeCkgLSBmb3JlY2FzdE9mZnNldCkgKiAzNjAwICogMTAwMDtcbiAgICAgICAgICAgIH0pOyAvLyBzZWxlY3RpbmcgdmFsaWRUaW1lcyBtYWtlcyB0aGUgY2FkZW5jZSBpcnJlZ3VsYXJcbiAgICAgICAgICAgIHZ0Q3ljbGVzID0gdnRDeWNsZXMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPCAwID8gKHggKyAyNCAqIDM2MDAgKiAxMDAwKSA6IHg7XG4gICAgICAgICAgICB9KTsgLy8gbWFrZSBzdXJlIG5vIGN5Y2xlcyBhcmUgbmVnYXRpdmVcbiAgICAgICAgICAgIHZ0Q3ljbGVzID0gdnRDeWNsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoYSkgLSBOdW1iZXIoYik7XG4gICAgICAgICAgICB9KTsgLy9zb3J0ICdlbVxuICAgICAgICAgICAgY3ljbGVzID0gY3ljbGVzLmxlbmd0aCA+IDAgPyBfLmludGVyc2VjdGlvbihjeWNsZXMsIHZ0Q3ljbGVzKSA6IHZ0Q3ljbGVzOyAvLyBpZiB3ZSBhbHJlYWR5IGhhZCBjeWNsZXMgZ2V0IHRoZSBvbmVzIHRoYXQgY29ycmVzcG9uZCB0byB2YWxpZCB0aW1lc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZ3VsYXIgPSAoZm9yY2VSZWd1bGFyQ2FkZW5jZSB8fCBhdmVyYWdlU3RyICE9PSBcIk5vbmVcIiB8fCAhKGN5Y2xlcyAhPT0gbnVsbCAmJiBjeWNsZXMubGVuZ3RoID4gMCkpOyAvLyBJZiBjdXJ2ZXMgaGF2ZSBhdmVyYWdpbmcsIHRoZSBjYWRlbmNlIGlzIGFsd2F5cyByZWd1bGFyLCBpLmUuIGl0J3MgdGhlIGNhZGVuY2Ugb2YgdGhlIGF2ZXJhZ2VcblxuICAgICAgICB2YXIgZEZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICAgICAgdmFyIGQgPSB7Ly8gZCB3aWxsIGNvbnRhaW4gdGhlIGN1cnZlIGRhdGFcbiAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICBlcnJvcl94OiBbXSxcbiAgICAgICAgICAgIGVycm9yX3k6IFtdLFxuICAgICAgICAgICAgc3ViVmFsczogW10sXG4gICAgICAgICAgICBzdWJTZWNzOiBbXSxcbiAgICAgICAgICAgIHN1YkxldnM6IFtdLFxuICAgICAgICAgICAgc3RhdHM6IFtdLFxuICAgICAgICAgICAgdGV4dDogW10sXG4gICAgICAgICAgICB4bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgeG1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIHltaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB5bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgc3VtOiAwXG4gICAgICAgIH07XG4gICAgICAgIHZhciBlcnJvciA9IFwiXCI7XG4gICAgICAgIHZhciBOMCA9IFtdO1xuICAgICAgICB2YXIgTl90aW1lcyA9IFtdO1xuXG4gICAgICAgIHBvb2wucXVlcnkoc3RhdGVtZW50LCBmdW5jdGlvbiAoZXJyLCByb3dzKSB7XG4gICAgICAgICAgICAvLyBxdWVyeSBjYWxsYmFjayAtIGJ1aWxkIHRoZSBjdXJ2ZSBkYXRhIGZyb20gdGhlIHJlc3VsdHMgLSBvciBzZXQgYW4gZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCAmJiBlcnIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyb3dzID09PSB1bmRlZmluZWQgfHwgcm93cyA9PT0gbnVsbCB8fCByb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbWF0c1R5cGVzLk1lc3NhZ2VzLk5PX0RBVEFfRk9VTkQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBwYXJzZVF1ZXJ5RGF0YVRpbWVTZXJpZXMocG9vbCwgcm93cywgZCwgY29tcGxldGVuZXNzUUNQYXJhbSwgaGFzTGV2ZWxzLCBhdmVyYWdlU3RyLCBmb3JlY2FzdE9mZnNldCwgY3ljbGVzLCByZWd1bGFyKTtcbiAgICAgICAgICAgICAgICBkID0gcGFyc2VkRGF0YS5kO1xuICAgICAgICAgICAgICAgIE4wID0gcGFyc2VkRGF0YS5OMDtcbiAgICAgICAgICAgICAgICBOX3RpbWVzID0gcGFyc2VkRGF0YS5OX3RpbWVzO1xuICAgICAgICAgICAgICAgIGN5Y2xlcyA9IHBhcnNlZERhdGEuY3ljbGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uZSB3YWl0aW5nIC0gaGF2ZSByZXN1bHRzXG4gICAgICAgICAgICBkRnV0dXJlWydyZXR1cm4nXSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3YWl0IGZvciBmdXR1cmUgdG8gZmluaXNoXG4gICAgICAgIGRGdXR1cmUud2FpdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIE4wOiBOMCxcbiAgICAgICAgICAgIE5fdGltZXM6IE5fdGltZXMsXG4gICAgICAgICAgICBhdmVyYWdlU3RyOiBhdmVyYWdlU3RyLFxuICAgICAgICAgICAgY3ljbGVzOiBjeWNsZXMsXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLy90aGlzIG1ldGhvZCBxdWVyaWVzIHRoZSBkYXRhYmFzZSBmb3Igc3BlY2lhbHR5IGN1cnZlcyBzdWNoIGFzIHByb2ZpbGVzLCBkaWVvZmZzLCB0aHJlc2hvbGQgcGxvdHMsIHZhbGlkIHRpbWUgcGxvdHMsIGFuZCBoaXN0b2dyYW1zXG5jb25zdCBxdWVyeURCU3BlY2lhbHR5Q3VydmUgPSBmdW5jdGlvbiAocG9vbCwgc3RhdGVtZW50LCBwbG90VHlwZSwgaGFzTGV2ZWxzKSB7XG4gICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICBjb25zdCBGdXR1cmUgPSByZXF1aXJlKCdmaWJlcnMvZnV0dXJlJyk7XG4gICAgICAgIGNvbnN0IHBsb3RQYXJhbXMgPSBtYXRzRGF0YVV0aWxzLmdldFBsb3RQYXJhbXNGcm9tU3RhY2soKTtcbiAgICAgICAgY29uc3QgY29tcGxldGVuZXNzUUNQYXJhbSA9IE51bWJlcihwbG90UGFyYW1zW1wiY29tcGxldGVuZXNzXCJdKSAvIDEwMDtcbiAgICAgICAgY29uc3QgYXBwVHlwZSA9IG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy5maW5kT25lKHt9KS5hcHBUeXBlO1xuXG4gICAgICAgIHZhciBkRnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgICAgICB2YXIgZCA9IHsvLyBkIHdpbGwgY29udGFpbiB0aGUgY3VydmUgZGF0YVxuICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICAgIGVycm9yX3g6IFtdLFxuICAgICAgICAgICAgZXJyb3JfeTogW10sXG4gICAgICAgICAgICBzdWJWYWxzOiBbXSxcbiAgICAgICAgICAgIHN1YlNlY3M6IFtdLFxuICAgICAgICAgICAgc3ViTGV2czogW10sXG4gICAgICAgICAgICBzdGF0czogW10sXG4gICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgIHhtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB4bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgeW1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIHltYXg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICBzdW06IDBcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXJyb3IgPSBcIlwiO1xuICAgICAgICB2YXIgTjAgPSBbXTtcbiAgICAgICAgdmFyIE5fdGltZXMgPSBbXTtcblxuICAgICAgICBwb29sLnF1ZXJ5KHN0YXRlbWVudCwgZnVuY3Rpb24gKGVyciwgcm93cykge1xuICAgICAgICAgICAgLy8gcXVlcnkgY2FsbGJhY2sgLSBidWlsZCB0aGUgY3VydmUgZGF0YSBmcm9tIHRoZSByZXN1bHRzIC0gb3Igc2V0IGFuIGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQgJiYgZXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocm93cyA9PT0gdW5kZWZpbmVkIHx8IHJvd3MgPT09IG51bGwgfHwgcm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG1hdHNUeXBlcy5NZXNzYWdlcy5OT19EQVRBX0ZPVU5EO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkRGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocGxvdFR5cGUgIT09IG1hdHNUeXBlcy5QbG90VHlwZXMuaGlzdG9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBwYXJzZVF1ZXJ5RGF0YVNwZWNpYWx0eUN1cnZlKHJvd3MsIGQsIGNvbXBsZXRlbmVzc1FDUGFyYW0sIHBsb3RUeXBlLCBhcHBUeXBlLCBoYXNMZXZlbHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBwYXJzZVF1ZXJ5RGF0YUhpc3RvZ3JhbShkLCByb3dzLCBoYXNMZXZlbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkID0gcGFyc2VkRGF0YS5kO1xuICAgICAgICAgICAgICAgIE4wID0gcGFyc2VkRGF0YS5OMDtcbiAgICAgICAgICAgICAgICBOX3RpbWVzID0gcGFyc2VkRGF0YS5OX3RpbWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZEZ1dHVyZVsncmV0dXJuJ10oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gd2FpdCBmb3IgZnV0dXJlIHRvIGZpbmlzaFxuICAgICAgICBkRnV0dXJlLndhaXQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBOMDogTjAsXG4gICAgICAgICAgICBOX3RpbWVzOiBOX3RpbWVzLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8vdGhpcyBtZXRob2QgcXVlcmllcyB0aGUgZGF0YWJhc2UgZm9yIG1hcCBwbG90c1xuY29uc3QgcXVlcnlNYXBEQiA9IGZ1bmN0aW9uIChwb29sLCBzdGF0ZW1lbnQsIGRhdGFTb3VyY2UsIHZhcmlhYmxlLCB2YXJVbml0cywgc2l0ZU1hcCkge1xuICAgIGlmIChNZXRlb3IuaXNTZXJ2ZXIpIHtcbiAgICAgICAgLy8gZCB3aWxsIGNvbnRhaW4gdGhlIGN1cnZlIGRhdGFcbiAgICAgICAgdmFyIGQgPSB7XG4gICAgICAgICAgICBzaXRlTmFtZTogW10sXG4gICAgICAgICAgICBxdWVyeVZhbDogW10sXG4gICAgICAgICAgICBsYXQ6IFtdLFxuICAgICAgICAgICAgbG9uOiBbXSxcbiAgICAgICAgICAgIGNvbG9yOiBbXSxcbiAgICAgICAgICAgIHN0YXRzOiBbXSxcbiAgICAgICAgICAgIHRleHQ6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBiaWFzZXMgPD0gLTFcbiAgICAgICAgdmFyIGRCbHVlID0ge1xuICAgICAgICAgICAgc2l0ZU5hbWU6IFtdLFxuICAgICAgICAgICAgcXVlcnlWYWw6IFtdLFxuICAgICAgICAgICAgbGF0OiBbXSxcbiAgICAgICAgICAgIGxvbjogW10sXG4gICAgICAgICAgICBzdGF0czogW10sXG4gICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgIGNvbG9yOiBcInJnYigwLDAsMjU1KVwiXG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBiaWFzZXMgPiAtMSBhbmQgPCAxXG4gICAgICAgIHZhciBkQmxhY2sgPSB7XG4gICAgICAgICAgICBzaXRlTmFtZTogW10sXG4gICAgICAgICAgICBxdWVyeVZhbDogW10sXG4gICAgICAgICAgICBsYXQ6IFtdLFxuICAgICAgICAgICAgbG9uOiBbXSxcbiAgICAgICAgICAgIHN0YXRzOiBbXSxcbiAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgY29sb3I6IFwicmdiKDAsMCwwKVwiXG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBiaWFzZXMgPj0gMVxuICAgICAgICB2YXIgZFJlZCA9IHtcbiAgICAgICAgICAgIHNpdGVOYW1lOiBbXSxcbiAgICAgICAgICAgIHF1ZXJ5VmFsOiBbXSxcbiAgICAgICAgICAgIGxhdDogW10sXG4gICAgICAgICAgICBsb246IFtdLFxuICAgICAgICAgICAgc3RhdHM6IFtdLFxuICAgICAgICAgICAgdGV4dDogW10sXG4gICAgICAgICAgICBjb2xvcjogXCJyZ2IoMjU1LDAsMClcIlxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlcnJvciA9IFwiXCI7XG4gICAgICAgIGNvbnN0IEZ1dHVyZSA9IHJlcXVpcmUoJ2ZpYmVycy9mdXR1cmUnKTtcbiAgICAgICAgdmFyIHBGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgICAgIHBvb2wucXVlcnkoc3RhdGVtZW50LCBmdW5jdGlvbiAoZXJyLCByb3dzKSB7XG4gICAgICAgICAgICAvLyBxdWVyeSBjYWxsYmFjayAtIGJ1aWxkIHRoZSBjdXJ2ZSBkYXRhIGZyb20gdGhlIHJlc3VsdHMgLSBvciBzZXQgYW4gZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCAmJiBlcnIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyb3dzID09PSB1bmRlZmluZWQgfHwgcm93cyA9PT0gbnVsbCB8fCByb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbWF0c1R5cGVzLk1lc3NhZ2VzLk5PX0RBVEFfRk9VTkQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVZhbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93cy5sZW5ndGg7IHJvd0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l0ZSA9IHJvd3Nbcm93SW5kZXhdLnN0YV9uYW1lO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVZhbCA9IHJvd3Nbcm93SW5kZXhdLm1vZGVsX29iX2RpZmY7XG4gICAgICAgICAgICAgICAgICAgIGQuc2l0ZU5hbWUucHVzaChzaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZC5xdWVyeVZhbC5wdXNoKHF1ZXJ5VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgZC5zdGF0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE5fdGltZXM6IHJvd3Nbcm93SW5kZXhdLk5fdGltZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5fdGltZTogcm93c1tyb3dJbmRleF0ubWluX3RpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhfdGltZTogcm93c1tyb3dJbmRleF0ubWF4X3RpbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b29sdGlwcyA9IHNpdGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCI8YnI+XCIgKyBcInZhcmlhYmxlOiBcIiArIHZhcmlhYmxlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGJyPlwiICsgXCJtb2RlbDogXCIgKyBkYXRhU291cmNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGJyPlwiICsgXCJtb2RlbC1vYnM6IFwiICsgcXVlcnlWYWwgKyBcIiBcIiArIHZhclVuaXRzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGJyPlwiICsgXCJuOiBcIiArIHJvd3Nbcm93SW5kZXhdLk5fdGltZXM7XG4gICAgICAgICAgICAgICAgICAgIGQudGV4dC5wdXNoKHRvb2x0aXBzKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc1NpdGUgPSBzaXRlTWFwLmZpbmQob2JqID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoubmFtZSA9PT0gc2l0ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGQubGF0LnB1c2godGhpc1NpdGUucG9pbnRbMF0pO1xuICAgICAgICAgICAgICAgICAgICBkLmxvbi5wdXNoKHRoaXNTaXRlLnBvaW50WzFdKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE1hcmtlciA9IHF1ZXJ5VmFsID09PSBudWxsID8gXCJcIiA6IHF1ZXJ5VmFsLnRvRml4ZWQoMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeVZhbCA8PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5jb2xvci5wdXNoKFwicmdiKDAsMCwyNTUpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZEJsdWUuc2l0ZU5hbWUucHVzaChzaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRCbHVlLnF1ZXJ5VmFsLnB1c2gocXVlcnlWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZEJsdWUudGV4dC5wdXNoKHRleHRNYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZEJsdWUubGF0LnB1c2godGhpc1NpdGUucG9pbnRbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZEJsdWUubG9uLnB1c2godGhpc1NpdGUucG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5VmFsID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuY29sb3IucHVzaChcInJnYigyNTUsMCwwKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRSZWQuc2l0ZU5hbWUucHVzaChzaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRSZWQucXVlcnlWYWwucHVzaChxdWVyeVZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkUmVkLnRleHQucHVzaCh0ZXh0TWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRSZWQubGF0LnB1c2godGhpc1NpdGUucG9pbnRbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZFJlZC5sb24ucHVzaCh0aGlzU2l0ZS5wb2ludFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLmNvbG9yLnB1c2goXCJyZ2IoMCwwLDApXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZEJsYWNrLnNpdGVOYW1lLnB1c2goc2l0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkQmxhY2sucXVlcnlWYWwucHVzaChxdWVyeVZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkQmxhY2sudGV4dC5wdXNoKHRleHRNYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZEJsYWNrLmxhdC5wdXNoKHRoaXNTaXRlLnBvaW50WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRCbGFjay5sb24ucHVzaCh0aGlzU2l0ZS5wb2ludFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9Ly8gZW5kIG9mIGxvb3Agcm93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb25lIHdhaXRpbmcgLSBoYXZlIHJlc3VsdHNcbiAgICAgICAgICAgIHBGdXR1cmVbJ3JldHVybiddKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdhaXQgZm9yIGZ1dHVyZSB0byBmaW5pc2hcbiAgICAgICAgcEZ1dHVyZS53YWl0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkLCAgICAvLyBbc3ViX3ZhbHVlcyxzdWJfc2Vjc10gYXMgYXJyYXlzXG4gICAgICAgICAgICBkYXRhQmx1ZTogZEJsdWUsICAgIC8vIFtzdWJfdmFsdWVzLHN1Yl9zZWNzXSBhcyBhcnJheXNcbiAgICAgICAgICAgIGRhdGFCbGFjazogZEJsYWNrLCAgICAvLyBbc3ViX3ZhbHVlcyxzdWJfc2Vjc10gYXMgYXJyYXlzXG4gICAgICAgICAgICBkYXRhUmVkOiBkUmVkLCAgICAvLyBbc3ViX3ZhbHVlcyxzdWJfc2Vjc10gYXMgYXJyYXlzXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLy90aGlzIG1ldGhvZCBxdWVyaWVzIHRoZSBkYXRhYmFzZSBmb3IgY29udG91ciBwbG90c1xuY29uc3QgcXVlcnlEQkNvbnRvdXIgPSBmdW5jdGlvbiAocG9vbCwgc3RhdGVtZW50KSB7XG4gICAgaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgICAgICBjb25zdCBGdXR1cmUgPSByZXF1aXJlKCdmaWJlcnMvZnV0dXJlJyk7XG5cbiAgICAgICAgdmFyIGRGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgICAgIHZhciBkID0gey8vIGQgd2lsbCBjb250YWluIHRoZSBjdXJ2ZSBkYXRhXG4gICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgIHk6IFtdLFxuICAgICAgICAgICAgejogW10sXG4gICAgICAgICAgICBuOiBbXSxcbiAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgeFRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgeVRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgelRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgblRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgbWluRGF0ZVRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgbWF4RGF0ZVRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgc3RhdHM6IFtdLFxuICAgICAgICAgICAgZ2xvYl9zdGF0czoge30sXG4gICAgICAgICAgICB4bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgeG1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIHltaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB5bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgem1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIHptYXg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICBzdW06IDBcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXJyb3IgPSBcIlwiO1xuICAgICAgICBwb29sLnF1ZXJ5KHN0YXRlbWVudCwgZnVuY3Rpb24gKGVyciwgcm93cykge1xuICAgICAgICAgICAgLy8gcXVlcnkgY2FsbGJhY2sgLSBidWlsZCB0aGUgY3VydmUgZGF0YSBmcm9tIHRoZSByZXN1bHRzIC0gb3Igc2V0IGFuIGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQgJiYgZXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocm93cyA9PT0gdW5kZWZpbmVkIHx8IHJvd3MgPT09IG51bGwgfHwgcm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG1hdHNUeXBlcy5NZXNzYWdlcy5OT19EQVRBX0ZPVU5EO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gcGFyc2VRdWVyeURhdGFDb250b3VyKHJvd3MsIGQpO1xuICAgICAgICAgICAgICAgIGQgPSBwYXJzZWREYXRhLmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkRnV0dXJlWydyZXR1cm4nXSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3YWl0IGZvciBmdXR1cmUgdG8gZmluaXNoXG4gICAgICAgIGRGdXR1cmUud2FpdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8vdGhpcyBtZXRob2QgcGFyc2VzIHRoZSByZXR1cm5lZCBxdWVyeSBkYXRhIGZvciB0aW1lc2VyaWVzIHBsb3RzXG5jb25zdCBwYXJzZVF1ZXJ5RGF0YVRpbWVTZXJpZXMgPSBmdW5jdGlvbiAocG9vbCwgcm93cywgZCwgY29tcGxldGVuZXNzUUNQYXJhbSwgaGFzTGV2ZWxzLCBhdmVyYWdlU3RyLCBmb3JlQ2FzdE9mZnNldCwgY3ljbGVzLCByZWd1bGFyKSB7XG4gICAgLypcbiAgICAgICAgdmFyIGQgPSB7Ly8gZCB3aWxsIGNvbnRhaW4gdGhlIGN1cnZlIGRhdGFcbiAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICBlcnJvcl94OiBbXSwgICAvLyBjdXJ2ZVRpbWVcbiAgICAgICAgICAgIGVycm9yX3k6IFtdLCAgIC8vIHZhbHVlc1xuICAgICAgICAgICAgc3ViVmFsczogW10sICAgLy9zdWJWYWxzXG4gICAgICAgICAgICBzdWJTZWNzOiBbXSwgICAvL3N1YlNlY3NcbiAgICAgICAgICAgIHN1YkxldnM6IFtdLCAgIC8vc3ViTGV2c1xuICAgICAgICAgICAgc3RhdHM6IFtdLCAgICAgLy9wb2ludFN0YXRzXG4gICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgIGdsb2Jfc3RhdHM6IHt9LCAgICAgLy9jdXJ2ZVN0YXRzXG4gICAgICAgICAgICB4bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgeG1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIHltaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB5bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgc3VtOiAwXG4gICAgICAgIH07XG4gICAgKi9cbiAgICBkLmVycm9yX3ggPSBudWxsOyAgLy8gdGltZSBzZXJpZXMgZG9lc24ndCB1c2UgeCBlcnJvcmJhcnNcbiAgICB2YXIgTjAgPSBbXTtcbiAgICB2YXIgTl90aW1lcyA9IFtdO1xuICAgIHZhciB4bWF4ID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICB2YXIgeG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICB2YXIgY3VydmVUaW1lID0gW107XG4gICAgdmFyIGN1cnZlU3RhdHMgPSBbXTtcbiAgICB2YXIgc3ViVmFscyA9IFtdO1xuICAgIHZhciBzdWJTZWNzID0gW107XG4gICAgdmFyIHN1YkxldnMgPSBbXTtcblxuICAgIHZhciB0aW1lX2ludGVydmFsID0gcm93cy5sZW5ndGggPiAxID8gTnVtYmVyKHJvd3NbMV0uYXZ0aW1lKSAtIE51bWJlcihyb3dzWzBdLmF2dGltZSkgOiB1bmRlZmluZWQ7IC8vY2FsY3VsYXRlIGEgYmFzZSB0aW1lIGludGVydmFsIC0tIHdpbGwgYmUgdXNlZCBpZiBkYXRhIGlzIHJlZ3VsYXJcbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93cy5sZW5ndGg7IHJvd0luZGV4KyspIHtcblxuICAgICAgICB2YXIgYXZTZWNvbmRzID0gTnVtYmVyKHJvd3Nbcm93SW5kZXhdLmF2dGltZSk7XG4gICAgICAgIHZhciBhdlRpbWUgPSBhdlNlY29uZHMgKiAxMDAwO1xuICAgICAgICB4bWluID0gYXZUaW1lIDwgeG1pbiA/IGF2VGltZSA6IHhtaW47XG4gICAgICAgIHhtYXggPSBhdlRpbWUgPiB4bWF4ID8gYXZUaW1lIDogeG1heDtcbiAgICAgICAgdmFyIHN0YXQgPSByb3dzW3Jvd0luZGV4XS5zdGF0O1xuICAgICAgICBOMC5wdXNoKHJvd3Nbcm93SW5kZXhdLk4wKTsgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHZhbHVlcyB0aGF0IGdvIGludG8gYSB0aW1lIHNlcmllcyBwb2ludFxuICAgICAgICBOX3RpbWVzLnB1c2gocm93c1tyb3dJbmRleF0uTl90aW1lcyk7ICAgLy8gbnVtYmVyIG9mIHRpbWVzIHRoYXQgZ28gaW50byBhIHRpbWUgc2VyaWVzIHBvaW50XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbWluaW11bSB0aW1lX2ludGVydmFsLiBGb3IgcmVndWxhciBtb2RlbHMsIHRoaXMgd2lsbCBkaWZmZXIgZnJvbSB0aGUgcHJldmlvdXMgdGltZV9pbnRlcnZhbFxuICAgICAgICAvLyBpZiB0aGUgaW50ZXJ2YWwgd2FzIGFydGlmaWNpYWxseSBsYXJnZSBkdWUgdG8gbWlzc2luZyB2YWx1ZXMuIEZvciBpcnJlZ3VsYXIgbW9kZWxzLCB3ZSBuZWVkIHRoZSBtaW5pbXVtXG4gICAgICAgIC8vIGludGVydmFsIHRvIGJlIHN1cmUgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGdvIHBhc3QgdGhlIG5leHQgZGF0YSBwb2ludC5cbiAgICAgICAgaWYgKHJvd0luZGV4IDwgcm93cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgdGltZV9kaWZmID0gTnVtYmVyKHJvd3Nbcm93SW5kZXggKyAxXS5hdnRpbWUpIC0gTnVtYmVyKHJvd3Nbcm93SW5kZXhdLmF2dGltZSk7XG4gICAgICAgICAgICBpZiAodGltZV9kaWZmIDwgdGltZV9pbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRpbWVfaW50ZXJ2YWwgPSB0aW1lX2RpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSBzdWIgdmFsdWVzIHRoYXQgd2lsbCBsYXRlciBiZSB1c2VkIGZvciBjYWxjdWxhdGluZyBlcnJvciBiYXIgc3RhdGlzdGljcy5cbiAgICAgICAgdmFyIHN1Yl92YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIHN1Yl9zZWNzID0gW107XG4gICAgICAgIHZhciBzdWJfbGV2cyA9IFtdO1xuICAgICAgICBpZiAoc3RhdCAhPT0gbnVsbCAmJiBzdGF0ICE9PSBcIk5VTExcIiAmJiByb3dzW3Jvd0luZGV4XS5zdWJfZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJfZGF0YSA9IHJvd3Nbcm93SW5kZXhdLnN1Yl9kYXRhLnRvU3RyaW5nKCkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB2YXIgY3Vycl9zdWJfZGF0YTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzZF9pZHggPSAwOyBzZF9pZHggPCBzdWJfZGF0YS5sZW5ndGg7IHNkX2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJfc3ViX2RhdGEgPSBzdWJfZGF0YVtzZF9pZHhdLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIHN1Yl92YWx1ZXMucHVzaChOdW1iZXIoY3Vycl9zdWJfZGF0YVswXSkpO1xuICAgICAgICAgICAgICAgICAgICBzdWJfc2Vjcy5wdXNoKE51bWJlcihjdXJyX3N1Yl9kYXRhWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oTnVtYmVyKGN1cnJfc3ViX2RhdGFbMl0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yl9sZXZzLnB1c2goTnVtYmVyKGN1cnJfc3ViX2RhdGFbMl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViX2xldnMucHVzaChjdXJyX3N1Yl9kYXRhWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGVycm9yIHByb2R1Y2VkIGJ5IGEgYnVnIGluIHRoZSBxdWVyeSBmdW5jdGlvbiwgbm90IGFuIGVycm9yIHJldHVybmVkIGJ5IHRoZSBteXNxbCBkYXRhYmFzZVxuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IFwiRXJyb3IgaW4gcGFyc2VRdWVyeURhdGFUaW1lU2VyaWVzLiBUaGUgZXhwZWN0ZWQgZmllbGRzIGRvbid0IHNlZW0gdG8gYmUgcHJlc2VudCBpbiB0aGUgcmVzdWx0cyBjYWNoZTogXCIgKyBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJfdmFsdWVzID0gTmFOO1xuICAgICAgICAgICAgc3ViX3NlY3MgPSBOYU47XG4gICAgICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgc3ViX2xldnMgPSBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VydmVUaW1lLnB1c2goYXZUaW1lKTtcbiAgICAgICAgY3VydmVTdGF0cy5wdXNoKHN0YXQpO1xuICAgICAgICBzdWJWYWxzLnB1c2goc3ViX3ZhbHVlcyk7XG4gICAgICAgIHN1YlNlY3MucHVzaChzdWJfc2Vjcyk7XG4gICAgICAgIGlmIChoYXNMZXZlbHMpIHtcbiAgICAgICAgICAgIHN1YkxldnMucHVzaChzdWJfbGV2cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgTjBfbWF4ID0gTWF0aC5tYXgoLi4uTjApO1xuICAgIHZhciBOX3RpbWVzX21heCA9IE1hdGgubWF4KC4uLk5fdGltZXMpO1xuXG4gICAgaWYgKHhtaW4gPCBOdW1iZXIocm93c1swXS5hdnRpbWUpICogMTAwMCB8fCBhdmVyYWdlU3RyICE9PSBcIk5vbmVcIikge1xuICAgICAgICB4bWluID0gTnVtYmVyKHJvd3NbMF0uYXZ0aW1lKSAqIDEwMDA7XG4gICAgfVxuXG4gICAgdGltZV9pbnRlcnZhbCA9IHRpbWVfaW50ZXJ2YWwgKiAxMDAwO1xuICAgIHZhciBsb29wVGltZSA9IHhtaW47XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgd2hpbGUgKGxvb3BUaW1lIDw9IHhtYXgpIHtcbiAgICAgICAgdmFyIGRfaWR4ID0gY3VydmVUaW1lLmluZGV4T2YobG9vcFRpbWUpO1xuICAgICAgICBpZiAoZF9pZHggPCAwKSB7XG4gICAgICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgLy9kLnB1c2goW2xvb3BUaW1lLCBudWxsLCAtMSwgTmFOLCBOYU4sIE5hTl0pOy8vIGFkZCBhIG51bGwgZm9yIG1pc3NpbmcgZGF0YVxuICAgICAgICAgICAgICAgIGQueC5wdXNoKGxvb3BUaW1lKTtcbiAgICAgICAgICAgICAgICBkLnkucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAvL2QuZXJyb3JfeCBub3QgdXNlZFxuICAgICAgICAgICAgICAgIGQuZXJyb3JfeS5wdXNoKG51bGwpOyAgIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICBkLnN1YlZhbHMucHVzaChOYU4pO1xuICAgICAgICAgICAgICAgIGQuc3ViU2Vjcy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgZC5zdWJMZXZzLnB1c2goTmFOKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9kLnB1c2goW2xvb3BUaW1lLCBudWxsLCAtMSwgTmFOLCBOYU5dKTsgICAgIC8vIGFkZCBhIG51bGwgZm9yIG1pc3NpbmcgZGF0YVxuICAgICAgICAgICAgICAgIGQueC5wdXNoKGxvb3BUaW1lKTtcbiAgICAgICAgICAgICAgICBkLnkucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAvL2QuZXJyb3JfeCBub3QgdXNlZFxuICAgICAgICAgICAgICAgIGQuZXJyb3JfeS5wdXNoKG51bGwpOyAvL3BsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgZC5zdWJWYWxzLnB1c2goTmFOKTtcbiAgICAgICAgICAgICAgICBkLnN1YlNlY3MucHVzaChOYU4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRoaXNfTjAgPSBOMFtkX2lkeF07XG4gICAgICAgICAgICB2YXIgdGhpc19OX3RpbWVzID0gTl90aW1lc1tkX2lkeF07XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBoYXZlIGFueSBwb2ludHMgd2l0aCBmYXIgbGVzcyBkYXRhIHRoYW4gdGhlIHJlc3Qgb2YgdGhlIGdyYXBoLCBhbmQgdGhhdFxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhbnkgcG9pbnRzIHdpdGggYSBzbWFsbGVyIGNvbXBsZXRlbmVzcyB2YWx1ZSB0aGFuIHNwZWNpZmllZCBieSB0aGUgdXNlci5cbiAgICAgICAgICAgIGlmICh0aGlzX04wIDwgMC4xICogTjBfbWF4IHx8IHRoaXNfTl90aW1lcyA8IGNvbXBsZXRlbmVzc1FDUGFyYW0gKiBOX3RpbWVzX21heCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNMZXZlbHMpIHtcbi8vICAgICAgICAgICAgICAgICAgICBkLnB1c2goW2xvb3BUaW1lLCBudWxsLCAtMSwgTmFOLCBOYU4sIE5hTl0pOyAgICAgLy8gYWRkIGEgbnVsbCBpZiB0aGlzIHRpbWUgZG9lc24ndCBwYXNzIFFDXG4gICAgICAgICAgICAgICAgICAgIGQueC5wdXNoKGxvb3BUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZC55LnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vZC5lcnJvcl94IG5vdCB1c2VkXG4gICAgICAgICAgICAgICAgICAgIGQuZXJyb3JfeS5wdXNoKG51bGwpOyAvL3BsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIGQuc3ViVmFscy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgICAgIGQuc3ViU2Vjcy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgICAgIGQuc3ViTGV2cy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICBkLnB1c2goW2xvb3BUaW1lLCBudWxsLCAtMSwgTmFOLCBOYU5dKTsgICAgIC8vIGFkZCBhIG51bGwgaWYgdGhpcyB0aW1lIGRvZXNuJ3QgcGFzcyBRQ1xuICAgICAgICAgICAgICAgICAgICBkLngucHVzaChsb29wVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGQueS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAvL2QuZXJyb3JfeCBub3QgdXNlZFxuICAgICAgICAgICAgICAgICAgICBkLmVycm9yX3kucHVzaChudWxsKTsgLy9wbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICBkLnN1YlZhbHMucHVzaChOYU4pO1xuICAgICAgICAgICAgICAgICAgICBkLnN1YlNlY3MucHVzaChOYU4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGN1cnZlU3RhdHNbZF9pZHhdO1xuICAgICAgICAgICAgICAgIGlmIChoYXNMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9kLnB1c2goW2xvb3BUaW1lLCBjdXJ2ZVN0YXRzW2RfaWR4XSwgLTEsIHN1YlZhbHNbZF9pZHhdLCBzdWJTZWNzW2RfaWR4XSwgc3ViTGV2c1tkX2lkeF1dKTsgICAvLyBlbHNlIGFkZCB0aGUgcmVhbCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGQueC5wdXNoKGxvb3BUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZC55LnB1c2goY3VydmVTdGF0c1tkX2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAvL2QuZXJyb3JfeCBub3QgdXNlZFxuICAgICAgICAgICAgICAgICAgICBkLmVycm9yX3kucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgZC5zdWJWYWxzLnB1c2goc3ViVmFsc1tkX2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICBkLnN1YlNlY3MucHVzaChzdWJTZWNzW2RfaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIGQuc3ViTGV2cy5wdXNoKHN1YkxldnNbZF9pZHhdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2QucHVzaChbbG9vcFRpbWUsIGN1cnZlU3RhdHNbZF9pZHhdLCAtMSwgc3ViVmFsc1tkX2lkeF0sIHN1YlNlY3NbZF9pZHhdXSk7ICAgLy8gZWxzZSBhZGQgdGhlIHJlYWwgZGF0YVxuICAgICAgICAgICAgICAgICAgICBkLngucHVzaChsb29wVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGQueS5wdXNoKGN1cnZlU3RhdHNbZF9pZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgLy9kLmVycm9yX3ggbm90IHVzZWRcbiAgICAgICAgICAgICAgICAgICAgZC5lcnJvcl95LnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGQuc3ViVmFscy5wdXNoKHN1YlZhbHNbZF9pZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgZC5zdWJTZWNzLnB1c2goc3ViU2Vjc1tkX2lkeF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZ3VsYXIpIHsgIC8vIGl0IGlzIGEgbW9kZWwgdGhhdCBoYXMgYW4gaXJyZWd1bGFyIHNldCBvZiBpbnRlcnZhbHMsIGkuZS4gYW4gaXJyZWd1bGFyIGNhZGVuY2VcbiAgICAgICAgICAgIHRpbWVfaW50ZXJ2YWwgPSBnZXRUaW1lSW50ZXJ2YWwobG9vcFRpbWUsIHRpbWVfaW50ZXJ2YWwsIGZvcmVDYXN0T2Zmc2V0LCBjeWNsZXMpOyAgIC8vIHRoZSB0aW1lIGludGVydmFsIG1vc3QgbGlrZWx5IHdpbGwgbm90IGJlIHRoZSBvbmUgY2FsY3VsYXRlZCBhYm92ZVxuICAgICAgICB9XG4gICAgICAgIGxvb3BUaW1lID0gbG9vcFRpbWUgKyB0aW1lX2ludGVydmFsOyAgICAvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IHRpbWUuXG4gICAgfVxuICAgIGlmIChyZWd1bGFyKSB7XG4gICAgICAgIGN5Y2xlcyA9IFt0aW1lX2ludGVydmFsXTsgICAvLyByZWd1bGFyIG1vZGVscyB3aWxsIHJldHVybiBvbmUgY3ljbGUgY2FkZW5jZVxuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJlZHggPSBkLnguZmlsdGVyKHggPT4geCk7XG4gICAgY29uc3QgZmlsdGVyZWR5ID0gZC55LmZpbHRlcih5ID0+IHkpO1xuICAgIGQueG1pbiA9IE1hdGgubWluKC4uLmZpbHRlcmVkeCk7XG4gICAgZC54bWF4ID0gTWF0aC5tYXgoLi4uZmlsdGVyZWR4KTtcbiAgICBkLnltaW4gPSBNYXRoLm1pbiguLi5maWx0ZXJlZHkpO1xuICAgIGQueW1heCA9IE1hdGgubWF4KC4uLmZpbHRlcmVkeSk7XG4gICAgZC5zdW0gPSBzdW07XG5cbiAgICBpZiAoZC54bWluID09IFwiLUluZmluaXR5XCIgfHwgKGQueC5pbmRleE9mKDApICE9PSAtMSAmJiAwIDwgZC54bWluKSkge1xuICAgICAgICBkLnhtaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoZC55bWluID09IFwiLUluZmluaXR5XCIgfHwgKGQueS5pbmRleE9mKDApICE9PSAtMSAmJiAwIDwgZC55bWluKSkge1xuICAgICAgICBkLnltaW4gPSAwO1xuICAgIH1cblxuICAgIGlmIChkLnhtYXggPT0gXCItSW5maW5pdHlcIikge1xuICAgICAgICBkLnhtYXggPSAwO1xuICAgIH1cbiAgICBpZiAoZC55bWF4ID09IFwiLUluZmluaXR5XCIpIHtcbiAgICAgICAgZC55bWF4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZDogZCxcbiAgICAgICAgTjA6IE4wLFxuICAgICAgICBOX3RpbWVzOiBOX3RpbWVzLFxuICAgICAgICBjeWNsZXM6IGN5Y2xlc1xuICAgIH07XG59O1xuXG4vL3RoaXMgbWV0aG9kIHBhcnNlcyB0aGUgcmV0dXJuZWQgcXVlcnkgZGF0YSBmb3Igc3BlY2lhbHR5IGN1cnZlcyBzdWNoIGFzIHByb2ZpbGVzLCBkaWVvZmZzLCB0aHJlc2hvbGQgcGxvdHMsIGFuZCB2YWxpZCB0aW1lIHBsb3RzXG5jb25zdCBwYXJzZVF1ZXJ5RGF0YVNwZWNpYWx0eUN1cnZlID0gZnVuY3Rpb24gKHJvd3MsIGQsIGNvbXBsZXRlbmVzc1FDUGFyYW0sIHBsb3RUeXBlLCBhcHBUeXBlLCBoYXNMZXZlbHMpIHtcbiAgICAvKlxuICAgICAgICB2YXIgZCA9IHsvLyBkIHdpbGwgY29udGFpbiB0aGUgY3VydmUgZGF0YVxuICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICAgIGVycm9yX3g6IFtdLCAgIC8vIGN1cnZlVGltZVxuICAgICAgICAgICAgZXJyb3JfeTogW10sICAgLy8gdmFsdWVzXG4gICAgICAgICAgICBzdWJWYWxzOiBbXSwgICAvL3N1YlZhbHNcbiAgICAgICAgICAgIHN1YlNlY3M6IFtdLCAgIC8vc3ViU2Vjc1xuICAgICAgICAgICAgc3ViTGV2czogW10sICAgLy9zdWJMZXZzXG4gICAgICAgICAgICBzdGF0czogW10sICAgICAvL3BvaW50U3RhdHNcbiAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgZ2xvYl9zdGF0czoge30sICAgICAvL2N1cnZlU3RhdHNcbiAgICAgICAgICAgIHhtaW46bnVtLFxuICAgICAgICAgICAgeW1pbjpudW0sXG4gICAgICAgICAgICB4bWF4Om51bSxcbiAgICAgICAgICAgIHltYXg6bnVtLFxuICAgICAgICAgICAgc3VtOm51bTtcbiAgICAgICAgfTtcbiAgICAqL1xuICAgIHZhciBOMCA9IFtdO1xuICAgIHZhciBOX3RpbWVzID0gW107XG4gICAgdmFyIGN1cnZlSW5kZXBlbmRlbnRWYXJzID0gW107XG4gICAgdmFyIGN1cnZlU3RhdHMgPSBbXTtcbiAgICB2YXIgc3ViVmFscyA9IFtdO1xuICAgIHZhciBzdWJTZWNzID0gW107XG4gICAgdmFyIHN1YkxldnMgPSBbXTtcbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93cy5sZW5ndGg7IHJvd0luZGV4KyspIHtcbiAgICAgICAgdmFyIGluZGVwZW5kZW50VmFyO1xuICAgICAgICBpZiAocGxvdFR5cGUgPT09IG1hdHNUeXBlcy5QbG90VHlwZXMudmFsaWR0aW1lKSB7XG4gICAgICAgICAgICBpbmRlcGVuZGVudFZhciA9IE51bWJlcihyb3dzW3Jvd0luZGV4XS5ocl9vZl9kYXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHBsb3RUeXBlID09PSBtYXRzVHlwZXMuUGxvdFR5cGVzLnByb2ZpbGUpIHtcbiAgICAgICAgICAgIGluZGVwZW5kZW50VmFyID0gTnVtYmVyKChyb3dzW3Jvd0luZGV4XS5hdlZhbCkudG9TdHJpbmcoKS5yZXBsYWNlKCdQJywgJycpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwbG90VHlwZSA9PT0gbWF0c1R5cGVzLlBsb3RUeXBlcy5kYWlseU1vZGVsQ3ljbGUpIHtcbiAgICAgICAgICAgIGluZGVwZW5kZW50VmFyID0gTnVtYmVyKHJvd3Nbcm93SW5kZXhdLmF2dGltZSkgKiAxMDAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXBlbmRlbnRWYXIgPSBOdW1iZXIocm93c1tyb3dJbmRleF0uYXZ0aW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0ID0gcm93c1tyb3dJbmRleF0uc3RhdDtcbiAgICAgICAgTjAucHVzaChyb3dzW3Jvd0luZGV4XS5OMCk7ICAgICAgICAgICAgIC8vIG51bWJlciBvZiB2YWx1ZXMgdGhhdCBnbyBpbnRvIGEgcG9pbnQgb24gdGhlIGdyYXBoXG4gICAgICAgIE5fdGltZXMucHVzaChyb3dzW3Jvd0luZGV4XS5OX3RpbWVzKTsgICAvLyBudW1iZXIgb2YgdGltZXMgdGhhdCBnbyBpbnRvIGEgcG9pbnQgb24gdGhlIGdyYXBoXG5cbiAgICAgICAgdmFyIHN1Yl9zdGF0cyA9IFtdO1xuICAgICAgICB2YXIgc3ViX3NlY3MgPSBbXTtcbiAgICAgICAgdmFyIHN1Yl9sZXZzID0gW107XG4gICAgICAgIGlmIChzdGF0ICE9PSBudWxsICYmIHN0YXQgIT09IFwiTlVMTFwiICYmIHJvd3Nbcm93SW5kZXhdLnN1Yl9kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Yl9kYXRhID0gcm93c1tyb3dJbmRleF0uc3ViX2RhdGEudG9TdHJpbmcoKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyX3N1Yl9kYXRhO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNkX2lkeCA9IDA7IHNkX2lkeCA8IHN1Yl9kYXRhLmxlbmd0aDsgc2RfaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vycl9zdWJfZGF0YSA9IHN1Yl9kYXRhW3NkX2lkeF0uc3BsaXQoJzsnKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViX3N0YXRzLnB1c2goTnVtYmVyKGN1cnJfc3ViX2RhdGFbMF0pKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViX3NlY3MucHVzaChOdW1iZXIoY3Vycl9zdWJfZGF0YVsxXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcihjdXJyX3N1Yl9kYXRhWzJdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJfbGV2cy5wdXNoKE51bWJlcihjdXJyX3N1Yl9kYXRhWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yl9sZXZzLnB1c2goY3Vycl9zdWJfZGF0YVsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBlcnJvciBwcm9kdWNlZCBieSBhIGJ1ZyBpbiB0aGUgcXVlcnkgZnVuY3Rpb24sIG5vdCBhbiBlcnJvciByZXR1cm5lZCBieSB0aGUgbXlzcWwgZGF0YWJhc2VcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIkVycm9yIGluIHBhcnNlUXVlcnlEYXRhU3BlY2lhbHR5Q3VydmUuIFRoZSBleHBlY3RlZCBmaWVsZHMgZG9uJ3Qgc2VlbSB0byBiZSBwcmVzZW50IGluIHRoZSByZXN1bHRzIGNhY2hlOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1Yl9zdGF0cyA9IE5hTjtcbiAgICAgICAgICAgIHN1Yl9zZWNzID0gTmFOO1xuICAgICAgICAgICAgaWYgKGhhc0xldmVscykge1xuICAgICAgICAgICAgICAgIHN1Yl9sZXZzID0gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVhbCB3aXRoIG1pc3NpbmcgZm9yZWNhc3QgY3ljbGVzIGZvciBkYWlseU1vZGVsQ3ljbGUgcGxvdCB0eXBlXG4gICAgICAgIGlmIChwbG90VHlwZSA9PT0gbWF0c1R5cGVzLlBsb3RUeXBlcy5kYWlseU1vZGVsQ3ljbGUgJiYgcm93SW5kZXggPiAwICYmIChOdW1iZXIoaW5kZXBlbmRlbnRWYXIpIC0gTnVtYmVyKHJvd3Nbcm93SW5kZXggLSAxXS5hdnRpbWUgKiAxMDAwKSkgPiAzNjAwICogMjQgKiAxMDAwKSB7XG4gICAgICAgICAgICBjb25zdCBjeWNsZXNfbWlzc2luZyA9IE1hdGguZmxvb3IoKE51bWJlcihpbmRlcGVuZGVudFZhcikgLSBOdW1iZXIocm93c1tyb3dJbmRleCAtIDFdLmF2dGltZSAqIDEwMDApKSAvICgzNjAwICogMjQgKiAxMDAwKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBtaXNzaW5nSWR4ID0gY3ljbGVzX21pc3Npbmc7IG1pc3NpbmdJZHggPiAwOyBtaXNzaW5nSWR4LS0pIHtcbiAgICAgICAgICAgICAgICBjdXJ2ZUluZGVwZW5kZW50VmFycy5wdXNoKGluZGVwZW5kZW50VmFyIC0gMzYwMCAqIDI0ICogMTAwMCAqIG1pc3NpbmdJZHgpO1xuICAgICAgICAgICAgICAgIGN1cnZlU3RhdHMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBzdWJWYWxzLnB1c2goTmFOKTtcbiAgICAgICAgICAgICAgICBzdWJTZWNzLnB1c2goTmFOKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YkxldnMucHVzaChOYU4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJ2ZUluZGVwZW5kZW50VmFycy5wdXNoKGluZGVwZW5kZW50VmFyKTtcbiAgICAgICAgY3VydmVTdGF0cy5wdXNoKHN0YXQpO1xuICAgICAgICBzdWJWYWxzLnB1c2goc3ViX3N0YXRzKTtcbiAgICAgICAgc3ViU2Vjcy5wdXNoKHN1Yl9zZWNzKTtcbiAgICAgICAgaWYgKGhhc0xldmVscykge1xuICAgICAgICAgICAgc3ViTGV2cy5wdXNoKHN1Yl9sZXZzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgTjBfbWF4ID0gTWF0aC5tYXgoLi4uTjApO1xuICAgIHZhciBOX3RpbWVzX21heCA9IE1hdGgubWF4KC4uLk5fdGltZXMpO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGRfaWR4ID0gMDsgZF9pZHggPCBjdXJ2ZUluZGVwZW5kZW50VmFycy5sZW5ndGg7IGRfaWR4KyspIHtcbiAgICAgICAgdmFyIHRoaXNfTjAgPSBOMFtkX2lkeF07XG4gICAgICAgIHZhciB0aGlzX05fdGltZXMgPSBOX3RpbWVzW2RfaWR4XTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhbnkgcG9pbnRzIHdpdGggZmFyIGxlc3MgZGF0YSB0aGFuIHRoZSByZXN0IG9mIHRoZSBncmFwaCwgYW5kIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhbnkgcG9pbnRzIHdpdGggYSBzbWFsbGVyIGNvbXBsZXRlbmVzcyB2YWx1ZSB0aGFuIHNwZWNpZmllZCBieSB0aGUgdXNlci5cbiAgICAgICAgaWYgKHRoaXNfTjAgPCAwLjA1ICogTjBfbWF4IHx8IHRoaXNfTl90aW1lcyA8IGNvbXBsZXRlbmVzc1FDUGFyYW0gKiBOX3RpbWVzX21heCkge1xuICAgICAgICAgICAgaWYgKHBsb3RUeXBlID09PSBtYXRzVHlwZXMuUGxvdFR5cGVzLnByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9maWxlIGhhcyB0aGUgc3RhdCBmaXJzdCwgYW5kIHRoZW4gdGhlIGluZGVwZW5kZW50IHZhci4gVGhlIG90aGVycyBoYXZlIGluZGVwZW5kZW50IHZhciBhbmQgdGhlbiBzdGF0LlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaW4gdGhlIHBhdHRlcm4gb2YgeC1wbG90dGVkLXZhcmlhYmxlLCB5LXBsb3R0ZWQtdmFyaWFibGUuXG4gICAgICAgICAgICAgICAgLy9kLnB1c2goW251bGwsIGN1cnZlSW5kZXBlbmRlbnRWYXJzW2RfaWR4XSwgLTEsIE5hTiwgTmFOLCBOYU5dKTtcbiAgICAgICAgICAgICAgICBkLngucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBkLnkucHVzaChjdXJ2ZUluZGVwZW5kZW50VmFyc1tkX2lkeF0pO1xuICAgICAgICAgICAgICAgIGQuZXJyb3JfeC5wdXNoKG51bGwpOyAgLy8gcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAvL2QuZXJyb3JfeSBub3QgdXNlZCBmb3IgcHJvZmlsZVxuICAgICAgICAgICAgICAgIGQuc3ViVmFscy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgZC5zdWJTZWNzLnB1c2goTmFOKTtcbiAgICAgICAgICAgICAgICBkLnN1YkxldnMucHVzaChOYU4pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwbG90VHlwZSAhPT0gbWF0c1R5cGVzLlBsb3RUeXBlcy5kaWVvZmYpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgZGllb2Zmcywgd2UgZG9uJ3Qgd2FudCB0byBhZGQgYSBudWxsIGZvciBtaXNzaW5nIGRhdGEuIEp1c3QgZG9uJ3QgaGF2ZSBhIHBvaW50IGZvciB0aGF0IEZIUi5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZC5wdXNoKFtjdXJ2ZUluZGVwZW5kZW50VmFyc1tkX2lkeF0sIG51bGwsIC0xLCBOYU4sIE5hTiwgTmFOXSk7XG4gICAgICAgICAgICAgICAgICAgIGQueC5wdXNoKGN1cnZlSW5kZXBlbmRlbnRWYXJzW2RfaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIGQueS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAvL2QuZXJyb3JfeCBub3QgdXNlZCBmb3IgY3VydmVzIG90aGVyIHRoYW4gcHJvZmlsZVxuICAgICAgICAgICAgICAgICAgICBkLmVycm9yX3kucHVzaChudWxsKTsgIC8vIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIGQuc3ViVmFscy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgICAgIGQuc3ViU2Vjcy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgICAgIGQuc3ViTGV2cy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9kLnB1c2goW2N1cnZlSW5kZXBlbmRlbnRWYXJzW2RfaWR4XSwgbnVsbCwgLTEsIE5hTiwgTmFOXSk7XG4gICAgICAgICAgICAgICAgICAgIGQueC5wdXNoKGN1cnZlSW5kZXBlbmRlbnRWYXJzW2RfaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIGQueS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAvL2QuZXJyb3JfeCBub3QgdXNlZCBmb3IgY3VydmVzIG90aGVyIHRoYW4gcHJvZmlsZVxuICAgICAgICAgICAgICAgICAgICBkLmVycm9yX3kucHVzaChudWxsKTsgIC8vIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIGQuc3ViVmFscy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgICAgIGQuc3ViU2Vjcy5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxzZSBhZGQgdGhlIHJlYWwgZGF0YVxuICAgICAgICAgICAgc3VtICs9IGN1cnZlU3RhdHNbZF9pZHhdO1xuICAgICAgICAgICAgaWYgKHBsb3RUeXBlID09PSBtYXRzVHlwZXMuUGxvdFR5cGVzLnByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9maWxlIGhhcyB0aGUgc3RhdCBmaXJzdCwgYW5kIHRoZW4gdGhlIGluZGVwZW5kZW50IHZhci4gVGhlIG90aGVycyBoYXZlIGluZGVwZW5kZW50IHZhciBhbmQgdGhlbiBzdGF0LlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaW4gdGhlIHBhdHRlcm4gb2YgeC1wbG90dGVkLXZhcmlhYmxlLCB5LXBsb3R0ZWQtdmFyaWFibGUuXG4vLyAgICAgICAgICAgICAgICBkLnB1c2goW2N1cnZlU3RhdHNbZF9pZHhdLCBjdXJ2ZUluZGVwZW5kZW50VmFyc1tkX2lkeF0sIC0xLCBzdWJWYWxzW2RfaWR4XSwgc3ViU2Vjc1tkX2lkeF0sIHN1YkxldnNbZF9pZHhdXSk7XG4gICAgICAgICAgICAgICAgZC54LnB1c2goY3VydmVTdGF0c1tkX2lkeF0pO1xuICAgICAgICAgICAgICAgIGQueS5wdXNoKGN1cnZlSW5kZXBlbmRlbnRWYXJzW2RfaWR4XSk7XG4gICAgICAgICAgICAgICAgZC5lcnJvcl94LnB1c2gobnVsbCk7IC8vIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgLy9kLmVycm9yX3kgbm90IHVzZWQgZm9yIGN1cnZlcyBvdGhlciB0aGFuIHByb2ZpbGVcbiAgICAgICAgICAgICAgICBkLnN1YlZhbHMucHVzaChzdWJWYWxzW2RfaWR4XSk7XG4gICAgICAgICAgICAgICAgZC5zdWJTZWNzLnB1c2goc3ViU2Vjc1tkX2lkeF0pO1xuICAgICAgICAgICAgICAgIGQuc3ViTGV2cy5wdXNoKHN1YkxldnNbZF9pZHhdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzTGV2ZWxzKSB7XG4vLyAgICAgICAgICAgICAgICBkLnB1c2goW2N1cnZlSW5kZXBlbmRlbnRWYXJzW2RfaWR4XSwgY3VydmVTdGF0c1tkX2lkeF0sIC0xLCBzdWJWYWxzW2RfaWR4XSwgc3ViU2Vjc1tkX2lkeF0sIHN1YkxldnNbZF9pZHhdXSk7XG4gICAgICAgICAgICAgICAgZC54LnB1c2goY3VydmVJbmRlcGVuZGVudFZhcnNbZF9pZHhdKTtcbiAgICAgICAgICAgICAgICBkLnkucHVzaChjdXJ2ZVN0YXRzW2RfaWR4XSk7XG4gICAgICAgICAgICAgICAgLy9kLmVycm9yX3ggbm90IHVzZWQgZm9yIGN1cnZlcyBvdGhlciB0aGFuIHByb2ZpbGVcbiAgICAgICAgICAgICAgICBkLmVycm9yX3kucHVzaChudWxsKTsgIC8vIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgZC5zdWJWYWxzLnB1c2goc3ViVmFsc1tkX2lkeF0pO1xuICAgICAgICAgICAgICAgIGQuc3ViU2Vjcy5wdXNoKHN1YlNlY3NbZF9pZHhdKTtcbiAgICAgICAgICAgICAgICBkLnN1YkxldnMucHVzaChzdWJMZXZzW2RfaWR4XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgZC5wdXNoKFtjdXJ2ZUluZGVwZW5kZW50VmFyc1tkX2lkeF0sIGN1cnZlU3RhdHNbZF9pZHhdLCAtMSwgc3ViVmFsc1tkX2lkeF0sIHN1YlNlY3NbZF9pZHhdXSk7XG4gICAgICAgICAgICAgICAgZC54LnB1c2goY3VydmVJbmRlcGVuZGVudFZhcnNbZF9pZHhdKTtcbiAgICAgICAgICAgICAgICBkLnkucHVzaChjdXJ2ZVN0YXRzW2RfaWR4XSk7XG4gICAgICAgICAgICAgICAgLy9kLmVycm9yX3ggbm90IHVzZWQgZm9yIGN1cnZlcyBvdGhlciB0aGFuIHByb2ZpbGVcbiAgICAgICAgICAgICAgICBkLmVycm9yX3kucHVzaChudWxsKTsgIC8vIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgZC5zdWJWYWxzLnB1c2goc3ViVmFsc1tkX2lkeF0pO1xuICAgICAgICAgICAgICAgIGQuc3ViU2Vjcy5wdXNoKHN1YlNlY3NbZF9pZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoZSBtZXQgbGV2ZWxzIGFyZSBvcmRlcmVkIGFzIHN0cmluZ3MsIHNvIHdlIG5lZWQgdG8gcmUtc29ydCB0aGVtXG4gICAgaWYgKHBsb3RUeXBlID09PSBtYXRzVHlwZXMuUGxvdFR5cGVzLnByb2ZpbGUgJiYgYXBwVHlwZSA9PT0gbWF0c1R5cGVzLkFwcFR5cGVzLm1ldGV4cHJlc3MpIHtcbiAgICAgICAgdmFyIGRTb3J0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgZGlkeCA9IDA7IGRpZHggPCBkLnkubGVuZ3RoOyBkaWR4KyspIHtcbiAgICAgICAgICAgIGRTb3J0ZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgeTogZC55W2RpZHhdLFxuICAgICAgICAgICAgICAgIHg6IGQueFtkaWR4XSxcbiAgICAgICAgICAgICAgICBlcnJvcl94OiBkLmVycm9yX3hbZGlkeF0sXG4gICAgICAgICAgICAgICAgc3ViVmFsczogZC5zdWJWYWxzW2RpZHhdLFxuICAgICAgICAgICAgICAgIHN1YlNlY3M6IGQuc3ViU2Vjc1tkaWR4XSxcbiAgICAgICAgICAgICAgICBzdWJMZXZzOiBkLnN1YkxldnNbZGlkeF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGQueSA9IFtdO1xuICAgICAgICBkLnggPSBbXTtcbiAgICAgICAgZC5lcnJvcl94ID0gW107XG4gICAgICAgIGQuc3ViVmFscyA9IFtdO1xuICAgICAgICBkLnN1YlNlY3MgPSBbXTtcbiAgICAgICAgZC5zdWJMZXZzID0gW107XG4gICAgICAgIGRTb3J0ZWQuc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEueSAtIGIueTsgfSk7XG4gICAgICAgIGRTb3J0ZWQubWFwKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICBkLnkucHVzaChlbGVtLnkpO1xuICAgICAgICAgICAgZC54LnB1c2goZWxlbS54KTtcbiAgICAgICAgICAgIGQuZXJyb3JfeC5wdXNoKGVsZW0uZXJyb3JfeCk7XG4gICAgICAgICAgICBkLnN1YlZhbHMucHVzaChlbGVtLnN1YlZhbHMpO1xuICAgICAgICAgICAgZC5zdWJTZWNzLnB1c2goZWxlbS5zdWJTZWNzKTtcbiAgICAgICAgICAgIGQuc3ViTGV2cy5wdXNoKGVsZW0uc3ViTGV2cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlcmVkeCA9IGQueC5maWx0ZXIoeCA9PiB4KTtcbiAgICBjb25zdCBmaWx0ZXJlZHkgPSBkLnkuZmlsdGVyKHkgPT4geSk7XG4gICAgZC54bWluID0gTWF0aC5taW4oLi4uZmlsdGVyZWR4KTtcbiAgICBkLnhtYXggPSBNYXRoLm1heCguLi5maWx0ZXJlZHgpO1xuICAgIGQueW1pbiA9IE1hdGgubWluKC4uLmZpbHRlcmVkeSk7XG4gICAgZC55bWF4ID0gTWF0aC5tYXgoLi4uZmlsdGVyZWR5KTtcbiAgICBkLnN1bSA9IHN1bTtcblxuICAgIGlmIChkLnhtaW4gPT0gXCItSW5maW5pdHlcIiB8fCAoZC54LmluZGV4T2YoMCkgIT09IC0xICYmIDAgPCBkLnhtaW4pKSB7XG4gICAgICAgIGQueG1pbiA9IDA7XG4gICAgfVxuICAgIGlmIChkLnltaW4gPT0gXCItSW5maW5pdHlcIiB8fCAoZC55LmluZGV4T2YoMCkgIT09IC0xICYmIDAgPCBkLnltaW4pKSB7XG4gICAgICAgIGQueW1pbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGQueG1heCA9PSBcIi1JbmZpbml0eVwiKSB7XG4gICAgICAgIGQueG1heCA9IDA7XG4gICAgfVxuICAgIGlmIChkLnltYXggPT0gXCItSW5maW5pdHlcIikge1xuICAgICAgICBkLnltYXggPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGQ6IGQsXG4gICAgICAgIE4wOiBOMCxcbiAgICAgICAgTl90aW1lczogTl90aW1lc1xuICAgIH07XG59O1xuXG4vLyB0aGlzIG1ldGhvZCBwYXJzZXMgdGhlIHJldHVybmVkIHF1ZXJ5IGRhdGEgZm9yIGhpc3RvZ3JhbXNcbmNvbnN0IHBhcnNlUXVlcnlEYXRhSGlzdG9ncmFtID0gZnVuY3Rpb24gKGQsIHJvd3MsIGhhc0xldmVscykge1xuICAgIC8qXG4gICAgICAgIHZhciBkID0gey8vIGQgd2lsbCBjb250YWluIHRoZSBjdXJ2ZSBkYXRhXG4gICAgICAgICAgICB4OiBbXSwgLy9wbGFjZWhvbGRlclxuICAgICAgICAgICAgeTogW10sIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGVycm9yX3g6IFtdLCAvLyB1bnVzZWRcbiAgICAgICAgICAgIGVycm9yX3k6IFtdLCAvLyB1bnVzZWRcbiAgICAgICAgICAgIHN1YlZhbHM6IFtdLFxuICAgICAgICAgICAgc3ViU2VjczogW10sXG4gICAgICAgICAgICBzdWJMZXZzOiBbXSxcbiAgICAgICAgICAgIGdsb2Jfc3RhdHM6IFtdLCAvLyBwbGFjZWhvbGRlclxuICAgICAgICAgICAgYmluX3N0YXRzOiBbXSwgLy8gcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHRleHQ6IFtdIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHhtaW46bnVtLFxuICAgICAgICAgICAgeG1heDpudW0sXG4gICAgICAgICAgICB5bWluOm51bSxcbiAgICAgICAgICAgIHltYXg6bnVtXG4gICAgICAgIH07XG4gICAgKi9cblxuICAgIC8vIHRoZXNlIGFycmF5cyBob2xkIGFsbCB0aGUgc3ViIHZhbHVlcyBhbmQgc2Vjb25kcyAoYW5kIGxldmVscykgdW50aWwgdGhleSBhcmUgc29ydGVkIGludG8gYmluc1xuICAgIHZhciBjdXJ2ZVN1YlN0YXRzUmF3ID0gW107XG4gICAgdmFyIGN1cnZlU3ViU2Vjc1JhdyA9IFtdO1xuICAgIHZhciBjdXJ2ZVN1YkxldnNSYXcgPSBbXTtcblxuICAgIC8vIHBhcnNlIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHF1ZXJ5XG4gICAgZm9yICh2YXIgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHJvd3MubGVuZ3RoOyByb3dJbmRleCsrKSB7XG5cbiAgICAgICAgdmFyIHN0YXQgPSByb3dzW3Jvd0luZGV4XS5zdGF0O1xuICAgICAgICB2YXIgc3ViX3N0YXRzID0gW107XG4gICAgICAgIHZhciBzdWJfc2VjcyA9IFtdO1xuICAgICAgICB2YXIgc3ViX2xldnMgPSBbXTtcbiAgICAgICAgaWYgKHN0YXQgIT09IG51bGwgJiYgc3RhdCAhPT0gXCJOVUxMXCIgJiYgcm93c1tyb3dJbmRleF0uc3ViX2RhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViX2RhdGEgPSByb3dzW3Jvd0luZGV4XS5zdWJfZGF0YS50b1N0cmluZygpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJfc3ViX2RhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2RfaWR4ID0gMDsgc2RfaWR4IDwgc3ViX2RhdGEubGVuZ3RoOyBzZF9pZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyX3N1Yl9kYXRhID0gc3ViX2RhdGFbc2RfaWR4XS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgICAgICAgICBzdWJfc3RhdHMucHVzaChOdW1iZXIoY3Vycl9zdWJfZGF0YVswXSkpO1xuICAgICAgICAgICAgICAgICAgICBzdWJfc2Vjcy5wdXNoKE51bWJlcihjdXJyX3N1Yl9kYXRhWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcihjdXJyX3N1Yl9kYXRhWzJdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViX2xldnMucHVzaChOdW1iZXIoY3Vycl9zdWJfZGF0YVsyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yl9sZXZzLnB1c2goY3Vycl9zdWJfZGF0YVsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVTdWJMZXZzUmF3LnB1c2goc3ViX2xldnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VydmVTdWJTdGF0c1Jhdy5wdXNoKHN1Yl9zdGF0cyk7XG4gICAgICAgICAgICAgICAgY3VydmVTdWJTZWNzUmF3LnB1c2goc3ViX3NlY3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3IgcHJvZHVjZWQgYnkgYSBidWcgaW4gdGhlIHF1ZXJ5IGZ1bmN0aW9uLCBub3QgYW4gZXJyb3IgcmV0dXJuZWQgYnkgdGhlIG15c3FsIGRhdGFiYXNlXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gXCJFcnJvciBpbiBwYXJzZVF1ZXJ5RGF0YUhpc3RvZ3JhbS4gVGhlIGV4cGVjdGVkIGZpZWxkcyBkb24ndCBzZWVtIHRvIGJlIHByZXNlbnQgaW4gdGhlIHJlc3VsdHMgY2FjaGU6IFwiICsgZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UgZG9uJ3QgaGF2ZSBiaW5zIHlldCwgc28gd2Ugd2FudCBhbGwgb2YgdGhlIGRhdGEgaW4gb25lIGFycmF5XG4gICAgY29uc3Qgc3ViVmFscyA9IFtdLmNvbmNhdC5hcHBseShbXSwgY3VydmVTdWJTdGF0c1Jhdyk7XG4gICAgY29uc3Qgc3ViU2VjcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgY3VydmVTdWJTZWNzUmF3KTtcbiAgICB2YXIgc3ViTGV2cztcbiAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgIHN1YkxldnMgPSBbXS5jb25jYXQuYXBwbHkoW10sIGN1cnZlU3ViTGV2c1Jhdyk7XG4gICAgfVxuXG4gICAgZC5zdWJWYWxzID0gc3ViVmFscztcbiAgICBkLnN1YlNlY3MgPSBzdWJTZWNzO1xuICAgIGQuc3ViTGV2cyA9IHN1YkxldnM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkOiBkLFxuICAgICAgICBOMDogc3ViVmFscy5sZW5ndGgsXG4gICAgICAgIE5fdGltZXM6IHN1YlNlY3MubGVuZ3RoXG4gICAgfTtcbn07XG5cbi8vdGhpcyBtZXRob2QgcGFyc2VzIHRoZSByZXR1cm5lZCBxdWVyeSBkYXRhIGZvciBjb250b3VyIHBsb3RzXG5jb25zdCBwYXJzZVF1ZXJ5RGF0YUNvbnRvdXIgPSBmdW5jdGlvbiAocm93cywgZCkge1xuICAgIC8qXG4gICAgICAgIHZhciBkID0gey8vIGQgd2lsbCBjb250YWluIHRoZSBjdXJ2ZSBkYXRhXG4gICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgIHk6IFtdLFxuICAgICAgICAgICAgejogW10sXG4gICAgICAgICAgICBuOiBbXSxcbiAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgeFRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgeVRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgelRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgblRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgbWluRGF0ZVRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgbWF4RGF0ZVRleHRPdXRwdXQ6IFtdLFxuICAgICAgICAgICAgc3RhdHM6IFtdXSxcbiAgICAgICAgICAgIGdsb2Jfc3RhdHM6IHt9LFxuICAgICAgICAgICAgeG1pbjpudW0sXG4gICAgICAgICAgICB5bWluOm51bSxcbiAgICAgICAgICAgIHptaW46bnVtLFxuICAgICAgICAgICAgeG1heDpudW0sXG4gICAgICAgICAgICB5bWF4Om51bSxcbiAgICAgICAgICAgIHptYXg6bnVtLFxuICAgICAgICAgICAgc3VtOm51bVxuICAgICAgICB9O1xuICAgICovXG4gICAgdmFyIGN1cnZlU3RhdExvb2t1cCA9IHt9O1xuICAgIHZhciBjdXJ2ZU5Mb29rdXAgPSB7fTtcbiAgICAvLyBnZXQgYWxsIHRoZSBkYXRhIG91dCBvZiB0aGUgcXVlcnkgYXJyYXlcbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93cy5sZW5ndGg7IHJvd0luZGV4KyspIHtcbiAgICAgICAgdmFyIHJvd1hWYWwgPSByb3dzW3Jvd0luZGV4XS54VmFsO1xuICAgICAgICB2YXIgcm93WVZhbCA9IHJvd3Nbcm93SW5kZXhdLnlWYWw7XG4gICAgICAgIHZhciBzdGF0S2V5ID0gcm93WFZhbC50b1N0cmluZygpICsgJ18nICsgcm93WVZhbC50b1N0cmluZygpO1xuICAgICAgICB2YXIgc3RhdCA9IHJvd3Nbcm93SW5kZXhdLnN0YXQ7XG4gICAgICAgIHZhciBuID0gcm93c1tyb3dJbmRleF0uc3ViX2RhdGEgIT09IG51bGwgPyByb3dzW3Jvd0luZGV4XS5zdWJfZGF0YS50b1N0cmluZygpLnNwbGl0KCcsJykubGVuZ3RoIDogMDtcbiAgICAgICAgdmFyIG1pbkRhdGUgPSByb3dzW3Jvd0luZGV4XS5taW5fc2VjcztcbiAgICAgICAgdmFyIG1heERhdGUgPSByb3dzW3Jvd0luZGV4XS5tYXhfc2VjcztcbiAgICAgICAgaWYgKHN0YXQgPT09IHVuZGVmaW5lZCB8fCBzdGF0ID09PSBudWxsIHx8IHN0YXQgPT09ICdOVUxMJykge1xuICAgICAgICAgICAgc3RhdCA9IG51bGw7XG4gICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgIG1pbkRhdGUgPSBudWxsO1xuICAgICAgICAgICAgbWF4RGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcmUgZmxhdCBhcnJheXMgb2YgYWxsIHRoZSBwYXJzZWQgZGF0YSwgdXNlZCBieSB0aGUgdGV4dCBvdXRwdXQgYW5kIGZvciBzb21lIGNhbGN1bGF0aW9ucyBsYXRlclxuICAgICAgICBkLnhUZXh0T3V0cHV0LnB1c2goTnVtYmVyKHJvd1hWYWwpKTtcbiAgICAgICAgZC55VGV4dE91dHB1dC5wdXNoKE51bWJlcihyb3dZVmFsKSk7XG4gICAgICAgIGQuelRleHRPdXRwdXQucHVzaChzdGF0KTtcbiAgICAgICAgZC5uVGV4dE91dHB1dC5wdXNoKG4pO1xuICAgICAgICBkLm1pbkRhdGVUZXh0T3V0cHV0LnB1c2gobWluRGF0ZSk7XG4gICAgICAgIGQubWF4RGF0ZVRleHRPdXRwdXQucHVzaChtYXhEYXRlKTtcbiAgICAgICAgY3VydmVTdGF0TG9va3VwW3N0YXRLZXldID0gc3RhdDtcbiAgICAgICAgY3VydmVOTG9va3VwW3N0YXRLZXldID0gbjtcbiAgICB9XG4gICAgLy8gZ2V0IHRoZSB1bmlxdWUgeCBhbmQgeSB2YWx1ZXMgYW5kIHNvcnQgdGhlIHN0YXRzIGludG8gdGhlIDJEIHogYXJyYXkgYWNjb3JkaW5nbHlcbiAgICBkLnggPSBtYXRzRGF0YVV0aWxzLmFycmF5VW5pcXVlKGQueFRleHRPdXRwdXQpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiXG4gICAgfSk7XG4gICAgZC55ID0gbWF0c0RhdGFVdGlscy5hcnJheVVuaXF1ZShkLnlUZXh0T3V0cHV0KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYlxuICAgIH0pO1xuICAgIHZhciBpO1xuICAgIHZhciBqO1xuICAgIHZhciBjdXJyWDtcbiAgICB2YXIgY3Vyclk7XG4gICAgdmFyIGN1cnJTdGF0O1xuICAgIHZhciBjdXJyTjtcbiAgICB2YXIgY3VyclN0YXRLZXk7XG4gICAgdmFyIGN1cnJZU3RhdEFycmF5O1xuICAgIHZhciBjdXJyWU5BcnJheTtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgblBvaW50cyA9IDA7XG4gICAgZm9yIChqID0gMDsgaiA8IGQueS5sZW5ndGg7IGorKykge1xuICAgICAgICBjdXJyWSA9IGQueVtqXTtcbiAgICAgICAgY3VycllTdGF0QXJyYXkgPSBbXTtcbiAgICAgICAgY3VycllOQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGQueC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VyclggPSBkLnhbaV07XG4gICAgICAgICAgICBjdXJyU3RhdEtleSA9IGN1cnJYLnRvU3RyaW5nKCkgKyAnXycgKyBjdXJyWS50b1N0cmluZygpO1xuICAgICAgICAgICAgY3VyclN0YXQgPSBjdXJ2ZVN0YXRMb29rdXBbY3VyclN0YXRLZXldO1xuICAgICAgICAgICAgY3Vyck4gPSBjdXJ2ZU5Mb29rdXBbY3VyclN0YXRLZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJTdGF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyWVN0YXRBcnJheS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGN1cnJZTkFycmF5LnB1c2goMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1bSArPSBjdXJyU3RhdDtcbiAgICAgICAgICAgICAgICBuUG9pbnRzID0gblBvaW50cyArIDE7XG4gICAgICAgICAgICAgICAgY3VycllTdGF0QXJyYXkucHVzaChjdXJyU3RhdCk7XG4gICAgICAgICAgICAgICAgY3VycllOQXJyYXkucHVzaChjdXJyTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZC56LnB1c2goY3VycllTdGF0QXJyYXkpO1xuICAgICAgICBkLm4ucHVzaChjdXJyWU5BcnJheSk7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHN0YXRpc3RpY3NcbiAgICBjb25zdCBmaWx0ZXJlZHggPSBkLnguZmlsdGVyKHggPT4geCk7XG4gICAgY29uc3QgZmlsdGVyZWR5ID0gZC55LmZpbHRlcih5ID0+IHkpO1xuICAgIGNvbnN0IGZpbHRlcmVkeiA9IGQuelRleHRPdXRwdXQuZmlsdGVyKHogPT4geik7XG4gICAgZC54bWluID0gTWF0aC5taW4oLi4uZmlsdGVyZWR4KTtcbiAgICBkLnhtYXggPSBNYXRoLm1heCguLi5maWx0ZXJlZHgpO1xuICAgIGQueW1pbiA9IE1hdGgubWluKC4uLmZpbHRlcmVkeSk7XG4gICAgZC55bWF4ID0gTWF0aC5tYXgoLi4uZmlsdGVyZWR5KTtcbiAgICBkLnptaW4gPSBNYXRoLm1pbiguLi5maWx0ZXJlZHopO1xuICAgIGQuem1heCA9IE1hdGgubWF4KC4uLmZpbHRlcmVkeik7XG4gICAgZC5zdW0gPSBzdW07XG5cbiAgICBpZiAoZC54bWluID09IFwiLUluZmluaXR5XCIgfHwgKGQueC5pbmRleE9mKDApICE9PSAtMSAmJiAwIDwgZC54bWluKSkge1xuICAgICAgICBkLnhtaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoZC55bWluID09IFwiLUluZmluaXR5XCIgfHwgKGQueS5pbmRleE9mKDApICE9PSAtMSAmJiAwIDwgZC55bWluKSkge1xuICAgICAgICBkLnltaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoZC56bWluID09IFwiLUluZmluaXR5XCIgfHwgKGQuelRleHRPdXRwdXQuaW5kZXhPZigwKSAhPT0gLTEgJiYgMCA8IGQuem1pbikpIHtcbiAgICAgICAgZC56bWluID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZC54bWF4ID09IFwiLUluZmluaXR5XCIpIHtcbiAgICAgICAgZC54bWF4ID0gMDtcbiAgICB9XG4gICAgaWYgKGQueW1heCA9PSBcIi1JbmZpbml0eVwiKSB7XG4gICAgICAgIGQueW1heCA9IDA7XG4gICAgfVxuICAgIGlmIChkLnptYXggPT0gXCItSW5maW5pdHlcIikge1xuICAgICAgICBkLnptYXggPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlcmVkTWluRGF0ZSA9IGQubWluRGF0ZVRleHRPdXRwdXQuZmlsdGVyKHQgPT4gdCk7XG4gICAgY29uc3QgZmlsdGVyZWRNYXhEYXRlID0gZC5tYXhEYXRlVGV4dE91dHB1dC5maWx0ZXIodCA9PiB0KTtcbiAgICBkLmdsb2Jfc3RhdHNbJ21lYW4nXSA9IHN1bSAvIG5Qb2ludHM7XG4gICAgZC5nbG9iX3N0YXRzWydtaW5EYXRlJ10gPSBNYXRoLm1pbiguLi5maWx0ZXJlZE1pbkRhdGUpO1xuICAgIGQuZ2xvYl9zdGF0c1snbWF4RGF0ZSddID0gTWF0aC5tYXgoLi4uZmlsdGVyZWRNYXhEYXRlKTtcbiAgICBkLmdsb2Jfc3RhdHNbJ24nXSA9IG5Qb2ludHM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkOiBkXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdHNEYXRhUXVlcnlVdGlscyA9IHtcblxuICAgIHNpbXBsZVBvb2xRdWVyeVdyYXBTeW5jaHJvbm91czogc2ltcGxlUG9vbFF1ZXJ5V3JhcFN5bmNocm9ub3VzLFxuICAgIHF1ZXJ5REJUaW1lU2VyaWVzOiBxdWVyeURCVGltZVNlcmllcyxcbiAgICBxdWVyeURCU3BlY2lhbHR5Q3VydmU6IHF1ZXJ5REJTcGVjaWFsdHlDdXJ2ZSxcbiAgICBxdWVyeU1hcERCOiBxdWVyeU1hcERCLFxuICAgIHF1ZXJ5REJDb250b3VyOiBxdWVyeURCQ29udG91clxuXG59XG5cblxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbmltcG9ydCB7bWF0c1R5cGVzfSBmcm9tICdtZXRlb3IvcmFuZHlwOm1hdHMtY29tbW9uJztcbmltcG9ydCB7bWF0c0NvbGxlY3Rpb25zfSBmcm9tICdtZXRlb3IvcmFuZHlwOm1hdHMtY29tbW9uJztcbmltcG9ydCB7bWF0c1Bsb3RVdGlsc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5cbi8vIHJldHVybnMgdGhlIGRhdGEgZm9yIHdoaWNoZXZlciBjdXJ2ZSBoYXMgdGhlIGxhcmdlciBpbnRlcnZhbCBpbiBpdHMgaW5kZXBlbmRlbnQgdmFyaWFibGVcbmNvbnN0IGdldExhcmdlSW50ZXJ2YWxDdXJ2ZURhdGEgPSBmdW5jdGlvbiAoZGF0YXNldCwgZGlmZkZyb20sIGluZGVwZW5kZW50VmFyTmFtZSkge1xuICAgIHZhciBkYXRhTWF4SW50ZXJ2YWwgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgIHZhciBsYXJnZUludGVydmFsQ3VydmVEYXRhID0gZGF0YXNldFtkaWZmRnJvbVswXV07XG4gICAgLy8gc2V0IHVwIHRoZSBpbmRleGVzIGFuZCBkZXRlcm1pbmUgdGhlIG1pbmltdW0gaW5kZXBlbmRlbnRWYXJOYW1lIHZhbHVlIGZvciB0aGUgZGF0YXNldFxuICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBkYXRhc2V0Lmxlbmd0aDsgY2krKykge1xuICAgICAgICBpZiAoZGF0YXNldFtjaV1baW5kZXBlbmRlbnRWYXJOYW1lXSA9PT0gdW5kZWZpbmVkIHx8IGRhdGFzZXRbY2ldW2luZGVwZW5kZW50VmFyTmFtZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBvbmUgb2YgdGhlIGN1cnZlcyBoYXMgbm8gZGF0YS4gTm8gbWF0Y2ggcG9zc2libGUuIEp1c3QgdXNlIGludGVydmFsIGZyb20gZmlyc3QgY3VydmVcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0W2NpXVtpbmRlcGVuZGVudFZhck5hbWVdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBkaWZmO1xuICAgICAgICAgICAgZm9yICh2YXIgZGkgPSAwOyBkaSA8IGRhdGFzZXRbY2ldW2luZGVwZW5kZW50VmFyTmFtZV0ubGVuZ3RoIC0gMTsgZGkrKykgeyAgLy8gZG9uJ3QgZ28gYWxsIHRoZSB3YXkgdG8gdGhlIGVuZCAtIG9uZSBzaHlcbiAgICAgICAgICAgICAgICBkaWZmID0gZGF0YXNldFtjaV1baW5kZXBlbmRlbnRWYXJOYW1lXVtkaSArIDFdIC0gZGF0YXNldFtjaV1baW5kZXBlbmRlbnRWYXJOYW1lXVtkaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPiBkYXRhTWF4SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YU1heEludGVydmFsID0gZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgbGFyZ2VJbnRlcnZhbEN1cnZlRGF0YSA9IGRhdGFzZXRbY2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGFyZ2VJbnRlcnZhbEN1cnZlRGF0YTtcbn07XG5cbi8vIGdlbmVyYXRlcyBkaWZmIGN1cnZlcyBmb3IgYWxsIHBsb3QgdHlwZXMgdGhhdCBoYXZlIGRpZmYgY3VydmVzLlxuY29uc3QgZ2V0RGF0YUZvckRpZmZDdXJ2ZSA9IGZ1bmN0aW9uIChkYXRhc2V0LCBkaWZmRnJvbSwgcGxvdFR5cGUsIGhhc0xldmVscykge1xuICAgIC8qXG4gICAgIERBVEFTRVQgRUxFTUVOVFM6XG4gICAgICAgIHNlcmllczogW2RhdGEsZGF0YSxkYXRhIC4uLi4uLiBdICAgZWFjaCBkYXRhIGlzIGl0c2VsZiBhbiBvYmplY3RcbiAgICAgICAgZCA9IHtcbiAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICBlcnJvcl94OiBbXSwgICAvLyBjdXJ2ZVRpbWVcbiAgICAgICAgICAgIGVycm9yX3k6IFtdLCAgIC8vIHZhbHVlc1xuICAgICAgICAgICAgc3ViVmFsczogW10sICAgLy9zdWJWYWxzXG4gICAgICAgICAgICBzdWJTZWNzOiBbXSwgICAvL3N1YlNlY3NcbiAgICAgICAgICAgIHN1YkxldnM6IFtdLCAgIC8vc3ViTGV2c1xuICAgICAgICAgICAgc3RhdHM6IFtdLCAgICAgLy9wb2ludFN0YXRzXG4gICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgIGdsb2Jfc3RhdHM6IHt9LCAgICAgLy9jdXJ2ZVN0YXRzXG4gICAgICAgICAgICB4bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgeG1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIHltaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB5bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgc3VtOiAwXG4gICAgICAgIH07XG5cbiAgICAgTk9URSAtLSBmb3IgcHJvZmlsZXMsIHggaXMgdGhlIHN0YXRWYXJOYW1lIGFuZCB5IGlzIHRoZSBpbmRlcGVuZGVudFZhck5hbWUsIGJlY2F1c2UgcHJvZmlsZXMgcGxvdCB0aGUgc3RhdFZhck5hbWVcbiAgICAgICAgb24gdGhlIHggYXhpcyBhbmQgdGhlIGluZGVwZW5kZW50VmFyTmFtZSBvbiB0aGUgeSBheGlzLlxuXG4gICAgRm9yIGhpc3RvZ3JhbXM6XG4gICAgREFUQVNFVCBFTEVNRU5UUzpcbiAgICAgICAgc2VyaWVzOiBbZGF0YSxkYXRhLGRhdGEgLi4uLi4uIF0gICBlYWNoIGRhdGEgaXMgaXRzZWxmIGFuIGFycmF5XG4gICAgICAgIGQgPSB7XG4gICAgICAgICAgICB4OiBbXSwgLy9wbGFjZWhvbGRlclxuICAgICAgICAgICAgeTogW10sIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGVycm9yX3g6IFtdLCAvLyB1bnVzZWRcbiAgICAgICAgICAgIGVycm9yX3k6IFtdLCAvLyB1bnVzZWRcbiAgICAgICAgICAgIHN1YlZhbHM6IFtdLFxuICAgICAgICAgICAgc3ViU2VjczogW10sXG4gICAgICAgICAgICBzdWJMZXZzOiBbXSxcbiAgICAgICAgICAgIGdsb2Jfc3RhdHM6IFtdLCAvLyBwbGFjZWhvbGRlclxuICAgICAgICAgICAgYmluX3N0YXRzOiBbXSwgLy8gcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHRleHQ6IFtdIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgfTtcblxuICAgICAqL1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgZGF0YVswXSBvciBkYXRhWzFdIGlzIHRoZSBpbmRlcGVuZGVudCB2YXJpYWJsZSwgYW5kIHdoaWNoIGlzIHRoZSBzdGF0IHZhbHVlXG4gICAgdmFyIGluZGVwZW5kZW50VmFyTmFtZTtcbiAgICB2YXIgc3RhdFZhck5hbWU7XG4gICAgaWYgKHBsb3RUeXBlICE9PSBtYXRzVHlwZXMuUGxvdFR5cGVzLnByb2ZpbGUpIHtcbiAgICAgICAgaW5kZXBlbmRlbnRWYXJOYW1lID0gJ3gnO1xuICAgICAgICBzdGF0VmFyTmFtZSA9ICd5JztcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlcGVuZGVudFZhck5hbWUgPSAneSc7XG4gICAgICAgIHN0YXRWYXJOYW1lID0gJ3gnO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgdmFyaWFibGVzXG4gICAgdmFyIG1pbnVlbmREYXRhID0gZGF0YXNldFtkaWZmRnJvbVswXV07XG4gICAgdmFyIHN1YnRyYWhlbmREYXRhID0gZGF0YXNldFtkaWZmRnJvbVsxXV07XG4gICAgdmFyIHN1YnRyYWhlbmRJbmRleCA9IDA7XG4gICAgdmFyIG1pbnVlbmRJbmRleCA9IDA7XG5cbiAgICB2YXIgZDtcbiAgICBpZiAocGxvdFR5cGUgIT09IG1hdHNUeXBlcy5QbG90VHlwZXMuaGlzdG9ncmFtKSB7XG4gICAgICAgIGQgPSB7XG4gICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgIHk6IFtdLFxuICAgICAgICAgICAgZXJyb3JfeDogW10sICAgLy8gY3VydmVUaW1lXG4gICAgICAgICAgICBlcnJvcl95OiBbXSwgICAvLyB2YWx1ZXNcbiAgICAgICAgICAgIHN1YlZhbHM6IFtdLCAgIC8vc3ViVmFsc1xuICAgICAgICAgICAgc3ViU2VjczogW10sICAgLy9zdWJTZWNzXG4gICAgICAgICAgICBzdWJMZXZzOiBbXSwgICAvL3N1YkxldnNcbiAgICAgICAgICAgIGdsb2Jfc3RhdHM6IFtdLFxuICAgICAgICAgICAgc3RhdHM6IFtdLCAgICAgLy9jdXJ2ZVN0YXRzXG4gICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgIHhtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB4bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgeW1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIHltYXg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICBzdW06IDBcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkID0ge1xuICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICAgIGVycm9yX3g6IFtdLFxuICAgICAgICAgICAgZXJyb3JfeTogW10sXG4gICAgICAgICAgICBzdWJWYWxzOiBbXSxcbiAgICAgICAgICAgIHN1YlNlY3M6IFtdLFxuICAgICAgICAgICAgc3ViTGV2czogW10sXG4gICAgICAgICAgICBnbG9iX3N0YXRzOiB7XG4gICAgICAgICAgICAgICAgJ2dsb2JfbWVhbic6IG51bGwsXG4gICAgICAgICAgICAgICAgJ2dsb2Jfc2QnOiBudWxsLFxuICAgICAgICAgICAgICAgICdnbG9iX24nOiBudWxsLFxuICAgICAgICAgICAgICAgICdnbG9iX21heCc6IG51bGwsXG4gICAgICAgICAgICAgICAgJ2dsb2JfbWluJzogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJpbl9zdGF0czogW10sXG4gICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgIHhtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB4bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgeW1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIHltYXg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIG5laXRoZXIgY3VydmUgaXMgZW1wdHlcbiAgICBpZiAobWludWVuZERhdGEueC5sZW5ndGggPT09IDAgfHwgc3VidHJhaGVuZERhdGEueC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsnZGF0YXNldCc6IGR9O1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgYSBkaWZmZXJlbmNlIGN1cnZlIC0gd2UgYXJlIGRpZmZlcmVuY2luZyBkaWZmRnJvbVswXSAtIGRpZmZGcm9tWzFdIGJhc2VkIG9uIHRoZVxuICAgIC8vIGluZGVwZW5kZW50VmFyTmFtZSB2YWx1ZXMgb2Ygd2hpY2hldmVyIGhhcyB0aGUgbGFyZ2VzdCBpbnRlcnZhbFxuICAgIC8vIGZpbmQgdGhlIGxhcmdlc3QgaW50ZXJ2YWwgYmV0d2VlbiBkaWZmRnJvbVswXSBjdXJ2ZSBhbmQgZGlmZkZyb21bMV0gY3VydmVcbiAgICB2YXIgbGFyZ2VJbnRlcnZhbEN1cnZlRGF0YSA9IGdldExhcmdlSW50ZXJ2YWxDdXJ2ZURhdGEoZGF0YXNldCwgZGlmZkZyb20sIGluZGVwZW5kZW50VmFyTmFtZSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2VzXG4gICAgZm9yICh2YXIgbGFyZ2VJbnRlcnZhbEN1cnZlSW5kZXggPSAwOyBsYXJnZUludGVydmFsQ3VydmVJbmRleCA8IGxhcmdlSW50ZXJ2YWxDdXJ2ZURhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXS5sZW5ndGg7IGxhcmdlSW50ZXJ2YWxDdXJ2ZUluZGV4KyspIHtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBhcmUgYWN0dWFsbHkgb24gdGhlIHNhbWUgaW5kZXBlbmRlbnRWYXJOYW1lIHZhbHVlIGZvciBlYWNoIGN1cnZlXG4gICAgICAgIHZhciBzdWJ0cmFoZW5kSW5kZXBlbmRlbnRWYXIgPSBzdWJ0cmFoZW5kRGF0YVtpbmRlcGVuZGVudFZhck5hbWVdW3N1YnRyYWhlbmRJbmRleF07XG4gICAgICAgIHZhciBtaW51ZW5kSW5kZXBlbmRlbnRWYXIgPSBtaW51ZW5kRGF0YVtpbmRlcGVuZGVudFZhck5hbWVdW21pbnVlbmRJbmRleF07XG4gICAgICAgIHZhciBsYXJnZUludGVydmFsSW5kZXBlbmRlbnRWYXIgPSBsYXJnZUludGVydmFsQ3VydmVEYXRhW2luZGVwZW5kZW50VmFyTmFtZV1bbGFyZ2VJbnRlcnZhbEN1cnZlSW5kZXhdO1xuXG4gICAgICAgIC8vIGluY3JlbWVudCB0aGUgbWludWVuZEluZGV4IHVudGlsIGl0IHJlYWNoZXMgdGhpcyBpdGVyYXRpb24ncyBsYXJnZUludGVydmFsSW5kZXBlbmRlbnRWYXJcbiAgICAgICAgdmFyIG1pbnVlbmRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChsYXJnZUludGVydmFsSW5kZXBlbmRlbnRWYXIgPiBtaW51ZW5kSW5kZXBlbmRlbnRWYXIgJiYgbWludWVuZEluZGV4IDwgbWludWVuZERhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBtaW51ZW5kSW5kZXBlbmRlbnRWYXIgPSBtaW51ZW5kRGF0YVtpbmRlcGVuZGVudFZhck5hbWVdWysrbWludWVuZEluZGV4XTtcbiAgICAgICAgICAgIG1pbnVlbmRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZSB3YXMgcmVhY2hlZCB3aXRob3V0IGZpbmRpbmcgdGhlIGxhcmdlSW50ZXJ2YWxJbmRlcGVuZGVudFZhciwgaW5jcmVhc2UgdGhlIG1pbnVlbmRJbmRleCB0byB0cmlnZ2VyIHRoZSBlbmQgY29uZGl0aW9ucy5cbiAgICAgICAgaWYgKCFtaW51ZW5kQ2hhbmdlZCAmJiBtaW51ZW5kSW5kZXggPj0gbWludWVuZERhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICArK21pbnVlbmRJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluY3JlbWVudCB0aGUgc3VidHJhaGVuZEluZGV4IHVudGlsIGl0IHJlYWNoZXMgdGhpcyBpdGVyYXRpb24ncyBsYXJnZUludGVydmFsSW5kZXBlbmRlbnRWYXJcbiAgICAgICAgdmFyIHN1YnRyYWhlbmRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChsYXJnZUludGVydmFsSW5kZXBlbmRlbnRWYXIgPiBzdWJ0cmFoZW5kSW5kZXBlbmRlbnRWYXIgJiYgc3VidHJhaGVuZEluZGV4IDwgc3VidHJhaGVuZERhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzdWJ0cmFoZW5kSW5kZXBlbmRlbnRWYXIgPSBzdWJ0cmFoZW5kRGF0YVtpbmRlcGVuZGVudFZhck5hbWVdWysrc3VidHJhaGVuZEluZGV4XTtcbiAgICAgICAgICAgIHN1YnRyYWhlbmRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZSB3YXMgcmVhY2hlZCB3aXRob3V0IGZpbmRpbmcgdGhlIGxhcmdlSW50ZXJ2YWxJbmRlcGVuZGVudFZhciwgaW5jcmVhc2UgdGhlIHN1YnRyYWhlbmRJbmRleCB0byB0cmlnZ2VyIHRoZSBlbmQgY29uZGl0aW9ucy5cbiAgICAgICAgaWYgKCFzdWJ0cmFoZW5kQ2hhbmdlZCAmJiBzdWJ0cmFoZW5kSW5kZXggPj0gc3VidHJhaGVuZERhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICArK3N1YnRyYWhlbmRJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmVmFsdWUgPSBudWxsO1xuICAgICAgICB2YXIgdGVtcFN1YlZhbHNBcnJheTtcbiAgICAgICAgdmFyIHRlbXBTdWJTZWNzQXJyYXk7XG4gICAgICAgIHZhciB0ZW1wU3ViTGV2c0FycmF5O1xuICAgICAgICBpZiAobWludWVuZERhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXVttaW51ZW5kSW5kZXhdICE9PSB1bmRlZmluZWQgJiYgc3VidHJhaGVuZERhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXVtzdWJ0cmFoZW5kSW5kZXhdICE9PSB1bmRlZmluZWQpIHsgIC8vIG1ha2Ugc3VyZSBib3RoIGN1cnZlcyBhY3R1YWxseSBoYXZlIGRhdGEgYXQgdGhpcyBpbmRleFxuICAgICAgICAgICAgaWYgKChtaW51ZW5kRGF0YVtzdGF0VmFyTmFtZV1bbWludWVuZEluZGV4XSAhPT0gbnVsbCAmJiBzdWJ0cmFoZW5kRGF0YVtzdGF0VmFyTmFtZV1bc3VidHJhaGVuZEluZGV4XSAhPT0gbnVsbCkgJiYgbWludWVuZERhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXVttaW51ZW5kSW5kZXhdID09PSBzdWJ0cmFoZW5kRGF0YVtpbmRlcGVuZGVudFZhck5hbWVdW3N1YnRyYWhlbmRJbmRleF0pIHsgLy8gbWFrZSBzdXJlIGRhdGEgaXMgbm90IG51bGwgYXQgdGhpcyBwb2ludCBhbmQgdGhlIGluZGVwZW5kZW50VmFycyBhY3R1YWxseSBtYXRjaFxuXG4gICAgICAgICAgICAgICAgZGlmZlZhbHVlID0gbWludWVuZERhdGFbc3RhdFZhck5hbWVdW21pbnVlbmRJbmRleF0gLSBzdWJ0cmFoZW5kRGF0YVtzdGF0VmFyTmFtZV1bc3VidHJhaGVuZEluZGV4XTtcbiAgICAgICAgICAgICAgICBkW2luZGVwZW5kZW50VmFyTmFtZV0ucHVzaChsYXJnZUludGVydmFsSW5kZXBlbmRlbnRWYXIpO1xuICAgICAgICAgICAgICAgIGRbc3RhdFZhck5hbWVdLnB1c2goZGlmZlZhbHVlKTtcbiAgICAgICAgICAgICAgICBkLmVycm9yX3gucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBkLmVycm9yX3kucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ViVmFsc0FycmF5ID0gW107XG4gICAgICAgICAgICAgICAgdGVtcFN1YlNlY3NBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChoYXNMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN1YkxldnNBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwbG90VHlwZSAhPT0gbWF0c1R5cGVzLlBsb3RUeXBlcy5oaXN0b2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbnVlbmREYXRhU3ViVmFsdWVzID0gbWludWVuZERhdGEuc3ViVmFsc1ttaW51ZW5kSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWludWVuZERhdGFTdWJTZWNvbmRzID0gbWludWVuZERhdGEuc3ViU2Vjc1ttaW51ZW5kSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWludWVuZERhdGFTdWJMZXZlbHMgPSBtaW51ZW5kRGF0YS5zdWJMZXZzW21pbnVlbmRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnRyYWhlbmREYXRhU3ViVmFsdWVzID0gc3VidHJhaGVuZERhdGEuc3ViVmFsc1tzdWJ0cmFoZW5kSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VidHJhaGVuZERhdGFTdWJTZWNvbmRzID0gc3VidHJhaGVuZERhdGEuc3ViU2Vjc1tzdWJ0cmFoZW5kSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VidHJhaGVuZERhdGFTdWJMZXZlbHMgPSBzdWJ0cmFoZW5kRGF0YS5zdWJMZXZzW3N1YnRyYWhlbmRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIG1hdGNoaW5nIHN1YiB2YWx1ZXMgYW5kIGRpZmYgdGhvc2VcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbXZhbElkeCA9IDA7IG12YWxJZHggPCBtaW51ZW5kRGF0YVN1YlZhbHVlcy5sZW5ndGg7IG12YWxJZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3ZhbElkeCA9IDA7IHN2YWxJZHggPCBzdWJ0cmFoZW5kRGF0YVN1YlZhbHVlcy5sZW5ndGg7IHN2YWxJZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNMZXZlbHMgJiYgbWludWVuZERhdGFTdWJTZWNvbmRzW212YWxJZHhdID09PSBzdWJ0cmFoZW5kRGF0YVN1YlNlY29uZHNbc3ZhbElkeF0gJiYgbWludWVuZERhdGFTdWJMZXZlbHNbbXZhbElkeF0gPT09IHN1YnRyYWhlbmREYXRhU3ViTGV2ZWxzW3N2YWxJZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTdWJWYWxzQXJyYXkucHVzaChtaW51ZW5kRGF0YVN1YlZhbHVlc1ttdmFsSWR4XSAtIHN1YnRyYWhlbmREYXRhU3ViVmFsdWVzW3N2YWxJZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN1YlNlY3NBcnJheS5wdXNoKG1pbnVlbmREYXRhU3ViU2Vjb25kc1ttdmFsSWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTdWJMZXZzQXJyYXkucHVzaChtaW51ZW5kRGF0YVN1YkxldmVsc1ttdmFsSWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaGFzTGV2ZWxzICYmIG1pbnVlbmREYXRhU3ViU2Vjb25kc1ttdmFsSWR4XSA9PT0gc3VidHJhaGVuZERhdGFTdWJTZWNvbmRzW3N2YWxJZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTdWJWYWxzQXJyYXkucHVzaChtaW51ZW5kRGF0YVN1YlZhbHVlc1ttdmFsSWR4XSAtIHN1YnRyYWhlbmREYXRhU3ViVmFsdWVzW3N2YWxJZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN1YlNlY3NBcnJheS5wdXNoKG1pbnVlbmREYXRhU3ViU2Vjb25kc1ttdmFsSWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZC5zdWJWYWxzLnB1c2godGVtcFN1YlZhbHNBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIGQuc3ViU2Vjcy5wdXNoKHRlbXBTdWJTZWNzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnN1YkxldnMucHVzaCh0ZW1wU3ViTGV2c0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGQuc3VtID0gZC5zdW0gKyBkW2luZGVwZW5kZW50VmFyTmFtZV1bbGFyZ2VJbnRlcnZhbEN1cnZlSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZC5iaW5fc3RhdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYmluX21lYW4nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jpbl9zZCc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmluX24nOiBkaWZmVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmluX3JmJzogbWludWVuZERhdGEuYmluX3N0YXRzW21pbnVlbmRJbmRleF0uYmluX3JmIC0gc3VidHJhaGVuZERhdGEuYmluX3N0YXRzW3N1YnRyYWhlbmRJbmRleF0uYmluX3JmLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jpbkxvd0JvdW5kJzogbWludWVuZERhdGEuYmluX3N0YXRzW21pbnVlbmRJbmRleF0uYmluTG93Qm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmluVXBCb3VuZCc6IG1pbnVlbmREYXRhLmJpbl9zdGF0c1ttaW51ZW5kSW5kZXhdLmJpblVwQm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmluTGFiZWwnOiBtaW51ZW5kRGF0YS5iaW5fc3RhdHNbbWludWVuZEluZGV4XS5iaW5MYWJlbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2ggZm9yIHRoaXMgaW5kZXBlbmRlbnRWYXJOYW1lXG4gICAgICAgICAgICAgICAgZFtpbmRlcGVuZGVudFZhck5hbWVdLnB1c2gobGFyZ2VJbnRlcnZhbEluZGVwZW5kZW50VmFyKTtcbiAgICAgICAgICAgICAgICBkW3N0YXRWYXJOYW1lXS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGQuZXJyb3JfeC5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGQuZXJyb3JfeS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGQuc3ViVmFscy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICBkLnN1YlNlY3MucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0xldmVscykge1xuICAgICAgICAgICAgICAgICAgICBkLnN1YkxldnMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwbG90VHlwZSA9PT0gbWF0c1R5cGVzLlBsb3RUeXBlcy5oaXN0b2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZC5iaW5fc3RhdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYmluX21lYW4nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jpbl9zZCc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmluX24nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jpbl9yZic6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmluTG93Qm91bmQnOiBtaW51ZW5kRGF0YS5iaW5fc3RhdHNbbWludWVuZEluZGV4XS5iaW5Mb3dCb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaW5VcEJvdW5kJzogbWludWVuZERhdGEuYmluX3N0YXRzW21pbnVlbmRJbmRleF0uYmluVXBCb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaW5MYWJlbCc6IG1pbnVlbmREYXRhLmJpbl9zdGF0c1ttaW51ZW5kSW5kZXhdLmJpbkxhYmVsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCghc3VidHJhaGVuZENoYW5nZWQgJiYgc3VidHJhaGVuZEluZGV4ID49IHN1YnRyYWhlbmREYXRhW2luZGVwZW5kZW50VmFyTmFtZV0ubGVuZ3RoIC0gMSkgfHwgKCFtaW51ZW5kQ2hhbmdlZCAmJiBtaW51ZW5kSW5kZXggPj0gbWludWVuZERhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXS5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgLy8gd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIGF0IGxlYXN0IG9uZSBjdXJ2ZSwgc28gZW5kIHRoZSBkaWZmaW5nLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZHggPSBkLnguZmlsdGVyKHggPT4geCk7XG4gICAgY29uc3QgZmlsdGVyZWR5ID0gZC55LmZpbHRlcih5ID0+IHkpO1xuICAgIGQueG1pbiA9IE1hdGgubWluKC4uLmZpbHRlcmVkeCk7XG4gICAgZC54bWF4ID0gTWF0aC5tYXgoLi4uZmlsdGVyZWR4KTtcbiAgICBkLnltaW4gPSBNYXRoLm1pbiguLi5maWx0ZXJlZHkpO1xuICAgIGQueW1heCA9IE1hdGgubWF4KC4uLmZpbHRlcmVkeSk7XG5cbiAgICByZXR1cm4geydkYXRhc2V0JzogZH07XG59O1xuXG4vLyBnZW5lcmF0ZXMgZGlmZiBvZiB0d28gY29udG91cnMuXG5jb25zdCBnZXREYXRhRm9yRGlmZkNvbnRvdXIgPSBmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgIC8qXG4gICAgIERBVEFTRVQgRUxFTUVOVFM6XG4gICAgICAgIGRbaV0gPSB7XG4gICAgICAgICAgICBsYWJlbDogc3RyaW5nLFxuICAgICAgICAgICAgY3VydmVJZDogc3RyaW5nLFxuICAgICAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgYW5ub3RhdGVDb2xvcjogc3RyaW5nLFxuICAgICAgICAgICAgYW5ub3RhdGlvbjogc3RyaW5nLCAgICAgICAgICAgICAtLS0tLVxuICAgICAgICAgICAgeDogW10sICAgICAgICAgICAgICAgICAgICAgICAgICAqKioqKlxuICAgICAgICAgICAgeTogW10sICAgICAgICAgICAgICAgICAgICAgICAgICAqKioqKlxuICAgICAgICAgICAgejogW1tdXSwgICAgICAgICAgICAgICAgICAgICAgICAqKioqKlxuICAgICAgICAgICAgbjogW1tdXSwgICAgICAgICAgICAgICAgICAgICAgICAqKioqKlxuICAgICAgICAgICAgdGV4dDogW10sXG4gICAgICAgICAgICBzdGF0czogW10sXG4gICAgICAgICAgICBnbG9iX3N0YXRzOiBvYmplY3QsICAgICAgICAgICAgIC0tLS0tXG4gICAgICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgICAgICBhdXRvY29udG91cjogYm9vbGVhbixcbiAgICAgICAgICAgIG5jb250b3VyczogbnVtYmVyLFxuICAgICAgICAgICAgY29sb3JiYXI6IG9iamVjdCxcbiAgICAgICAgICAgIGNvbG9yc2NhbGU6IHN0cmluZyxcbiAgICAgICAgICAgIHJldmVyc2VzY2FsZTogYm9vbGVhbixcbiAgICAgICAgICAgIGNvbnRvdXJzOiBvYmplY3QsXG4gICAgICAgICAgICBtYXJrZXI6IG9iamVjdCxcbiAgICAgICAgICAgIHhBeGlzS2V5OiBbXSxcbiAgICAgICAgICAgIHlBeGlzS2V5OiBbXSxcbiAgICAgICAgICAgIHZpc2libGU6IGJvb2xlYW4sXG4gICAgICAgICAgICB4VGV4dE91dHB1dDogW10sICAgICAgICAgICAgICAgICoqKioqXG4gICAgICAgICAgICB5VGV4dE91dHB1dDogW10sICAgICAgICAgICAgICAgICoqKioqXG4gICAgICAgICAgICB6VGV4dE91dHB1dDogW10sICAgICAgICAgICAgICAgICoqKioqXG4gICAgICAgICAgICBuVGV4dE91dHB1dDogW10sICAgICAgICAgICAgICAgICoqKioqXG4gICAgICAgICAgICBtYXhEYXRlVGV4dE91dHB1dDogW10sICAgICAgICAgICoqKioqXG4gICAgICAgICAgICBtaW5EYXRlVGV4dE91dHB1dDogW10sICAgICAgICAgICoqKioqXG4gICAgICAgICAgICB4bWF4OiBudW1iZXIsICAgICAgICAgICAgICAgICAgIC0tLS0tXG4gICAgICAgICAgICB4bWluOiBudW1iZXIsICAgICAgICAgICAgICAgICAgIC0tLS0tXG4gICAgICAgICAgICB5bWF4OiBudW1iZXIsICAgICAgICAgICAgICAgICAgIC0tLS0tXG4gICAgICAgICAgICB5bWluOiBudW1iZXIsICAgICAgICAgICAgICAgICAgIC0tLS0tXG4gICAgICAgICAgICB6bWF4OiBudW1iZXIsICAgICAgICAgICAgICAgICAgIC0tLS0tXG4gICAgICAgICAgICB6bWluOiBudW1iZXIsICAgICAgICAgICAgICAgICAgIC0tLS0tXG4gICAgICAgICAgICBzdW06IG51bWJlciAgICAgICAgICAgICAgICAgICAgICoqKioqXG4gICAgICAgIH07XG5cbiAgICAgICAgKioqKiogaW5kaWNhdGVzIGNhbGN1bGF0aW9uIGluIGxvb3BzXG4gICAgICAgIC0tLS0tIGluZGljYXRlcyBjYWxjdWxhdGlvbiBhZnRlciBsb29wc1xuICAgICAqL1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBvdXRwdXQgb2JqZWN0XG4gICAgdmFyIGRpZmZEYXRhc2V0ID0ge307XG4gICAgZGlmZkRhdGFzZXRbJ2xhYmVsJ10gPSBkYXRhc2V0WzFdLmxhYmVsICsgJy0nICsgZGF0YXNldFswXS5sYWJlbDtcbiAgICBkaWZmRGF0YXNldFsnY3VydmVJZCddID0gZGF0YXNldFsxXS5jdXJ2ZUlkICsgJy0nICsgZGF0YXNldFswXS5jdXJ2ZUlkO1xuICAgIGRpZmZEYXRhc2V0WyduYW1lJ10gPSBkYXRhc2V0WzFdLm5hbWUgKyAnLScgKyBkYXRhc2V0WzBdLm5hbWU7XG4gICAgZGlmZkRhdGFzZXRbJ2Fubm90YXRlQ29sb3InXSA9IFwicmdiKDI1NSwxNjUsMClcIjtcbiAgICBkaWZmRGF0YXNldFsnYW5ub3RhdGlvbiddID0gXCJcIjtcbiAgICBkaWZmRGF0YXNldFsndGV4dCddID0gW107XG4gICAgZGlmZkRhdGFzZXRbJ3R5cGUnXSA9IGRhdGFzZXRbMF0udHlwZTtcbiAgICBkaWZmRGF0YXNldFsnbWFya2VyJ10gPSBkYXRhc2V0WzBdLm1hcmtlcjtcbiAgICBkaWZmRGF0YXNldFsneEF4aXNLZXknXSA9IGRhdGFzZXRbMF0ueEF4aXNLZXk7XG4gICAgZGlmZkRhdGFzZXRbJ3lBeGlzS2V5J10gPSBkYXRhc2V0WzBdLnlBeGlzS2V5O1xuICAgIGRpZmZEYXRhc2V0Wyd2aXNpYmxlJ10gPSBkYXRhc2V0WzBdLnZpc2libGU7XG4gICAgZGlmZkRhdGFzZXRbJ3gnXSA9IFtdO1xuICAgIGRpZmZEYXRhc2V0Wyd5J10gPSBbXTtcbiAgICBkaWZmRGF0YXNldFsneiddID0gW107XG4gICAgZGlmZkRhdGFzZXRbJ24nXSA9IFtdO1xuICAgIGRpZmZEYXRhc2V0Wyd4VGV4dE91dHB1dCddID0gW107XG4gICAgZGlmZkRhdGFzZXRbJ3lUZXh0T3V0cHV0J10gPSBbXTtcbiAgICBkaWZmRGF0YXNldFsnelRleHRPdXRwdXQnXSA9IFtdO1xuICAgIGRpZmZEYXRhc2V0WyduVGV4dE91dHB1dCddID0gW107XG4gICAgZGlmZkRhdGFzZXRbJ21heERhdGVUZXh0T3V0cHV0J10gPSBbXTtcbiAgICBkaWZmRGF0YXNldFsnbWluRGF0ZVRleHRPdXRwdXQnXSA9IFtdO1xuICAgIGRpZmZEYXRhc2V0WydzdGF0cyddID0gW107XG4gICAgZGlmZkRhdGFzZXRbJ2dsb2Jfc3RhdHMnXSA9IHt9O1xuICAgIGRpZmZEYXRhc2V0Wyd4bWF4J10gPSAtMSAqIE51bWJlci5NQVhfVkFMVUU7XG4gICAgZGlmZkRhdGFzZXRbJ3htaW4nXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgZGlmZkRhdGFzZXRbJ3ltYXgnXSA9IC0xICogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBkaWZmRGF0YXNldFsneW1pbiddID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBkaWZmRGF0YXNldFsnem1heCddID0gLTEgKiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGRpZmZEYXRhc2V0Wyd6bWluJ10gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGRpZmZEYXRhc2V0WydzdW0nXSA9IDA7XG5cbiAgICAvLyBpbml0aWFsaXplIGxvY2FsIHZhcmlhYmxlc1xuICAgIHZhciBtaW51ZW5kRGF0YSA9IGRhdGFzZXRbMV07XG4gICAgdmFyIHN1YnRyYWhlbmREYXRhID0gZGF0YXNldFswXTtcblxuICAgIC8vIGdldCBjb21tb24geCBhbmQgeVxuICAgIGRpZmZEYXRhc2V0LnggPSBfLmludGVyc2VjdGlvbihtaW51ZW5kRGF0YS54LCBzdWJ0cmFoZW5kRGF0YS54KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYlxuICAgIH0pO1xuICAgIGRpZmZEYXRhc2V0LnkgPSBfLmludGVyc2VjdGlvbihtaW51ZW5kRGF0YS55LCBzdWJ0cmFoZW5kRGF0YS55KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYlxuICAgIH0pO1xuXG4gICAgLy8gbWFrZSB3ZSBhY3R1YWxseSBoYXZlIG1hdGNoZXNcbiAgICBpZiAoZGlmZkRhdGFzZXQueC5sZW5ndGggPT09IDAgfHwgZGlmZkRhdGFzZXQueS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGlmZkRhdGFzZXQueCA9IFtdO1xuICAgICAgICBkaWZmRGF0YXNldC55ID0gW107XG4gICAgICAgIHJldHVybiBbZGlmZkRhdGFzZXRdO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSBuZWl0aGVyIGRhdGFzZXQgaXMgZW1wdHlcbiAgICBpZiAobWludWVuZERhdGEueC5sZW5ndGggPT09IDAgfHwgc3VidHJhaGVuZERhdGEueC5sZW5ndGggPT09IDAgfHwgbWludWVuZERhdGEueS5sZW5ndGggPT09IDAgfHwgc3VidHJhaGVuZERhdGEueS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtkaWZmRGF0YXNldF07XG4gICAgfVxuXG4gICAgdmFyIG1pbnVlbmRZSW5kZXggPSAwO1xuICAgIHZhciBzdWJ0cmFoZW5kWUluZGV4ID0gMDtcbiAgICB2YXIgblBvaW50cyA9IDA7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggY29tbW9uIFlzXG4gICAgZm9yICh2YXIgZGlmZkRhdGFZSW5kZXggPSAwOyBkaWZmRGF0YVlJbmRleCA8IGRpZmZEYXRhc2V0LnkubGVuZ3RoOyBkaWZmRGF0YVlJbmRleCsrKSB7XG4gICAgICAgIC8vbWFrZSBzdXJlIHRoYXQgd2UgYXJlIGFjdHVhbGx5IG9uIHRoZSBzYW1lIHkgdmFsdWUgZm9yIGVhY2ggY3VydmVcbiAgICAgICAgdmFyIGRpZmZEYXRhWSA9IGRpZmZEYXRhc2V0LnlbZGlmZkRhdGFZSW5kZXhdO1xuICAgICAgICB2YXIgbWludWVuZFkgPSBtaW51ZW5kRGF0YS55W21pbnVlbmRZSW5kZXhdO1xuICAgICAgICB2YXIgc3VidHJhaGVuZFkgPSBzdWJ0cmFoZW5kRGF0YS55W3N1YnRyYWhlbmRZSW5kZXhdO1xuXG4gICAgICAgIC8vaW5jcmVtZW50IHRoZSBtaW51ZW5kWUluZGV4IHVudGlsIGl0IHJlYWNoZXMgdGhpcyBpdGVyYXRpb24ncyBkaWZmRGF0YVlcbiAgICAgICAgd2hpbGUgKGRpZmZEYXRhWSA+IG1pbnVlbmRZICYmIG1pbnVlbmRZSW5kZXggPCBtaW51ZW5kRGF0YS55Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIG1pbnVlbmRZID0gbWludWVuZERhdGEueVsrK21pbnVlbmRZSW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pbmNyZW1lbnQgdGhlIHN1YnRyYWhlbmRZSW5kZXggdW50aWwgaXQgcmVhY2hlcyB0aGlzIGl0ZXJhdGlvbidzIGRpZmZEYXRhWVxuICAgICAgICB3aGlsZSAoZGlmZkRhdGFZID4gc3VidHJhaGVuZFkgJiYgc3VidHJhaGVuZFlJbmRleCA8IHN1YnRyYWhlbmREYXRhLnkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc3VidHJhaGVuZFkgPSBzdWJ0cmFoZW5kRGF0YS55Wysrc3VidHJhaGVuZFlJbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXplIG4gYW5kIHogYXJyYXlzIGZvciB0aGlzIFlcbiAgICAgICAgZGlmZkRhdGFzZXQueltkaWZmRGF0YVlJbmRleF0gPSBbXTtcbiAgICAgICAgZGlmZkRhdGFzZXQubltkaWZmRGF0YVlJbmRleF0gPSBbXTtcblxuICAgICAgICB2YXIgbWludWVuZFhJbmRleCA9IDA7XG4gICAgICAgIHZhciBzdWJ0cmFoZW5kWEluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgZGlmZkRhdGFYSW5kZXggPSAwOyBkaWZmRGF0YVhJbmRleCA8IGRpZmZEYXRhc2V0LngubGVuZ3RoOyBkaWZmRGF0YVhJbmRleCsrKSB7XG4gICAgICAgICAgICAvL21ha2Ugc3VyZSB0aGF0IHdlIGFyZSBhY3R1YWxseSBvbiB0aGUgc2FtZSB4IHZhbHVlIGZvciBlYWNoIGN1cnZlXG4gICAgICAgICAgICB2YXIgZGlmZkRhdGFYID0gZGlmZkRhdGFzZXQueFtkaWZmRGF0YVhJbmRleF07XG4gICAgICAgICAgICB2YXIgbWludWVuZFggPSBtaW51ZW5kRGF0YS54W21pbnVlbmRYSW5kZXhdO1xuICAgICAgICAgICAgdmFyIHN1YnRyYWhlbmRYID0gc3VidHJhaGVuZERhdGEueFtzdWJ0cmFoZW5kWEluZGV4XTtcblxuICAgICAgICAgICAgLy9pbmNyZW1lbnQgdGhlIG1pbnVlbmRYSW5kZXggdW50aWwgaXQgcmVhY2hlcyB0aGlzIGl0ZXJhdGlvbidzIGRpZmZEYXRhWFxuICAgICAgICAgICAgd2hpbGUgKGRpZmZEYXRhWCA+IG1pbnVlbmRYICYmIG1pbnVlbmRYSW5kZXggPCBtaW51ZW5kRGF0YS54Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBtaW51ZW5kWCA9IG1pbnVlbmREYXRhLnhbKyttaW51ZW5kWEluZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9pbmNyZW1lbnQgdGhlIHN1YnRyYWhlbmRYSW5kZXggdW50aWwgaXQgcmVhY2hlcyB0aGlzIGl0ZXJhdGlvbidzIGRpZmZEYXRhWFxuICAgICAgICAgICAgd2hpbGUgKGRpZmZEYXRhWCA+IHN1YnRyYWhlbmRYICYmIHN1YnRyYWhlbmRYSW5kZXggPCBzdWJ0cmFoZW5kRGF0YS54Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdWJ0cmFoZW5kWCA9IHN1YnRyYWhlbmREYXRhLnhbKytzdWJ0cmFoZW5kWEluZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpZmZWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgZGlmZk51bWJlciA9IDA7XG4gICAgICAgICAgICB2YXIgZGlmZk1pbkRhdGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGRpZmZNYXhEYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICgobWludWVuZERhdGEuelttaW51ZW5kWUluZGV4XVttaW51ZW5kWEluZGV4XSAhPT0gdW5kZWZpbmVkICYmIHN1YnRyYWhlbmREYXRhLnpbc3VidHJhaGVuZFlJbmRleF1bc3VidHJhaGVuZFhJbmRleF0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAmJiAobWludWVuZERhdGEuelttaW51ZW5kWUluZGV4XVttaW51ZW5kWEluZGV4XSAhPT0gbnVsbCAmJiBzdWJ0cmFoZW5kRGF0YS56W3N1YnRyYWhlbmRZSW5kZXhdW3N1YnRyYWhlbmRYSW5kZXhdICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICYmIG1pbnVlbmRYID09PSBzdWJ0cmFoZW5kWCAmJiBtaW51ZW5kWSA9PT0gc3VidHJhaGVuZFkpIHsgLy8gbWFrZSBzdXJlIGJvdGggY29udG91cnMgYWN0dWFsbHkgaGF2ZSBkYXRhIGF0IHRoZXNlIGluZGljZXMsIGRhdGEgaXMgbm90IG51bGwgYXQgdGhpcyBwb2ludCwgYW5kIHRoZSB4IGFuZCB5IGFjdHVhbGx5IG1hdGNoXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIHZhbHVlc1xuICAgICAgICAgICAgICAgIGRpZmZWYWx1ZSA9IG1pbnVlbmREYXRhLnpbbWludWVuZFlJbmRleF1bbWludWVuZFhJbmRleF0gLSBzdWJ0cmFoZW5kRGF0YS56W3N1YnRyYWhlbmRZSW5kZXhdW3N1YnRyYWhlbmRYSW5kZXhdO1xuICAgICAgICAgICAgICAgIGRpZmZOdW1iZXIgPSBtaW51ZW5kRGF0YS5uW21pbnVlbmRZSW5kZXhdW21pbnVlbmRYSW5kZXhdIDw9IHN1YnRyYWhlbmREYXRhLm5bc3VidHJhaGVuZFlJbmRleF1bc3VidHJhaGVuZFhJbmRleF0gPyBtaW51ZW5kRGF0YS5uW21pbnVlbmRZSW5kZXhdW21pbnVlbmRYSW5kZXhdIDogc3VidHJhaGVuZERhdGEubltzdWJ0cmFoZW5kWUluZGV4XVtzdWJ0cmFoZW5kWEluZGV4XTtcbiAgICAgICAgICAgICAgICBkaWZmTWluRGF0ZSA9IG1pbnVlbmREYXRhLm1pbkRhdGVUZXh0T3V0cHV0W21pbnVlbmRZSW5kZXggKiBtaW51ZW5kRGF0YS54Lmxlbmd0aCArIG1pbnVlbmRYSW5kZXhdIDw9IHN1YnRyYWhlbmREYXRhLm1pbkRhdGVUZXh0T3V0cHV0W3N1YnRyYWhlbmRZSW5kZXggKiBzdWJ0cmFoZW5kRGF0YS54Lmxlbmd0aCArIHN1YnRyYWhlbmRYSW5kZXhdID8gbWludWVuZERhdGEubWluRGF0ZVRleHRPdXRwdXRbbWludWVuZFlJbmRleCAqIG1pbnVlbmREYXRhLngubGVuZ3RoICsgbWludWVuZFhJbmRleF0gOiBzdWJ0cmFoZW5kRGF0YS5taW5EYXRlVGV4dE91dHB1dFtzdWJ0cmFoZW5kWUluZGV4ICogc3VidHJhaGVuZERhdGEueC5sZW5ndGggKyBzdWJ0cmFoZW5kWEluZGV4XTtcbiAgICAgICAgICAgICAgICBkaWZmTWF4RGF0ZSA9IG1pbnVlbmREYXRhLm1heERhdGVUZXh0T3V0cHV0W21pbnVlbmRZSW5kZXggKiBtaW51ZW5kRGF0YS54Lmxlbmd0aCArIG1pbnVlbmRYSW5kZXhdID49IHN1YnRyYWhlbmREYXRhLm1heERhdGVUZXh0T3V0cHV0W3N1YnRyYWhlbmRZSW5kZXggKiBzdWJ0cmFoZW5kRGF0YS54Lmxlbmd0aCArIHN1YnRyYWhlbmRYSW5kZXhdID8gbWludWVuZERhdGEubWF4RGF0ZVRleHRPdXRwdXRbbWludWVuZFlJbmRleCAqIG1pbnVlbmREYXRhLngubGVuZ3RoICsgbWludWVuZFhJbmRleF0gOiBzdWJ0cmFoZW5kRGF0YS5tYXhEYXRlVGV4dE91dHB1dFtzdWJ0cmFoZW5kWUluZGV4ICogc3VidHJhaGVuZERhdGEueC5sZW5ndGggKyBzdWJ0cmFoZW5kWEluZGV4XTtcbiAgICAgICAgICAgICAgICBkaWZmRGF0YXNldFsnc3VtJ10gKz0gZGlmZlZhbHVlO1xuICAgICAgICAgICAgICAgIG5Qb2ludHMgPSBuUG9pbnRzICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpZmZEYXRhc2V0LnpbZGlmZkRhdGFZSW5kZXhdLnB1c2goZGlmZlZhbHVlKTtcbiAgICAgICAgICAgIGRpZmZEYXRhc2V0Lm5bZGlmZkRhdGFZSW5kZXhdLnB1c2goZGlmZk51bWJlcik7XG4gICAgICAgICAgICBkaWZmRGF0YXNldC54VGV4dE91dHB1dC5wdXNoKGRpZmZEYXRhWCk7XG4gICAgICAgICAgICBkaWZmRGF0YXNldC55VGV4dE91dHB1dC5wdXNoKGRpZmZEYXRhWSk7XG4gICAgICAgICAgICBkaWZmRGF0YXNldC56VGV4dE91dHB1dC5wdXNoKGRpZmZWYWx1ZSk7XG4gICAgICAgICAgICBkaWZmRGF0YXNldC5uVGV4dE91dHB1dC5wdXNoKGRpZmZOdW1iZXIpO1xuICAgICAgICAgICAgZGlmZkRhdGFzZXQubWluRGF0ZVRleHRPdXRwdXQucHVzaChkaWZmTWluRGF0ZSk7XG4gICAgICAgICAgICBkaWZmRGF0YXNldC5tYXhEYXRlVGV4dE91dHB1dC5wdXNoKGRpZmZNYXhEYXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBzdGF0aXN0aWNzXG4gICAgY29uc3QgZmlsdGVyZWR4ID0gZGlmZkRhdGFzZXQueC5maWx0ZXIoeCA9PiB4KTtcbiAgICBjb25zdCBmaWx0ZXJlZHkgPSBkaWZmRGF0YXNldC55LmZpbHRlcih5ID0+IHkpO1xuICAgIGNvbnN0IGZpbHRlcmVkeiA9IGRpZmZEYXRhc2V0LnpUZXh0T3V0cHV0LmZpbHRlcih6ID0+IHopO1xuICAgIGRpZmZEYXRhc2V0LnhtaW4gPSBNYXRoLm1pbiguLi5maWx0ZXJlZHgpO1xuICAgIGRpZmZEYXRhc2V0LnhtYXggPSBNYXRoLm1heCguLi5maWx0ZXJlZHgpO1xuICAgIGRpZmZEYXRhc2V0LnltaW4gPSBNYXRoLm1pbiguLi5maWx0ZXJlZHkpO1xuICAgIGRpZmZEYXRhc2V0LnltYXggPSBNYXRoLm1heCguLi5maWx0ZXJlZHkpO1xuICAgIGRpZmZEYXRhc2V0LnptaW4gPSBNYXRoLm1pbiguLi5maWx0ZXJlZHopO1xuICAgIGRpZmZEYXRhc2V0LnptYXggPSBNYXRoLm1heCguLi5maWx0ZXJlZHopO1xuXG4gICAgaWYgKGRpZmZEYXRhc2V0LnhtaW4gPT0gXCItSW5maW5pdHlcIiB8fCAoZGlmZkRhdGFzZXQueC5pbmRleE9mKDApICE9PSAtMSAmJiAwIDwgZGlmZkRhdGFzZXQueG1pbikpIHtcbiAgICAgICAgZGlmZkRhdGFzZXQueG1pbiA9IDA7XG4gICAgfVxuICAgIGlmIChkaWZmRGF0YXNldC55bWluID09IFwiLUluZmluaXR5XCIgfHwgKGRpZmZEYXRhc2V0LnkuaW5kZXhPZigwKSAhPT0gLTEgJiYgMCA8IGRpZmZEYXRhc2V0LnltaW4pKSB7XG4gICAgICAgIGRpZmZEYXRhc2V0LnltaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoZGlmZkRhdGFzZXQuem1pbiA9PSBcIi1JbmZpbml0eVwiIHx8IChkaWZmRGF0YXNldC56VGV4dE91dHB1dC5pbmRleE9mKDApICE9PSAtMSAmJiAwIDwgZGlmZkRhdGFzZXQuem1pbikpIHtcbiAgICAgICAgZGlmZkRhdGFzZXQuem1pbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGRpZmZEYXRhc2V0LnhtYXggPT0gXCItSW5maW5pdHlcIikge1xuICAgICAgICBkaWZmRGF0YXNldC54bWF4ID0gMDtcbiAgICB9XG4gICAgaWYgKGRpZmZEYXRhc2V0LnltYXggPT0gXCItSW5maW5pdHlcIikge1xuICAgICAgICBkaWZmRGF0YXNldC55bWF4ID0gMDtcbiAgICB9XG4gICAgaWYgKGRpZmZEYXRhc2V0LnptYXggPT0gXCItSW5maW5pdHlcIikge1xuICAgICAgICBkaWZmRGF0YXNldC56bWF4ID0gMDtcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZE1pbkRhdGUgPSBkaWZmRGF0YXNldC5taW5EYXRlVGV4dE91dHB1dC5maWx0ZXIodCA9PiB0KTtcbiAgICBjb25zdCBmaWx0ZXJlZE1heERhdGUgPSBkaWZmRGF0YXNldC5tYXhEYXRlVGV4dE91dHB1dC5maWx0ZXIodCA9PiB0KTtcbiAgICBkaWZmRGF0YXNldC5nbG9iX3N0YXRzWydtZWFuJ10gPSBkaWZmRGF0YXNldC5zdW0gLyBuUG9pbnRzO1xuICAgIGRpZmZEYXRhc2V0Lmdsb2Jfc3RhdHNbJ21pbkRhdGUnXSA9IE1hdGgubWluKC4uLmZpbHRlcmVkTWluRGF0ZSk7XG4gICAgZGlmZkRhdGFzZXQuZ2xvYl9zdGF0c1snbWF4RGF0ZSddID0gTWF0aC5tYXgoLi4uZmlsdGVyZWRNYXhEYXRlKTtcbiAgICBkaWZmRGF0YXNldC5nbG9iX3N0YXRzWyduJ10gPSBuUG9pbnRzO1xuICAgIGRpZmZEYXRhc2V0Wydhbm5vdGF0aW9uJ10gPSBkaWZmRGF0YXNldC5nbG9iX3N0YXRzLm1lYW4gPT09IHVuZGVmaW5lZCA/IGRpZmZEYXRhc2V0LmxhYmVsICsgXCItIG1lYW4gPSBOYU5cIiA6IGRpZmZEYXRhc2V0LmxhYmVsICsgXCItIG1lYW4gPSBcIiArIGRpZmZEYXRhc2V0Lmdsb2Jfc3RhdHMubWVhbi50b1ByZWNpc2lvbig0KTtcblxuICAgIC8vIG1ha2UgY29udG91cnMgc3ltbWV0cmljYWwgYXJvdW5kIDBcbiAgICBkaWZmRGF0YXNldFsnYXV0b2NvbnRvdXInXSA9IGZhbHNlO1xuICAgIGRpZmZEYXRhc2V0WyduY29udG91cnMnXSA9IDE1O1xuICAgIGRpZmZEYXRhc2V0Wydjb2xvcmJhciddID0gZGF0YXNldFswXS5jb2xvcmJhcjtcbiAgICBkaWZmRGF0YXNldFsnY29sb3JiYXInXVsndGl0bGUnXSA9IGRhdGFzZXRbMF0uY29sb3JiYXIudGl0bGUgPT09IGRhdGFzZXRbMV0uY29sb3JiYXIudGl0bGUgPyBkYXRhc2V0WzBdLmNvbG9yYmFyLnRpdGxlIDogZGF0YXNldFsxXS5jb2xvcmJhci50aXRsZSArIFwiIC0gXCIgKyBkYXRhc2V0WzBdLmNvbG9yYmFyLnRpdGxlO1xuICAgIGRpZmZEYXRhc2V0Wydjb2xvcnNjYWxlJ10gPSBbWzAsXCJyZ2IoNSwxMCwxNzIpXCJdLFswLjM1LFwicmdiKDEwNiwxMzcsMjQ3KVwiXSxbMC40NSxcInJnYigyNTUsMjU1LDI1NSlcIl0sWzAuNTUsXCJyZ2IoMjU1LDI1NSwyNTUpXCJdLFswLjYsXCJyZ2IoMjIwLDE3MCwxMzIpXCJdLFswLjcsXCJyZ2IoMjMwLDE0NSw5MClcIl0sWzEsXCJyZ2IoMTc4LDEwLDI4KVwiXV07XG4gICAgZGlmZkRhdGFzZXRbJ3JldmVyc2VzY2FsZSddID0gZGF0YXNldFswXS5yZXZlcnNlc2NhbGU7XG4gICAgZGlmZkRhdGFzZXRbJ2NvbnRvdXJzJ10gPSBkYXRhc2V0WzBdLmNvbnRvdXJzO1xuICAgIGNvbnN0IG1heFogPSBNYXRoLmFicyhkaWZmRGF0YXNldC56bWF4KSA+IE1hdGguYWJzKGRpZmZEYXRhc2V0LnptaW4pID8gTWF0aC5hYnMoZGlmZkRhdGFzZXQuem1heCkgOiBNYXRoLmFicyhkaWZmRGF0YXNldC56bWluKTtcbiAgICBkaWZmRGF0YXNldFsnY29udG91cnMnXVsnc3RhcnQnXSA9IC0xICogbWF4WiArICgyICogbWF4WikgLyAxNjtcbiAgICBkaWZmRGF0YXNldFsnY29udG91cnMnXVsnZW5kJ10gPSBtYXhaIC0gKDIgKiBtYXhaKSAvIDE2O1xuICAgIGRpZmZEYXRhc2V0Wydjb250b3VycyddWydzaXplJ10gPSAoMiAqIG1heFopIC8gMTY7XG5cbiAgICByZXR1cm4gW2RpZmZEYXRhc2V0XTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdHNEYXRhRGlmZlV0aWxzID0ge1xuXG4gICAgZ2V0RGF0YUZvckRpZmZDdXJ2ZTogZ2V0RGF0YUZvckRpZmZDdXJ2ZSxcbiAgICBnZXREYXRhRm9yRGlmZkNvbnRvdXI6IGdldERhdGFGb3JEaWZmQ29udG91clxuXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IENvbG9yYWRvIFN0YXRlIFVuaXZlcnNpdHkgYW5kIFJlZ2VudHMgb2YgdGhlIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHttYXRzRGF0YVV0aWxzfSBmcm9tICdtZXRlb3IvcmFuZHlwOm1hdHMtY29tbW9uJztcbmltcG9ydCB7bWF0c1R5cGVzfSBmcm9tICdtZXRlb3IvcmFuZHlwOm1hdHMtY29tbW9uJztcblxuLy8gZnVuY3Rpb24gZm9yIHJlbW92aW5nIHVubWF0Y2hlZCBkYXRhIGZyb20gYSBkYXRhc2V0IGNvbnRhaW5pbmcgbXVsdGlwbGUgY3VydmVzICp3aXRob3V0KiBsZXZlbHNcbmNvbnN0IGdldE1hdGNoZWREYXRhU2V0ID0gZnVuY3Rpb24gKGRhdGFzZXQsIGN1cnZlc0xlbmd0aCkge1xuXG4gICAgdmFyIHN1YlNlY3MgPSBbXTtcbiAgICB2YXIgc3ViVmFsdWVzID0gW107XG4gICAgdmFyIG5ld1N1YlNlY3MgPSBbXTtcbiAgICB2YXIgbmV3U3ViVmFsdWVzID0gW107XG4gICAgdmFyIGluZGVwZW5kZW50VmFyR3JvdXBzID0gW107XG4gICAgdmFyIGluZGVwZW5kZW50VmFySGFzUG9pbnQgPSBbXTtcbiAgICB2YXIgY3VyckluZGVwZW5kZW50VmFyO1xuICAgIHZhciBjdXJ2ZUluZGV4O1xuICAgIHZhciBkYXRhO1xuICAgIHZhciBkaTtcbiAgICB2YXIgZmk7XG4gICAgdmFyIHNpO1xuXG4gICAgLy8gbWF0Y2hpbmcgaW4gdGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBhIGN1cnZlJ3MgaW5kZXBlbmRlbnQgdmFyaWFibGUuIEZvciBhIHRpbWVzZXJpZXMsIHRoZSBpbmRlcGVuZGVudFZhciBpcyBlcG9jaCxcbiAgICAvLyBmb3IgYSBwcm9maWxlLCBpdCdzIGxldmVsLCBmb3IgYSBkaWVvZmYsIGl0J3MgZm9yZWNhc3QgaG91ciwgZm9yIGEgdGhyZXNob2xkIHBsb3QsIGl0J3MgdGhyZXNob2xkLCBhbmQgZm9yIGFcbiAgICAvLyB2YWxpZCB0aW1lIHBsb3QsIGl0J3MgaG91ciBvZiBkYXkuIFRoaXMgZnVuY3Rpb24gaWRlbnRpZmllcyB0aGUgdGhlIGluZGVwZW5kZW50VmFyIHZhbHVlcyBjb21tb24gYWNyb3NzIGFsbCBvZlxuICAgIC8vIHRoZSBjdXJ2ZXMsIGFuZCB0aGVuIHRoZSBjb21tb24gc3ViIHRpbWVzL2xldmVscy92YWx1ZXMgZm9yIHRob3NlIGluZGVwZW5kZW50VmFyIHZhbHVlcy5cblxuICAgIC8vIGZpbmQgdGhlIG1hdGNoaW5nIGluZGVwZW5kZW50VmFycyBzaGFyZWQgYWNyb3NzIGFsbCBjdXJ2ZXNcbiAgICBmb3IgKGN1cnZlSW5kZXggPSAwOyBjdXJ2ZUluZGV4IDwgY3VydmVzTGVuZ3RoOyBjdXJ2ZUluZGV4KyspIHsgLy8gZXZlcnkgY3VydmVcbiAgICAgICAgaW5kZXBlbmRlbnRWYXJHcm91cHNbY3VydmVJbmRleF0gPSBbXTsgIC8vIHN0b3JlIHRoZSBpbmRlcGVuZGVudFZhcnMgZm9yIGVhY2ggY3VydmUgdGhhdCBhcmUgbm90IG51bGxcbiAgICAgICAgaW5kZXBlbmRlbnRWYXJIYXNQb2ludFtjdXJ2ZUluZGV4XSA9IFtdOyAgIC8vIHN0b3JlIHRoZSAqYWxsKiBvZiB0aGUgaW5kZXBlbmRlbnRWYXJzIGZvciBlYWNoIGN1cnZlXG4gICAgICAgIHN1YlNlY3NbY3VydmVJbmRleF0gPSB7fTsgIC8vIHN0b3JlIHRoZSBpbmRpdmlkdWFsIHJlY29yZCB0aW1lcyAoc3ViU2VjcykgZ29pbmcgaW50byBlYWNoIGluZGVwZW5kZW50VmFyIGZvciBlYWNoIGN1cnZlXG4gICAgICAgIGRhdGEgPSBkYXRhc2V0W2N1cnZlSW5kZXhdO1xuICAgICAgICBmb3IgKGRpID0gMDsgZGkgPCBkYXRhLngubGVuZ3RoOyBkaSsrKSB7IC8vIGxvb3Agb3ZlciBldmVyeSBpbmRlcGVuZGVudFZhciB2YWx1ZSBpbiB0aGlzIGN1cnZlXG4gICAgICAgICAgICBjdXJySW5kZXBlbmRlbnRWYXIgPSBkYXRhLnhbZGldO1xuICAgICAgICAgICAgaWYgKGRhdGEueVtkaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWJTZWNzW2N1cnZlSW5kZXhdW2N1cnJJbmRlcGVuZGVudFZhcl0gPSBkYXRhLnN1YlNlY3NbZGldOyAgIC8vIHN0b3JlIHJhdyBzZWNzIGZvciB0aGlzIGluZGVwZW5kZW50VmFyIHZhbHVlLCBzaW5jZSBpdCdzIG5vdCBhIG51bGwgcG9pbnRcbiAgICAgICAgICAgICAgICBpbmRlcGVuZGVudFZhckdyb3Vwc1tjdXJ2ZUluZGV4XS5wdXNoKGN1cnJJbmRlcGVuZGVudFZhcik7ICAgLy8gc3RvcmUgdGhpcyBpbmRlcGVuZGVudFZhciB2YWx1ZSwgc2luY2UgaXQncyBub3QgYSBudWxsIHBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRlcGVuZGVudFZhckhhc1BvaW50W2N1cnZlSW5kZXhdLnB1c2goY3VyckluZGVwZW5kZW50VmFyKTsgICAgLy8gc3RvcmUgYWxsIHRoZSBpbmRlcGVuZGVudFZhciB2YWx1ZXMsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGV5J3JlIG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXRjaGluZ0luZGVwZW5kZW50VmFycyA9IF8uaW50ZXJzZWN0aW9uLmFwcGx5KF8sIGluZGVwZW5kZW50VmFyR3JvdXBzKTsgICAgLy8gZmluZCBhbGwgb2YgdGhlIG5vbi1udWxsIGluZGVwZW5kZW50VmFyIHZhbHVlcyBjb21tb24gYWNyb3NzIGFsbCB0aGUgY3VydmVzXG4gICAgdmFyIG1hdGNoaW5nSW5kZXBlbmRlbnRIYXNQb2ludCA9IF8uaW50ZXJzZWN0aW9uLmFwcGx5KF8sIGluZGVwZW5kZW50VmFySGFzUG9pbnQpOyAgICAvLyBmaW5kIGFsbCBvZiB0aGUgaW5kZXBlbmRlbnRWYXIgdmFsdWVzIGNvbW1vbiBhY3Jvc3MgYWxsIHRoZSBjdXJ2ZXMsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgdGhleSdyZSBudWxsXG4gICAgdmFyIHN1YlNlY0ludGVyc2VjdGlvbiA9IHt9OyAgICAgICAvLyBldmVudHVhbGx5IGZpbmQgdGhlIGludGVyc2VjdGluZyBzdWJTZWNzIGZvciBlYWNoIGNvbW1vbiBub24tbnVsbCBpbmRlcGVuZGVudFZhciB2YWx1ZVxuXG4gICAgZm9yIChmaSA9IDA7IGZpIDwgbWF0Y2hpbmdJbmRlcGVuZGVudFZhcnMubGVuZ3RoOyBmaSsrKSB7IC8vIGxvb3Agb3ZlciBlYWNoIGNvbW1vbiBub24tbnVsbCBpbmRlcGVuZGVudFZhciB2YWx1ZVxuICAgICAgICBjdXJySW5kZXBlbmRlbnRWYXIgPSBtYXRjaGluZ0luZGVwZW5kZW50VmFyc1tmaV07XG4gICAgICAgIHZhciBjdXJyU3ViU2VjSW50ZXJzZWN0aW9uID0gc3ViU2Vjc1swXVtjdXJySW5kZXBlbmRlbnRWYXJdOyAgIC8vIGZpbGwgY3VycmVudCBzdWJTZWNzIGludGVyc2VjdGlvbiBhcnJheSB3aXRoIHN1YlNlY3MgZnJvbSB0aGUgZmlyc3QgY3VydmVcbiAgICAgICAgZm9yIChjdXJ2ZUluZGV4ID0gMTsgY3VydmVJbmRleCA8IGN1cnZlc0xlbmd0aDsgY3VydmVJbmRleCsrKSB7IC8vIGxvb3Agb3ZlciBldmVyeSBjdXJ2ZVxuICAgICAgICAgICAgY3VyclN1YlNlY0ludGVyc2VjdGlvbiA9IF8uaW50ZXJzZWN0aW9uKGN1cnJTdWJTZWNJbnRlcnNlY3Rpb24sIHN1YlNlY3NbY3VydmVJbmRleF1bY3VyckluZGVwZW5kZW50VmFyXSk7ICAgLy8ga2VlcCB0YWtpbmcgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgY3VycmVudCBzdWJTZWNzIGludGVyc2VjdGlvbiBhcnJheSB3aXRoIGVhY2ggY3VydmUncyBzdWJTZWNzIGFycmF5IGZvciB0aGlzIGluZGVwZW5kZW50VmFyIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgc3ViU2VjSW50ZXJzZWN0aW9uW2N1cnJJbmRlcGVuZGVudFZhcl0gPSBjdXJyU3ViU2VjSW50ZXJzZWN0aW9uOyAgIC8vIHN0b3JlIHRoZSBmaW5hbCBpbnRlcnNlY3Rpbmcgc3ViU2VjcyBhcnJheSBmb3IgdGhpcyBjb21tb24gbm9uLW51bGwgaW5kZXBlbmRlbnRWYXIgdmFsdWVcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgbm9uLW1hdGNoaW5nIGluZGVwZW5kZW50VmFycyBhbmQgc3ViU2Vjc1xuICAgIGZvciAoY3VydmVJbmRleCA9IDA7IGN1cnZlSW5kZXggPCBjdXJ2ZXNMZW5ndGg7IGN1cnZlSW5kZXgrKykgeyAvLyBsb29wIG92ZXIgZXZlcnkgY3VydmVcbiAgICAgICAgZGF0YSA9IGRhdGFzZXRbY3VydmVJbmRleF07XG5cbiAgICAgICAgLy8gbmVlZCB0byBsb29wIGJhY2t3YXJkcyB0aHJvdWdoIHRoZSBkYXRhIGFycmF5IHNvIHRoYXQgd2UgY2FuIHNwbGljZSBub24tbWF0Y2hpbmcgaW5kaWNlc1xuICAgICAgICAvLyB3aGlsZSBzdGlsbCBoYXZpbmcgdGhlIHJlbWFpbmluZyBpbmRpY2VzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gICAgICAgIHZhciBkYXRhTGVuZ3RoID0gZGF0YS54Lmxlbmd0aDtcbiAgICAgICAgZm9yIChkaSA9IGRhdGFMZW5ndGggLSAxOyBkaSA+PSAwOyBkaS0tKSB7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGluZ0luZGVwZW5kZW50VmFycy5pbmRleE9mKGRhdGEueFtkaV0pID09PSAtMSkgeyAgLy8gaWYgdGhpcyBpcyBub3QgYSBjb21tb24gbm9uLW51bGwgaW5kZXBlbmRlbnRWYXIgdmFsdWUsIHdlJ2xsIGhhdmUgdG8gcmVtb3ZlIHNvbWUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ0luZGVwZW5kZW50SGFzUG9pbnQuaW5kZXhPZihkYXRhLnhbZGldKSA9PT0gLTEpIHsgICAvLyBpZiBhdCBsZWFzdCBvbmUgY3VydmUgZG9lc24ndCBldmVuIGhhdmUgYSBudWxsIGhlcmUsIG11Y2ggbGVzcyBhIG1hdGNoaW5nIHZhbHVlIChiZWFjYXVzZSBvZiB0aGUgY2FkZW5jZSksIGp1c3QgZHJvcCB0aGlzIGluZGVwZW5kZW50VmFyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEueC5zcGxpY2UoZGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnkuc3BsaWNlKGRpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lcnJvcl95LmFycmF5LnNwbGljZShkaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc3ViVmFscy5zcGxpY2UoZGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnN1YlNlY3Muc3BsaWNlKGRpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdGF0cy5zcGxpY2UoZGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnRleHQuc3BsaWNlKGRpLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAvLyBpZiBhbGwgb2YgdGhlIGN1cnZlcyBoYXZlIGVpdGhlciBkYXRhIG9yIG51bGxzIGF0IHRoaXMgaW5kZXBlbmRlbnRWYXIsIGFuZCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbnVsbCwgZW5zdXJlIGFsbCBvZiB0aGUgY3VydmVzIGFyZSBudWxsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEueVtkaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnN1YlZhbHNbZGldID0gTmFOO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnN1YlNlY3NbZGldID0gTmFOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTsgICAvLyB0aGVuIG1vdmUgb24gdG8gdGhlIG5leHQgaW5kZXBlbmRlbnRWYXIuIFRoZXJlJ3Mgbm8gbmVlZCB0byBtZXNzIHdpdGggdGhlIHN1YlNlY3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YlNlY3MgPSBkYXRhLnN1YlNlY3NbZGldO1xuICAgICAgICAgICAgc3ViVmFsdWVzID0gZGF0YS5zdWJWYWxzW2RpXTtcblxuICAgICAgICAgICAgaWYgKHN1YlNlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJJbmRlcGVuZGVudFZhciA9IGRhdGEueFtkaV07XG4gICAgICAgICAgICAgICAgbmV3U3ViVmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgbmV3U3ViU2VjcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoc2kgPSAwOyBzaSA8IHN1YlNlY3MubGVuZ3RoOyBzaSsrKSB7ICAvLyBsb29wIG92ZXIgYWxsIHN1YlNlY3MgZm9yIHRoaXMgaW5kZXBlbmRlbnRWYXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YlNlY0ludGVyc2VjdGlvbltjdXJySW5kZXBlbmRlbnRWYXJdLmluZGV4T2Yoc3ViU2Vjc1tzaV0pICE9PSAtMSkgeyAvLyBrZWVwIHRoZSBzdWJWYWx1ZSBvbmx5IGlmIGl0cyBhc3NvY2lhdGVkIHN1YlNlYyBpcyBjb21tb24gdG8gYWxsIGN1cnZlcyBmb3IgdGhpcyBpbmRlcGVuZGVudFZhclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IHN1YlZhbHVlc1tzaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2VjID0gc3ViU2Vjc1tzaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdWJWYWx1ZXMucHVzaChuZXdWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N1YlNlY3MucHVzaChuZXdTZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBmaWx0ZXJlZCBkYXRhXG4gICAgICAgICAgICAgICAgZGF0YS5zdWJWYWxzW2RpXSA9IG5ld1N1YlZhbHVlcztcbiAgICAgICAgICAgICAgICBkYXRhLnN1YlNlY3NbZGldID0gbmV3U3ViU2VjcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhc2V0W2N1cnZlSW5kZXhdID0gZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YXNldDtcbn07XG5cbi8vIGZ1bmN0aW9uIGZvciByZW1vdmluZyB1bm1hdGNoZWQgZGF0YSBmcm9tIGEgZGF0YXNldCBjb250YWluaW5nIG11bHRpcGxlIGN1cnZlcyAqd2l0aCogbGV2ZWxzXG5jb25zdCBnZXRNYXRjaGVkRGF0YVNldFdpdGhMZXZlbHMgPSBmdW5jdGlvbiAoZGF0YXNldCwgY3VydmVzTGVuZ3RoLCBwbG90VHlwZSkge1xuXG4gICAgdmFyIHN1YlNlY3MgPSBbXTtcbiAgICB2YXIgc3ViTGV2cyA9IFtdO1xuICAgIHZhciBzdWJWYWx1ZXMgPSBbXTtcbiAgICB2YXIgbmV3U3ViU2VjcyA9IFtdO1xuICAgIHZhciBuZXdTdWJMZXZzID0gW107XG4gICAgdmFyIG5ld1N1YlZhbHVlcyA9IFtdO1xuICAgIHZhciBpbmRlcGVuZGVudFZhckdyb3VwcyA9IFtdO1xuICAgIHZhciBpbmRlcGVuZGVudFZhckhhc1BvaW50ID0gW107XG4gICAgdmFyIGN1cnJJbmRlcGVuZGVudFZhcjtcbiAgICB2YXIgY3VydmVJbmRleDtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgZGk7XG4gICAgdmFyIGZpO1xuICAgIHZhciBzaTtcblxuICAgIC8vIG1hdGNoaW5nIGluIHRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gYSBjdXJ2ZSdzIGluZGVwZW5kZW50IHZhcmlhYmxlLiBGb3IgYSB0aW1lc2VyaWVzLCB0aGUgaW5kZXBlbmRlbnRWYXIgaXMgZXBvY2gsXG4gICAgLy8gZm9yIGEgcHJvZmlsZSwgaXQncyBsZXZlbCwgZm9yIGEgZGllb2ZmLCBpdCdzIGZvcmVjYXN0IGhvdXIsIGZvciBhIHRocmVzaG9sZCBwbG90LCBpdCdzIHRocmVzaG9sZCwgYW5kIGZvciBhXG4gICAgLy8gdmFsaWQgdGltZSBwbG90LCBpdCdzIGhvdXIgb2YgZGF5LiBUaGlzIGZ1bmN0aW9uIGlkZW50aWZpZXMgdGhlIHRoZSBpbmRlcGVuZGVudFZhciB2YWx1ZXMgY29tbW9uIGFjcm9zcyBhbGwgb2ZcbiAgICAvLyB0aGUgY3VydmVzLCBhbmQgdGhlbiB0aGUgY29tbW9uIHN1YiB0aW1lcy9sZXZlbHMvdmFsdWVzIGZvciB0aG9zZSBpbmRlcGVuZGVudFZhciB2YWx1ZXMuXG5cbiAgICAvL2RldGVybWluZSB3aGV0aGVyIGRhdGEueCBvciBkYXRhLnkgaXMgdGhlIGluZGVwZW5kZW50IHZhcmlhYmxlLCBhbmQgd2hpY2ggaXMgdGhlIHN0YXQgdmFsdWVcbiAgICB2YXIgaW5kZXBlbmRlbnRWYXJOYW1lO1xuICAgIHZhciBzdGF0VmFyTmFtZTtcbiAgICBpZiAocGxvdFR5cGUgIT09IG1hdHNUeXBlcy5QbG90VHlwZXMucHJvZmlsZSkge1xuICAgICAgICBpbmRlcGVuZGVudFZhck5hbWUgPSAneCc7XG4gICAgICAgIHN0YXRWYXJOYW1lID0gJ3knO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVwZW5kZW50VmFyTmFtZSA9ICd5JztcbiAgICAgICAgc3RhdFZhck5hbWUgPSAneCc7XG4gICAgfVxuXG4gICAgZm9yIChjdXJ2ZUluZGV4ID0gMDsgY3VydmVJbmRleCA8IGN1cnZlc0xlbmd0aDsgY3VydmVJbmRleCsrKSB7IC8vIGV2ZXJ5IGN1cnZlXG4gICAgICAgIGluZGVwZW5kZW50VmFyR3JvdXBzW2N1cnZlSW5kZXhdID0gW107ICAvLyBzdG9yZSB0aGUgaW5kZXBlbmRlbnRWYXJzIGZvciBlYWNoIGN1cnZlIHRoYXQgYXJlIG5vdCBudWxsXG4gICAgICAgIGluZGVwZW5kZW50VmFySGFzUG9pbnRbY3VydmVJbmRleF0gPSBbXTsgICAvLyBzdG9yZSB0aGUgKmFsbCogb2YgdGhlIGluZGVwZW5kZW50VmFycyBmb3IgZWFjaCBjdXJ2ZVxuICAgICAgICBzdWJTZWNzW2N1cnZlSW5kZXhdID0ge307ICAvLyBzdG9yZSB0aGUgaW5kaXZpZHVhbCByZWNvcmQgdGltZXMgKHN1YlNlY3MpIGdvaW5nIGludG8gZWFjaCBpbmRlcGVuZGVudFZhciBmb3IgZWFjaCBjdXJ2ZVxuICAgICAgICBzdWJMZXZzW2N1cnZlSW5kZXhdID0ge307ICAvLyBzdG9yZSB0aGUgaW5kaXZpZHVhbCByZWNvcmQgbGV2ZWxzIChzdWJMZXZzKSBnb2luZyBpbnRvIGVhY2ggaW5kZXBlbmRlbnRWYXIgZm9yIGVhY2ggY3VydmVcbiAgICAgICAgZGF0YSA9IGRhdGFzZXRbY3VydmVJbmRleF07XG4gICAgICAgIGZvciAoZGkgPSAwOyBkaSA8IGRhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXS5sZW5ndGg7IGRpKyspIHsgLy8gbG9vcCBvdmVyIGV2ZXJ5IGluZGVwZW5kZW50VmFyIHZhbHVlIGluIHRoaXMgY3VydmVcbiAgICAgICAgICAgIGN1cnJJbmRlcGVuZGVudFZhciA9IGRhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXVtkaV07XG4gICAgICAgICAgICBpZiAoZGF0YVtzdGF0VmFyTmFtZV1bZGldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViU2Vjc1tjdXJ2ZUluZGV4XVtjdXJySW5kZXBlbmRlbnRWYXJdID0gZGF0YS5zdWJTZWNzW2RpXTsgICAvLyBzdG9yZSByYXcgc2VjcyBmb3IgdGhpcyBpbmRlcGVuZGVudFZhciB2YWx1ZSwgc2luY2UgaXQncyBub3QgYSBudWxsIHBvaW50XG4gICAgICAgICAgICAgICAgc3ViTGV2c1tjdXJ2ZUluZGV4XVtjdXJySW5kZXBlbmRlbnRWYXJdID0gZGF0YS5zdWJMZXZzW2RpXTsgICAvLyBzdG9yZSByYXcgbGV2cyBmb3IgdGhpcyBpbmRlcGVuZGVudFZhciB2YWx1ZSwgc2luY2UgaXQncyBub3QgYSBudWxsIHBvaW50XG4gICAgICAgICAgICAgICAgaW5kZXBlbmRlbnRWYXJHcm91cHNbY3VydmVJbmRleF0ucHVzaChjdXJySW5kZXBlbmRlbnRWYXIpOyAgIC8vIHN0b3JlIHRoaXMgaW5kZXBlbmRlbnRWYXIgdmFsdWUsIHNpbmNlIGl0J3Mgbm90IGEgbnVsbCBwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXBlbmRlbnRWYXJIYXNQb2ludFtjdXJ2ZUluZGV4XS5wdXNoKGN1cnJJbmRlcGVuZGVudFZhcik7ICAgIC8vIHN0b3JlIGFsbCB0aGUgaW5kZXBlbmRlbnRWYXIgdmFsdWVzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleSdyZSBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hpbmdJbmRlcGVuZGVudFZhcnMgPSBfLmludGVyc2VjdGlvbi5hcHBseShfLCBpbmRlcGVuZGVudFZhckdyb3Vwcyk7ICAgIC8vIGZpbmQgYWxsIG9mIHRoZSBub24tbnVsbCBpbmRlcGVuZGVudFZhciB2YWx1ZXMgY29tbW9uIGFjcm9zcyBhbGwgdGhlIGN1cnZlc1xuICAgIHZhciBtYXRjaGluZ0luZGVwZW5kZW50SGFzUG9pbnQgPSBfLmludGVyc2VjdGlvbi5hcHBseShfLCBpbmRlcGVuZGVudFZhckhhc1BvaW50KTsgICAgLy8gZmluZCBhbGwgb2YgdGhlIGluZGVwZW5kZW50VmFyIHZhbHVlcyBjb21tb24gYWNyb3NzIGFsbCB0aGUgY3VydmVzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHRoZXkncmUgbnVsbFxuICAgIHZhciBzdWJJbnRlcnNlY3Rpb25zID0gW107ICAgICAgIC8vIGV2ZW50dWFsbHkgZmluZCB0aGUgaW50ZXJzZWN0aW5nIHN1YlNlY3MgYW5kIHN1YkxldnMgZm9yIGVhY2ggY29tbW9uIG5vbi1udWxsIGluZGVwZW5kZW50VmFyIHZhbHVlXG5cbiAgICBmb3IgKGZpID0gMDsgZmkgPCBtYXRjaGluZ0luZGVwZW5kZW50VmFycy5sZW5ndGg7IGZpKyspIHsgLy8gbG9vcCBvdmVyIGVhY2ggY29tbW9uIG5vbi1udWxsIGluZGVwZW5kZW50VmFyIHZhbHVlXG4gICAgICAgIGN1cnJJbmRlcGVuZGVudFZhciA9IG1hdGNoaW5nSW5kZXBlbmRlbnRWYXJzW2ZpXTtcbiAgICAgICAgc3ViSW50ZXJzZWN0aW9uc1tjdXJySW5kZXBlbmRlbnRWYXJdID0gW107XG4gICAgICAgIHZhciBjdXJyU3ViSW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHNpID0gMDsgc2kgPCBzdWJTZWNzWzBdW2N1cnJJbmRlcGVuZGVudFZhcl0ubGVuZ3RoOyBzaSsrKSB7ICAgLy8gZmlsbCBjdXJyZW50IGludGVyc2VjdGlvbiBhcnJheSB3aXRoIHNlYy1sZXYgcGFpcnMgZnJvbSB0aGUgZmlyc3QgY3VydmVcbiAgICAgICAgICAgIGN1cnJTdWJJbnRlcnNlY3Rpb25zLnB1c2goW3N1YlNlY3NbMF1bY3VyckluZGVwZW5kZW50VmFyXVtzaV0sIHN1YkxldnNbMF1bY3VyckluZGVwZW5kZW50VmFyXVtzaV1dKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGN1cnZlSW5kZXggPSAxOyBjdXJ2ZUluZGV4IDwgY3VydmVzTGVuZ3RoOyBjdXJ2ZUluZGV4KyspIHsgLy8gbG9vcCBvdmVyIGV2ZXJ5IGN1cnZlIGFmdGVyIHRoZSBmaXJzdFxuICAgICAgICAgICAgdmFyIHRlbXBTdWJJbnRlcnNlY3Rpb25zID0gW107XG4gICAgICAgICAgICB2YXIgdGVtcFBhaXI7XG4gICAgICAgICAgICBmb3IgKHNpID0gMDsgc2kgPCBzdWJTZWNzW2N1cnZlSW5kZXhdW2N1cnJJbmRlcGVuZGVudFZhcl0ubGVuZ3RoOyBzaSsrKSB7IC8vIGxvb3Agb3ZlciBldmVyeSBzdWJTZWNzIHZhbHVlXG4gICAgICAgICAgICAgICAgdGVtcFBhaXIgPSBbc3ViU2Vjc1tjdXJ2ZUluZGV4XVtjdXJySW5kZXBlbmRlbnRWYXJdW3NpXSwgc3ViTGV2c1tjdXJ2ZUluZGV4XVtjdXJySW5kZXBlbmRlbnRWYXJdW3NpXV07ICAgIC8vIGNyZWF0ZSBhbiBpbmRpdmlkdWFsIHNlYy1sZXYgcGFpciBmb3IgZWFjaCBpbmRleCBpbiB0aGUgc3ViU2VjcyBhbmQgc3ViTGV2cyBhcnJheXNcbiAgICAgICAgICAgICAgICBpZiAobWF0c0RhdGFVdGlscy5hcnJheUNvbnRhaW5zU3ViQXJyYXkoY3VyclN1YkludGVyc2VjdGlvbnMsIHRlbXBQYWlyKSkgeyAgIC8vIHNlZSBpZiB0aGUgaW5kaXZpZHVhbCBzZWMtbGV2IHBhaXIgbWF0Y2hlcyBhIHBhaXIgZnJvbSB0aGUgY3VycmVudCBpbnRlcnNlY3Rpb24gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN1YkludGVyc2VjdGlvbnMucHVzaCh0ZW1wUGFpcik7ICAgIC8vIHN0b3JlIG1hdGNoaW5nIHBhaXJzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyclN1YkludGVyc2VjdGlvbnMgPSB0ZW1wU3ViSW50ZXJzZWN0aW9uczsgICAgLy9yZXBsYWNlIGN1cnJlbnQgaW50ZXJzZWN0aW9uIGFycmF5IHdpdGggYXJyYXkgb2Ygb25seSBwYWlycyB0aGF0IG1hdGNoZWQgZnJvbSB0aGlzIGxvb3AgdGhyb3VnaC5cbiAgICAgICAgfVxuICAgICAgICBzdWJJbnRlcnNlY3Rpb25zW2N1cnJJbmRlcGVuZGVudFZhcl0gPSBjdXJyU3ViSW50ZXJzZWN0aW9uczsgICAvLyBzdG9yZSB0aGUgZmluYWwgaW50ZXJzZWN0aW5nIHN1YlNlY3MgYXJyYXkgZm9yIHRoaXMgY29tbW9uIG5vbi1udWxsIGluZGVwZW5kZW50VmFyIHZhbHVlXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIG5vbi1tYXRjaGluZyBpbmRlcGVuZGVudFZhcnMgYW5kIHN1YlNlY3NcbiAgICBmb3IgKGN1cnZlSW5kZXggPSAwOyBjdXJ2ZUluZGV4IDwgY3VydmVzTGVuZ3RoOyBjdXJ2ZUluZGV4KyspIHsgLy8gbG9vcCBvdmVyIGV2ZXJ5IGN1cnZlXG4gICAgICAgIGRhdGEgPSBkYXRhc2V0W2N1cnZlSW5kZXhdO1xuXG4gICAgICAgIC8vIG5lZWQgdG8gbG9vcCBiYWNrd2FyZHMgdGhyb3VnaCB0aGUgZGF0YSBhcnJheSBzbyB0aGF0IHdlIGNhbiBzcGxpY2Ugbm9uLW1hdGNoaW5nIGluZGljZXNcbiAgICAgICAgLy8gd2hpbGUgc3RpbGwgaGF2aW5nIHRoZSByZW1haW5pbmcgaW5kaWNlcyBpbiB0aGUgY29ycmVjdCBvcmRlclxuICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IGRhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXS5sZW5ndGg7XG4gICAgICAgIGZvciAoZGkgPSBkYXRhTGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdJbmRlcGVuZGVudFZhcnMuaW5kZXhPZihkYXRhW2luZGVwZW5kZW50VmFyTmFtZV1bZGldKSA9PT0gLTEpIHsgIC8vIGlmIHRoaXMgaXMgbm90IGEgY29tbW9uIG5vbi1udWxsIGluZGVwZW5kZW50VmFyIHZhbHVlLCB3ZSdsbCBoYXZlIHRvIHJlbW92ZSBzb21lIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdJbmRlcGVuZGVudEhhc1BvaW50LmluZGV4T2YoZGF0YVtpbmRlcGVuZGVudFZhck5hbWVdW2RpXSkgPT09IC0xKSB7ICAgLy8gaWYgYXQgbGVhc3Qgb25lIGN1cnZlIGRvZXNuJ3QgZXZlbiBoYXZlIGEgbnVsbCBoZXJlLCBtdWNoIGxlc3MgYSBtYXRjaGluZyB2YWx1ZSAoYmVhY2F1c2Ugb2YgdGhlIGNhZGVuY2UpLCBqdXN0IGRyb3AgdGhpcyBpbmRlcGVuZGVudFZhclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnguc3BsaWNlKGRpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS55LnNwbGljZShkaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbKCdlcnJvcl8nICsgc3RhdFZhck5hbWUpXS5hcnJheS5zcGxpY2UoZGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnN1YlZhbHMuc3BsaWNlKGRpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdWJTZWNzLnNwbGljZShkaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc3ViTGV2cy5zcGxpY2UoZGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXRzLnNwbGljZShkaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dC5zcGxpY2UoZGksIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgIC8vIGlmIGFsbCBvZiB0aGUgY3VydmVzIGhhdmUgZWl0aGVyIGRhdGEgb3IgbnVsbHMgYXQgdGhpcyBpbmRlcGVuZGVudFZhciwgYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBudWxsLCBlbnN1cmUgYWxsIG9mIHRoZSBjdXJ2ZXMgYXJlIG51bGxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtzdGF0VmFyTmFtZV1bZGldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdWJWYWxzW2RpXSA9IE5hTjtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdWJTZWNzW2RpXSA9IE5hTjtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdWJMZXZzW2RpXSA9IE5hTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7ICAgLy8gdGhlbiBtb3ZlIG9uIHRvIHRoZSBuZXh0IGluZGVwZW5kZW50VmFyLiBUaGVyZSdzIG5vIG5lZWQgdG8gbWVzcyB3aXRoIHRoZSBzdWJTZWNzIG9yIHN1YkxldnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YlNlY3MgPSBkYXRhLnN1YlNlY3NbZGldO1xuICAgICAgICAgICAgc3ViTGV2cyA9IGRhdGEuc3ViTGV2c1tkaV07XG4gICAgICAgICAgICBzdWJWYWx1ZXMgPSBkYXRhLnN1YlZhbHNbZGldO1xuXG4gICAgICAgICAgICBpZiAoc3ViU2Vjcy5sZW5ndGggPiAwICYmIHN1YkxldnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJJbmRlcGVuZGVudFZhciA9IGRhdGFbaW5kZXBlbmRlbnRWYXJOYW1lXVtkaV07XG4gICAgICAgICAgICAgICAgbmV3U3ViVmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgbmV3U3ViU2VjcyA9IFtdO1xuICAgICAgICAgICAgICAgIG5ld1N1YkxldnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHNpID0gMDsgc2kgPCBzdWJTZWNzLmxlbmd0aDsgc2krKykgeyAgLy8gbG9vcCBvdmVyIGFsbCBzdWJTZWNzIGZvciB0aGlzIGluZGVwZW5kZW50VmFyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBQYWlyID0gW3N1YlNlY3Nbc2ldLCBzdWJMZXZzW3NpXV07IC8vY3JlYXRlIHNlYy1sZXYgcGFpciBmb3IgZWFjaCBzdWIgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdHNEYXRhVXRpbHMuYXJyYXlDb250YWluc1N1YkFycmF5KHN1YkludGVyc2VjdGlvbnNbY3VyckluZGVwZW5kZW50VmFyXSwgdGVtcFBhaXIpKSB7ICAvLyBrZWVwIHRoZSBzdWJWYWx1ZSBvbmx5IGlmIGl0cyBzZWMtbGV2IHBhaXIgaXMgY29tbW9uIHRvIGFsbCBjdXJ2ZXMgZm9yIHRoaXMgaW5kZXBlbmRlbnRWYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWwgPSBzdWJWYWx1ZXNbc2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NlYyA9IHN1YlNlY3Nbc2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0xldiA9IHN1YkxldnNbc2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3ViVmFsdWVzLnB1c2gobmV3VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdWJTZWNzLnB1c2gobmV3U2VjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdWJMZXZzLnB1c2gobmV3TGV2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgZmlsdGVyZWQgZGF0YVxuICAgICAgICAgICAgICAgIGRhdGEuc3ViVmFsc1tkaV0gPSBuZXdTdWJWYWx1ZXM7XG4gICAgICAgICAgICAgICAgZGF0YS5zdWJTZWNzW2RpXSA9IG5ld1N1YlNlY3M7XG4gICAgICAgICAgICAgICAgZGF0YS5zdWJMZXZzW2RpXSA9IG5ld1N1YkxldnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YXNldFtjdXJ2ZUluZGV4XSA9IGRhdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFzZXQ7XG59O1xuXG4vLyBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgdW5tYXRjaGVkIGRhdGEgZnJvbSBhIGRhdGFzZXQgY29udGFpbmluZyBtdWx0aXBsZSBjdXJ2ZXMgZm9yIGEgaGlzdG9ncmFtICp3aXRob3V0KiBsZXZlbHMuXG4vLyBzZXBhcmF0ZSBtYXRjaGluZyBmdW5jdGlvbnMgYXJlIG5lZWRlZCBmb3IgaGlzdG9ncmFtcyBiZWNhdXNlIHlvdSBoYXZlIHRvIHRha2UgYWxsIG9mIHRoZSBkYXRhIG91dCBvZiB0aGUgYmlucywgdGhlblxuLy8gbWF0Y2ggaXQsIHRoZW4gcmVjYWxjdWxhdGUgdGhlIGJpbnMuIEZvciBvdGhlciBwbG90IHR5cGVzLCB5b3UgY2FuIGp1c3QgbGVhdmUgdGhlIGRhdGEgaW4gaXRzIGFscmVhZHktc29ydGVkIGZociwgbGV2ZWwsIGV0Yy5cbmNvbnN0IGdldE1hdGNoZWREYXRhU2V0SGlzdG9ncmFtID0gZnVuY3Rpb24gKGRhdGFzZXQsIGN1cnZlc0xlbmd0aCwgYmluU3RhdHMpIHtcblxuICAgIHZhciBzdWJTdGF0c1JhdyA9IHt9O1xuICAgIHZhciBzdWJTZWNzUmF3ID0ge307XG4gICAgdmFyIHN1YlN0YXRzID0ge307XG4gICAgdmFyIHN1YlNlY3MgPSB7fTtcbiAgICB2YXIgbmV3U3ViU3RhdHMgPSB7fTtcbiAgICB2YXIgbmV3U3ViU2VjcyA9IHt9O1xuICAgIHZhciBuZXdDdXJ2ZURhdGE7XG4gICAgdmFyIGN1cnZlSW5kZXg7XG4gICAgdmFyIGRpO1xuICAgIHZhciBzaTtcblxuICAgIC8vIHB1bGwgYWxsIHN1YlNlY3MgYW5kIHN1YlN0YXRzIG91dCBvZiB0aGVpciBiaW5zLCBhbmQgYmFjayBpbnRvIG9uZSBtYXN0ZXIgYXJyYXlcbiAgICBmb3IgKGN1cnZlSW5kZXggPSAwOyBjdXJ2ZUluZGV4IDwgY3VydmVzTGVuZ3RoOyBjdXJ2ZUluZGV4KyspIHtcbiAgICAgICAgZGF0YSA9IGRhdGFzZXRbY3VydmVJbmRleF07XG4gICAgICAgIHN1YlN0YXRzUmF3W2N1cnZlSW5kZXhdID0gW107XG4gICAgICAgIHN1YlNlY3NSYXdbY3VydmVJbmRleF0gPSBbXTtcbiAgICAgICAgc3ViU3RhdHNbY3VydmVJbmRleF0gPSBbXTtcbiAgICAgICAgc3ViU2Vjc1tjdXJ2ZUluZGV4XSA9IFtdO1xuICAgICAgICBmb3IgKGRpID0gMDsgZGkgPCBkYXRhLngubGVuZ3RoOyBkaSsrKSB7XG4gICAgICAgICAgICBzdWJTdGF0c1Jhd1tjdXJ2ZUluZGV4XS5wdXNoKGRhdGEuc3ViVmFsc1tkaV0pO1xuICAgICAgICAgICAgc3ViU2Vjc1Jhd1tjdXJ2ZUluZGV4XS5wdXNoKGRhdGEuc3ViU2Vjc1tkaV0pO1xuICAgICAgICB9XG4gICAgICAgIHN1YlN0YXRzW2N1cnZlSW5kZXhdID0gW10uY29uY2F0LmFwcGx5KFtdLCBzdWJTdGF0c1Jhd1tjdXJ2ZUluZGV4XSk7XG4gICAgICAgIHN1YlNlY3NbY3VydmVJbmRleF0gPSBbXS5jb25jYXQuYXBwbHkoW10sIHN1YlNlY3NSYXdbY3VydmVJbmRleF0pO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSB3aGljaCBzZWNvbmRzIGFyZSBwcmVzZW50IGluIGFsbCBjdXJ2ZXNcbiAgICB2YXIgc3ViU2VjSW50ZXJzZWN0aW9uID0gc3ViU2Vjc1swXTsgICAvLyBmaWxsIGN1cnJlbnQgc3ViU2VjcyBpbnRlcnNlY3Rpb24gYXJyYXkgd2l0aCBzdWJTZWNzIGZyb20gdGhlIGZpcnN0IGN1cnZlXG4gICAgZm9yIChjdXJ2ZUluZGV4ID0gMTsgY3VydmVJbmRleCA8IGN1cnZlc0xlbmd0aDsgY3VydmVJbmRleCsrKSB7IC8vIGxvb3Agb3ZlciBldmVyeSBjdXJ2ZVxuICAgICAgICBzdWJTZWNJbnRlcnNlY3Rpb24gPSBfLmludGVyc2VjdGlvbihzdWJTZWNJbnRlcnNlY3Rpb24sIHN1YlNlY3NbY3VydmVJbmRleF0pOyAgIC8vIGtlZXAgdGFraW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIGN1cnJlbnQgc3ViU2VjcyBpbnRlcnNlY3Rpb24gYXJyYXkgd2l0aCBlYWNoIGN1cnZlJ3Mgc3ViU2VjcyBhcnJheVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBub24tbWF0Y2hpbmcgc3ViU2VjcyBhbmQgc3ViU3RhdHNcbiAgICBmb3IgKGN1cnZlSW5kZXggPSAwOyBjdXJ2ZUluZGV4IDwgY3VydmVzTGVuZ3RoOyBjdXJ2ZUluZGV4KyspIHsgLy8gbG9vcCBvdmVyIGV2ZXJ5IGN1cnZlXG4gICAgICAgIGRhdGEgPSBkYXRhc2V0W2N1cnZlSW5kZXhdO1xuICAgICAgICBpZiAoc3ViU2VjSW50ZXJzZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5ld1N1YlN0YXRzW2N1cnZlSW5kZXhdID0gW107XG4gICAgICAgICAgICBuZXdTdWJTZWNzW2N1cnZlSW5kZXhdID0gW107XG5cbiAgICAgICAgICAgIGZvciAoc2kgPSAwOyBzaSA8IHN1YlNlY3NbY3VydmVJbmRleF0ubGVuZ3RoOyBzaSsrKSB7ICAvLyBsb29wIG92ZXIgYWxsIHN1YlNlY3MgZm9yIHRoaXMgY3VydmVcbiAgICAgICAgICAgICAgICBpZiAoc3ViU2VjSW50ZXJzZWN0aW9uLmluZGV4T2Yoc3ViU2Vjc1tjdXJ2ZUluZGV4XVtzaV0pICE9PSAtMSkgeyAvLyBrZWVwIHRoZSBzdWJTdGF0IG9ubHkgaWYgaXRzIGFzc29jaWF0ZWQgc3ViU2VjIGlzIGNvbW1vbiB0byBhbGwgY3VydmVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ID0gc3ViU3RhdHNbY3VydmVJbmRleF1bc2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2VjID0gc3ViU2Vjc1tjdXJ2ZUluZGV4XVtzaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N1YlN0YXRzW2N1cnZlSW5kZXhdLnB1c2gobmV3U3RhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdWJTZWNzW2N1cnZlSW5kZXhdLnB1c2gobmV3U2VjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlLXNvcnQgYWxsIG9mIHRoZSBkYXRhIGludG8gaGlzdG9ncmFtIGJpbnNcbiAgICAgICAgICAgIHZhciBkID0gey8vIGQgd2lsbCBjb250YWluIHRoZSBjdXJ2ZSBkYXRhXG4gICAgICAgICAgICAgICAgeDogW10sIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICB5OiBbXSwgLy9wbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGVycm9yX3g6IFtdLCAvLyB1bnVzZWRcbiAgICAgICAgICAgICAgICBlcnJvcl95OiBbXSwgLy8gdW51c2VkXG4gICAgICAgICAgICAgICAgc3ViVmFsczogW10sXG4gICAgICAgICAgICAgICAgc3ViU2VjczogW10sXG4gICAgICAgICAgICAgICAgc3ViTGV2czogW10sXG4gICAgICAgICAgICAgICAgZ2xvYl9zdGF0czoge30sIC8vIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgYmluX3N0YXRzOiBbXSwgLy8gcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICB0ZXh0OiBbXSwgLy9wbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIHhtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICAgICAgeG1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgICAgICB5bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgICAgIHltYXg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmV3Q3VydmVEYXRhID0gbWF0c0RhdGFVdGlscy5zb3J0SGlzdG9ncmFtQmlucyhuZXdTdWJTdGF0c1tjdXJ2ZUluZGV4XSwgbmV3U3ViU2Vjc1tjdXJ2ZUluZGV4XSwgW10sIGRhdGEueC5sZW5ndGgsIGJpblN0YXRzLCBmYWxzZSwgZCk7XG4gICAgICAgICAgICB2YXIgbmV3Q3VydmVEYXRhS2V5cyA9IE9iamVjdC5rZXlzKG5ld0N1cnZlRGF0YS5kKTtcbiAgICAgICAgICAgIGZvciAodmFyIGRpZHggPSAwOyBkaWR4IDwgbmV3Q3VydmVEYXRhS2V5cy5sZW5ndGg7IGRpZHgrKykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRbY3VydmVJbmRleF1bbmV3Q3VydmVEYXRhS2V5c1tkaWR4XV0gPSBuZXdDdXJ2ZURhdGEuZFtuZXdDdXJ2ZURhdGFLZXlzW2RpZHhdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtYXRjaGluZyB2YWx1ZXMsIHNldCBkYXRhIHRvIGFuIGVtcHR5IGFycmF5XG4gICAgICAgICAgICBkYXRhc2V0W2N1cnZlSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgICAgIHk6IFtdLFxuICAgICAgICAgICAgICAgIGVycm9yX3g6IFtdLFxuICAgICAgICAgICAgICAgIGVycm9yX3k6IFtdLFxuICAgICAgICAgICAgICAgIHN1YlZhbHM6IFtdLFxuICAgICAgICAgICAgICAgIHN1YlNlY3M6IFtdLFxuICAgICAgICAgICAgICAgIHN1YkxldnM6IFtdLFxuICAgICAgICAgICAgICAgIGdsb2Jfc3RhdHM6IHt9LFxuICAgICAgICAgICAgICAgIGJpbl9zdGF0czogW10sXG4gICAgICAgICAgICAgICAgdGV4dDogW10sXG4gICAgICAgICAgICAgICAgeG1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgICAgICB4bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgICAgIHltaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICAgICAgeW1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFzZXQ7XG59O1xuXG4vLyBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgdW5tYXRjaGVkIGRhdGEgZnJvbSBhIGRhdGFzZXQgY29udGFpbmluZyBtdWx0aXBsZSBjdXJ2ZXMgZm9yIGEgaGlzdG9ncmFtICp3aXRoKiBsZXZlbHMuXG4vLyBzZXBhcmF0ZSBtYXRjaGluZyBmdW5jdGlvbnMgYXJlIG5lZWRlZCBmb3IgaGlzdG9ncmFtcyBiZWNhdXNlIHlvdSBoYXZlIHRvIHRha2UgYWxsIG9mIHRoZSBkYXRhIG91dCBvZiB0aGUgYmlucywgdGhlblxuLy8gbWF0Y2ggaXQsIHRoZW4gcmVjYWxjdWxhdGUgdGhlIGJpbnMuIEZvciBvdGhlciBwbG90IHR5cGVzLCB5b3UgY2FuIGp1c3QgbGVhdmUgdGhlIGRhdGEgaW4gaXRzIGFscmVhZHktc29ydGVkIGZociwgbGV2ZWwsIGV0Yy5cbmNvbnN0IGdldE1hdGNoZWREYXRhU2V0SGlzdG9ncmFtV2l0aExldmVscyA9IGZ1bmN0aW9uIChkYXRhc2V0LCBjdXJ2ZXNMZW5ndGgsIGJpblN0YXRzKSB7XG5cbiAgICB2YXIgc3ViU3RhdHNSYXcgPSB7fTtcbiAgICB2YXIgc3ViU2Vjc1JhdyA9IHt9O1xuICAgIHZhciBzdWJMZXZzUmF3ID0ge307XG4gICAgdmFyIHN1YlN0YXRzID0ge307XG4gICAgdmFyIHN1YlNlY3MgPSB7fTtcbiAgICB2YXIgc3ViTGV2cyA9IHt9O1xuICAgIHZhciBuZXdTdWJTdGF0cyA9IHt9O1xuICAgIHZhciBuZXdTdWJTZWNzID0ge307XG4gICAgdmFyIG5ld1N1YkxldnMgPSB7fTtcbiAgICB2YXIgbmV3Q3VydmVEYXRhO1xuICAgIHZhciBjdXJ2ZUluZGV4O1xuICAgIHZhciBkaTtcbiAgICB2YXIgc2k7XG5cbiAgICAvLyBwdWxsIGFsbCBzdWJTZWNzIGFuZCBzdWJTdGF0cyBvdXQgb2YgdGhlaXIgYmlucywgYW5kIGJhY2sgaW50byBvbmUgbWFzdGVyIGFycmF5XG4gICAgZm9yIChjdXJ2ZUluZGV4ID0gMDsgY3VydmVJbmRleCA8IGN1cnZlc0xlbmd0aDsgY3VydmVJbmRleCsrKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhc2V0W2N1cnZlSW5kZXhdO1xuICAgICAgICBzdWJTdGF0c1Jhd1tjdXJ2ZUluZGV4XSA9IFtdO1xuICAgICAgICBzdWJTZWNzUmF3W2N1cnZlSW5kZXhdID0gW107XG4gICAgICAgIHN1YkxldnNSYXdbY3VydmVJbmRleF0gPSBbXTtcbiAgICAgICAgc3ViU3RhdHNbY3VydmVJbmRleF0gPSBbXTtcbiAgICAgICAgc3ViU2Vjc1tjdXJ2ZUluZGV4XSA9IFtdO1xuICAgICAgICBzdWJMZXZzW2N1cnZlSW5kZXhdID0gW107XG4gICAgICAgIGZvciAoZGkgPSAwOyBkaSA8IGRhdGEueC5sZW5ndGg7IGRpKyspIHtcbiAgICAgICAgICAgIHN1YlN0YXRzUmF3W2N1cnZlSW5kZXhdLnB1c2goZGF0YS5zdWJWYWxzW2RpXSk7XG4gICAgICAgICAgICBzdWJTZWNzUmF3W2N1cnZlSW5kZXhdLnB1c2goZGF0YS5zdWJTZWNzW2RpXSk7XG4gICAgICAgICAgICBzdWJMZXZzUmF3W2N1cnZlSW5kZXhdLnB1c2goZGF0YS5zdWJMZXZzW2RpXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3ViU3RhdHNbY3VydmVJbmRleF0gPSBbXS5jb25jYXQuYXBwbHkoW10sIHN1YlN0YXRzUmF3W2N1cnZlSW5kZXhdKTtcbiAgICAgICAgc3ViU2Vjc1tjdXJ2ZUluZGV4XSA9IFtdLmNvbmNhdC5hcHBseShbXSwgc3ViU2Vjc1Jhd1tjdXJ2ZUluZGV4XSk7XG4gICAgICAgIHN1YkxldnNbY3VydmVJbmRleF0gPSBbXS5jb25jYXQuYXBwbHkoW10sIHN1YkxldnNSYXdbY3VydmVJbmRleF0pO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSB3aGljaCBzZWNvbmRzIGFuZCBsZXZlbHMgYXJlIHByZXNlbnQgaW4gYWxsIGN1cnZlc1xuICAgIHZhciBzdWJJbnRlcnNlY3Rpb25zID0gW107ICAgICAgIC8vIGV2ZW50dWFsbHkgZmluZCB0aGUgaW50ZXJzZWN0aW5nIHN1YlNlY3MgYW5kIHN1YkxldnMgYWNyb3NzIGFsbCBjdXJ2ZXNcbiAgICBmb3IgKHNpID0gMDsgc2kgPCBzdWJTZWNzWzBdLmxlbmd0aDsgc2krKykgeyAgIC8vIGZpbGwgY3VycmVudCBpbnRlcnNlY3Rpb24gYXJyYXkgd2l0aCBzZWMtbGV2IHBhaXJzIGZyb20gdGhlIGZpcnN0IGN1cnZlXG4gICAgICAgIHN1YkludGVyc2VjdGlvbnMucHVzaChbc3ViU2Vjc1swXVtzaV0sIHN1YkxldnNbMF1bc2ldXSk7XG4gICAgfVxuICAgIGZvciAoY3VydmVJbmRleCA9IDE7IGN1cnZlSW5kZXggPCBjdXJ2ZXNMZW5ndGg7IGN1cnZlSW5kZXgrKykgeyAvLyBsb29wIG92ZXIgZXZlcnkgY3VydmUgYWZ0ZXIgdGhlIGZpcnN0XG4gICAgICAgIHZhciB0ZW1wU3ViSW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgdGVtcFBhaXI7XG4gICAgICAgIGZvciAoc2kgPSAwOyBzaSA8IHN1YlNlY3NbY3VydmVJbmRleF0ubGVuZ3RoOyBzaSsrKSB7IC8vIGxvb3Agb3ZlciBldmVyeSBzdWJTZWNzIHZhbHVlXG4gICAgICAgICAgICB0ZW1wUGFpciA9IFtzdWJTZWNzW2N1cnZlSW5kZXhdW3NpXSwgc3ViTGV2c1tjdXJ2ZUluZGV4XVtzaV1dOyAgICAvLyBjcmVhdGUgYW4gaW5kaXZpZHVhbCBzZWMtbGV2IHBhaXIgZm9yIGVhY2ggaW5kZXggaW4gdGhlIHN1YlNlY3MgYW5kIHN1YkxldnMgYXJyYXlzXG4gICAgICAgICAgICBpZiAobWF0c0RhdGFVdGlscy5hcnJheUNvbnRhaW5zU3ViQXJyYXkoc3ViSW50ZXJzZWN0aW9ucywgdGVtcFBhaXIpKSB7ICAgLy8gc2VlIGlmIHRoZSBpbmRpdmlkdWFsIHNlYy1sZXYgcGFpciBtYXRjaGVzIGEgcGFpciBmcm9tIHRoZSBjdXJyZW50IGludGVyc2VjdGlvbiBhcnJheVxuICAgICAgICAgICAgICAgIHRlbXBTdWJJbnRlcnNlY3Rpb25zLnB1c2godGVtcFBhaXIpOyAgICAvLyBzdG9yZSBtYXRjaGluZyBwYWlyc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1YkludGVyc2VjdGlvbnMgPSB0ZW1wU3ViSW50ZXJzZWN0aW9uczsgICAgLy9yZXBsYWNlIGN1cnJlbnQgaW50ZXJzZWN0aW9uIGFycmF5IHdpdGggYXJyYXkgb2Ygb25seSBwYWlycyB0aGF0IG1hdGNoZWQgZnJvbSB0aGlzIGxvb3AgdGhyb3VnaC5cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgbm9uLW1hdGNoaW5nIHN1YlNlY3MsIHN1YkxldnMsIGFuZCBzdWJTdGF0c1xuICAgIGZvciAoY3VydmVJbmRleCA9IDA7IGN1cnZlSW5kZXggPCBjdXJ2ZXNMZW5ndGg7IGN1cnZlSW5kZXgrKykgeyAvLyBsb29wIG92ZXIgZXZlcnkgY3VydmVcbiAgICAgICAgZGF0YSA9IGRhdGFzZXRbY3VydmVJbmRleF07XG4gICAgICAgIGlmIChzdWJJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5ld1N1YlN0YXRzW2N1cnZlSW5kZXhdID0gW107XG4gICAgICAgICAgICBuZXdTdWJTZWNzW2N1cnZlSW5kZXhdID0gW107XG4gICAgICAgICAgICBuZXdTdWJMZXZzW2N1cnZlSW5kZXhdID0gW107XG5cbiAgICAgICAgICAgIGZvciAoc2kgPSAwOyBzaSA8IHN1YlNlY3NbY3VydmVJbmRleF0ubGVuZ3RoOyBzaSsrKSB7ICAvLyBsb29wIG92ZXIgYWxsIHN1YlNlY3MgZm9yIHRoaXMgY3VydmVcbiAgICAgICAgICAgICAgICB0ZW1wUGFpciA9IFtzdWJTZWNzW2N1cnZlSW5kZXhdW3NpXSwgc3ViTGV2c1tjdXJ2ZUluZGV4XVtzaV1dOyAvL2NyZWF0ZSBzZWMtbGV2IHBhaXIgZm9yIGVhY2ggc3ViU3RhdFxuICAgICAgICAgICAgICAgIGlmIChtYXRzRGF0YVV0aWxzLmFycmF5Q29udGFpbnNTdWJBcnJheShzdWJJbnRlcnNlY3Rpb25zLCB0ZW1wUGFpcikpIHsgIC8vIGtlZXAgdGhlIHN1YlN0YXQgb25seSBpZiBpdHMgc2VjLWxldiBwYWlyIGlzIGNvbW1vbiB0byBhbGwgY3VydmVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ID0gc3ViU3RhdHNbY3VydmVJbmRleF1bc2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2VjID0gc3ViU2Vjc1tjdXJ2ZUluZGV4XVtzaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdMZXYgPSBzdWJMZXZzW2N1cnZlSW5kZXhdW3NpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1N0YXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3ViU3RhdHNbY3VydmVJbmRleF0ucHVzaChuZXdTdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N1YlNlY3NbY3VydmVJbmRleF0ucHVzaChuZXdTZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3ViTGV2c1tjdXJ2ZUluZGV4XS5wdXNoKG5ld0xldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZS1zb3J0IGFsbCBvZiB0aGUgZGF0YSBpbnRvIGhpc3RvZ3JhbSBiaW5zXG4gICAgICAgICAgICB2YXIgZCA9IHsvLyBkIHdpbGwgY29udGFpbiB0aGUgY3VydmUgZGF0YVxuICAgICAgICAgICAgICAgIHg6IFtdLCAvL3BsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgeTogW10sIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICBlcnJvcl94OiBbXSwgLy8gdW51c2VkXG4gICAgICAgICAgICAgICAgZXJyb3JfeTogW10sIC8vIHVudXNlZFxuICAgICAgICAgICAgICAgIHN1YlZhbHM6IFtdLFxuICAgICAgICAgICAgICAgIHN1YlNlY3M6IFtdLFxuICAgICAgICAgICAgICAgIHN1YkxldnM6IFtdLFxuICAgICAgICAgICAgICAgIGdsb2Jfc3RhdHM6IHt9LCAvLyBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGJpbl9zdGF0czogW10sIC8vIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgdGV4dDogW10sIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICB4bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgICAgIHhtYXg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICAgICAgeW1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgICAgICB5bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5ld0N1cnZlRGF0YSA9IG1hdHNEYXRhVXRpbHMuc29ydEhpc3RvZ3JhbUJpbnMobmV3U3ViU3RhdHNbY3VydmVJbmRleF0sIG5ld1N1YlNlY3NbY3VydmVJbmRleF0sIG5ld1N1YkxldnNbY3VydmVJbmRleF0sIGRhdGEueC5sZW5ndGgsIGJpblN0YXRzLCB0cnVlLCBkKTtcbiAgICAgICAgICAgIHZhciBuZXdDdXJ2ZURhdGFLZXlzID0gT2JqZWN0LmtleXMobmV3Q3VydmVEYXRhLmQpO1xuICAgICAgICAgICAgZm9yICh2YXIgZGlkeCA9IDA7IGRpZHggPCBuZXdDdXJ2ZURhdGFLZXlzLmxlbmd0aDsgZGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldFtjdXJ2ZUluZGV4XVtuZXdDdXJ2ZURhdGFLZXlzW2RpZHhdXSA9IG5ld0N1cnZlRGF0YS5kW25ld0N1cnZlRGF0YUtleXNbZGlkeF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1hdGNoaW5nIHZhbHVlcywgc2V0IGRhdGEgdG8gYW4gZW1wdHkgZGF0YXNldFxuICAgICAgICAgICAgZGF0YXNldFtjdXJ2ZUluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICAgICAgICBlcnJvcl94OiBbXSxcbiAgICAgICAgICAgICAgICBlcnJvcl95OiBbXSxcbiAgICAgICAgICAgICAgICBzdWJWYWxzOiBbXSxcbiAgICAgICAgICAgICAgICBzdWJTZWNzOiBbXSxcbiAgICAgICAgICAgICAgICBzdWJMZXZzOiBbXSxcbiAgICAgICAgICAgICAgICBnbG9iX3N0YXRzOiB7fSxcbiAgICAgICAgICAgICAgICBiaW5fc3RhdHM6IFtdLFxuICAgICAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgICAgIHhtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICAgICAgeG1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgICAgICB5bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgICAgIHltYXg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhc2V0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWF0c0RhdGFNYXRjaFV0aWxzID0ge1xuXG4gICAgZ2V0TWF0Y2hlZERhdGFTZXQ6IGdldE1hdGNoZWREYXRhU2V0LFxuICAgIGdldE1hdGNoZWREYXRhU2V0V2l0aExldmVsczogZ2V0TWF0Y2hlZERhdGFTZXRXaXRoTGV2ZWxzLFxuICAgIGdldE1hdGNoZWREYXRhU2V0SGlzdG9ncmFtOiBnZXRNYXRjaGVkRGF0YVNldEhpc3RvZ3JhbSxcbiAgICBnZXRNYXRjaGVkRGF0YVNldEhpc3RvZ3JhbVdpdGhMZXZlbHM6IGdldE1hdGNoZWREYXRhU2V0SGlzdG9ncmFtV2l0aExldmVsc1xuXG59IiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8vIGFkZHMgYSBob3Jpem9udGFsIGJsYWNrIGxpbmUgYWxvbmcgYSBzcGVjaWZpYyB5IHZhbHVlXG5jb25zdCBnZXRIb3Jpem9udGFsVmFsdWVMaW5lID0gZnVuY3Rpb24gKHhtYXgsIHhtaW4sIHlWYWx1ZSwgY0xhYmVsKSB7XG5cbiAgICBjb25zdCB2YWx1ZUxpbmUgPSB7XG4gICAgICAgIFwibGFiZWxcIjogY0xhYmVsLFxuICAgICAgICBcImN1cnZlSWRcIjogY0xhYmVsLFxuICAgICAgICBcImFubm90YXRpb25cIjogXCJcIixcbiAgICAgICAgXCJuYW1lXCI6IFwieSA9IFwiICsgeVZhbHVlLnRvU3RyaW5nKCksXG4gICAgICAgIFwibW9kZVwiOiBcImxpbmVzXCIsXG4gICAgICAgIFwieFwiOiBbeG1pbiwgeG1heF0sXG4gICAgICAgIFwieF9lcG9jaFwiOiBbeG1pbiwgeG1heF0sXG4gICAgICAgIFwieVwiOiBbeVZhbHVlLCB5VmFsdWVdLFxuICAgICAgICBcImVycm9yX3hcIjogW251bGwsIG51bGxdLFxuICAgICAgICBcImVycm9yX3lcIjogW251bGwsIG51bGxdLFxuICAgICAgICBcInN1YlZhbHNcIjogW10sXG4gICAgICAgIFwic3ViU2Vjc1wiOiBbXSxcbiAgICAgICAgXCJzdWJMZXZzXCI6IFtdLFxuICAgICAgICBcInN0YXRzXCI6IFt7XCJkX21lYW5cIjogMCwgXCJzZFwiOiAwLCBcIm5fZ29vZFwiOiAwLCBcImxhZzFcIjogMCwgXCJzdGRlXCI6IDB9LCB7XG4gICAgICAgICAgICBcImRfbWVhblwiOiAwLFxuICAgICAgICAgICAgXCJzZFwiOiAwLFxuICAgICAgICAgICAgXCJuX2dvb2RcIjogMCxcbiAgICAgICAgICAgIFwibGFnMVwiOiAwLFxuICAgICAgICAgICAgXCJzdGRlXCI6IDBcbiAgICAgICAgfV0sXG4gICAgICAgIFwidG9vbHRpcFwiOiBbXCJ5ID0gXCIgKyB5VmFsdWUudG9TdHJpbmcoKSwgXCJ5ID0gXCIgKyB5VmFsdWUudG9TdHJpbmcoKV0sXG4gICAgICAgIFwieG1pblwiOiB4bWluLFxuICAgICAgICBcInhtYXhcIjogeG1heCxcbiAgICAgICAgXCJ5bWluXCI6IHlWYWx1ZSxcbiAgICAgICAgXCJ5bWF4XCI6IHlWYWx1ZSxcbiAgICAgICAgXCJsaW5lXCI6IHtcbiAgICAgICAgICAgIFwiY29sb3JcIjogXCJyZ2IoMCwwLDApXCIsXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHZhbHVlTGluZVxufTtcblxuLy8gYWRkcyBhIHZlcnRpY2FsIGJsYWNrIGxpbmUgYWxvbmcgYSBzcGVjaWZpYyB4IHZhbHVlXG5jb25zdCBnZXRWZXJ0aWNhbFZhbHVlTGluZSA9IGZ1bmN0aW9uICh5bWF4LCB5bWluLCB4VmFsdWUsIGNMYWJlbCkge1xuXG4gICAgY29uc3QgdmFsdWVMaW5lID0ge1xuICAgICAgICBcImxhYmVsXCI6IGNMYWJlbCxcbiAgICAgICAgXCJjdXJ2ZUlkXCI6IGNMYWJlbCxcbiAgICAgICAgXCJhbm5vdGF0aW9uXCI6IFwiXCIsXG4gICAgICAgIFwibmFtZVwiOiBcInggPSBcIiArIHhWYWx1ZS50b1N0cmluZygpLFxuICAgICAgICBcIm1vZGVcIjogXCJsaW5lc1wiLFxuICAgICAgICBcInhcIjogW3hWYWx1ZSwgeFZhbHVlXSxcbiAgICAgICAgXCJ5XCI6IFt5bWluLCB5bWF4XSxcbiAgICAgICAgXCJlcnJvcl94XCI6IFtudWxsLCBudWxsXSxcbiAgICAgICAgXCJlcnJvcl95XCI6IFtudWxsLCBudWxsXSxcbiAgICAgICAgXCJzdWJWYWxzXCI6IFtdLFxuICAgICAgICBcInN1YlNlY3NcIjogW10sXG4gICAgICAgIFwic3ViTGV2c1wiOiBbXSxcbiAgICAgICAgXCJzdGF0c1wiOiBbe1wiZF9tZWFuXCI6IDAsIFwic2RcIjogMCwgXCJuX2dvb2RcIjogMCwgXCJsYWcxXCI6IDAsIFwic3RkZVwiOiAwfSwge1xuICAgICAgICAgICAgXCJkX21lYW5cIjogMCxcbiAgICAgICAgICAgIFwic2RcIjogMCxcbiAgICAgICAgICAgIFwibl9nb29kXCI6IDAsXG4gICAgICAgICAgICBcImxhZzFcIjogMCxcbiAgICAgICAgICAgIFwic3RkZVwiOiAwXG4gICAgICAgIH1dLFxuICAgICAgICBcInRvb2x0aXBcIjogW1wieCA9IFwiICsgeFZhbHVlLnRvU3RyaW5nKCksIFwieCA9IFwiICsgeFZhbHVlLnRvU3RyaW5nKCldLFxuICAgICAgICBcInhtaW5cIjogeFZhbHVlLFxuICAgICAgICBcInhtYXhcIjogeFZhbHVlLFxuICAgICAgICBcInltaW5cIjogeW1pbixcbiAgICAgICAgXCJ5bWF4XCI6IHltYXgsXG4gICAgICAgIFwibGluZVwiOiB7XG4gICAgICAgICAgICBcImNvbG9yXCI6IFwicmdiKDAsMCwwKVwiLFxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB2YWx1ZUxpbmVcbn07XG5cbi8vIGFkZHMgYSBsaW5lYXIgbGluZVxuY29uc3QgZ2V0TGluZWFyVmFsdWVMaW5lID0gZnVuY3Rpb24gKHhtYXgsIHhtaW4sIHltYXgsIHltaW4sIGNMYWJlbCkge1xuXG4gICAgY29uc3QgdmFsdWVMaW5lID0ge1xuICAgICAgICBcImxhYmVsXCI6IGNMYWJlbCxcbiAgICAgICAgXCJjdXJ2ZUlkXCI6IGNMYWJlbCxcbiAgICAgICAgXCJhbm5vdGF0aW9uXCI6IFwiXCIsXG4gICAgICAgIFwibmFtZVwiOiBjTGFiZWwsXG4gICAgICAgIFwibW9kZVwiOiBcImxpbmVzXCIsXG4gICAgICAgIFwieFwiOiBbeG1pbiwgeG1heF0sXG4gICAgICAgIFwieF9lcG9jaFwiOiBbeG1pbiwgeG1heF0sXG4gICAgICAgIFwieVwiOiBbeW1pbiwgeW1heF0sXG4gICAgICAgIFwiZXJyb3JfeFwiOiBbbnVsbCwgbnVsbF0sXG4gICAgICAgIFwiZXJyb3JfeVwiOiBbbnVsbCwgbnVsbF0sXG4gICAgICAgIFwic3ViVmFsc1wiOiBbXSxcbiAgICAgICAgXCJzdWJTZWNzXCI6IFtdLFxuICAgICAgICBcInN1YkxldnNcIjogW10sXG4gICAgICAgIFwic3RhdHNcIjogW3tcImRfbWVhblwiOiAwLCBcInNkXCI6IDAsIFwibl9nb29kXCI6IDAsIFwibGFnMVwiOiAwLCBcInN0ZGVcIjogMH0sIHtcbiAgICAgICAgICAgIFwiZF9tZWFuXCI6IDAsXG4gICAgICAgICAgICBcInNkXCI6IDAsXG4gICAgICAgICAgICBcIm5fZ29vZFwiOiAwLFxuICAgICAgICAgICAgXCJsYWcxXCI6IDAsXG4gICAgICAgICAgICBcInN0ZGVcIjogMFxuICAgICAgICB9XSxcbiAgICAgICAgXCJ0b29sdGlwXCI6IFwiXCIsXG4gICAgICAgIFwieG1pblwiOiB4bWluLFxuICAgICAgICBcInhtYXhcIjogeG1heCxcbiAgICAgICAgXCJ5bWluXCI6IHltaW4sXG4gICAgICAgIFwieW1heFwiOiB5bWF4LFxuICAgICAgICBcImxpbmVcIjoge1xuICAgICAgICAgICAgXCJjb2xvclwiOiBcInJnYigwLDAsMClcIixcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gdmFsdWVMaW5lXG59O1xuXG4vLyBwcm92aWRlcyBjdXJ2ZSBvcHRpb25zIGZvciBhbGwgcGxvdCB0eXBlcyB3aXRoIGFuIGluZGVwZW5kZW50IHggYXhpcyBhbmQgYSBkZXBlbmRlbnQgeSBheGlzXG5jb25zdCBnZW5lcmF0ZVNlcmllc0N1cnZlT3B0aW9ucyA9IGZ1bmN0aW9uIChjdXJ2ZSwgY3VydmVJbmRleCwgYXhpc01hcCwgZGF0YVNlcmllcykge1xuXG4gICAgY29uc3QgbGFiZWwgPSBjdXJ2ZVsnbGFiZWwnXTtcbiAgICBjb25zdCBhbm5vdGF0aW9uID0gY3VydmVbJ2Fubm90YXRpb24nXTtcblxuICAgIC8vIGFkanVzdCBheGVzIGZvciBsYXRlciBzZXR0aW5nIG9mIHRoZSBwbG90IG9wdGlvbnNcbiAgICBjb25zdCB5bWluID0gY3VydmVbJ3ltaW4nXTtcbiAgICBjb25zdCB5bWF4ID0gY3VydmVbJ3ltYXgnXTtcbiAgICBjb25zdCB4bWluID0gY3VydmVbJ3htaW4nXTtcbiAgICBjb25zdCB4bWF4ID0gY3VydmVbJ3htYXgnXTtcbiAgICBjb25zdCBheGlzS2V5ID0gY3VydmVbJ2F4aXNLZXknXTtcbiAgICBpZiAoYXhpc0tleSBpbiBheGlzTWFwKSB7XG4gICAgICAgIGF4aXNNYXBbYXhpc0tleV0uYXhpc0xhYmVsID0gYXhpc0tleTtcbiAgICAgICAgYXhpc01hcFtheGlzS2V5XS55bWluID0geW1pbiA8IGF4aXNNYXBbYXhpc0tleV0ueW1pbiA/IHltaW4gOiBheGlzTWFwW2F4aXNLZXldLnltaW47XG4gICAgICAgIGF4aXNNYXBbYXhpc0tleV0ueW1heCA9IHltYXggPiBheGlzTWFwW2F4aXNLZXldLnltYXggPyB5bWF4IDogYXhpc01hcFtheGlzS2V5XS55bWF4O1xuICAgICAgICBheGlzTWFwW2F4aXNLZXldLnhtaW4gPSB4bWluIDwgYXhpc01hcFtheGlzS2V5XS54bWluID8geG1pbiA6IGF4aXNNYXBbYXhpc0tleV0ueG1pbjtcbiAgICAgICAgYXhpc01hcFtheGlzS2V5XS54bWF4ID0geG1heCA+IGF4aXNNYXBbYXhpc0tleV0ueG1heCA/IHhtYXggOiBheGlzTWFwW2F4aXNLZXldLnhtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXhpc01hcFtheGlzS2V5XSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBPYmplY3Qua2V5cyhheGlzTWFwKS5sZW5ndGggKyAxLFxuICAgICAgICAgICAgeG1pbjogeG1pbixcbiAgICAgICAgICAgIHhtYXg6IHhtYXgsXG4gICAgICAgICAgICB5bWluOiB5bWluLFxuICAgICAgICAgICAgeW1heDogeW1heCxcbiAgICAgICAgICAgIGF4aXNMYWJlbDogYXhpc0tleVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGF4aXNOdW1iZXIgPSBPYmplY3Qua2V5cyhheGlzTWFwKS5pbmRleE9mKGF4aXNLZXkpO1xuXG4gICAgdmFyIGVycm9yX3lfdGVtcCA9IHtcbiAgICAgICAgZXJyb3JfeToge1xuICAgICAgICAgICAgYXJyYXk6IGRhdGFTZXJpZXMuZXJyb3JfeSxcbiAgICAgICAgICAgIHRoaWNrbmVzczogMSwgICAgIC8vIHNldCB0aGUgdGhpY2tuZXNzIG9mIHRoZSBlcnJvciBiYXJzXG4gICAgICAgICAgICBjb2xvcjogY3VydmVbJ2NvbG9yJ10sXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSwgLy8gY2hhbmdlZCBsYXRlciBpZiBtYXRjaGluZ1xuICAgICAgICAgICAgLy8gd2lkdGg6IDBcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGN1cnZlT3B0aW9ucyA9IHtcbiAgICAgICAgLi4ue1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgY3VydmVJZDogbGFiZWwsXG4gICAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICAgIHhheGlzOiBcIngxXCIsXG4gICAgICAgICAgICB5YXhpczogXCJ5XCIgKyAoYXhpc051bWJlciArIDEpLFxuICAgICAgICAgICAgYW5ub3RhdGlvbjogYW5ub3RhdGlvbixcbiAgICAgICAgICAgIGFubm90YXRlQ29sb3I6IGN1cnZlWydjb2xvciddLFxuICAgICAgICAgICAgbW9kZTogXCJsaW5lcyttYXJrZXJzXCIsXG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICBzeW1ib2w6IFwiY2lyY2xlXCIsXG4gICAgICAgICAgICAgICAgY29sb3I6IGN1cnZlWydjb2xvciddLFxuICAgICAgICAgICAgICAgIHNpemU6IDhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgICAgZGFzaDogJ3NvbGlkJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogY3VydmVbJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH0sIC4uLmRhdGFTZXJpZXNcbiAgICB9O1xuXG4gICAgZGVsZXRlIGN1cnZlT3B0aW9ucy5lcnJvcl95O1xuXG4gICAgY3VydmVPcHRpb25zWydlcnJvcl95J10gPSBlcnJvcl95X3RlbXAuZXJyb3JfeTtcblxuICAgIHJldHVybiBjdXJ2ZU9wdGlvbnM7XG59O1xuXG4vLyBwcm92aWRlcyBjdXJ2ZSBvcHRpb25zIGZvciBhbGwgcGxvdCB0eXBlcyB3aXRoIGFuIGluZGVwZW5kZW50IHkgYXhpcyBhbmQgYSBkZXBlbmRlbnQgeCBheGlzXG5jb25zdCBnZW5lcmF0ZVByb2ZpbGVDdXJ2ZU9wdGlvbnMgPSBmdW5jdGlvbiAoY3VydmUsIGN1cnZlSW5kZXgsIGF4aXNNYXAsIGRhdGFQcm9maWxlKSB7XG5cbiAgICBjb25zdCBsYWJlbCA9IGN1cnZlWydsYWJlbCddO1xuICAgIGNvbnN0IGFubm90YXRpb24gPSBjdXJ2ZVsnYW5ub3RhdGlvbiddO1xuXG4gICAgLy8gYWRqdXN0IGF4ZXMgZm9yIGxhdGVyIHNldHRpbmcgb2YgdGhlIHBsb3Qgb3B0aW9uc1xuICAgIGNvbnN0IHltaW4gPSBjdXJ2ZVsneW1pbiddO1xuICAgIGNvbnN0IHltYXggPSBjdXJ2ZVsneW1heCddO1xuICAgIGNvbnN0IHhtaW4gPSBjdXJ2ZVsneG1pbiddO1xuICAgIGNvbnN0IHhtYXggPSBjdXJ2ZVsneG1heCddO1xuICAgIGNvbnN0IGF4aXNLZXkgPSBjdXJ2ZVsnYXhpc0tleSddO1xuICAgIGlmIChheGlzS2V5IGluIGF4aXNNYXApIHtcbiAgICAgICAgYXhpc01hcFtheGlzS2V5XS5heGlzTGFiZWwgPSBheGlzS2V5O1xuICAgICAgICBheGlzTWFwW2F4aXNLZXldLnltaW4gPSB5bWluIDwgYXhpc01hcFtheGlzS2V5XS55bWluID8geW1pbiA6IGF4aXNNYXBbYXhpc0tleV0ueW1pbjtcbiAgICAgICAgYXhpc01hcFtheGlzS2V5XS55bWF4ID0geW1heCA+IGF4aXNNYXBbYXhpc0tleV0ueW1heCA/IHltYXggOiBheGlzTWFwW2F4aXNLZXldLnltYXg7XG4gICAgICAgIGF4aXNNYXBbYXhpc0tleV0ueG1pbiA9IHhtaW4gPCBheGlzTWFwW2F4aXNLZXldLnhtaW4gPyB4bWluIDogYXhpc01hcFtheGlzS2V5XS54bWluO1xuICAgICAgICBheGlzTWFwW2F4aXNLZXldLnhtYXggPSB4bWF4ID4gYXhpc01hcFtheGlzS2V5XS54bWF4ID8geG1heCA6IGF4aXNNYXBbYXhpc0tleV0ueG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBheGlzTWFwW2F4aXNLZXldID0ge1xuICAgICAgICAgICAgaW5kZXg6IE9iamVjdC5rZXlzKGF4aXNNYXApLmxlbmd0aCArIDEsXG4gICAgICAgICAgICB4bWluOiB4bWluLFxuICAgICAgICAgICAgeG1heDogeG1heCxcbiAgICAgICAgICAgIHltaW46IHltaW4sXG4gICAgICAgICAgICB5bWF4OiB5bWF4LFxuICAgICAgICAgICAgYXhpc0xhYmVsOiBheGlzS2V5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgYXhpc051bWJlciA9IE9iamVjdC5rZXlzKGF4aXNNYXApLmluZGV4T2YoYXhpc0tleSk7XG5cbiAgICB2YXIgZXJyb3JfeF90ZW1wID0ge1xuICAgICAgICBlcnJvcl94OiB7XG4gICAgICAgICAgICBhcnJheTogZGF0YVByb2ZpbGUuZXJyb3JfeCxcbiAgICAgICAgICAgIHRoaWNrbmVzczogMSwgICAgIC8vIHNldCB0aGUgdGhpY2tuZXNzIG9mIHRoZSBlcnJvciBiYXJzXG4gICAgICAgICAgICBjb2xvcjogY3VydmVbJ2NvbG9yJ10sXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSwgLy8gY2hhbmdlZCBsYXRlciBpZiBtYXRjaGluZ1xuICAgICAgICAgICAgLy8gd2lkdGg6IDBcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGN1cnZlT3B0aW9ucyA9IHtcbiAgICAgICAgLi4ue1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgY3VydmVJZDogbGFiZWwsXG4gICAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICAgIHhheGlzOiBcInhcIiArIChheGlzTnVtYmVyICsgMSksXG4gICAgICAgICAgICB5YXhpczogXCJ5MVwiLFxuICAgICAgICAgICAgYW5ub3RhdGlvbjogYW5ub3RhdGlvbixcbiAgICAgICAgICAgIGFubm90YXRlQ29sb3I6IGN1cnZlWydjb2xvciddLFxuICAgICAgICAgICAgbW9kZTogXCJsaW5lcyttYXJrZXJzXCIsXG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICBzeW1ib2w6IFwiY2lyY2xlXCIsXG4gICAgICAgICAgICAgICAgY29sb3I6IGN1cnZlWydjb2xvciddLFxuICAgICAgICAgICAgICAgIHNpemU6IDhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgICAgZGFzaDogJ3NvbGlkJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogY3VydmVbJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH0sIC4uLmRhdGFQcm9maWxlXG4gICAgfTtcblxuICAgIGRlbGV0ZSBjdXJ2ZU9wdGlvbnMuZXJyb3JfeDtcblxuICAgIGN1cnZlT3B0aW9uc1snZXJyb3JfeCddID0gZXJyb3JfeF90ZW1wLmVycm9yX3g7XG5cbiAgICByZXR1cm4gY3VydmVPcHRpb25zO1xufTtcblxuLy8gcHJvdmlkZXMgY3VydmUgb3B0aW9ucyBmb3IgcmVsaWFiaWxpdHkgZGlhZ3JhbXNcbmNvbnN0IGdlbmVyYXRlUmVsaWFiaWxpdHlDdXJ2ZU9wdGlvbnMgPSBmdW5jdGlvbiAoY3VydmUsIGN1cnZlSW5kZXgsIGF4aXNNYXAsIGRhdGFTZXJpZXMpIHtcblxuICAgIGNvbnN0IGxhYmVsID0gY3VydmVbJ2xhYmVsJ107XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IGN1cnZlWydhbm5vdGF0aW9uJ107XG5cbiAgICAvLyBhZGp1c3QgYXhlcyBmb3IgbGF0ZXIgc2V0dGluZyBvZiB0aGUgcGxvdCBvcHRpb25zXG4gICAgY29uc3QgeW1pbiA9IGN1cnZlWyd5bWluJ107XG4gICAgY29uc3QgeW1heCA9IGN1cnZlWyd5bWF4J107XG4gICAgY29uc3QgeG1pbiA9IGN1cnZlWyd4bWluJ107XG4gICAgY29uc3QgeG1heCA9IGN1cnZlWyd4bWF4J107XG4gICAgY29uc3QgYXhpc0tleSA9IGN1cnZlWydheGlzS2V5J107XG4gICAgaWYgKGF4aXNLZXkgaW4gYXhpc01hcCkge1xuICAgICAgICBheGlzTWFwW2F4aXNLZXldLmF4aXNMYWJlbCA9IGF4aXNLZXk7XG4gICAgICAgIGF4aXNNYXBbYXhpc0tleV0ueW1pbiA9IHltaW4gPCBheGlzTWFwW2F4aXNLZXldLnltaW4gPyB5bWluIDogYXhpc01hcFtheGlzS2V5XS55bWluO1xuICAgICAgICBheGlzTWFwW2F4aXNLZXldLnltYXggPSB5bWF4ID4gYXhpc01hcFtheGlzS2V5XS55bWF4ID8geW1heCA6IGF4aXNNYXBbYXhpc0tleV0ueW1heDtcbiAgICAgICAgYXhpc01hcFtheGlzS2V5XS54bWluID0geG1pbiA8IGF4aXNNYXBbYXhpc0tleV0ueG1pbiA/IHhtaW4gOiBheGlzTWFwW2F4aXNLZXldLnhtaW47XG4gICAgICAgIGF4aXNNYXBbYXhpc0tleV0ueG1heCA9IHhtYXggPiBheGlzTWFwW2F4aXNLZXldLnhtYXggPyB4bWF4IDogYXhpc01hcFtheGlzS2V5XS54bWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGF4aXNNYXBbYXhpc0tleV0gPSB7XG4gICAgICAgICAgICBpbmRleDogT2JqZWN0LmtleXMoYXhpc01hcCkubGVuZ3RoICsgMSxcbiAgICAgICAgICAgIHhtaW46IHhtaW4sXG4gICAgICAgICAgICB4bWF4OiB4bWF4LFxuICAgICAgICAgICAgeW1pbjogeW1pbixcbiAgICAgICAgICAgIHltYXg6IHltYXgsXG4gICAgICAgICAgICBheGlzTGFiZWw6IGF4aXNLZXlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBheGlzTnVtYmVyID0gT2JqZWN0LmtleXMoYXhpc01hcCkuaW5kZXhPZihheGlzS2V5KTtcblxuICAgIHZhciBlcnJvcl95X3RlbXAgPSB7XG4gICAgICAgIGVycm9yX3k6IHtcbiAgICAgICAgICAgIGFycmF5OiBkYXRhU2VyaWVzLmVycm9yX3ksXG4gICAgICAgICAgICB0aGlja25lc3M6IDEsICAgICAvLyBzZXQgdGhlIHRoaWNrbmVzcyBvZiB0aGUgZXJyb3IgYmFyc1xuICAgICAgICAgICAgY29sb3I6IGN1cnZlWydjb2xvciddLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsIC8vIGNoYW5nZWQgbGF0ZXIgaWYgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vIHdpZHRoOiAwXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjdXJ2ZU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLntcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgIGN1cnZlSWQ6IGxhYmVsLFxuICAgICAgICAgICAgbmFtZTogbGFiZWwsXG4gICAgICAgICAgICB4YXhpczogXCJ4MVwiLFxuICAgICAgICAgICAgeWF4aXM6IFwieVwiICsgKGF4aXNOdW1iZXIgKyAxKSxcbiAgICAgICAgICAgIGFubm90YXRpb246IGFubm90YXRpb24sXG4gICAgICAgICAgICBhbm5vdGF0ZUNvbG9yOiBjdXJ2ZVsnY29sb3InXSxcbiAgICAgICAgICAgIG1vZGU6IFwibGluZXMrbWFya2Vyc1wiLFxuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sOiBcImNpcmNsZVwiLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjdXJ2ZVsnY29sb3InXSxcbiAgICAgICAgICAgICAgICBzaXplOiA4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGRhc2g6ICdzb2xpZCcsXG4gICAgICAgICAgICAgICAgY29sb3I6IGN1cnZlWydjb2xvciddLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICB9LCAuLi5kYXRhU2VyaWVzXG4gICAgfTtcblxuICAgIGRlbGV0ZSBjdXJ2ZU9wdGlvbnMuZXJyb3JfeTtcblxuICAgIGN1cnZlT3B0aW9uc1snZXJyb3JfeSddID0gZXJyb3JfeV90ZW1wLmVycm9yX3k7XG5cbiAgICByZXR1cm4gY3VydmVPcHRpb25zO1xufTtcblxuLy8gcHJvdmlkZXMgY3VydmUgb3B0aW9ucyBmb3IgYWxsIHBsb3QgdHlwZXMgd2l0aCBhbiBpbmRlcGVuZGVudCB4IGF4aXMgYW5kIGEgZGVwZW5kZW50IHkgYXhpc1xuY29uc3QgZ2VuZXJhdGVCYXJDaGFydEN1cnZlT3B0aW9ucyA9IGZ1bmN0aW9uIChjdXJ2ZSwgY3VydmVJbmRleCwgYXhpc01hcCwgZGF0YUJhcnMpIHtcblxuICAgIGNvbnN0IGxhYmVsID0gY3VydmVbJ2xhYmVsJ107XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IGN1cnZlWydhbm5vdGF0aW9uJ107XG5cbiAgICAvLyBhZGp1c3QgYXhlcyBmb3IgbGF0ZXIgc2V0dGluZyBvZiB0aGUgcGxvdCBvcHRpb25zXG4gICAgY29uc3QgeW1pbiA9IGN1cnZlWyd5bWluJ107XG4gICAgY29uc3QgeW1heCA9IGN1cnZlWyd5bWF4J107XG4gICAgY29uc3QgeG1pbiA9IGN1cnZlWyd4bWluJ107XG4gICAgY29uc3QgeG1heCA9IGN1cnZlWyd4bWF4J107XG4gICAgY29uc3QgYXhpc0tleSA9IGN1cnZlWydheGlzS2V5J107XG4gICAgaWYgKGF4aXNLZXkgaW4gYXhpc01hcCkge1xuICAgICAgICBheGlzTWFwW2F4aXNLZXldLmF4aXNMYWJlbCA9IGF4aXNLZXk7XG4gICAgICAgIGF4aXNNYXBbYXhpc0tleV0ueW1pbiA9IHltaW4gPCBheGlzTWFwW2F4aXNLZXldLnltaW4gPyB5bWluIDogYXhpc01hcFtheGlzS2V5XS55bWluO1xuICAgICAgICBheGlzTWFwW2F4aXNLZXldLnltYXggPSB5bWF4ID4gYXhpc01hcFtheGlzS2V5XS55bWF4ID8geW1heCA6IGF4aXNNYXBbYXhpc0tleV0ueW1heDtcbiAgICAgICAgYXhpc01hcFtheGlzS2V5XS54bWluID0geG1pbiA8IGF4aXNNYXBbYXhpc0tleV0ueG1pbiA/IHhtaW4gOiBheGlzTWFwW2F4aXNLZXldLnhtaW47XG4gICAgICAgIGF4aXNNYXBbYXhpc0tleV0ueG1heCA9IHhtYXggPiBheGlzTWFwW2F4aXNLZXldLnhtYXggPyB4bWF4IDogYXhpc01hcFtheGlzS2V5XS54bWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGF4aXNNYXBbYXhpc0tleV0gPSB7XG4gICAgICAgICAgICBpbmRleDogT2JqZWN0LmtleXMoYXhpc01hcCkubGVuZ3RoICsgMSxcbiAgICAgICAgICAgIHhtaW46IHhtaW4sXG4gICAgICAgICAgICB4bWF4OiB4bWF4LFxuICAgICAgICAgICAgeW1pbjogeW1pbixcbiAgICAgICAgICAgIHltYXg6IHltYXgsXG4gICAgICAgICAgICBheGlzTGFiZWw6IGF4aXNLZXlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLntcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgIGN1cnZlSWQ6IGxhYmVsLFxuICAgICAgICAgICAgbmFtZTogbGFiZWwsXG4gICAgICAgICAgICBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLFxuICAgICAgICAgICAgYW5ub3RhdGVDb2xvcjogY3VydmVbJ2NvbG9yJ10sXG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY3VydmVbJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJyZ2IoMCwwLDApXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogJ2JhcicsXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH0sIC4uLmRhdGFCYXJzXG4gICAgfTtcblxuICAgIHJldHVybiBjdXJ2ZU9wdGlvbnM7XG59O1xuXG5jb25zdCBnZW5lcmF0ZU1hcEN1cnZlT3B0aW9ucyA9IGZ1bmN0aW9uIChjdXJ2ZSwgZGF0YVNlcmllcykge1xuXG4gICAgY29uc3QgbWFya2VyU2l6ZXMgPSBkYXRhU2VyaWVzLnF1ZXJ5VmFsLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5hYnModmFsICogNCkpICsgMjtcbiAgICB9KTtcblxuICAgIGNvbnN0IGxhYmVsID0gY3VydmVbJ2xhYmVsJ107XG5cbiAgICBjb25zdCBjdXJ2ZU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLntcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgIGN1cnZlSWQ6IGxhYmVsLFxuICAgICAgICAgICAgbmFtZTogbGFiZWwsXG4gICAgICAgICAgICB0eXBlOiAnc2NhdHRlcm1hcGJveCcsXG4gICAgICAgICAgICBtb2RlOiAnbWFya2VycycsXG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogZGF0YVNlcmllcy5jb2xvcixcbiAgICAgICAgICAgICAgICBzaXplOiBtYXJrZXJTaXplcyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCAuLi5kYXRhU2VyaWVzXG4gICAgfTtcblxuICAgIGRlbGV0ZSBjdXJ2ZU9wdGlvbnMuY29sb3I7XG5cbiAgICByZXR1cm4gY3VydmVPcHRpb25zO1xufTtcblxuY29uc3QgZ2VuZXJhdGVNYXBDb2xvclRleHRPcHRpb25zID0gZnVuY3Rpb24gKGxhYmVsLCBkYXRhU2VyaWVzKSB7XG5cbiAgICBjb25zdCBjdXJ2ZU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLntcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgIHR5cGU6ICdzY2F0dGVybWFwYm94JyxcbiAgICAgICAgICAgIG1vZGU6ICdtYXJrZXJzK3RleHQnLFxuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHRmb250OiB7XG4gICAgICAgICAgICAgICAgZmFtaWx5OiAnc2FucyBzZXJpZicsXG4gICAgICAgICAgICAgICAgLy8gc2l6ZTogMTgsXG4gICAgICAgICAgICAgICAgY29sb3I6IGRhdGFTZXJpZXMuY29sb3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBob3ZlcmluZm86ICdza2lwJyxcbiAgICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgfSwgLi4uZGF0YVNlcmllc1xuICAgIH07XG5cbiAgICBkZWxldGUgY3VydmVPcHRpb25zLmNvbG9yO1xuXG4gICAgcmV0dXJuIGN1cnZlT3B0aW9ucztcbn07XG5cbmNvbnN0IGdlbmVyYXRlQ29udG91ckN1cnZlT3B0aW9ucyA9IGZ1bmN0aW9uIChjdXJ2ZSwgYXhpc01hcCwgZGF0YXNldCkge1xuXG4gICAgY29uc3QgbGFiZWwgPSBjdXJ2ZVsnbGFiZWwnXTtcbiAgICBjb25zdCBhbm5vdGF0aW9uID0gY3VydmVbJ2Fubm90YXRpb24nXTtcbiAgICBjb25zdCB1bml0S2V5ID0gY3VydmVbJ3VuaXRLZXknXTtcblxuICAgIGNvbnN0IGN1cnZlT3B0aW9ucyA9IHtcbiAgICAgICAgLi4ue1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgY3VydmVJZDogbGFiZWwsXG4gICAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICAgIGFubm90YXRpb246IGFubm90YXRpb24sXG4gICAgICAgICAgICBhbm5vdGF0ZUNvbG9yOiBjdXJ2ZVsnY29sb3InXSxcbiAgICAgICAgICAgIHhBeGlzS2V5OiBjdXJ2ZVsneEF4aXNLZXknXSxcbiAgICAgICAgICAgIHlBeGlzS2V5OiBjdXJ2ZVsneUF4aXNLZXknXSxcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjdXJ2ZVsnY29sb3InXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiAnY29udG91cicsXG4gICAgICAgICAgICBhdXRvY29udG91cjogZmFsc2UsXG4gICAgICAgICAgICBuY29udG91cnM6IDE1LCAgIC8vIGFwcGFyZW50bHkgcGxvdGx5IHJlZ2FyZHMgdGhpcyBhcyBhIFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvXCIgZmllbGRcbiAgICAgICAgICAgIGNvbnRvdXJzOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgYXJlIG9ubHkgdXNlZCBpZiBhdXRvY29udG91ciBpcyBzZXQgdG8gZmFsc2UgYW5kIG5jb250b3VyIGlzIGRpc3JlZ2FyZGVkXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGFzZXQuem1pbiArIChkYXRhc2V0LnptYXggLSBkYXRhc2V0LnptaW4pIC8gMTYsXG4gICAgICAgICAgICAgICAgZW5kOiBkYXRhc2V0LnptYXggLSAoZGF0YXNldC56bWF4IC0gZGF0YXNldC56bWluKSAvIDE2LFxuICAgICAgICAgICAgICAgIHNpemU6ICAoZGF0YXNldC56bWF4IC0gZGF0YXNldC56bWluKSAvIDE2LFxuICAgICAgICAgICAgICAgIHNob3dsYWJlbHM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sb3JzY2FsZTogJ1JkQnUnLFxuICAgICAgICAgICAgcmV2ZXJzZXNjYWxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbG9yYmFyOntcbiAgICAgICAgICAgICAgICB0aXRsZTogdW5pdEtleSxcbiAgICAgICAgICAgICAgICB0aXRsZXNpZGU6ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgdGl0bGVmb250OiB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDIwLFxuICAgICAgICAgICAgICAgICAgICBmYW1pbHk6ICdBcmlhbCwgc2Fucy1zZXJpZidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gY29ubmVjdGdhcHM6IHRydWUsICAgLy8gdGhpcyBvcHRpb24gd2lsbCBpbnRlcnBvbGF0ZSB0byBmaWxsIGluIG51bGxzXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH0sIC4uLmRhdGFzZXRcbiAgICB9O1xuXG4gICAgcmV0dXJuIGN1cnZlT3B0aW9ucztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdHNEYXRhQ3VydmVPcHNVdGlscyA9IHtcblxuICAgIGdldEhvcml6b250YWxWYWx1ZUxpbmU6IGdldEhvcml6b250YWxWYWx1ZUxpbmUsXG4gICAgZ2V0VmVydGljYWxWYWx1ZUxpbmU6IGdldFZlcnRpY2FsVmFsdWVMaW5lLFxuICAgIGdldExpbmVhclZhbHVlTGluZTogZ2V0TGluZWFyVmFsdWVMaW5lLFxuXG4gICAgZ2VuZXJhdGVTZXJpZXNDdXJ2ZU9wdGlvbnM6IGdlbmVyYXRlU2VyaWVzQ3VydmVPcHRpb25zLFxuICAgIGdlbmVyYXRlUmVsaWFiaWxpdHlDdXJ2ZU9wdGlvbnM6IGdlbmVyYXRlUmVsaWFiaWxpdHlDdXJ2ZU9wdGlvbnMsXG4gICAgZ2VuZXJhdGVQcm9maWxlQ3VydmVPcHRpb25zOiBnZW5lcmF0ZVByb2ZpbGVDdXJ2ZU9wdGlvbnMsXG4gICAgZ2VuZXJhdGVCYXJDaGFydEN1cnZlT3B0aW9uczogZ2VuZXJhdGVCYXJDaGFydEN1cnZlT3B0aW9ucyxcbiAgICBnZW5lcmF0ZU1hcEN1cnZlT3B0aW9uczogZ2VuZXJhdGVNYXBDdXJ2ZU9wdGlvbnMsXG4gICAgZ2VuZXJhdGVNYXBDb2xvclRleHRPcHRpb25zOiBnZW5lcmF0ZU1hcENvbG9yVGV4dE9wdGlvbnMsXG4gICAgZ2VuZXJhdGVDb250b3VyQ3VydmVPcHRpb25zOiBnZW5lcmF0ZUNvbnRvdXJDdXJ2ZU9wdGlvbnNcblxufSIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgQ29sb3JhZG8gU3RhdGUgVW5pdmVyc2l0eSBhbmQgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5pbXBvcnQge21hdHNDb2xsZWN0aW9uc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNUeXBlc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21vbWVudH0gZnJvbSAnbWV0ZW9yL21vbWVudGpzOm1vbWVudCdcblxuLy8gc2V0cyBwbG90IG9wdGlvbnMgZm9yIHRpbWVzZXJpZXMgZ3JhcGhzXG5jb25zdCBnZW5lcmF0ZVNlcmllc1Bsb3RPcHRpb25zID0gZnVuY3Rpb24gKGRhdGFzZXQsIGN1cnZlcywgYXhpc01hcCwgZXJyb3JNYXgpIHtcbiAgICB2YXIgeG1pbiA9IGF4aXNNYXBbT2JqZWN0LmtleXMoYXhpc01hcClbMF1dLnhtaW47XG4gICAgdmFyIHhtYXggPSBheGlzTWFwW09iamVjdC5rZXlzKGF4aXNNYXApWzBdXS54bWF4O1xuXG4gICAgdmFyIGxheW91dCA9IHtcbiAgICAgICAgbWFyZ2luOiB7XG4gICAgICAgICAgICBsOiA4MCxcbiAgICAgICAgICAgIHI6IDgwLFxuICAgICAgICAgICAgYjogODAsXG4gICAgICAgICAgICB0OiAyMCxcbiAgICAgICAgICAgIHBhZDogNFxuICAgICAgICB9LFxuICAgICAgICB6ZXJvbGluZTogZmFsc2UsXG4gICAgICAgIGhvdmVybW9kZTogJ2Nsb3Nlc3QnLFxuICAgICAgICBob3ZlcmxhYmVsOiB7J2ZvbnQnOiB7J3NpemUnOiAxNCwgJ2ZhbWlseSc6ICdBcmlhbCcsICdjb2xvcic6ICcjRkZGRkZGJ319LFxuICAgICAgICBzaG93bGVnZW5kOiBmYWxzZVxuICAgIH07XG5cbiAgICBsYXlvdXRbJ3hheGlzJ10gPSB7XG4gICAgICAgIHRpdGxlOiAnVGltZScsXG4gICAgICAgIHRpdGxlZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDIyfSxcbiAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxMn1cbiAgICB9O1xuXG4gICAgY29uc3QgYXhpc0FuY2hvciA9IHswOiAneCcsIDE6ICd4JywgMjogJ2ZyZWUnLCAzOiAnZnJlZScsIDQ6ICdmcmVlJywgNTogJ2ZyZWUnLCA2OiAnZnJlZScsIDc6ICdmcmVlJ307XG4gICAgY29uc3QgYXhpc1NpZGUgPSB7MDogJ2xlZnQnLCAxOiAncmlnaHQnLCAyOiAnbGVmdCcsIDM6ICdyaWdodCcsIDQ6ICdsZWZ0JywgNTogJ3JpZ2h0JywgNjogJ2xlZnQnLCA3OiAncmlnaHQnfTtcbiAgICBjb25zdCBheGlzUG9zaXRpb24gPSB7MDogMCwgMTogMSwgMjogMC4xLCAzOiAwLjksIDQ6IDAuMiwgNTogMC44LCA2OiAwLjMsIDc6IDAuN307XG5cbiAgICBjb25zdCB5QXhpc051bWJlciA9IE9iamVjdC5rZXlzKGF4aXNNYXApLmxlbmd0aDtcbiAgICB2YXIgYXhpc0tleTtcbiAgICB2YXIgYXhpc0lkeDtcbiAgICB2YXIgYXhpc0xhYmVsO1xuICAgIGZvciAoYXhpc0lkeCA9IDA7IGF4aXNJZHggPCB5QXhpc051bWJlcjsgYXhpc0lkeCsrKSB7XG4gICAgICAgIGF4aXNLZXkgPSBPYmplY3Qua2V5cyhheGlzTWFwKVtheGlzSWR4XTtcbiAgICAgICAgdmFyIHltaW4gPSBheGlzTWFwW2F4aXNLZXldLnltaW47XG4gICAgICAgIHZhciB5bWF4ID0gYXhpc01hcFtheGlzS2V5XS55bWF4O1xuICAgICAgICB5bWF4ID0geW1heCArIGVycm9yTWF4O1xuICAgICAgICB5bWluID0geW1pbiAtIGVycm9yTWF4O1xuICAgICAgICBjb25zdCB5UGFkID0gKCh5bWF4IC0geW1pbikgKiAwLjA1KSAhPT0gMCA/ICh5bWF4IC0geW1pbikgKiAwLjA1IDogMC4wNTtcbiAgICAgICAgeG1pbiA9IGF4aXNNYXBbYXhpc0tleV0ueG1pbiA8IHhtaW4gPyBheGlzTWFwW2F4aXNLZXldLnhtaW4gOiB4bWluO1xuICAgICAgICB4bWF4ID0gYXhpc01hcFtheGlzS2V5XS54bWF4ID4geG1heCA/IGF4aXNNYXBbYXhpc0tleV0ueG1heCA6IHhtYXg7XG4gICAgICAgIGF4aXNMYWJlbCA9IGF4aXNNYXBbYXhpc0tleV0uYXhpc0xhYmVsO1xuICAgICAgICB2YXIgYXhpc09iamVjdEtleTtcbiAgICAgICAgaWYgKGF4aXNJZHggPT09IDApIHtcbiAgICAgICAgICAgIGF4aXNPYmplY3RLZXkgPSAneWF4aXMnO1xuICAgICAgICAgICAgbGF5b3V0W2F4aXNPYmplY3RLZXldID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBheGlzTGFiZWwsXG4gICAgICAgICAgICAgICAgdGl0bGVmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMjJ9LFxuICAgICAgICAgICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTR9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbeW1pbiAtIHlQYWQsIHltYXggKyB5UGFkXSxcbiAgICAgICAgICAgICAgICB6ZXJvbGluZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0lkeCA8IE9iamVjdC5rZXlzKGF4aXNQb3NpdGlvbikubGVuZ3RoKSB7XG4gICAgICAgICAgICBheGlzT2JqZWN0S2V5ID0gJ3lheGlzJyArIChheGlzSWR4ICsgMSk7XG4gICAgICAgICAgICBsYXlvdXRbYXhpc09iamVjdEtleV0gPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGF4aXNMYWJlbCxcbiAgICAgICAgICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgICAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxNH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt5bWluIC0geVBhZCwgeW1heCArIHlQYWRdLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogYXhpc0FuY2hvcltheGlzSWR4XSxcbiAgICAgICAgICAgICAgICBvdmVybGF5aW5nOiAneScsXG4gICAgICAgICAgICAgICAgc2lkZTogYXhpc1NpZGVbYXhpc0lkeF0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGF4aXNQb3NpdGlvbltheGlzSWR4XSxcbiAgICAgICAgICAgICAgICB6ZXJvbGluZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBheGlzT2JqZWN0S2V5ID0gJ3lheGlzJyArIChheGlzSWR4ICsgMSk7XG4gICAgICAgICAgICBsYXlvdXRbYXhpc09iamVjdEtleV0gPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGF4aXNMYWJlbCxcbiAgICAgICAgICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgICAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxNH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt5bWluIC0geVBhZCwgeW1heCArIHlQYWRdLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogYXhpc0FuY2hvcltPYmplY3Qua2V5cyhheGlzUG9zaXRpb24pLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlpbmc6ICd5JyxcbiAgICAgICAgICAgICAgICBzaWRlOiBheGlzU2lkZVtPYmplY3Qua2V5cyhheGlzUG9zaXRpb24pLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBheGlzUG9zaXRpb25bT2JqZWN0LmtleXMoYXhpc1Bvc2l0aW9uKS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICB6ZXJvbGluZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeFBhZCA9ICgoeG1heCAtIHhtaW4pICogMC4wNzUpICE9PSAwID8gKHhtYXggLSB4bWluKSAqIDAuMDc1IDogMC4wNzU7XG4gICAgeG1heCA9IG1vbWVudC51dGMoeG1heCArIHhQYWQgKiBNYXRoLmNlaWwoeUF4aXNOdW1iZXIgLyAyKSkuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbVwiKTtcbiAgICB4bWluID0gbW9tZW50LnV0Yyh4bWluIC0geFBhZCAqIE1hdGguY2VpbCh5QXhpc051bWJlciAvIDIpKS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tXCIpO1xuICAgIGxheW91dFsneGF4aXMnXVsncmFuZ2UnXSA9IFt4bWluLCB4bWF4XTtcbiAgICByZXR1cm4gbGF5b3V0O1xufTtcblxuLy8gc2V0cyBwbG90IG9wdGlvbnMgZm9yIHByb2ZpbGUgZ3JhcGhzXG5jb25zdCBnZW5lcmF0ZVByb2ZpbGVQbG90T3B0aW9ucyA9IGZ1bmN0aW9uIChkYXRhc2V0LCBjdXJ2ZXMsIGF4aXNNYXAsIGVycm9yTWF4KSB7XG4gICAgdmFyIHltaW4gPSAxMDtcbiAgICB2YXIgeW1heCA9IDEwNzU7XG4gICAgY29uc3QgeEF4aXNOdW1iZXIgPSBPYmplY3Qua2V5cyhheGlzTWFwKS5sZW5ndGg7XG5cbiAgICB2YXIgbGF5b3V0ID0ge1xuICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICAgIGw6IDgwLFxuICAgICAgICAgICAgcjogODAsXG4gICAgICAgICAgICBiOiA4MCxcbiAgICAgICAgICAgIHQ6IHhBeGlzTnVtYmVyID4gMSA/IDgwIDogMjAsXG4gICAgICAgICAgICBwYWQ6IDRcbiAgICAgICAgfSxcbiAgICAgICAgemVyb2xpbmU6IGZhbHNlLFxuICAgICAgICBob3Zlcm1vZGU6ICdjbG9zZXN0JyxcbiAgICAgICAgaG92ZXJsYWJlbDogeydmb250JzogeydzaXplJzogMTQsICdmYW1pbHknOiAnQXJpYWwnLCAnY29sb3InOiAnI0ZGRkZGRid9fSxcbiAgICAgICAgc2hvd2xlZ2VuZDogZmFsc2VcbiAgICB9O1xuICAgIHZhciB0aWNrVmFscztcbiAgICB2YXIgdGlja1RleHQ7XG4gICAgaWYgKG1hdHNDb2xsZWN0aW9ucy5TZXR0aW5ncy5maW5kT25lKHt9KS5hcHBUeXBlID09PSBtYXRzVHlwZXMuQXBwVHlwZXMubWV0ZXhwcmVzcykge1xuICAgICAgICB0aWNrVmFscyA9IFsxMDAwLCA4NTAsIDcwMCwgNjAwLCA1MDAsIDQwMCwgMzAwLCAyNTAsIDIwMCwgMTUwLCAxMDAsIDUwLCAxMF07XG4gICAgICAgIHRpY2tUZXh0ID0gWycxMDAwJywgJzg1MCcsICc3MDAnLCAnNjAwJywgJzUwMCcsICc0MDAnLCAnMzAwJywgJzI1MCcsICcyMDAnLCAnMTUwJywgJzEwMCcsICc1MCcsICcxMCddO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tWYWxzID0gWzEwMDAsIDkwMCwgODAwLCA3MDAsIDYwMCwgNTAwLCA0MDAsIDMwMCwgMjAwLCAxMDBdO1xuICAgICAgICB0aWNrVGV4dCA9IFsnMTAwMCcsICc5MDAnLCAnODAwJywgJzcwMCcsICc2MDAnLCAnNTAwJywgJzQwMCcsICczMDAnLCAnMjAwJywgJzEwMCddO1xuICAgIH1cbiAgICBsYXlvdXRbJ3lheGlzJ10gPSB7XG4gICAgICAgIHRpdGxlOiAnUHJlc3N1cmUgTGV2ZWwnLFxuICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTR9LFxuICAgICAgICB0aWNrdmFsczogdGlja1ZhbHMsXG4gICAgICAgIHRpY2t0ZXh0OiB0aWNrVGV4dCxcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgIGF1dG9yYW5nZTogJ3JldmVyc2VkJ1xuICAgIH07XG5cbiAgICBjb25zdCBheGlzQW5jaG9yID0gezA6ICd4JywgMTogJ3gnLCAyOiAnZnJlZScsIDM6ICdmcmVlJywgNDogJ2ZyZWUnLCA1OiAnZnJlZScsIDY6ICdmcmVlJywgNzogJ2ZyZWUnfTtcbiAgICBjb25zdCBheGlzU2lkZSA9IHswOiAnYm90dG9tJywgMTogJ3RvcCcsIDI6ICdib3R0b20nLCAzOiAndG9wJywgNDogJ2JvdHRvbScsIDU6ICd0b3AnLCA2OiAnYm90dG9tJywgNzogJ3RvcCd9O1xuICAgIGNvbnN0IGF4aXNQb3NpdGlvbiA9IHswOiAwLCAxOiAxLCAyOiAwLjE1LCAzOiAwLjg1LCA0OiAwLjMsIDU6IDAuNywgNjogMC40NSwgNzogMC41NX07XG5cbiAgICB2YXIgYXhpc0tleTtcbiAgICB2YXIgYXhpc0lkeDtcbiAgICB2YXIgYXhpc0xhYmVsO1xuICAgIGZvciAoYXhpc0lkeCA9IDA7IGF4aXNJZHggPCB4QXhpc051bWJlcjsgYXhpc0lkeCsrKSB7XG4gICAgICAgIGF4aXNLZXkgPSBPYmplY3Qua2V5cyhheGlzTWFwKVtheGlzSWR4XTtcbiAgICAgICAgdmFyIHhtaW4gPSBheGlzTWFwW2F4aXNLZXldLnhtaW47XG4gICAgICAgIHZhciB4bWF4ID0gYXhpc01hcFtheGlzS2V5XS54bWF4O1xuICAgICAgICB4bWF4ID0geG1heCArIGVycm9yTWF4O1xuICAgICAgICB4bWluID0geG1pbiAtIGVycm9yTWF4O1xuICAgICAgICBheGlzTGFiZWwgPSBheGlzTWFwW2F4aXNLZXldLmF4aXNMYWJlbDtcbiAgICAgICAgY29uc3QgeFBhZCA9ICgoeG1heCAtIHhtaW4pICogMC4wNSkgIT09IDAgPyAoeG1heCAtIHhtaW4pICogMC4wNSA6IDAuMDU7XG4gICAgICAgIGF4aXNMYWJlbCA9IGF4aXNNYXBbYXhpc0tleV0uYXhpc0xhYmVsO1xuICAgICAgICB2YXIgYXhpc09iamVjdEtleTtcbiAgICAgICAgaWYgKGF4aXNJZHggPT09IDApIHtcbiAgICAgICAgICAgIGF4aXNPYmplY3RLZXkgPSAneGF4aXMnO1xuICAgICAgICAgICAgbGF5b3V0W2F4aXNPYmplY3RLZXldID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBheGlzTGFiZWwsXG4gICAgICAgICAgICAgICAgdGl0bGVmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMjJ9LFxuICAgICAgICAgICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTR9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbeG1pbiAtIHhQYWQsIHhtYXggKyB4UGFkXSxcbiAgICAgICAgICAgICAgICB6ZXJvbGluZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0lkeCA8IE9iamVjdC5rZXlzKGF4aXNQb3NpdGlvbikubGVuZ3RoKSB7XG4gICAgICAgICAgICBheGlzT2JqZWN0S2V5ID0gJ3hheGlzJyArIChheGlzSWR4ICsgMSk7XG4gICAgICAgICAgICBsYXlvdXRbYXhpc09iamVjdEtleV0gPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGF4aXNMYWJlbCxcbiAgICAgICAgICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgICAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxNH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt4bWluIC0geFBhZCwgeG1heCArIHhQYWRdLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogYXhpc0FuY2hvcltheGlzSWR4XSxcbiAgICAgICAgICAgICAgICBvdmVybGF5aW5nOiAneCcsXG4gICAgICAgICAgICAgICAgc2lkZTogYXhpc1NpZGVbYXhpc0lkeF0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGF4aXNQb3NpdGlvbltheGlzSWR4XSxcbiAgICAgICAgICAgICAgICB6ZXJvbGluZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBheGlzT2JqZWN0S2V5ID0gJ3hheGlzJyArIChheGlzSWR4ICsgMSk7XG4gICAgICAgICAgICBsYXlvdXRbYXhpc09iamVjdEtleV0gPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGF4aXNMYWJlbCxcbiAgICAgICAgICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgICAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxNH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt4bWluIC0geFBhZCwgeG1heCArIHhQYWRdLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogYXhpc0FuY2hvcltPYmplY3Qua2V5cyhheGlzUG9zaXRpb24pLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlpbmc6ICd4JyxcbiAgICAgICAgICAgICAgICBzaWRlOiBheGlzU2lkZVtPYmplY3Qua2V5cyhheGlzUG9zaXRpb24pLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBheGlzUG9zaXRpb25bT2JqZWN0LmtleXMoYXhpc1Bvc2l0aW9uKS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICB6ZXJvbGluZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeVBhZCA9ICgoeW1heCAtIHltaW4pICogMC4yNSkgIT09IDAgPyAoeW1heCAtIHltaW4pICogMC4yNSA6IDAuMjU7XG4gICAgeW1heCA9IHltYXggKyAoeVBhZCAqIE1hdGguY2VpbCh4QXhpc051bWJlciAvIDIpKTtcbiAgICB5bWluID0geW1pbiAtICh5UGFkICogTWF0aC5jZWlsKHhBeGlzTnVtYmVyIC8gMikpO1xuICAgIGxheW91dFsneWF4aXMnXVsncmFuZ2UnXSA9IFt5bWluLCB5bWF4XTtcbiAgICByZXR1cm4gbGF5b3V0O1xufTtcblxuLy8gc2V0cyBwbG90IG9wdGlvbnMgZm9yIGRpZW9mZiBncmFwaHNcbmNvbnN0IGdlbmVyYXRlRGllb2ZmUGxvdE9wdGlvbnMgPSBmdW5jdGlvbiAoZGF0YXNldCwgY3VydmVzLCBheGlzTWFwLCBlcnJvck1heCkge1xuICAgIHZhciB4bWluID0gYXhpc01hcFtPYmplY3Qua2V5cyhheGlzTWFwKVswXV0ueG1pbjtcbiAgICB2YXIgeG1heCA9IGF4aXNNYXBbT2JqZWN0LmtleXMoYXhpc01hcClbMF1dLnhtYXg7XG5cbiAgICB2YXIgbGF5b3V0ID0ge1xuICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICAgIGw6IDgwLFxuICAgICAgICAgICAgcjogODAsXG4gICAgICAgICAgICBiOiA4MCxcbiAgICAgICAgICAgIHQ6IDIwLFxuICAgICAgICAgICAgcGFkOiA0XG4gICAgICAgIH0sXG4gICAgICAgIHplcm9saW5lOiBmYWxzZSxcbiAgICAgICAgaG92ZXJtb2RlOiAnY2xvc2VzdCcsXG4gICAgICAgIGhvdmVybGFiZWw6IHsnZm9udCc6IHsnc2l6ZSc6IDE0LCAnZmFtaWx5JzogJ0FyaWFsJywgJ2NvbG9yJzogJyNGRkZGRkYnfX0sXG4gICAgICAgIHNob3dsZWdlbmQ6IGZhbHNlXG4gICAgfTtcblxuICAgIGxheW91dFsneGF4aXMnXSA9IHtcbiAgICAgICAgdGl0bGU6ICdGb3JlY2FzdCBIb3VyJyxcbiAgICAgICAgdGl0bGVmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMjJ9LFxuICAgICAgICB0aWNrZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDE0fSxcbiAgICB9O1xuXG4gICAgY29uc3QgYXhpc0FuY2hvciA9IHswOiAneCcsIDE6ICd4JywgMjogJ2ZyZWUnLCAzOiAnZnJlZScsIDQ6ICdmcmVlJywgNTogJ2ZyZWUnLCA2OiAnZnJlZScsIDc6ICdmcmVlJ307XG4gICAgY29uc3QgYXhpc1NpZGUgPSB7MDogJ2xlZnQnLCAxOiAncmlnaHQnLCAyOiAnbGVmdCcsIDM6ICdyaWdodCcsIDQ6ICdsZWZ0JywgNTogJ3JpZ2h0JywgNjogJ2xlZnQnLCA3OiAncmlnaHQnfTtcbiAgICBjb25zdCBheGlzUG9zaXRpb24gPSB7MDogMCwgMTogMSwgMjogMC4xLCAzOiAwLjksIDQ6IDAuMiwgNTogMC44LCA2OiAwLjMsIDc6IDAuN307XG5cbiAgICBjb25zdCB5QXhpc051bWJlciA9IE9iamVjdC5rZXlzKGF4aXNNYXApLmxlbmd0aDtcbiAgICB2YXIgYXhpc0tleTtcbiAgICB2YXIgYXhpc0lkeDtcbiAgICB2YXIgYXhpc0xhYmVsO1xuICAgIGZvciAoYXhpc0lkeCA9IDA7IGF4aXNJZHggPCB5QXhpc051bWJlcjsgYXhpc0lkeCsrKSB7XG4gICAgICAgIGF4aXNLZXkgPSBPYmplY3Qua2V5cyhheGlzTWFwKVtheGlzSWR4XTtcbiAgICAgICAgdmFyIHltaW4gPSBheGlzTWFwW2F4aXNLZXldLnltaW47XG4gICAgICAgIHZhciB5bWF4ID0gYXhpc01hcFtheGlzS2V5XS55bWF4O1xuICAgICAgICB5bWF4ID0geW1heCArIGVycm9yTWF4O1xuICAgICAgICB5bWluID0geW1pbiAtIGVycm9yTWF4O1xuICAgICAgICBjb25zdCB5UGFkID0gKCh5bWF4IC0geW1pbikgKiAwLjA1KSAhPT0gMCA/ICh5bWF4IC0geW1pbikgKiAwLjA1IDogMC4wNTtcbiAgICAgICAgeG1pbiA9IGF4aXNNYXBbYXhpc0tleV0ueG1pbiA8IHhtaW4gPyBheGlzTWFwW2F4aXNLZXldLnhtaW4gOiB4bWluO1xuICAgICAgICB4bWF4ID0gYXhpc01hcFtheGlzS2V5XS54bWF4ID4geG1heCA/IGF4aXNNYXBbYXhpc0tleV0ueG1heCA6IHhtYXg7XG4gICAgICAgIGF4aXNMYWJlbCA9IGF4aXNNYXBbYXhpc0tleV0uYXhpc0xhYmVsO1xuICAgICAgICB2YXIgYXhpc09iamVjdEtleTtcbiAgICAgICAgaWYgKGF4aXNJZHggPT09IDApIHtcbiAgICAgICAgICAgIGF4aXNPYmplY3RLZXkgPSAneWF4aXMnO1xuICAgICAgICAgICAgbGF5b3V0W2F4aXNPYmplY3RLZXldID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBheGlzTGFiZWwsXG4gICAgICAgICAgICAgICAgdGl0bGVmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMjJ9LFxuICAgICAgICAgICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTR9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbeW1pbiAtIHlQYWQsIHltYXggKyB5UGFkXSxcbiAgICAgICAgICAgICAgICB6ZXJvbGluZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0lkeCA8IE9iamVjdC5rZXlzKGF4aXNQb3NpdGlvbikubGVuZ3RoKSB7XG4gICAgICAgICAgICBheGlzT2JqZWN0S2V5ID0gJ3lheGlzJyArIChheGlzSWR4ICsgMSk7XG4gICAgICAgICAgICBsYXlvdXRbYXhpc09iamVjdEtleV0gPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGF4aXNMYWJlbCxcbiAgICAgICAgICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgICAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxNH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt5bWluIC0geVBhZCwgeW1heCArIHlQYWRdLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogYXhpc0FuY2hvcltheGlzSWR4XSxcbiAgICAgICAgICAgICAgICBvdmVybGF5aW5nOiAneScsXG4gICAgICAgICAgICAgICAgc2lkZTogYXhpc1NpZGVbYXhpc0lkeF0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGF4aXNQb3NpdGlvbltheGlzSWR4XSxcbiAgICAgICAgICAgICAgICB6ZXJvbGluZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBheGlzT2JqZWN0S2V5ID0gJ3lheGlzJyArIChheGlzSWR4ICsgMSk7XG4gICAgICAgICAgICBsYXlvdXRbYXhpc09iamVjdEtleV0gPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGF4aXNMYWJlbCxcbiAgICAgICAgICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgICAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxNH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt5bWluIC0geVBhZCwgeW1heCArIHlQYWRdLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogYXhpc0FuY2hvcltPYmplY3Qua2V5cyhheGlzUG9zaXRpb24pLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlpbmc6ICd5JyxcbiAgICAgICAgICAgICAgICBzaWRlOiBheGlzU2lkZVtPYmplY3Qua2V5cyhheGlzUG9zaXRpb24pLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBheGlzUG9zaXRpb25bT2JqZWN0LmtleXMoYXhpc1Bvc2l0aW9uKS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICB6ZXJvbGluZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeFBhZCA9ICgoeG1heCAtIHhtaW4pICogMC4wNzUpICE9PSAwID8gKHhtYXggLSB4bWluKSAqIDAuMDc1IDogMC4wNzU7XG4gICAgeG1heCA9IHhtYXggKyAoeFBhZCAqIE1hdGguY2VpbCh5QXhpc051bWJlciAvIDIpKTtcbiAgICB4bWluID0geG1pbiAtICh4UGFkICogTWF0aC5jZWlsKHlBeGlzTnVtYmVyIC8gMikpO1xuICAgIGxheW91dFsneGF4aXMnXVsncmFuZ2UnXSA9IFt4bWluLCB4bWF4XTtcbiAgICByZXR1cm4gbGF5b3V0O1xufTtcblxuLy8gc2V0cyBwbG90IG9wdGlvbnMgZm9yIHRocmVzaG9sZCBncmFwaHNcbmNvbnN0IGdlbmVyYXRlVGhyZXNob2xkUGxvdE9wdGlvbnMgPSBmdW5jdGlvbiAoZGF0YXNldCwgY3VydmVzLCBheGlzTWFwLCBlcnJvck1heCkge1xuICAgIHZhciB4bWluID0gMDtcbiAgICB2YXIgeG1heCA9IDM7XG5cbiAgICB2YXIgbGF5b3V0ID0ge1xuICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICAgIGw6IDgwLFxuICAgICAgICAgICAgcjogODAsXG4gICAgICAgICAgICBiOiA4MCxcbiAgICAgICAgICAgIHQ6IDIwLFxuICAgICAgICAgICAgcGFkOiA0XG4gICAgICAgIH0sXG4gICAgICAgIHplcm9saW5lOiBmYWxzZSxcbiAgICAgICAgaG92ZXJtb2RlOiAnY2xvc2VzdCcsXG4gICAgICAgIGhvdmVybGFiZWw6IHsnZm9udCc6IHsnc2l6ZSc6IDE0LCAnZmFtaWx5JzogJ0FyaWFsJywgJ2NvbG9yJzogJyNGRkZGRkYnfX0sXG4gICAgICAgIHNob3dsZWdlbmQ6IGZhbHNlXG4gICAgfTtcblxuICAgIGxheW91dFsneGF4aXMnXSA9IHtcbiAgICAgICAgdGl0bGU6ICdUaHJlc2hvbGQnLFxuICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTR9LFxuICAgICAgICB0aWNrdmFsczogWzAuMDEsIDAuMSwgMC4yNSwgMC41LCAxLjAsIDEuNSwgMi4wLCAzLjBdLFxuICAgICAgICB0aWNrdGV4dDogW1wiMC4wMVwiLCBcIjAuMTBcIiwgXCIwLjI1XCIsIFwiMC41MFwiLCBcIjEuMDBcIiwgXCIxLjUwXCIsIFwiMi4wMFwiLCBcIjMuMDBcIl1cbiAgICB9O1xuXG4gICAgY29uc3QgYXhpc0FuY2hvciA9IHswOiAneCcsIDE6ICd4JywgMjogJ2ZyZWUnLCAzOiAnZnJlZScsIDQ6ICdmcmVlJywgNTogJ2ZyZWUnLCA2OiAnZnJlZScsIDc6ICdmcmVlJ307XG4gICAgY29uc3QgYXhpc1NpZGUgPSB7MDogJ2xlZnQnLCAxOiAncmlnaHQnLCAyOiAnbGVmdCcsIDM6ICdyaWdodCcsIDQ6ICdsZWZ0JywgNTogJ3JpZ2h0JywgNjogJ2xlZnQnLCA3OiAncmlnaHQnfTtcbiAgICBjb25zdCBheGlzUG9zaXRpb24gPSB7MDogMCwgMTogMSwgMjogMC4xLCAzOiAwLjksIDQ6IDAuMiwgNTogMC44LCA2OiAwLjMsIDc6IDAuN307XG5cbiAgICBjb25zdCB5QXhpc051bWJlciA9IE9iamVjdC5rZXlzKGF4aXNNYXApLmxlbmd0aDtcbiAgICB2YXIgYXhpc0tleTtcbiAgICB2YXIgYXhpc0lkeDtcbiAgICB2YXIgYXhpc0xhYmVsO1xuICAgIGZvciAoYXhpc0lkeCA9IDA7IGF4aXNJZHggPCB5QXhpc051bWJlcjsgYXhpc0lkeCsrKSB7XG4gICAgICAgIGF4aXNLZXkgPSBPYmplY3Qua2V5cyhheGlzTWFwKVtheGlzSWR4XTtcbiAgICAgICAgdmFyIHltaW4gPSBheGlzTWFwW2F4aXNLZXldLnltaW47XG4gICAgICAgIHZhciB5bWF4ID0gYXhpc01hcFtheGlzS2V5XS55bWF4O1xuICAgICAgICB5bWF4ID0geW1heCArIGVycm9yTWF4O1xuICAgICAgICB5bWluID0geW1pbiAtIGVycm9yTWF4O1xuICAgICAgICBjb25zdCB5UGFkID0gKCh5bWF4IC0geW1pbikgKiAwLjA1KSAhPT0gMCA/ICh5bWF4IC0geW1pbikgKiAwLjA1IDogMC4wNTtcbiAgICAgICAgYXhpc0xhYmVsID0gYXhpc01hcFtheGlzS2V5XS5heGlzTGFiZWw7XG4gICAgICAgIHZhciBheGlzT2JqZWN0S2V5O1xuICAgICAgICBpZiAoYXhpc0lkeCA9PT0gMCkge1xuICAgICAgICAgICAgYXhpc09iamVjdEtleSA9ICd5YXhpcyc7XG4gICAgICAgICAgICBsYXlvdXRbYXhpc09iamVjdEtleV0gPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGF4aXNMYWJlbCxcbiAgICAgICAgICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgICAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxNH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt5bWluIC0geVBhZCwgeW1heCArIHlQYWRdLFxuICAgICAgICAgICAgICAgIHplcm9saW5lOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzSWR4IDwgT2JqZWN0LmtleXMoYXhpc1Bvc2l0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF4aXNPYmplY3RLZXkgPSAneWF4aXMnICsgKGF4aXNJZHggKyAxKTtcbiAgICAgICAgICAgIGxheW91dFtheGlzT2JqZWN0S2V5XSA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogYXhpc0xhYmVsLFxuICAgICAgICAgICAgICAgIHRpdGxlZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDIyfSxcbiAgICAgICAgICAgICAgICB0aWNrZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDE0fSxcbiAgICAgICAgICAgICAgICByYW5nZTogW3ltaW4gLSB5UGFkLCB5bWF4ICsgeVBhZF0sXG4gICAgICAgICAgICAgICAgYW5jaG9yOiBheGlzQW5jaG9yW2F4aXNJZHhdLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlpbmc6ICd5JyxcbiAgICAgICAgICAgICAgICBzaWRlOiBheGlzU2lkZVtheGlzSWR4XSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYXhpc1Bvc2l0aW9uW2F4aXNJZHhdLFxuICAgICAgICAgICAgICAgIHplcm9saW5lOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF4aXNPYmplY3RLZXkgPSAneWF4aXMnICsgKGF4aXNJZHggKyAxKTtcbiAgICAgICAgICAgIGxheW91dFtheGlzT2JqZWN0S2V5XSA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogYXhpc0xhYmVsLFxuICAgICAgICAgICAgICAgIHRpdGxlZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDIyfSxcbiAgICAgICAgICAgICAgICB0aWNrZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDE0fSxcbiAgICAgICAgICAgICAgICByYW5nZTogW3ltaW4gLSB5UGFkLCB5bWF4ICsgeVBhZF0sXG4gICAgICAgICAgICAgICAgYW5jaG9yOiBheGlzQW5jaG9yW09iamVjdC5rZXlzKGF4aXNQb3NpdGlvbikubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgb3ZlcmxheWluZzogJ3knLFxuICAgICAgICAgICAgICAgIHNpZGU6IGF4aXNTaWRlW09iamVjdC5rZXlzKGF4aXNQb3NpdGlvbikubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGF4aXNQb3NpdGlvbltPYmplY3Qua2V5cyhheGlzUG9zaXRpb24pLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHplcm9saW5lOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4UGFkID0gKCh4bWF4IC0geG1pbikgKiAwLjA3NSkgIT09IDAgPyAoeG1heCAtIHhtaW4pICogMC4wNzUgOiAwLjA3NTtcbiAgICB4bWF4ID0geG1heCArICh4UGFkICogTWF0aC5jZWlsKHlBeGlzTnVtYmVyIC8gMikpO1xuICAgIHhtaW4gPSB4bWluIC0gKHhQYWQgKiBNYXRoLmNlaWwoeUF4aXNOdW1iZXIgLyAyKSk7XG4gICAgbGF5b3V0Wyd4YXhpcyddWydyYW5nZSddID0gW3htaW4sIHhtYXhdO1xuICAgIHJldHVybiBsYXlvdXQ7XG59O1xuXG4vLyBzZXRzIHBsb3Qgb3B0aW9ucyBmb3IgdmFsaWQgdGltZSBncmFwaHNcbmNvbnN0IGdlbmVyYXRlVmFsaWRUaW1lUGxvdE9wdGlvbnMgPSBmdW5jdGlvbiAoZGF0YXNldCwgY3VydmVzLCBheGlzTWFwLCBlcnJvck1heCkge1xuICAgIHZhciB4bWluID0gMDtcbiAgICB2YXIgeG1heCA9IDIzO1xuXG4gICAgdmFyIGxheW91dCA9IHtcbiAgICAgICAgbWFyZ2luOiB7XG4gICAgICAgICAgICBsOiA4MCxcbiAgICAgICAgICAgIHI6IDgwLFxuICAgICAgICAgICAgYjogODAsXG4gICAgICAgICAgICB0OiAyMCxcbiAgICAgICAgICAgIHBhZDogNFxuICAgICAgICB9LFxuICAgICAgICB6ZXJvbGluZTogZmFsc2UsXG4gICAgICAgIGhvdmVybW9kZTogJ2Nsb3Nlc3QnLFxuICAgICAgICBob3ZlcmxhYmVsOiB7J2ZvbnQnOiB7J3NpemUnOiAxNCwgJ2ZhbWlseSc6ICdBcmlhbCcsICdjb2xvcic6ICcjRkZGRkZGJ319LFxuICAgICAgICBzaG93bGVnZW5kOiBmYWxzZVxuICAgIH07XG5cbiAgICBsYXlvdXRbJ3hheGlzJ10gPSB7XG4gICAgICAgIHRpdGxlOiAnSG91ciBvZiBEYXknLFxuICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTR9LFxuICAgICAgICB0aWNrdmFsczogWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyM10sXG4gICAgICAgIHRpY2t0ZXh0OiBbXCIwXCIsIFwiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCIsIFwiMTNcIiwgXCIxNFwiLCBcIjE1XCIsIFwiMTZcIiwgXCIxN1wiLCBcIjE4XCIsIFwiMTlcIiwgXCIyMFwiLCBcIjIxXCIsIFwiMjJcIiwgXCIyM1wiXVxuICAgIH07XG5cbiAgICBjb25zdCBheGlzQW5jaG9yID0gezA6ICd4JywgMTogJ3gnLCAyOiAnZnJlZScsIDM6ICdmcmVlJywgNDogJ2ZyZWUnLCA1OiAnZnJlZScsIDY6ICdmcmVlJywgNzogJ2ZyZWUnfTtcbiAgICBjb25zdCBheGlzU2lkZSA9IHswOiAnbGVmdCcsIDE6ICdyaWdodCcsIDI6ICdsZWZ0JywgMzogJ3JpZ2h0JywgNDogJ2xlZnQnLCA1OiAncmlnaHQnLCA2OiAnbGVmdCcsIDc6ICdyaWdodCd9O1xuICAgIGNvbnN0IGF4aXNQb3NpdGlvbiA9IHswOiAwLCAxOiAxLCAyOiAwLjEsIDM6IDAuOSwgNDogMC4yLCA1OiAwLjgsIDY6IDAuMywgNzogMC43fTtcblxuICAgIGNvbnN0IHlBeGlzTnVtYmVyID0gT2JqZWN0LmtleXMoYXhpc01hcCkubGVuZ3RoO1xuICAgIHZhciBheGlzS2V5O1xuICAgIHZhciBheGlzSWR4O1xuICAgIHZhciBheGlzTGFiZWw7XG4gICAgZm9yIChheGlzSWR4ID0gMDsgYXhpc0lkeCA8IHlBeGlzTnVtYmVyOyBheGlzSWR4KyspIHtcbiAgICAgICAgYXhpc0tleSA9IE9iamVjdC5rZXlzKGF4aXNNYXApW2F4aXNJZHhdO1xuICAgICAgICB2YXIgeW1pbiA9IGF4aXNNYXBbYXhpc0tleV0ueW1pbjtcbiAgICAgICAgdmFyIHltYXggPSBheGlzTWFwW2F4aXNLZXldLnltYXg7XG4gICAgICAgIHltYXggPSB5bWF4ICsgZXJyb3JNYXg7XG4gICAgICAgIHltaW4gPSB5bWluIC0gZXJyb3JNYXg7XG4gICAgICAgIGNvbnN0IHlQYWQgPSAoKHltYXggLSB5bWluKSAqIDAuMDUpICE9PSAwID8gKHltYXggLSB5bWluKSAqIDAuMDUgOiAwLjA1O1xuICAgICAgICBheGlzTGFiZWwgPSBheGlzTWFwW2F4aXNLZXldLmF4aXNMYWJlbDtcbiAgICAgICAgdmFyIGF4aXNPYmplY3RLZXk7XG4gICAgICAgIGlmIChheGlzSWR4ID09PSAwKSB7XG4gICAgICAgICAgICBheGlzT2JqZWN0S2V5ID0gJ3lheGlzJztcbiAgICAgICAgICAgIGxheW91dFtheGlzT2JqZWN0S2V5XSA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogYXhpc0xhYmVsLFxuICAgICAgICAgICAgICAgIHRpdGxlZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDIyfSxcbiAgICAgICAgICAgICAgICB0aWNrZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDE0fSxcbiAgICAgICAgICAgICAgICByYW5nZTogW3ltaW4gLSB5UGFkLCB5bWF4ICsgeVBhZF0sXG4gICAgICAgICAgICAgICAgemVyb2xpbmU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXNJZHggPCBPYmplY3Qua2V5cyhheGlzUG9zaXRpb24pLmxlbmd0aCkge1xuICAgICAgICAgICAgYXhpc09iamVjdEtleSA9ICd5YXhpcycgKyAoYXhpc0lkeCArIDEpO1xuICAgICAgICAgICAgbGF5b3V0W2F4aXNPYmplY3RLZXldID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBheGlzTGFiZWwsXG4gICAgICAgICAgICAgICAgdGl0bGVmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMjJ9LFxuICAgICAgICAgICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTR9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbeW1pbiAtIHlQYWQsIHltYXggKyB5UGFkXSxcbiAgICAgICAgICAgICAgICBhbmNob3I6IGF4aXNBbmNob3JbYXhpc0lkeF0sXG4gICAgICAgICAgICAgICAgb3ZlcmxheWluZzogJ3knLFxuICAgICAgICAgICAgICAgIHNpZGU6IGF4aXNTaWRlW2F4aXNJZHhdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBheGlzUG9zaXRpb25bYXhpc0lkeF0sXG4gICAgICAgICAgICAgICAgemVyb2xpbmU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXhpc09iamVjdEtleSA9ICd5YXhpcycgKyAoYXhpc0lkeCArIDEpO1xuICAgICAgICAgICAgbGF5b3V0W2F4aXNPYmplY3RLZXldID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBheGlzTGFiZWwsXG4gICAgICAgICAgICAgICAgdGl0bGVmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMjJ9LFxuICAgICAgICAgICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTR9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbeW1pbiAtIHlQYWQsIHltYXggKyB5UGFkXSxcbiAgICAgICAgICAgICAgICBhbmNob3I6IGF4aXNBbmNob3JbT2JqZWN0LmtleXMoYXhpc1Bvc2l0aW9uKS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBvdmVybGF5aW5nOiAneScsXG4gICAgICAgICAgICAgICAgc2lkZTogYXhpc1NpZGVbT2JqZWN0LmtleXMoYXhpc1Bvc2l0aW9uKS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYXhpc1Bvc2l0aW9uW09iamVjdC5rZXlzKGF4aXNQb3NpdGlvbikubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgemVyb2xpbmU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHhQYWQgPSAoKHhtYXggLSB4bWluKSAqIDAuMDc1KSAhPT0gMCA/ICh4bWF4IC0geG1pbikgKiAwLjA3NSA6IDAuMDc1O1xuICAgIHhtYXggPSB4bWF4ICsgKHhQYWQgKiBNYXRoLmNlaWwoeUF4aXNOdW1iZXIgLyAyKSk7XG4gICAgeG1pbiA9IHhtaW4gLSAoeFBhZCAqIE1hdGguY2VpbCh5QXhpc051bWJlciAvIDIpKTtcbiAgICBsYXlvdXRbJ3hheGlzJ11bJ3JhbmdlJ10gPSBbeG1pbiwgeG1heF07XG4gICAgcmV0dXJuIGxheW91dDtcbn07XG5cbi8vIHNldHMgcGxvdCBvcHRpb25zIGZvciByZWxpYWJpbGl0eSBncmFwaHNcbmNvbnN0IGdlbmVyYXRlUmVsaWFiaWxpdHlQbG90T3B0aW9ucyA9IGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gICAgdmFyIHhtaW4gPSAwO1xuICAgIHZhciB4bWF4ID0gMTtcbiAgICB2YXIgeW1pbiA9IDA7XG4gICAgdmFyIHltYXggPSAxO1xuXG4gICAgdmFyIGxheW91dCA9IHtcbiAgICAgICAgbWFyZ2luOiB7XG4gICAgICAgICAgICBsOiA4MCxcbiAgICAgICAgICAgIHI6IDgwLFxuICAgICAgICAgICAgYjogODAsXG4gICAgICAgICAgICB0OiAyMCxcbiAgICAgICAgICAgIHBhZDogNFxuICAgICAgICB9LFxuICAgICAgICB6ZXJvbGluZTogdHJ1ZSxcbiAgICAgICAgcGVyZmVjdExpbmU6IGZhbHNlLFxuICAgICAgICBob3Zlcm1vZGU6ICdjbG9zZXN0JyxcbiAgICAgICAgaG92ZXJsYWJlbDogeydmb250JzogeydzaXplJzogMTQsICdmYW1pbHknOiAnQXJpYWwnLCAnY29sb3InOiAnI0ZGRkZGRid9fSxcbiAgICAgICAgc2hvd2xlZ2VuZDogZmFsc2VcbiAgICB9O1xuXG4gICAgbGF5b3V0Wyd4YXhpcyddID0ge1xuICAgICAgICB0aXRsZTogJ0ZvcmVjYXN0IFByb2JhYmlsaXR5JyxcbiAgICAgICAgdGl0bGVmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMjJ9LFxuICAgICAgICB0aWNrZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDE0fSxcbiAgICAgICAgdGlja3ZhbHM6IFswLjAsIDAuMSwgMC4yLCAwLjMsIDAuNCwgMC41LCAwLjYsIDAuNywgMC44LCAwLjksIDEuMF0sXG4gICAgICAgIHRpY2t0ZXh0OiBbXCIwLjBcIiwgXCIwLjFcIiwgXCIwLjJcIiwgXCIwLjNcIiwgXCIwLjRcIiwgXCIwLjVcIiwgXCIwLjZcIiwgXCIwLjdcIiwgXCIwLjhcIiwgXCIwLjlcIiwgXCIxLjBcIl0sXG4gICAgICAgIHJhbmdlOiBbeG1pbiwgeG1heF1cbiAgICB9O1xuXG4gICAgbGF5b3V0Wyd5YXhpcyddID0ge1xuICAgICAgICB0aXRsZTogJ09ic2VydmVkIFJlbGF0aXZlIEZyZXF1ZW5jeScsXG4gICAgICAgIHRpdGxlZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDIyfSxcbiAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxNH0sXG4gICAgICAgIHRpY2t2YWxzOiBbMC4wLCAwLjEsIDAuMiwgMC4zLCAwLjQsIDAuNSwgMC42LCAwLjcsIDAuOCwgMC45LCAxLjBdLFxuICAgICAgICB0aWNrdGV4dDogW1wiMC4wXCIsIFwiMC4xXCIsIFwiMC4yXCIsIFwiMC4zXCIsIFwiMC40XCIsIFwiMC41XCIsIFwiMC42XCIsIFwiMC43XCIsIFwiMC44XCIsIFwiMC45XCIsIFwiMS4wXCJdLFxuICAgICAgICByYW5nZTogW3ltaW4sIHltYXhdXG4gICAgfTtcblxuICAgIHJldHVybiBsYXlvdXQ7XG59O1xuXG5cbi8vIHNldHMgcGxvdCBvcHRpb25zIGZvciBtYXAgZ3JhcGhzXG5jb25zdCBnZW5lcmF0ZU1hcFBsb3RPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGF1dG9zaXplOiB0cnVlLFxuICAgICAgICBob3Zlcm1vZGU6ICdjbG9zZXN0JyxcbiAgICAgICAgbWFwYm94OiB7XG4gICAgICAgICAgICBiZWFyaW5nOiAwLFxuICAgICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICAgICAgbGF0OiAzOS44MzQsXG4gICAgICAgICAgICAgICAgbG9uOiAtOTguNjA0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGl0Y2g6IDAsXG4gICAgICAgICAgICB6b29tOiAzLjI1LFxuICAgICAgICAgICAgYWNjZXNzdG9rZW46ICdway5leUoxSWpvaWJXRjBjeTFuYzJRaUxDSmhJam9pWTJwdk4ybDFOMk15TUc5eGRUTjNiV1IzT0RWNWEyRTJaaUo5LlB0Z2NHaHhhb0Q0M04wT3dKU05WTWcnLFxuICAgICAgICAgICAgc3R5bGU6ICdsaWdodCdcbiAgICAgICAgfSxcbiAgICAgICAgbWFyZ2luOiB7XG4gICAgICAgICAgICBsOiAzMCxcbiAgICAgICAgICAgIHI6IDMwLFxuICAgICAgICAgICAgYjogNDAsXG4gICAgICAgICAgICB0OiAxMCxcbiAgICAgICAgICAgIHBhZDogNFxuICAgICAgICB9LFxuICAgICAgICBzaG93bGVnZW5kOiBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLy8gc2V0cyBwbG90IG9wdGlvbnMgZm9yIHZhbGlkIHRpbWUgZ3JhcGhzXG5jb25zdCBnZW5lcmF0ZUhpc3RvZ3JhbVBsb3RPcHRpb25zID0gZnVuY3Rpb24gKGRhdGFzZXQsIGN1cnZlcywgYXhpc01hcCwgcGxvdEJpbnMpIHtcbiAgICBjb25zdCBheGlzS2V5ID0gY3VydmVzWzBdLmF4aXNLZXk7XG4gICAgY29uc3QgYXhpc0xhYmVsID0gYXhpc01hcFtheGlzS2V5XS5heGlzTGFiZWw7XG5cbiAgICB2YXIgbGF5b3V0ID0ge1xuICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICAgIGw6IDgwLFxuICAgICAgICAgICAgcjogODAsXG4gICAgICAgICAgICBiOiA4MCxcbiAgICAgICAgICAgIHQ6IDIwLFxuICAgICAgICAgICAgcGFkOiA0XG4gICAgICAgIH0sXG4gICAgICAgIHplcm9saW5lOiBmYWxzZSxcbiAgICAgICAgYmFyZ2FwOiAwLjI1LFxuICAgICAgICBiYXJtb2RlOiAnZ3JvdXAnLFxuICAgICAgICBob3Zlcm1vZGU6ICdjbG9zZXN0JyxcbiAgICAgICAgaG92ZXJsYWJlbDogeydmb250JzogeydzaXplJzogMTQsICdmYW1pbHknOiAnQXJpYWwnLCAnY29sb3InOiAnI0ZGRkZGRid9fSxcbiAgICAgICAgc2hvd2xlZ2VuZDogZmFsc2VcbiAgICB9O1xuXG4gICAgbGF5b3V0Wyd4YXhpcyddID0ge1xuICAgICAgICB0aXRsZTogJ0JpbicsXG4gICAgICAgIHRpdGxlZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDIyfSxcbiAgICAgICAgdGlja2ZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAxMn0sXG4gICAgICAgIHRpY2t2YWxzOiBwbG90Qmlucy5iaW5NZWFucyxcbiAgICAgICAgdGlja3RleHQ6IHBsb3RCaW5zLmJpbkxhYmVscyxcbiAgICB9O1xuXG4gICAgbGF5b3V0Wyd5YXhpcyddID0ge1xuICAgICAgICB0aXRsZTogYXhpc0xhYmVsLFxuICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTR9LFxuICAgIH07XG5cbiAgICByZXR1cm4gbGF5b3V0O1xuXG59O1xuXG4vLyBzZXRzIHBsb3Qgb3B0aW9ucyBmb3IgdmFsaWQgdGltZSBncmFwaHNcbmNvbnN0IGdlbmVyYXRlQ29udG91clBsb3RPcHRpb25zID0gZnVuY3Rpb24gKGRhdGFzZXQsIGF4aXNNYXApIHtcbiAgICBjb25zdCB4QXhpc0tleSA9IGRhdGFzZXRbMF1bJ3hBeGlzS2V5J107XG4gICAgY29uc3QgeUF4aXNLZXkgPSBkYXRhc2V0WzBdWyd5QXhpc0tleSddO1xuXG4gICAgdmFyIGxheW91dCA9IHtcbiAgICAgICAgbWFyZ2luOiB7XG4gICAgICAgICAgICBsOiA4MCxcbiAgICAgICAgICAgIHI6IDgwLFxuICAgICAgICAgICAgYjogODAsXG4gICAgICAgICAgICB0OiAyMCxcbiAgICAgICAgICAgIHBhZDogNFxuICAgICAgICB9LFxuICAgICAgICB6ZXJvbGluZTogZmFsc2UsXG4gICAgICAgIGhvdmVybW9kZTogJ2Nsb3Nlc3QnLFxuICAgICAgICBob3ZlcmxhYmVsOiB7J2ZvbnQnOiB7J3NpemUnOiAxNCwgJ2ZhbWlseSc6ICdBcmlhbCcsICdjb2xvcic6ICcjRkZGRkZGJ319XG4gICAgfTtcblxuICAgIGxheW91dFsneGF4aXMnXSA9IHtcbiAgICAgICAgdGl0bGU6IHhBeGlzS2V5LFxuICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgIHRpY2tmb250OiB7Y29sb3I6ICcjMDAwMDAwJywgc2l6ZTogMTJ9LFxuICAgIH07XG5cbiAgICBpZiAoeUF4aXNLZXkgPT09IFwiUHJlc3N1cmUgbGV2ZWxcIikge1xuICAgICAgICBsYXlvdXRbJ3lheGlzJ10gPSB7XG4gICAgICAgICAgICB0aXRsZTogeUF4aXNLZXksXG4gICAgICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgICAgICB0aWNrZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDE0fSxcbiAgICAgICAgICAgIHRpY2t2YWxzOiBbMTAwMCwgOTAwLCA4MDAsIDcwMCwgNjAwLCA1MDAsIDQwMCwgMzAwLCAyMDAsIDEwMF0sXG4gICAgICAgICAgICB0aWNrdGV4dDogWycxMDAwJywgJzkwMCcsICc4MDAnLCAnNzAwJywgJzYwMCcsICc1MDAnLCAnNDAwJywgJzMwMCcsICcyMDAnLCAnMTAwJ10sXG4gICAgICAgICAgICByYW5nZTogWzExMDAsIDBdLFxuICAgICAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgICAgICBhdXRvcmFuZ2U6ICdyZXZlcnNlZCdcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXlvdXRbJ3lheGlzJ10gPSB7XG4gICAgICAgICAgICB0aXRsZTogeUF4aXNLZXksXG4gICAgICAgICAgICB0aXRsZWZvbnQ6IHtjb2xvcjogJyMwMDAwMDAnLCBzaXplOiAyMn0sXG4gICAgICAgICAgICB0aWNrZm9udDoge2NvbG9yOiAnIzAwMDAwMCcsIHNpemU6IDE0fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGxheW91dDtcblxufTtcblxuZXhwb3J0IGRlZmF1bHQgbWF0c0RhdGFQbG90T3BzVXRpbHMgPSB7XG5cbiAgICBnZW5lcmF0ZVNlcmllc1Bsb3RPcHRpb25zOiBnZW5lcmF0ZVNlcmllc1Bsb3RPcHRpb25zLFxuICAgIGdlbmVyYXRlUHJvZmlsZVBsb3RPcHRpb25zOiBnZW5lcmF0ZVByb2ZpbGVQbG90T3B0aW9ucyxcbiAgICBnZW5lcmF0ZURpZW9mZlBsb3RPcHRpb25zOiBnZW5lcmF0ZURpZW9mZlBsb3RPcHRpb25zLFxuICAgIGdlbmVyYXRlVGhyZXNob2xkUGxvdE9wdGlvbnM6IGdlbmVyYXRlVGhyZXNob2xkUGxvdE9wdGlvbnMsXG4gICAgZ2VuZXJhdGVWYWxpZFRpbWVQbG90T3B0aW9uczogZ2VuZXJhdGVWYWxpZFRpbWVQbG90T3B0aW9ucyxcbiAgICBnZW5lcmF0ZVJlbGlhYmlsaXR5UGxvdE9wdGlvbnM6IGdlbmVyYXRlUmVsaWFiaWxpdHlQbG90T3B0aW9ucyxcbiAgICBnZW5lcmF0ZU1hcFBsb3RPcHRpb25zOiBnZW5lcmF0ZU1hcFBsb3RPcHRpb25zLFxuICAgIGdlbmVyYXRlSGlzdG9ncmFtUGxvdE9wdGlvbnM6IGdlbmVyYXRlSGlzdG9ncmFtUGxvdE9wdGlvbnMsXG4gICAgZ2VuZXJhdGVDb250b3VyUGxvdE9wdGlvbnM6IGdlbmVyYXRlQ29udG91clBsb3RPcHRpb25zXG5cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgQ29sb3JhZG8gU3RhdGUgVW5pdmVyc2l0eSBhbmQgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5pbXBvcnQge21hdHNUeXBlc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNDb2xsZWN0aW9uc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNEYXRhVXRpbHN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaW1wb3J0IHttYXRzRGF0YU1hdGNoVXRpbHN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaW1wb3J0IHttYXRzRGF0YURpZmZVdGlsc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNEYXRhQ3VydmVPcHNVdGlsc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNEYXRhUGxvdE9wc1V0aWxzfSBmcm9tICdtZXRlb3IvcmFuZHlwOm1hdHMtY29tbW9uJztcbmltcG9ydCB7bW9tZW50fSBmcm9tICdtZXRlb3IvbW9tZW50anM6bW9tZW50J1xuXG5jb25zdCBwcm9jZXNzRGF0YVhZQ3VydmUgPSBmdW5jdGlvbiAoZGF0YXNldCwgYXBwUGFyYW1zLCBjdXJ2ZUluZm9QYXJhbXMsIHBsb3RQYXJhbXMsIGJvb2trZWVwaW5nUGFyYW1zKSB7XG4gICAgLy8gdmFyaWFibGUgdG8gc3RvcmUgbWF4aW11bSBlcnJvciBiYXIgbGVuZ3RoXG4gICAgdmFyIGVycm9yTWF4ID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICB2YXIgZXJyb3IgPSBcIlwiO1xuXG4gICAgY29uc3QgYXBwTmFtZSA9IG1hdHNDb2xsZWN0aW9ucy5hcHBOYW1lLmZpbmRPbmUoe30pLmFwcDtcblxuICAgIC8vIGlmIG1hdGNoaW5nLCBwYXJlIGRvd24gZGF0YXNldCB0byBvbmx5IG1hdGNoaW5nIGRhdGFcbiAgICBpZiAoY3VydmVJbmZvUGFyYW1zLmN1cnZlc0xlbmd0aCA+IDEgJiYgYXBwUGFyYW1zLm1hdGNoaW5nKSB7XG4gICAgICAgIGlmIChhcHBQYXJhbXMuaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICBkYXRhc2V0ID0gbWF0c0RhdGFNYXRjaFV0aWxzLmdldE1hdGNoZWREYXRhU2V0V2l0aExldmVscyhkYXRhc2V0LCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzTGVuZ3RoLCBhcHBQYXJhbXMucGxvdFR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldCA9IG1hdHNEYXRhTWF0Y2hVdGlscy5nZXRNYXRjaGVkRGF0YVNldChkYXRhc2V0LCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdlIG1heSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSBheGlzIGxpbWl0cyBhZnRlciB1bm1hdGNoZWQgZGF0YSBhbmQgb3V0bGllcnMgYXJlIHJlbW92ZWRcbiAgICB2YXIgYXhpc0xpbWl0UmVwcm9jZXNzZWQgPSB7fTtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIHN0YXRpc3RpY3MgKGluY2x1ZGluZyBlcnJvciBiYXJzKSBmb3IgZWFjaCBjdXJ2ZVxuICAgIGZvciAodmFyIGN1cnZlSW5kZXggPSAwOyBjdXJ2ZUluZGV4IDwgY3VydmVJbmZvUGFyYW1zLmN1cnZlc0xlbmd0aDsgY3VydmVJbmRleCsrKSB7XG4gICAgICAgIGlmIChhcHBOYW1lICE9PSBcInN1cmZyYWRcIikge1xuICAgICAgICAgICAgYXhpc0xpbWl0UmVwcm9jZXNzZWRbY3VydmVJbmZvUGFyYW1zLmN1cnZlc1tjdXJ2ZUluZGV4XS5heGlzS2V5XSA9IGF4aXNMaW1pdFJlcHJvY2Vzc2VkW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmZkZyb20gPSBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmRpZmZGcm9tO1xuICAgICAgICB2YXIgc3RhdGlzdGljU2VsZWN0ID0gYXBwTmFtZS5pbmRleE9mKFwiYW5vbWFseWNvclwiKSAhPT0gLTEgPyBcIkFDQ1wiIDogY3VydmVJbmZvUGFyYW1zLmN1cnZlc1tjdXJ2ZUluZGV4XVsnc3RhdGlzdGljJ107XG4gICAgICAgIHZhciBkYXRhID0gZGF0YXNldFtjdXJ2ZUluZGV4XTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkYXRhc2V0W2N1cnZlSW5kZXhdLmxhYmVsO1xuXG4gICAgICAgIHZhciBkaSA9IDA7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIGluZFZhcnMgPSBbXTtcbiAgICAgICAgdmFyIG1lYW5zID0gW107XG4gICAgICAgIHZhciByYXdTdGF0O1xuXG4gICAgICAgIC8qXG4gICAgICAgIGRhdGFzZXRbY3VydmVJbmRleF0gaXMgdGhlIGRhdGFzZXQuXG4gICAgICAgIGl0IGxvb2tzIGxpa2U6XG5cbiAgICAgICAgZCA9IHtcbiAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICBlcnJvcl94OiBbXSwgICAvLyBjdXJ2ZVRpbWVcbiAgICAgICAgICAgIGVycm9yX3k6IFtdLCAgIC8vIHZhbHVlc1xuICAgICAgICAgICAgc3ViVmFsczogW10sICAgLy9zdWJWYWxzXG4gICAgICAgICAgICBzdWJTZWNzOiBbXSwgICAvL3N1YlNlY3NcbiAgICAgICAgICAgIHN1YkxldnM6IFtdLCAgIC8vc3ViTGV2c1xuICAgICAgICAgICAgc3RhdHM6IFtdLCAgICAgLy9wb2ludFN0YXRzXG4gICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgIGdsb2Jfc3RhdHM6IHt9LCAgICAgLy9jdXJ2ZVN0YXRzXG4gICAgICAgICAgICB4bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgeG1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIHltaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB5bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgc3VtOiAwXG4gICAgICAgIH07XG4gICAgICAgICovXG5cbiAgICAgICAgd2hpbGUgKGRpIDwgZGF0YS54Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBlcnJvclJlc3VsdCBob2xkcyBhbGwgdGhlIGNhbGN1bGF0ZWQgY3VydmUgc3RhdHMgbGlrZSBtZWFuLCBzZCwgZXRjLlxuICAgICAgICAgICAgdmFyIGVycm9yUmVzdWx0O1xuICAgICAgICAgICAgaWYgKGFwcFBhcmFtcy5oYXNMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICBlcnJvclJlc3VsdCA9IG1hdHNEYXRhVXRpbHMuZ2V0X2VycihkYXRhLnN1YlZhbHNbZGldLCBkYXRhLnN1YlNlY3NbZGldLCBkYXRhLnN1YkxldnNbZGldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JSZXN1bHQgPSBtYXRzRGF0YVV0aWxzLmdldF9lcnIoZGF0YS5zdWJWYWxzW2RpXSwgZGF0YS5zdWJTZWNzW2RpXSwgW10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdG9yZSByYXcgc3RhdGlzdGljIGZyb20gcXVlcnkgYmVmb3JlIHJlY2FsY3VsYXRpbmcgdGhhdCBzdGF0aXN0aWMgdG8gYWNjb3VudCBmb3IgZGF0YSByZW1vdmVkIGR1ZSB0byBtYXRjaGluZywgUUMsIGV0Yy5cbiAgICAgICAgICAgIHJhd1N0YXQgPSBkYXRhLnlbZGldO1xuICAgICAgICAgICAgLy8gdGhpcyB1bmdhaW5seSBpZiBzdGF0ZW1lbnQgaXMgYmVjYXVzZSB0aGUgc3VyZnJhZDMgZGF0YWJhc2UgZG9lc24ndCBzdXBwb3J0IHJlY2FsY3VsYXRpbmcgc29tZSBzdGF0cy5cbiAgICAgICAgICAgIGlmIChhcHBOYW1lICE9PSBcInN1cmZyYWRcIiB8fFxuICAgICAgICAgICAgICAgICEoYXBwTmFtZSA9PT0gXCJzdXJmcmFkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRpc3RpY1NlbGVjdCA9PT0gJ1N0ZCBkZXZpYXRpb24gKGRvIG5vdCBwbG90IG1hdGNoZWQpJyB8fCBzdGF0aXN0aWNTZWxlY3QgPT09ICdSTVMgKGRvIG5vdCBwbG90IG1hdGNoZWQpJykgJiZcbiAgICAgICAgICAgICAgICAgICAgIWFwcFBhcmFtcy5tYXRjaGluZykpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRpZmZGcm9tID09PSBudWxsIHx8IGRpZmZGcm9tID09PSB1bmRlZmluZWQpIHx8ICFhcHBQYXJhbXMubWF0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIHJlY2FsY3VsYXRlZCBzdGF0aXN0aWMgdG8gZGF0YVtkaV1bMV0sIHdoaWNoIGlzIHRoZSB2YWx1ZSB0byBiZSBwbG90dGVkXG4gICAgICAgICAgICAgICAgICAgIGRhdGEueVtkaV0gPSBlcnJvclJlc3VsdC5kX21lYW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFzZXRbZGlmZkZyb21bMF1dLnlbZGldICE9PSBudWxsICYmIGRhdGFzZXRbZGlmZkZyb21bMV1dLnlbZGldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgZGlmZiBjdXJ2ZSBhY3R1YWxseSBzaG93cyB0aGUgZGlmZmVyZW5jZSB3aGVuIG1hdGNoaW5nLiBPdGhlcndpc2Ugb3V0bGllciBmaWx0ZXJpbmcgZXRjLiBjYW4gbWFrZSBpdCBzbGlnaHRseSBvZmYuXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnlbZGldID0gZGF0YXNldFtkaWZmRnJvbVswXV0ueVtkaV0gLSBkYXRhc2V0W2RpZmZGcm9tWzFdXS55W2RpXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIG51bGwgZm9yIG5vIGRhdGEgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS55W2RpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChkYXRhLnlbZGldKTtcbiAgICAgICAgICAgIGluZFZhcnMucHVzaChkYXRhLnhbZGldKTtcbiAgICAgICAgICAgIG1lYW5zLnB1c2goZXJyb3JSZXN1bHQuZF9tZWFuKTtcblxuICAgICAgICAgICAgLy8gc3RvcmUgZXJyb3IgYmFycyBpZiBtYXRjaGluZ1xuICAgICAgICAgICAgY29uc3QgZXJyb3JCYXIgPSBlcnJvclJlc3VsdC5zdGRlX2JldHN5ICogMS45NjtcbiAgICAgICAgICAgIGlmIChhcHBQYXJhbXMubWF0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1heCA9IGVycm9yTWF4ID4gZXJyb3JCYXIgPyBlcnJvck1heCA6IGVycm9yQmFyO1xuICAgICAgICAgICAgICAgIGRhdGEuZXJyb3JfeS5hcnJheVtkaV0gPSBlcnJvckJhcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lcnJvcl95LmFycmF5W2RpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBzdWIgdmFsdWVzIGFuZCB0aW1lcyB0byBzYXZlIHNwYWNlXG4gICAgICAgICAgICBkYXRhLnN1YlZhbHNbZGldID0gW107XG4gICAgICAgICAgICBkYXRhLnN1YlNlY3NbZGldID0gW107XG4gICAgICAgICAgICBkYXRhLnN1YkxldnNbZGldID0gW107XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIHN0YXRpc3RpY3MgZm9yIHRoaXMgZGkgZGF0YXBvaW50XG4gICAgICAgICAgICBkYXRhLnN0YXRzW2RpXSA9IHtcbiAgICAgICAgICAgICAgICByYXdfc3RhdDogcmF3U3RhdCxcbiAgICAgICAgICAgICAgICBkX21lYW46IGVycm9yUmVzdWx0LmRfbWVhbixcbiAgICAgICAgICAgICAgICBzZDogZXJyb3JSZXN1bHQuc2QsXG4gICAgICAgICAgICAgICAgbl9nb29kOiBlcnJvclJlc3VsdC5uX2dvb2QsXG4gICAgICAgICAgICAgICAgbGFnMTogZXJyb3JSZXN1bHQubGFnMSxcbiAgICAgICAgICAgICAgICBzdGRlX2JldHN5OiBlcnJvclJlc3VsdC5zdGRlX2JldHN5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSB0b29sdGlwLCBpdCBpcyB0aGUgbGFzdCBlbGVtZW50IG9mIGVhY2ggZGF0YXNlcmllcyBlbGVtZW50LlxuICAgICAgICAgICAgLy8gYWxzbyBjaGFuZ2UgdGhlIHggYXJyYXkgZnJvbSBlcG9jaCB0byBkYXRlIGZvciB0aW1lc2VyaWVzIGFuZCBETUMsIGFzIHdlIGFyZSBub3cgZG9uZSB3aXRoIGl0IGZvciBjYWxjdWxhdGlvbnMuXG4gICAgICAgICAgICBkYXRhLnRleHRbZGldID0gbGFiZWw7XG4gICAgICAgICAgICBzd2l0Y2ggKGFwcFBhcmFtcy5wbG90VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy50aW1lU2VyaWVzOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRleHRbZGldID0gZGF0YS50ZXh0W2RpXSArIFwiPGJyPnRpbWU6IFwiICsgbW9tZW50LnV0YyhkYXRhLnhbZGldKS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMuZGFpbHlNb2RlbEN5Y2xlOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZmhyID0gKChkYXRhLnhbZGldIC8gMTAwMCkgJSAoMjQgKiAzNjAwKSkgLyAzNjAwIC0gY3VydmVJbmZvUGFyYW1zLnV0Y0N5Y2xlU3RhcnRzW2N1cnZlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBmaHIgPSBmaHIgPCAwID8gZmhyICsgMjQgOiBmaHI7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFtkaV0gPSBkYXRhLnRleHRbZGldICsgXCI8YnI+dGltZTogXCIgKyBtb21lbnQudXRjKGRhdGEueFtkaV0pLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW1cIik7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFtkaV0gPSBkYXRhLnRleHRbZGldICsgXCI8YnI+Zm9yZWNhc3QgaG91cjogXCIgKyBmaHI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kaWVvZmY6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFtkaV0gPSBkYXRhLnRleHRbZGldICsgXCI8YnI+ZmhyOiBcIiArIGRhdGEueFtkaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy50aHJlc2hvbGQ6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFtkaV0gPSBkYXRhLnRleHRbZGldICsgXCI8YnI+dGhyZXNob2xkOiBcIiArIGRhdGEueFtkaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy52YWxpZHRpbWU6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFtkaV0gPSBkYXRhLnRleHRbZGldICsgXCI8YnI+aG91ciBvZiBkYXk6IFwiICsgZGF0YS54W2RpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0W2RpXSA9IGRhdGEudGV4dFtkaV0gKyBcIjxicj5cIiArIGRhdGEueFtkaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS50ZXh0W2RpXSA9IGRhdGEudGV4dFtkaV0gK1xuICAgICAgICAgICAgICAgIFwiPGJyPlwiICsgc3RhdGlzdGljU2VsZWN0ICsgXCI6IFwiICsgKGRhdGEueVtkaV0gPT09IG51bGwgPyBudWxsIDogZGF0YS55W2RpXS50b1ByZWNpc2lvbig0KSkgK1xuICAgICAgICAgICAgICAgIFwiPGJyPnNkOiBcIiArIChlcnJvclJlc3VsdC5zZCA9PT0gbnVsbCA/IG51bGwgOiBlcnJvclJlc3VsdC5zZC50b1ByZWNpc2lvbig0KSkgK1xuICAgICAgICAgICAgICAgIFwiPGJyPm1lYW46IFwiICsgKGVycm9yUmVzdWx0LmRfbWVhbiA9PT0gbnVsbCA/IG51bGwgOiBlcnJvclJlc3VsdC5kX21lYW4udG9QcmVjaXNpb24oNCkpICtcbiAgICAgICAgICAgICAgICBcIjxicj5uOiBcIiArIGVycm9yUmVzdWx0Lm5fZ29vZCArXG4gICAgICAgICAgICAgICAgLy8gXCI8YnI+bGFnMTogXCIgKyAoZXJyb3JSZXN1bHQubGFnMSA9PT0gbnVsbCA/IG51bGwgOiBlcnJvclJlc3VsdC5sYWcxLnRvUHJlY2lzaW9uKDQpKSArXG4gICAgICAgICAgICAgICAgLy8gXCI8YnI+c3RkZTogXCIgKyBlcnJvclJlc3VsdC5zdGRlX2JldHN5ICtcbiAgICAgICAgICAgICAgICBcIjxicj5lcnJvcmJhcnM6IFwiICsgTnVtYmVyKChkYXRhLnlbZGldKSAtIChlcnJvclJlc3VsdC5zdGRlX2JldHN5ICogMS45NikpLnRvUHJlY2lzaW9uKDQpICsgXCIgdG8gXCIgKyBOdW1iZXIoKGRhdGEueVtkaV0pICsgKGVycm9yUmVzdWx0LnN0ZGVfYmV0c3kgKiAxLjk2KSkudG9QcmVjaXNpb24oNCk7XG5cbiAgICAgICAgICAgIGRpKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmFibGUgZXJyb3IgYmFycyBpZiBtYXRjaGluZyBhbmQgdGhleSBhcmVuJ3QgbnVsbFxuICAgICAgICBpZiAoYXBwUGFyYW1zLm1hdGNoaW5nICYmIGRhdGEuZXJyb3JfeS5hcnJheS5maWx0ZXIoeCA9PiB4KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yX3kudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIG92ZXJhbGwgc3RhdHMgZm9yIHRoZSB0ZXh0IG91dHB1dCAtIHRoaXMgdXNlcyB0aGUgbWVhbnMgbm90IHRoZSBzdGF0cy5cbiAgICAgICAgY29uc3Qgc3RhdHMgPSBtYXRzRGF0YVV0aWxzLmdldF9lcnIodmFsdWVzLCBpbmRWYXJzLCBbXSk7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWVhbnMgPSBtZWFucy5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgdmFyIG1pbnkgPSBNYXRoLm1pbiguLi5maWx0ZXJlZE1lYW5zKTtcbiAgICAgICAgdmFyIG1heHkgPSBNYXRoLm1heCguLi5maWx0ZXJlZE1lYW5zKTtcbiAgICAgICAgaWYgKG1lYW5zLmluZGV4T2YoMCkgIT09IC0xICYmIDAgPCBtaW55KSB7XG4gICAgICAgICAgICBtaW55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVhbnMuaW5kZXhPZigwKSAhPT0gLTEgJiYgMCA+IG1heHkpIHtcbiAgICAgICAgICAgIG1heHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLm1pbnkgPSBtaW55O1xuICAgICAgICBzdGF0cy5tYXh5ID0gbWF4eTtcbiAgICAgICAgZGF0YXNldFtjdXJ2ZUluZGV4XVsnZ2xvYl9zdGF0cyddID0gc3RhdHM7XG5cbiAgICAgICAgLy8gcmVjYWxjdWxhdGUgYXhpcyBvcHRpb25zIGFmdGVyIFFDIGFuZCBtYXRjaGluZ1xuICAgICAgICBpZiAoYXBwTmFtZSAhPT0gXCJzdXJmcmFkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbnggPSBNYXRoLm1pbiguLi5pbmRWYXJzKTtcbiAgICAgICAgICAgIGNvbnN0IG1heHggPSBNYXRoLm1heCguLi5pbmRWYXJzKTtcbiAgICAgICAgICAgIGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV1bJ3ltYXgnXSA9IChjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcFtjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmF4aXNLZXldWyd5bWF4J10gPCBtYXh5IHx8ICFheGlzTGltaXRSZXByb2Nlc3NlZFtjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmF4aXNLZXldKSA/IG1heHkgOiBjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcFtjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmF4aXNLZXldWyd5bWF4J107XG4gICAgICAgICAgICBjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcFtjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmF4aXNLZXldWyd5bWluJ10gPSAoY3VydmVJbmZvUGFyYW1zLmF4aXNNYXBbY3VydmVJbmZvUGFyYW1zLmN1cnZlc1tjdXJ2ZUluZGV4XS5heGlzS2V5XVsneW1pbiddID4gbWlueSB8fCAhYXhpc0xpbWl0UmVwcm9jZXNzZWRbY3VydmVJbmZvUGFyYW1zLmN1cnZlc1tjdXJ2ZUluZGV4XS5heGlzS2V5XSkgPyBtaW55IDogY3VydmVJbmZvUGFyYW1zLmF4aXNNYXBbY3VydmVJbmZvUGFyYW1zLmN1cnZlc1tjdXJ2ZUluZGV4XS5heGlzS2V5XVsneW1pbiddO1xuICAgICAgICAgICAgY3VydmVJbmZvUGFyYW1zLmF4aXNNYXBbY3VydmVJbmZvUGFyYW1zLmN1cnZlc1tjdXJ2ZUluZGV4XS5heGlzS2V5XVsneG1heCddID0gKGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV1bJ3htYXgnXSA8IG1heHggfHwgIWF4aXNMaW1pdFJlcHJvY2Vzc2VkW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV0pID8gbWF4eCA6IGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV1bJ3htYXgnXTtcbiAgICAgICAgICAgIGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV1bJ3htaW4nXSA9IChjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcFtjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmF4aXNLZXldWyd4bWluJ10gPiBtaW54IHx8ICFheGlzTGltaXRSZXByb2Nlc3NlZFtjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmF4aXNLZXldKSA/IG1pbnggOiBjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcFtjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmF4aXNLZXldWyd4bWluJ107XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWNhbGN1bGF0ZSBjdXJ2ZSBhbm5vdGF0aW9uIGFmdGVyIFFDIGFuZCBtYXRjaGluZ1xuICAgICAgICBpZiAoc3RhdHMuZF9tZWFuICE9PSB1bmRlZmluZWQgJiYgc3RhdHMuZF9tZWFuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhc2V0W2N1cnZlSW5kZXhdWydhbm5vdGF0aW9uJ10gPSBsYWJlbCArIFwiLSBtZWFuID0gXCIgKyBzdGF0cy5kX21lYW4udG9QcmVjaXNpb24oNCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXBwUGFyYW1zLnBsb3RUeXBlID09PSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRpbWVTZXJpZXMgfHwgYXBwUGFyYW1zLnBsb3RUeXBlID09PSBtYXRzVHlwZXMuUGxvdFR5cGVzLmRhaWx5TW9kZWxDeWNsZSkge1xuICAgICAgICAgICAgZGF0YVsneF9lcG9jaCddID0gZGF0YS54O1xuICAgICAgICAgICAgZGF0YS54ID0gZGF0YS54Lm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbWVudC51dGModmFsKS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGFkZCBibGFjayAwIGxpbmUgY3VydmVcbiAgICAvLyBuZWVkIHRvIGRlZmluZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB4IHZhbHVlIGZvciBtYWtpbmcgdGhlIHplcm8gY3VydmVcbiAgICBjb25zdCB6ZXJvTGluZSA9IG1hdHNEYXRhQ3VydmVPcHNVdGlscy5nZXRIb3Jpem9udGFsVmFsdWVMaW5lKGN1cnZlSW5mb1BhcmFtcy54bWF4LCBjdXJ2ZUluZm9QYXJhbXMueG1pbiwgMCwgbWF0c1R5cGVzLlJlc2VydmVkV29yZHMuemVybyk7XG4gICAgZGF0YXNldC5wdXNoKHplcm9MaW5lKTtcblxuICAgIC8vYWRkIGlkZWFsIHZhbHVlIGxpbmVzLCBpZiBhbnlcbiAgICB2YXIgaWRlYWxWYWx1ZUxpbmU7XG4gICAgdmFyIGlkZWFsTGFiZWw7XG4gICAgZm9yICh2YXIgaXZJZHggPSAwOyBpdklkeCA8IGN1cnZlSW5mb1BhcmFtcy5pZGVhbFZhbHVlcy5sZW5ndGg7IGl2SWR4KyspIHtcbiAgICAgICAgaWRlYWxMYWJlbCA9IFwiaWRlYWxcIiArIGl2SWR4LnRvU3RyaW5nKCk7XG4gICAgICAgIGlkZWFsVmFsdWVMaW5lID0gbWF0c0RhdGFDdXJ2ZU9wc1V0aWxzLmdldEhvcml6b250YWxWYWx1ZUxpbmUoY3VydmVJbmZvUGFyYW1zLnhtYXgsIGN1cnZlSW5mb1BhcmFtcy54bWluLCBjdXJ2ZUluZm9QYXJhbXMuaWRlYWxWYWx1ZXNbaXZJZHhdLCBtYXRzVHlwZXMuUmVzZXJ2ZWRXb3Jkc1tpZGVhbExhYmVsXSk7XG4gICAgICAgIGRhdGFzZXQucHVzaChpZGVhbFZhbHVlTGluZSk7XG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgcGxvdCBvcHRpb25zXG4gICAgdmFyIHJlc3VsdE9wdGlvbnM7XG4gICAgc3dpdGNoIChhcHBQYXJhbXMucGxvdFR5cGUpIHtcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRpbWVTZXJpZXM6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kYWlseU1vZGVsQ3ljbGU6XG4gICAgICAgICAgICByZXN1bHRPcHRpb25zID0gbWF0c0RhdGFQbG90T3BzVXRpbHMuZ2VuZXJhdGVTZXJpZXNQbG90T3B0aW9ucyhkYXRhc2V0LCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzLCBjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcCwgZXJyb3JNYXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kaWVvZmY6XG4gICAgICAgICAgICByZXN1bHRPcHRpb25zID0gbWF0c0RhdGFQbG90T3BzVXRpbHMuZ2VuZXJhdGVEaWVvZmZQbG90T3B0aW9ucyhkYXRhc2V0LCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzLCBjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcCwgZXJyb3JNYXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy52YWxpZHRpbWU6XG4gICAgICAgICAgICByZXN1bHRPcHRpb25zID0gbWF0c0RhdGFQbG90T3BzVXRpbHMuZ2VuZXJhdGVWYWxpZFRpbWVQbG90T3B0aW9ucyhkYXRhc2V0LCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzLCBjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcCwgZXJyb3JNYXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy50aHJlc2hvbGQ6XG4gICAgICAgICAgICByZXN1bHRPcHRpb25zID0gbWF0c0RhdGFQbG90T3BzVXRpbHMuZ2VuZXJhdGVUaHJlc2hvbGRQbG90T3B0aW9ucyhkYXRhc2V0LCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzLCBjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcCwgZXJyb3JNYXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdG90YWxQcm9jZXNzaW5nRmluaXNoID0gbW9tZW50KCk7XG4gICAgYm9va2tlZXBpbmdQYXJhbXMuZGF0YVJlcXVlc3RzW1widG90YWwgcmV0cmlldmFsIGFuZCBwcm9jZXNzaW5nIHRpbWUgZm9yIGN1cnZlIHNldFwiXSA9IHtcbiAgICAgICAgYmVnaW46IGJvb2trZWVwaW5nUGFyYW1zLnRvdGFsUHJvY2Vzc2luZ1N0YXJ0LmZvcm1hdCgpLFxuICAgICAgICBmaW5pc2g6IHRvdGFsUHJvY2Vzc2luZ0ZpbmlzaC5mb3JtYXQoKSxcbiAgICAgICAgZHVyYXRpb246IG1vbWVudC5kdXJhdGlvbih0b3RhbFByb2Nlc3NpbmdGaW5pc2guZGlmZihib29ra2VlcGluZ1BhcmFtcy50b3RhbFByb2Nlc3NpbmdTdGFydCkpLmFzU2Vjb25kcygpICsgJyBzZWNvbmRzJ1xuICAgIH07XG5cbiAgICAvLyBwYXNzIHJlc3VsdCB0byBjbGllbnQtc2lkZSBwbG90dGluZyBmdW5jdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGRhdGE6IGRhdGFzZXQsXG4gICAgICAgIG9wdGlvbnM6IHJlc3VsdE9wdGlvbnMsXG4gICAgICAgIGJhc2lzOiB7XG4gICAgICAgICAgICBwbG90UGFyYW1zOiBwbG90UGFyYW1zLFxuICAgICAgICAgICAgcXVlcmllczogYm9va2tlZXBpbmdQYXJhbXMuZGF0YVJlcXVlc3RzXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgcHJvY2Vzc0RhdGFQcm9maWxlID0gZnVuY3Rpb24gKGRhdGFzZXQsIGFwcFBhcmFtcywgY3VydmVJbmZvUGFyYW1zLCBwbG90UGFyYW1zLCBib29ra2VlcGluZ1BhcmFtcykge1xuICAgIC8vIHZhcmlhYmxlIHRvIHN0b3JlIG1heGltdW0gZXJyb3IgYmFyIGxlbmd0aFxuICAgIHZhciBlcnJvck1heCA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgdmFyIGVycm9yID0gXCJcIjtcblxuICAgIGNvbnN0IGFwcE5hbWUgPSBtYXRzQ29sbGVjdGlvbnMuYXBwTmFtZS5maW5kT25lKHt9KS5hcHA7XG5cbiAgICAvLyBpZiBtYXRjaGluZywgcGFyZSBkb3duIGRhdGFzZXQgdG8gb25seSBtYXRjaGluZyBkYXRhXG4gICAgaWYgKGN1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNMZW5ndGggPiAxICYmIGFwcFBhcmFtcy5tYXRjaGluZykge1xuICAgICAgICBkYXRhc2V0ID0gbWF0c0RhdGFNYXRjaFV0aWxzLmdldE1hdGNoZWREYXRhU2V0V2l0aExldmVscyhkYXRhc2V0LCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzTGVuZ3RoLCBhcHBQYXJhbXMucGxvdFR5cGUpO1xuICAgIH1cblxuICAgIC8vIHdlIG1heSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSBheGlzIGxpbWl0cyBhZnRlciB1bm1hdGNoZWQgZGF0YSBhbmQgb3V0bGllcnMgYXJlIHJlbW92ZWRcbiAgICB2YXIgYXhpc0xpbWl0UmVwcm9jZXNzZWQgPSB7fTtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIHN0YXRpc3RpY3MgKGluY2x1ZGluZyBlcnJvciBiYXJzKSBmb3IgZWFjaCBjdXJ2ZVxuICAgIGZvciAodmFyIGN1cnZlSW5kZXggPSAwOyBjdXJ2ZUluZGV4IDwgY3VydmVJbmZvUGFyYW1zLmN1cnZlc0xlbmd0aDsgY3VydmVJbmRleCsrKSB7XG4gICAgICAgIGF4aXNMaW1pdFJlcHJvY2Vzc2VkW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV0gPSBheGlzTGltaXRSZXByb2Nlc3NlZFtjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmF4aXNLZXldICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBkaWZmRnJvbSA9IGN1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uZGlmZkZyb207XG4gICAgICAgIHZhciBzdGF0aXN0aWNTZWxlY3QgPSBhcHBOYW1lLmluZGV4T2YoXCJhbm9tYWx5Y29yXCIpICE9PSAtMSA/IFwiQUNDXCIgOiBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdWydzdGF0aXN0aWMnXTtcbiAgICAgICAgdmFyIGRhdGEgPSBkYXRhc2V0W2N1cnZlSW5kZXhdO1xuICAgICAgICBjb25zdCBsYWJlbCA9IGRhdGFzZXRbY3VydmVJbmRleF0ubGFiZWw7XG5cbiAgICAgICAgdmFyIGRpID0gMDtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgICAgIHZhciBtZWFucyA9IFtdO1xuICAgICAgICB2YXIgcmF3U3RhdDtcblxuICAgICAgICAvKlxuICAgICAgICBkYXRhc2V0W2N1cnZlSW5kZXhdIGlzIHRoZSBkYXRhc2V0LlxuICAgICAgICBpdCBsb29rcyBsaWtlOlxuXG4gICAgICAgIGQgPSB7XG4gICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgIHk6IFtdLFxuICAgICAgICAgICAgZXJyb3JfeDogW10sICAgLy8gY3VydmVUaW1lXG4gICAgICAgICAgICBlcnJvcl95OiBbXSwgICAvLyB2YWx1ZXNcbiAgICAgICAgICAgIHN1YlZhbHM6IFtdLCAgIC8vc3ViVmFsc1xuICAgICAgICAgICAgc3ViU2VjczogW10sICAgLy9zdWJTZWNzXG4gICAgICAgICAgICBzdWJMZXZzOiBbXSwgICAvL3N1YkxldnNcbiAgICAgICAgICAgIHN0YXRzOiBbXSwgICAgIC8vcG9pbnRTdGF0c1xuICAgICAgICAgICAgdGV4dDogW10sXG4gICAgICAgICAgICBnbG9iX3N0YXRzOiB7fSwgICAgIC8vY3VydmVTdGF0c1xuICAgICAgICAgICAgeG1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIHhtYXg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICB5bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgeW1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIHN1bTogMFxuICAgICAgICB9O1xuICAgICAgICAqL1xuXG4gICAgICAgIHdoaWxlIChkaSA8IGRhdGEueS5sZW5ndGgpIHtcblxuICAgICAgICAgICAgLy8gZXJyb3JSZXN1bHQgaG9sZHMgYWxsIHRoZSBjYWxjdWxhdGVkIGN1cnZlIHN0YXRzIGxpa2UgbWVhbiwgc2QsIGV0Yy5cbiAgICAgICAgICAgIHZhciBlcnJvclJlc3VsdCA9IG1hdHNEYXRhVXRpbHMuZ2V0X2VycihkYXRhLnN1YlZhbHNbZGldLCBkYXRhLnN1YlNlY3NbZGldLCBkYXRhLnN1YkxldnNbZGldKTtcblxuICAgICAgICAgICAgLy8gc3RvcmUgcmF3IHN0YXRpc3RpYyBmcm9tIHF1ZXJ5IGJlZm9yZSByZWNhbGN1bGF0aW5nIHRoYXQgc3RhdGlzdGljIHRvIGFjY291bnQgZm9yIGRhdGEgcmVtb3ZlZCBkdWUgdG8gbWF0Y2hpbmcsIFFDLCBldGMuXG4gICAgICAgICAgICByYXdTdGF0ID0gZGF0YS54W2RpXTtcbiAgICAgICAgICAgIGlmICgoZGlmZkZyb20gPT09IG51bGwgfHwgZGlmZkZyb20gPT09IHVuZGVmaW5lZCkgfHwgIWFwcFBhcmFtcy5tYXRjaGluZykge1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiByZWNhbGN1bGF0ZWQgc3RhdGlzdGljIHRvIGRhdGFbZGldWzFdLCB3aGljaCBpcyB0aGUgdmFsdWUgdG8gYmUgcGxvdHRlZFxuICAgICAgICAgICAgICAgIGRhdGEueFtkaV0gPSBlcnJvclJlc3VsdC5kX21lYW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhc2V0W2RpZmZGcm9tWzBdXS54W2RpXSAhPT0gbnVsbCAmJiBkYXRhc2V0W2RpZmZGcm9tWzFdXS54W2RpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgZGlmZiBjdXJ2ZSBhY3R1YWxseSBzaG93cyB0aGUgZGlmZmVyZW5jZSB3aGVuIG1hdGNoaW5nLiBPdGhlcndpc2Ugb3V0bGllciBmaWx0ZXJpbmcgZXRjLiBjYW4gbWFrZSBpdCBzbGlnaHRseSBvZmYuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEueFtkaV0gPSBkYXRhc2V0W2RpZmZGcm9tWzBdXS54W2RpXSAtIGRhdGFzZXRbZGlmZkZyb21bMV1dLnhbZGldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIG51bGwgZm9yIG5vIGRhdGEgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgICAgICBkYXRhLnhbZGldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChkYXRhLnhbZGldKTtcbiAgICAgICAgICAgIGxldmVscy5wdXNoKGRhdGEueVtkaV0pO1xuICAgICAgICAgICAgbWVhbnMucHVzaChlcnJvclJlc3VsdC5kX21lYW4pO1xuXG4gICAgICAgICAgICAvLyBzdG9yZSBlcnJvciBiYXJzIGlmIG1hdGNoaW5nXG4gICAgICAgICAgICBjb25zdCBlcnJvckJhciA9IGVycm9yUmVzdWx0LnN0ZGVfYmV0c3kgKiAxLjk2O1xuICAgICAgICAgICAgaWYgKGFwcFBhcmFtcy5tYXRjaGluZykge1xuICAgICAgICAgICAgICAgIGVycm9yTWF4ID0gZXJyb3JNYXggPiBlcnJvckJhciA/IGVycm9yTWF4IDogZXJyb3JCYXI7XG4gICAgICAgICAgICAgICAgZGF0YS5lcnJvcl94LmFycmF5W2RpXSA9IGVycm9yQmFyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVycm9yX3guYXJyYXlbZGldID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHN1YiB2YWx1ZXMgYW5kIHRpbWVzIHRvIHNhdmUgc3BhY2VcbiAgICAgICAgICAgIGRhdGEuc3ViVmFsc1tkaV0gPSBbXTtcbiAgICAgICAgICAgIGRhdGEuc3ViU2Vjc1tkaV0gPSBbXTtcbiAgICAgICAgICAgIGRhdGEuc3ViTGV2c1tkaV0gPSBbXTtcblxuICAgICAgICAgICAgLy8gc3RvcmUgc3RhdGlzdGljc1xuICAgICAgICAgICAgZGF0YS5zdGF0c1tkaV0gPSB7XG4gICAgICAgICAgICAgICAgcmF3X3N0YXQ6IHJhd1N0YXQsXG4gICAgICAgICAgICAgICAgZF9tZWFuOiBlcnJvclJlc3VsdC5kX21lYW4sXG4gICAgICAgICAgICAgICAgc2Q6IGVycm9yUmVzdWx0LnNkLFxuICAgICAgICAgICAgICAgIG5fZ29vZDogZXJyb3JSZXN1bHQubl9nb29kLFxuICAgICAgICAgICAgICAgIGxhZzE6IGVycm9yUmVzdWx0LmxhZzEsXG4gICAgICAgICAgICAgICAgc3RkZV9iZXRzeTogZXJyb3JSZXN1bHQuc3RkZV9iZXRzeVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgdG9vbHRpcCwgaXQgaXMgdGhlIGxhc3QgZWxlbWVudCBvZiBlYWNoIGRhdGFzZXJpZXMgZWxlbWVudFxuICAgICAgICAgICAgZGF0YS50ZXh0W2RpXSA9IGxhYmVsICtcbiAgICAgICAgICAgICAgICBcIjxicj5cIiArIGRhdGEueVtkaV0gKyBcIm1iXCIgK1xuICAgICAgICAgICAgICAgIFwiPGJyPlwiICsgc3RhdGlzdGljU2VsZWN0ICsgXCI6IFwiICsgKGRhdGEueFtkaV0gPT09IG51bGwgPyBudWxsIDogZGF0YS54W2RpXS50b1ByZWNpc2lvbig0KSkgK1xuICAgICAgICAgICAgICAgIFwiPGJyPnNkOiBcIiArIChlcnJvclJlc3VsdC5zZCA9PT0gbnVsbCA/IG51bGwgOiBlcnJvclJlc3VsdC5zZC50b1ByZWNpc2lvbig0KSkgK1xuICAgICAgICAgICAgICAgIFwiPGJyPm1lYW46IFwiICsgKGVycm9yUmVzdWx0LmRfbWVhbiA9PT0gbnVsbCA/IG51bGwgOiBlcnJvclJlc3VsdC5kX21lYW4udG9QcmVjaXNpb24oNCkpICtcbiAgICAgICAgICAgICAgICBcIjxicj5uOiBcIiArIGVycm9yUmVzdWx0Lm5fZ29vZCArXG4gICAgICAgICAgICAgICAgLy8gXCI8YnI+bGFnMTogXCIgKyAoZXJyb3JSZXN1bHQubGFnMSA9PT0gbnVsbCA/IG51bGwgOiBlcnJvclJlc3VsdC5sYWcxLnRvUHJlY2lzaW9uKDQpKSArXG4gICAgICAgICAgICAgICAgLy8gXCI8YnI+c3RkZTogXCIgKyBlcnJvclJlc3VsdC5zdGRlX2JldHN5ICtcbiAgICAgICAgICAgICAgICBcIjxicj5lcnJvcmJhcnM6IFwiICsgTnVtYmVyKChkYXRhLnhbZGldKSAtIChlcnJvclJlc3VsdC5zdGRlX2JldHN5ICogMS45NikpLnRvUHJlY2lzaW9uKDQpICsgXCIgdG8gXCIgKyBOdW1iZXIoKGRhdGEueFtkaV0pICsgKGVycm9yUmVzdWx0LnN0ZGVfYmV0c3kgKiAxLjk2KSkudG9QcmVjaXNpb24oNCk7XG5cbiAgICAgICAgICAgIGRpKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmFibGUgZXJyb3IgYmFycyBpZiBtYXRjaGluZyBhbmQgdGhleSBhcmVuJ3QgbnVsbFxuICAgICAgICBpZiAoYXBwUGFyYW1zLm1hdGNoaW5nICYmIGRhdGEuZXJyb3JfeC5hcnJheS5maWx0ZXIoeCA9PiB4KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yX3gudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIG92ZXJhbGwgc3RhdHMgZm9yIHRoZSB0ZXh0IG91dHB1dCAtIHRoaXMgdXNlcyB0aGUgbWVhbnMgbm90IHRoZSBzdGF0cy5cbiAgICAgICAgY29uc3Qgc3RhdHMgPSBtYXRzRGF0YVV0aWxzLmdldF9lcnIodmFsdWVzLnJldmVyc2UoKSwgbGV2ZWxzLnJldmVyc2UoKSwgW10pOyAvLyBoYXZlIHRvIHJldmVyc2UgYmVjYXVzZSBvZiBkYXRhIGludmVyc2lvblxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1lYW5zID0gbWVhbnMuZmlsdGVyKHggPT4geCk7XG4gICAgICAgIHZhciBtaW54ID0gTWF0aC5taW4oLi4uZmlsdGVyZWRNZWFucyk7XG4gICAgICAgIHZhciBtYXh4ID0gTWF0aC5tYXgoLi4uZmlsdGVyZWRNZWFucyk7XG4gICAgICAgIGlmIChtZWFucy5pbmRleE9mKDApICE9PSAtMSAmJiAwIDwgbWlueCkge1xuICAgICAgICAgICAgbWlueCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lYW5zLmluZGV4T2YoMCkgIT09IC0xICYmIDAgPiBtYXh4KSB7XG4gICAgICAgICAgICBtYXh4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0cy5taW54ID0gbWlueDtcbiAgICAgICAgc3RhdHMubWF4eCA9IG1heHg7XG4gICAgICAgIGRhdGFzZXRbY3VydmVJbmRleF1bJ2dsb2Jfc3RhdHMnXSA9IHN0YXRzO1xuXG4gICAgICAgIC8vIHJlY2FsY3VsYXRlIGF4aXMgb3B0aW9ucyBhZnRlciBRQyBhbmQgbWF0Y2hpbmdcbiAgICAgICAgY3VydmVJbmZvUGFyYW1zLmF4aXNNYXBbY3VydmVJbmZvUGFyYW1zLmN1cnZlc1tjdXJ2ZUluZGV4XS5heGlzS2V5XVsneG1heCddID0gKGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV1bJ3htYXgnXSA8IG1heHggfHwgIWF4aXNMaW1pdFJlcHJvY2Vzc2VkW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV0pID8gbWF4eCA6IGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV1bJ3htYXgnXTtcbiAgICAgICAgY3VydmVJbmZvUGFyYW1zLmF4aXNNYXBbY3VydmVJbmZvUGFyYW1zLmN1cnZlc1tjdXJ2ZUluZGV4XS5heGlzS2V5XVsneG1pbiddID0gKGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV1bJ3htaW4nXSA+IG1pbnggfHwgIWF4aXNMaW1pdFJlcHJvY2Vzc2VkW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV0pID8gbWlueCA6IGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwW2N1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uYXhpc0tleV1bJ3htaW4nXTtcblxuICAgICAgICAvLyByZWNhbGN1bGF0ZSBjdXJ2ZSBhbm5vdGF0aW9uIGFmdGVyIFFDIGFuZCBtYXRjaGluZ1xuICAgICAgICBpZiAoc3RhdHMuZF9tZWFuICE9PSB1bmRlZmluZWQgJiYgc3RhdHMuZF9tZWFuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhc2V0W2N1cnZlSW5kZXhdWydhbm5vdGF0aW9uJ10gPSBsYWJlbCArIFwiLSBtZWFuID0gXCIgKyBzdGF0cy5kX21lYW4udG9QcmVjaXNpb24oNCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgYmxhY2sgMCBsaW5lIGN1cnZlXG4gICAgLy8gbmVlZCB0byBkZWZpbmUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0geCB2YWx1ZSBmb3IgbWFraW5nIHRoZSB6ZXJvIGN1cnZlXG4gICAgY29uc3QgemVyb0xpbmUgPSBtYXRzRGF0YUN1cnZlT3BzVXRpbHMuZ2V0VmVydGljYWxWYWx1ZUxpbmUoMTEwMCwgMCwgMCwgbWF0c1R5cGVzLlJlc2VydmVkV29yZHMuemVybyk7XG4gICAgZGF0YXNldC5wdXNoKHplcm9MaW5lKTtcblxuICAgIC8vYWRkIGlkZWFsIHZhbHVlIGxpbmVzLCBpZiBhbnlcbiAgICB2YXIgaWRlYWxWYWx1ZUxpbmU7XG4gICAgdmFyIGlkZWFsTGFiZWw7XG4gICAgZm9yICh2YXIgaXZJZHggPSAwOyBpdklkeCA8IGN1cnZlSW5mb1BhcmFtcy5pZGVhbFZhbHVlcy5sZW5ndGg7IGl2SWR4KyspIHtcbiAgICAgICAgaWRlYWxMYWJlbCA9IFwiaWRlYWxcIiArIGl2SWR4LnRvU3RyaW5nKCk7XG4gICAgICAgIGlkZWFsVmFsdWVMaW5lID0gbWF0c0RhdGFDdXJ2ZU9wc1V0aWxzLmdldFZlcnRpY2FsVmFsdWVMaW5lKDExMDAsIDAsIGN1cnZlSW5mb1BhcmFtcy5pZGVhbFZhbHVlc1tpdklkeF0sIG1hdHNUeXBlcy5SZXNlcnZlZFdvcmRzW2lkZWFsTGFiZWxdKTtcbiAgICAgICAgZGF0YXNldC5wdXNoKGlkZWFsVmFsdWVMaW5lKTtcbiAgICB9XG5cbiAgICAvLyBnZW5lcmF0ZSBwbG90IG9wdGlvbnNcbiAgICBjb25zdCByZXN1bHRPcHRpb25zID0gbWF0c0RhdGFQbG90T3BzVXRpbHMuZ2VuZXJhdGVQcm9maWxlUGxvdE9wdGlvbnMoZGF0YXNldCwgY3VydmVJbmZvUGFyYW1zLmN1cnZlcywgY3VydmVJbmZvUGFyYW1zLmF4aXNNYXAsIGVycm9yTWF4KTtcbiAgICB2YXIgdG90YWxQcm9jZXNzaW5nRmluaXNoID0gbW9tZW50KCk7XG4gICAgYm9va2tlZXBpbmdQYXJhbXMuZGF0YVJlcXVlc3RzW1widG90YWwgcmV0cmlldmFsIGFuZCBwcm9jZXNzaW5nIHRpbWUgZm9yIGN1cnZlIHNldFwiXSA9IHtcbiAgICAgICAgYmVnaW46IGJvb2trZWVwaW5nUGFyYW1zLnRvdGFsUHJvY2Vzc2luZ1N0YXJ0LmZvcm1hdCgpLFxuICAgICAgICBmaW5pc2g6IHRvdGFsUHJvY2Vzc2luZ0ZpbmlzaC5mb3JtYXQoKSxcbiAgICAgICAgZHVyYXRpb246IG1vbWVudC5kdXJhdGlvbih0b3RhbFByb2Nlc3NpbmdGaW5pc2guZGlmZihib29ra2VlcGluZ1BhcmFtcy50b3RhbFByb2Nlc3NpbmdTdGFydCkpLmFzU2Vjb25kcygpICsgJyBzZWNvbmRzJ1xuICAgIH07XG5cbiAgICAvLyBwYXNzIHJlc3VsdCB0byBjbGllbnQtc2lkZSBwbG90dGluZyBmdW5jdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGRhdGE6IGRhdGFzZXQsXG4gICAgICAgIG9wdGlvbnM6IHJlc3VsdE9wdGlvbnMsXG4gICAgICAgIGJhc2lzOiB7XG4gICAgICAgICAgICBwbG90UGFyYW1zOiBwbG90UGFyYW1zLFxuICAgICAgICAgICAgcXVlcmllczogYm9va2tlZXBpbmdQYXJhbXMuZGF0YVJlcXVlc3RzXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgcHJvY2Vzc0RhdGFSZWxpYWJpbGl0eSA9IGZ1bmN0aW9uIChkYXRhc2V0LCBhcHBQYXJhbXMsIGN1cnZlSW5mb1BhcmFtcywgcGxvdFBhcmFtcywgYm9va2tlZXBpbmdQYXJhbXMpIHtcbiAgICB2YXIgZXJyb3IgPSBcIlwiO1xuXG4gICAgLy8gY2FsY3VsYXRlIGRhdGEgc3RhdGlzdGljcyAoaW5jbHVkaW5nIGVycm9yIGJhcnMpIGZvciBlYWNoIGN1cnZlXG4gICAgZm9yICh2YXIgY3VydmVJbmRleCA9IDA7IGN1cnZlSW5kZXggPCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzTGVuZ3RoOyBjdXJ2ZUluZGV4KyspIHtcblxuICAgICAgICB2YXIgZGF0YSA9IGRhdGFzZXRbY3VydmVJbmRleF07XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZGF0YXNldFtjdXJ2ZUluZGV4XS5sYWJlbDtcblxuICAgICAgICB2YXIgc2FtcGxlX2NsaW1vID0gZGF0YS5zdWJWYWxzO1xuICAgICAgICB2YXIgZGkgPSAwO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGRhdGFzZXRbY3VydmVJbmRleF0gaXMgdGhlIGRhdGFzZXQuXG4gICAgICAgIGl0IGxvb2tzIGxpa2U6XG5cbiAgICAgICAgZCA9IHtcbiAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICBlcnJvcl94OiBbXSwgICAvLyBjdXJ2ZVRpbWVcbiAgICAgICAgICAgIGVycm9yX3k6IFtdLCAgIC8vIHZhbHVlc1xuICAgICAgICAgICAgc3ViVmFsczogW10sICAgLy9zdWJWYWxzXG4gICAgICAgICAgICBzdWJTZWNzOiBbXSwgICAvL3N1YlNlY3NcbiAgICAgICAgICAgIHN1YkxldnM6IFtdLCAgIC8vc3ViTGV2c1xuICAgICAgICAgICAgc3RhdHM6IFtdLCAgICAgLy9wb2ludFN0YXRzXG4gICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgIGdsb2Jfc3RhdHM6IHt9LCAgICAgLy9jdXJ2ZVN0YXRzXG4gICAgICAgICAgICB4bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgeG1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIHltaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB5bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAgICAgc3VtOiAwXG4gICAgICAgIH07XG4gICAgICAgICovXG5cbiAgICAgICAgd2hpbGUgKGRpIDwgZGF0YS54Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBzdG9yZSBzdGF0aXN0aWNzIGZvciB0aGlzIGRpIGRhdGFwb2ludFxuICAgICAgICAgICAgZGF0YS5zdGF0c1tkaV0gPSB7XG4gICAgICAgICAgICAgICAgcHJvYl9iaW46IGRhdGEueFtkaV0sXG4gICAgICAgICAgICAgICAgaGl0X3JhdGU6IGRhdGEueVtkaV0sXG4gICAgICAgICAgICAgICAgb2JzX3k6IGRhdGEuZXJyb3JfeFtkaV0sXG4gICAgICAgICAgICAgICAgb2JzX246IGRhdGEuc3ViTGV2c1tkaV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHRvb2x0aXAsIGl0IGlzIHRoZSBsYXN0IGVsZW1lbnQgb2YgZWFjaCBkYXRhc2VyaWVzIGVsZW1lbnQuXG4gICAgICAgICAgICAvLyBhbHNvIGNoYW5nZSB0aGUgeCBhcnJheSBmcm9tIGVwb2NoIHRvIGRhdGUgZm9yIHRpbWVzZXJpZXMgYW5kIERNQywgYXMgd2UgYXJlIG5vdyBkb25lIHdpdGggaXQgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgICAgIGRhdGEudGV4dFtkaV0gPSBsYWJlbDtcbiAgICAgICAgICAgIGRhdGEudGV4dFtkaV0gPSBkYXRhLnRleHRbZGldICsgXCI8YnI+cHJvYmFiaWxpdHkgYmluOiBcIiArIGRhdGEueFtkaV07XG4gICAgICAgICAgICBkYXRhLnRleHRbZGldID0gZGF0YS50ZXh0W2RpXSArIFwiPGJyPmhpdCByYXRlOiBcIiArIGRhdGEueVtkaV07XG4gICAgICAgICAgICBkYXRhLnRleHRbZGldID0gZGF0YS50ZXh0W2RpXSArIFwiPGJyPm95OiBcIiArIGRhdGEuZXJyb3JfeFtkaV07XG4gICAgICAgICAgICBkYXRhLnRleHRbZGldID0gZGF0YS50ZXh0W2RpXSArIFwiPGJyPm9uOiBcIiArIGRhdGEuc3ViTGV2c1tkaV07XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBzdWIgdmFsdWVzIGFuZCB0aW1lcyB0byBzYXZlIHNwYWNlXG4gICAgICAgICAgICBkYXRhLnN1YlZhbHNbZGldID0gW107XG4gICAgICAgICAgICBkYXRhLnN1YlNlY3NbZGldID0gW107XG4gICAgICAgICAgICBkYXRhLnN1YkxldnNbZGldID0gW107XG5cbiAgICAgICAgICAgIGRpKys7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhc2V0W2N1cnZlSW5kZXhdWydnbG9iX3N0YXRzJ10gPSB7XG4gICAgICAgICAgICBzYW1wbGVfY2xpbW86IHNhbXBsZV9jbGltb1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGFkZCBibGFjayBwZXJmZWN0IHJlbGlhYmlsaXR5IGxpbmUgY3VydmVcbiAgICBjb25zdCBwZXJmZWN0TGluZSA9IG1hdHNEYXRhQ3VydmVPcHNVdGlscy5nZXRMaW5lYXJWYWx1ZUxpbmUoY3VydmVJbmZvUGFyYW1zLnhtYXgsIGN1cnZlSW5mb1BhcmFtcy54bWluLCBkYXRhLnltYXgsIGRhdGEueW1pbiwgbWF0c1R5cGVzLlJlc2VydmVkV29yZHMucGVyZmVjdFJlbGlhYmlsaXR5KTtcbiAgICBkYXRhc2V0LnB1c2gocGVyZmVjdExpbmUpO1xuXG4gICAgaWYgKHNhbXBsZV9jbGltbyA+PSBkYXRhLnltaW4pIHtcbiAgICAgICAgdmFyIHNraWxsbWluID0gc2FtcGxlX2NsaW1vIC0gKChzYW1wbGVfY2xpbW8gLSBkYXRhLnhtaW4pIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNraWxsbWluID0gZGF0YS54bWluIC0gKChkYXRhLnhtaW4gLSBzYW1wbGVfY2xpbW8pIC8gMik7XG4gICAgfVxuICAgIGlmIChzYW1wbGVfY2xpbW8gPj0gZGF0YS55bWF4KSB7XG4gICAgICAgIHZhciBza2lsbG1heCA9IHNhbXBsZV9jbGltbyAtICgoc2FtcGxlX2NsaW1vIC0gZGF0YS54bWF4KSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBza2lsbG1heCA9IGRhdGEueG1heCAtICgoZGF0YS54bWF4IC0gc2FtcGxlX2NsaW1vKSAvIDIpO1xuICAgIH1cblxuXG4gICAgLy8gYWRkIGJsYWNrIG5vIHNraWxsIGxpbmUgY3VydmVcbiAgICBjb25zdCBub1NraWxsTGluZSA9IG1hdHNEYXRhQ3VydmVPcHNVdGlscy5nZXRMaW5lYXJWYWx1ZUxpbmUoY3VydmVJbmZvUGFyYW1zLnhtYXgsIGN1cnZlSW5mb1BhcmFtcy54bWluLCBza2lsbG1heCwgc2tpbGxtaW4sIG1hdHNUeXBlcy5SZXNlcnZlZFdvcmRzLm5vU2tpbGwpO1xuICAgIGRhdGFzZXQucHVzaChub1NraWxsTGluZSk7XG5cbiAgICAvLyBhZGQgc2FtcGxlIGNsaW1vIGxpbmVzXG4gICAgLy8gbmVlZCB0byBkZWZpbmUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0geCB2YWx1ZSBmb3IgbWFraW5nIHRoZSBjdXJ2ZXNcbiAgICBjb25zdCB4Q2xpbW9MaW5lID0gbWF0c0RhdGFDdXJ2ZU9wc1V0aWxzLmdldEhvcml6b250YWxWYWx1ZUxpbmUoY3VydmVJbmZvUGFyYW1zLnhtYXgsIGN1cnZlSW5mb1BhcmFtcy54bWluLCBzYW1wbGVfY2xpbW8sIG1hdHNUeXBlcy5SZXNlcnZlZFdvcmRzLnplcm8pO1xuICAgIGRhdGFzZXQucHVzaCh4Q2xpbW9MaW5lKTtcblxuICAgIGNvbnN0IHlDbGltb0xpbmUgPSBtYXRzRGF0YUN1cnZlT3BzVXRpbHMuZ2V0VmVydGljYWxWYWx1ZUxpbmUoY3VydmVJbmZvUGFyYW1zLnhtYXgsIGN1cnZlSW5mb1BhcmFtcy54bWluLCBzYW1wbGVfY2xpbW8sIG1hdHNUeXBlcy5SZXNlcnZlZFdvcmRzLnplcm8pO1xuICAgIGRhdGFzZXQucHVzaCh5Q2xpbW9MaW5lKTtcblxuICAgIC8vIGdlbmVyYXRlIHBsb3Qgb3B0aW9uc1xuICAgIHZhciByZXN1bHRPcHRpb25zID0gbWF0c0RhdGFQbG90T3BzVXRpbHMuZ2VuZXJhdGVSZWxpYWJpbGl0eVBsb3RPcHRpb25zKCk7XG5cbiAgICB2YXIgdG90YWxQcm9jZXNzaW5nRmluaXNoID0gbW9tZW50KCk7XG4gICAgYm9va2tlZXBpbmdQYXJhbXMuZGF0YVJlcXVlc3RzW1widG90YWwgcmV0cmlldmFsIGFuZCBwcm9jZXNzaW5nIHRpbWUgZm9yIGN1cnZlIHNldFwiXSA9IHtcbiAgICAgICAgYmVnaW46IGJvb2trZWVwaW5nUGFyYW1zLnRvdGFsUHJvY2Vzc2luZ1N0YXJ0LmZvcm1hdCgpLFxuICAgICAgICBmaW5pc2g6IHRvdGFsUHJvY2Vzc2luZ0ZpbmlzaC5mb3JtYXQoKSxcbiAgICAgICAgZHVyYXRpb246IG1vbWVudC5kdXJhdGlvbih0b3RhbFByb2Nlc3NpbmdGaW5pc2guZGlmZihib29ra2VlcGluZ1BhcmFtcy50b3RhbFByb2Nlc3NpbmdTdGFydCkpLmFzU2Vjb25kcygpICsgJyBzZWNvbmRzJ1xuICAgIH07XG5cbiAgICAvLyBwYXNzIHJlc3VsdCB0byBjbGllbnQtc2lkZSBwbG90dGluZyBmdW5jdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGRhdGE6IGRhdGFzZXQsXG4gICAgICAgIG9wdGlvbnM6IHJlc3VsdE9wdGlvbnMsXG4gICAgICAgIGJhc2lzOiB7XG4gICAgICAgICAgICBwbG90UGFyYW1zOiBwbG90UGFyYW1zLFxuICAgICAgICAgICAgcXVlcmllczogYm9va2tlZXBpbmdQYXJhbXMuZGF0YVJlcXVlc3RzXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgcHJvY2Vzc0RhdGFIaXN0b2dyYW0gPSBmdW5jdGlvbiAoYWxsUmV0dXJuZWRTdWJTdGF0cywgYWxsUmV0dXJuZWRTdWJTZWNzLCBhbGxSZXR1cm5lZFN1YkxldnMsIGRhdGFzZXQsIGFwcFBhcmFtcywgY3VydmVJbmZvUGFyYW1zLCBwbG90UGFyYW1zLCBiaW5QYXJhbXMsIGJvb2trZWVwaW5nUGFyYW1zKSB7XG4gICAgdmFyIGVycm9yID0gXCJcIjtcbiAgICB2YXIgY3VydmVzTGVuZ3RoU29GYXIgPSAwO1xuXG4gICAgLy8gZmxhdHRlbiBhbGwgdGhlIHJldHVybmVkIGRhdGEgaW50byBvbmUgc3RhdHMgYXJyYXkgYW5kIG9uZSBzZWNzIGFycmF5IGluIG9yZGVyIHRvIGNhbGN1bGF0ZSBoaXN0b2dyYW0gYmlucyBvdmVyIHRoZSB3aG9sZSByYW5nZS5cbiAgICBjb25zdCBjdXJ2ZVN1YlN0YXRzID0gW10uY29uY2F0LmFwcGx5KFtdLCBhbGxSZXR1cm5lZFN1YlN0YXRzKTtcbiAgICBjb25zdCBjdXJ2ZVN1YlNlY3MgPSBbXS5jb25jYXQuYXBwbHkoW10sIGFsbFJldHVybmVkU3ViU2Vjcyk7XG5cbiAgICB2YXIgYmluU3RhdHM7XG4gICAgaWYgKGJpblBhcmFtcy5iaW5Cb3VuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJpblN0YXRzID0gbWF0c0RhdGFVdGlscy5jYWxjdWxhdGVIaXN0b2dyYW1CaW5zKGN1cnZlU3ViU3RhdHMsIGN1cnZlU3ViU2VjcywgYmluUGFyYW1zKS5iaW5TdGF0cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBiaW5TdGF0cyA9IG1hdHNEYXRhVXRpbHMucHJlc2NyaWJlSGlzdG9ncmFtQmlucyhjdXJ2ZVN1YlN0YXRzLCBjdXJ2ZVN1YlNlY3MsIGJpblBhcmFtcykuYmluU3RhdHM7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgYmluIGxhYmVscyBhbmQgeC1heGlzIHBvc2l0aW9ucyBvZiB0aG9zZSBsYWJlbHMgZm9yIGxhdGVyIHdoZW4gd2Ugc2V0IHVwIHRoZSBwbG90IG9wdGlvbnNcbiAgICB2YXIgcGxvdEJpbnMgPSB7fTtcbiAgICBwbG90Qmluc1snYmluTWVhbnMnXSA9IFtdO1xuICAgIHBsb3RCaW5zWydiaW5MYWJlbHMnXSA9IFtdO1xuICAgIGZvciAodmFyIGJfaWR4ID0gMDsgYl9pZHggPCBiaW5TdGF0cy5iaW5NZWFucy5sZW5ndGg7IGJfaWR4KyspIHtcbiAgICAgICAgcGxvdEJpbnNbJ2Jpbk1lYW5zJ10ucHVzaChiaW5TdGF0cy5iaW5NZWFuc1tiX2lkeF0pO1xuICAgICAgICBwbG90Qmluc1snYmluTGFiZWxzJ10ucHVzaChiaW5TdGF0cy5iaW5MYWJlbHNbYl9pZHhdKTtcbiAgICB9XG5cbiAgICAvLyBwb3N0IHByb2Nlc3MgY3VydmVzXG4gICAgdmFyIHNvcnRlZERhdGE7XG4gICAgdmFyIGN1cnZlO1xuICAgIHZhciBkaWZmRnJvbTtcbiAgICB2YXIgbGFiZWw7XG4gICAgZm9yICh2YXIgY3VydmVJbmRleCA9IDA7IGN1cnZlSW5kZXggPCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzTGVuZ3RoOyBjdXJ2ZUluZGV4KyspIHtcbiAgICAgICAgY3VydmUgPSBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdO1xuICAgICAgICBkaWZmRnJvbSA9IGN1cnZlLmRpZmZGcm9tO1xuICAgICAgICBsYWJlbCA9IGN1cnZlLmxhYmVsO1xuXG4gICAgICAgIHZhciBkID0gey8vIGQgd2lsbCBjb250YWluIHRoZSBjdXJ2ZSBkYXRhXG4gICAgICAgICAgICB4OiBbXSwgLy9wbGFjZWhvbGRlclxuICAgICAgICAgICAgeTogW10sIC8vcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGVycm9yX3g6IFtdLCAvLyB1bnVzZWRcbiAgICAgICAgICAgIGVycm9yX3k6IFtdLCAvLyB1bnVzZWRcbiAgICAgICAgICAgIHN1YlZhbHM6IFtdLFxuICAgICAgICAgICAgc3ViU2VjczogW10sXG4gICAgICAgICAgICBzdWJMZXZzOiBbXSxcbiAgICAgICAgICAgIGdsb2Jfc3RhdHM6IHt9LCAvLyBwbGFjZWhvbGRlclxuICAgICAgICAgICAgYmluX3N0YXRzOiBbXSwgLy8gcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHRleHQ6IFtdLCAvL3BsYWNlaG9sZGVyXG4gICAgICAgICAgICB4bWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgeG1heDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIHltaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB5bWF4OiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkaWZmRnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcG9zdFF1ZXJ5U3RhcnRNb21lbnQgPSBtb21lbnQoKTtcbiAgICAgICAgICAgIGlmIChjdXJ2ZUluZm9QYXJhbXMuZGF0YUZvdW5kRm9yQ3VydmVbY3VydmVJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvLyBzb3J0IHF1ZXJpZWQgZGF0YSBpbnRvIHRoZSBmdWxsIHNldCBvZiBoaXN0b2dyYW0gYmluc1xuICAgICAgICAgICAgICAgIHNvcnRlZERhdGEgPSBtYXRzRGF0YVV0aWxzLnNvcnRIaXN0b2dyYW1CaW5zKGFsbFJldHVybmVkU3ViU3RhdHNbY3VydmVJbmRleF0sIGFsbFJldHVybmVkU3ViU2Vjc1tjdXJ2ZUluZGV4XSwgYWxsUmV0dXJuZWRTdWJMZXZzW2N1cnZlSW5kZXhdLCBiaW5QYXJhbXMuYmluTnVtLCBiaW5TdGF0cywgYXBwUGFyYW1zLmhhc0xldmVscywgZCk7XG4gICAgICAgICAgICAgICAgZCA9IHNvcnRlZERhdGEuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBkaWZmZXJlbmNlIGN1cnZlLCBzbyB3ZSdyZSBkb25lIHdpdGggcmVndWxhciBjdXJ2ZXMuXG4gICAgICAgICAgICAvLyBkbyBhbnkgbWF0Y2hpbmcgdGhhdCBuZWVkcyB0byBiZSBkb25lLlxuICAgICAgICAgICAgaWYgKGFwcFBhcmFtcy5tYXRjaGluZyAmJiAhYm9va2tlZXBpbmdQYXJhbXMuYWxyZWFkeU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwUGFyYW1zLmhhc0xldmVscykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0ID0gbWF0c0RhdGFNYXRjaFV0aWxzLmdldE1hdGNoZWREYXRhU2V0SGlzdG9ncmFtV2l0aExldmVscyhkYXRhc2V0LCBjdXJ2ZXNMZW5ndGhTb0ZhciwgYmluU3RhdHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXQgPSBtYXRzRGF0YU1hdGNoVXRpbHMuZ2V0TWF0Y2hlZERhdGFTZXRIaXN0b2dyYW0oZGF0YXNldCwgY3VydmVzTGVuZ3RoU29GYXIsIGJpblN0YXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9va2tlZXBpbmdQYXJhbXMuYWxyZWFkeU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGVuIHRha2UgZGlmZnNcbiAgICAgICAgICAgIGNvbnN0IGRpZmZSZXN1bHQgPSBtYXRzRGF0YURpZmZVdGlscy5nZXREYXRhRm9yRGlmZkN1cnZlKGRhdGFzZXQsIGRpZmZGcm9tLCBtYXRzVHlwZXMuUGxvdFR5cGVzLmhpc3RvZ3JhbSwgYXBwUGFyYW1zLmhhc0xldmVscyk7XG5cbiAgICAgICAgICAgIC8vIGFkanVzdCBheGlzIHN0YXRzIGJhc2VkIG9uIG5ldyBkYXRhIGZyb20gZGlmZiBjdXJ2ZVxuICAgICAgICAgICAgZCA9IGRpZmZSZXN1bHQuZGF0YXNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjdXJ2ZSBhbm5vdGF0aW9uIHRvIGJlIHRoZSBjdXJ2ZSBtZWFuIC0tIG1heSBiZSByZWNhbGN1bGF0ZWQgbGF0ZXJcbiAgICAgICAgLy8gYWxzbyBwYXNzIHByZXZpb3VzbHkgY2FsY3VsYXRlZCBheGlzIHN0YXRzIHRvIGN1cnZlIG9wdGlvbnNcbiAgICAgICAgY3VydmVbJ2Fubm90YXRpb24nXSA9IFwiXCI7XG4gICAgICAgIGN1cnZlWydheGlzS2V5J10gPSBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzW2N1cnZlSW5kZXhdLmF4aXNLZXk7XG4gICAgICAgIGNvbnN0IGNPcHRpb25zID0gbWF0c0RhdGFDdXJ2ZU9wc1V0aWxzLmdlbmVyYXRlQmFyQ2hhcnRDdXJ2ZU9wdGlvbnMoY3VydmUsIGN1cnZlSW5kZXgsIGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwLCBkKTsgIC8vIGdlbmVyYXRlIHBsb3Qgd2l0aCBkYXRhLCBjdXJ2ZSBhbm5vdGF0aW9uLCBheGlzIGxhYmVscywgZXRjLlxuICAgICAgICBkYXRhc2V0LnB1c2goY09wdGlvbnMpO1xuICAgICAgICBjdXJ2ZXNMZW5ndGhTb0ZhcisrO1xuICAgICAgICB2YXIgcG9zdFF1ZXJ5RmluaXNoTW9tZW50ID0gbW9tZW50KCk7XG4gICAgICAgIGJvb2trZWVwaW5nUGFyYW1zLmRhdGFSZXF1ZXN0c1tcInBvc3QgZGF0YSByZXRyaWV2YWwgKHF1ZXJ5KSBwcm9jZXNzIHRpbWUgLSBcIiArIGN1cnZlLmxhYmVsXSA9IHtcbiAgICAgICAgICAgIGJlZ2luOiBwb3N0UXVlcnlTdGFydE1vbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIGZpbmlzaDogcG9zdFF1ZXJ5RmluaXNoTW9tZW50LmZvcm1hdCgpLFxuICAgICAgICAgICAgZHVyYXRpb246IG1vbWVudC5kdXJhdGlvbihwb3N0UXVlcnlGaW5pc2hNb21lbnQuZGlmZihwb3N0UXVlcnlTdGFydE1vbWVudCkpLmFzU2Vjb25kcygpICsgJyBzZWNvbmRzJ1xuICAgICAgICB9XG4gICAgfSAgLy8gZW5kIGZvciBjdXJ2ZXNcblxuICAgIC8vIGlmIG1hdGNoaW5nLCBwYXJlIGRvd24gZGF0YXNldCB0byBvbmx5IG1hdGNoaW5nIGRhdGEuIE9ubHkgZG8gdGhpcyBpZiB3ZSBkaWRuJ3QgYWxyZWFkeSBkbyBpdCB3aGlsZSBjYWxjdWxhdGluZyBkaWZmcy5cbiAgICBpZiAoY3VydmVJbmZvUGFyYW1zLmN1cnZlc0xlbmd0aCA+IDEgJiYgKGFwcFBhcmFtcy5tYXRjaGluZyAmJiAhYm9va2tlZXBpbmdQYXJhbXMuYWxyZWFkeU1hdGNoZWQpKSB7XG4gICAgICAgIGlmIChhcHBQYXJhbXMuaGFzTGV2ZWxzKSB7XG4gICAgICAgICAgICBkYXRhc2V0ID0gbWF0c0RhdGFNYXRjaFV0aWxzLmdldE1hdGNoZWREYXRhU2V0SGlzdG9ncmFtV2l0aExldmVscyhkYXRhc2V0LCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzTGVuZ3RoLCBiaW5TdGF0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhc2V0ID0gbWF0c0RhdGFNYXRjaFV0aWxzLmdldE1hdGNoZWREYXRhU2V0SGlzdG9ncmFtKGRhdGFzZXQsIGN1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNMZW5ndGgsIGJpblN0YXRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIHN0YXRpc3RpY3MgKGluY2x1ZGluZyBlcnJvciBiYXJzKSBmb3IgZWFjaCBjdXJ2ZVxuICAgIGZvciAoY3VydmVJbmRleCA9IDA7IGN1cnZlSW5kZXggPCBjdXJ2ZUluZm9QYXJhbXMuY3VydmVzTGVuZ3RoOyBjdXJ2ZUluZGV4KyspIHtcbiAgICAgICAgdmFyIHN0YXRpc3RpY1NlbGVjdCA9IGN1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF1bJ3N0YXRpc3RpYyddO1xuICAgICAgICBkaWZmRnJvbSA9IGN1cnZlSW5mb1BhcmFtcy5jdXJ2ZXNbY3VydmVJbmRleF0uZGlmZkZyb207XG4gICAgICAgIHZhciBkYXRhID0gZGF0YXNldFtjdXJ2ZUluZGV4XTtcbiAgICAgICAgbGFiZWwgPSBkYXRhc2V0W2N1cnZlSW5kZXhdLmxhYmVsO1xuXG4gICAgICAgIHZhciBkaSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGRpIDwgZGF0YS54Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoY3VydmVJbmZvUGFyYW1zLnlBeGlzRm9ybWF0ID09PSAnUmVsYXRpdmUgZnJlcXVlbmN5Jykge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGJpbiBudW1iZXIgd2l0aCB0aGUgYmluIHJlbGF0aXZlIGZyZXF1ZW5jeSBmb3IgdGhlIHBsb3R0ZWQgc3RhdGlzdGljXG4gICAgICAgICAgICAgICAgZGF0YS55W2RpXSA9IGRhdGEuYmluX3N0YXRzW2RpXS5iaW5fcmYgKiAxMDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBzdWIgdmFsdWVzIGFuZCB0aW1lcyB0byBzYXZlIHNwYWNlXG4gICAgICAgICAgICBkYXRhLnN1YlZhbHNbZGldID0gW107XG4gICAgICAgICAgICBkYXRhLnN1YlNlY3NbZGldID0gW107XG4gICAgICAgICAgICBkYXRhLnN1YkxldnNbZGldID0gW107XG5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHRvb2x0aXAsIGl0IGlzIHRoZSBsYXN0IGVsZW1lbnQgb2YgZWFjaCBkYXRhc2VyaWVzIGVsZW1lbnRcbiAgICAgICAgICAgIGRhdGEudGV4dFtkaV0gPSBsYWJlbCArXG4gICAgICAgICAgICAgICAgXCI8YnI+XCIgKyBcImJpbjogXCIgKyBkaSArIFwiIChcIiArIHN0YXRpc3RpY1NlbGVjdCArIFwiIHZhbHVlcyBiZXR3ZWVuIFwiICsgKGRhdGEuYmluX3N0YXRzW2RpXS5iaW5Mb3dCb3VuZCA9PT0gbnVsbCA/IG51bGwgOiBkYXRhLmJpbl9zdGF0c1tkaV0uYmluTG93Qm91bmQudG9QcmVjaXNpb24oNCkpICsgXCIgYW5kIFwiICsgKGRhdGEuYmluX3N0YXRzW2RpXS5iaW5VcEJvdW5kID09PSBudWxsID8gbnVsbCA6IGRhdGEuYmluX3N0YXRzW2RpXS5iaW5VcEJvdW5kLnRvUHJlY2lzaW9uKDQpKSArIFwiKVwiICtcbiAgICAgICAgICAgICAgICBcIjxicj5cIiArIFwibnVtYmVyIGluIGJpbiBmb3IgdGhpcyBjdXJ2ZTogXCIgKyAoZGF0YS55W2RpXSA9PT0gbnVsbCA/IG51bGwgOiBkYXRhLnlbZGldKSArXG4gICAgICAgICAgICAgICAgXCI8YnI+YmluIG1lYW4gZm9yIHRoaXMgY3VydmU6IFwiICsgc3RhdGlzdGljU2VsZWN0ICsgXCIgPSBcIiArIChkYXRhLmJpbl9zdGF0c1tkaV0uYmluX21lYW4gPT09IG51bGwgPyBudWxsIDogZGF0YS5iaW5fc3RhdHNbZGldLmJpbl9tZWFuLnRvUHJlY2lzaW9uKDQpKSArXG4gICAgICAgICAgICAgICAgXCI8YnI+YmluIHNkICBmb3IgdGhpcyBjdXJ2ZTogXCIgKyBzdGF0aXN0aWNTZWxlY3QgKyBcIiA9IFwiICsgKGRhdGEuYmluX3N0YXRzW2RpXS5iaW5fc2QgPT09IG51bGwgPyBudWxsIDogZGF0YS5iaW5fc3RhdHNbZGldLmJpbl9zZC50b1ByZWNpc2lvbig0KSk7XG5cbiAgICAgICAgICAgIGRpKys7XG4gICAgICAgIH1cbiAgICB9IC8vIGVuZCBjdXJ2ZXNcblxuICAgIC8vIGdlbmVyYXRlIHBsb3Qgb3B0aW9uc1xuICAgIGNvbnN0IHJlc3VsdE9wdGlvbnMgPSBtYXRzRGF0YVBsb3RPcHNVdGlscy5nZW5lcmF0ZUhpc3RvZ3JhbVBsb3RPcHRpb25zKGRhdGFzZXQsIGN1cnZlSW5mb1BhcmFtcy5jdXJ2ZXMsIGN1cnZlSW5mb1BhcmFtcy5heGlzTWFwLCBwbG90Qmlucyk7XG4gICAgdmFyIHRvdGFsUHJvY2Vzc2luZ0ZpbmlzaCA9IG1vbWVudCgpO1xuICAgIGJvb2trZWVwaW5nUGFyYW1zLmRhdGFSZXF1ZXN0c1tcInRvdGFsIHJldHJpZXZhbCBhbmQgcHJvY2Vzc2luZyB0aW1lIGZvciBjdXJ2ZSBzZXRcIl0gPSB7XG4gICAgICAgIGJlZ2luOiBib29ra2VlcGluZ1BhcmFtcy50b3RhbFByb2Nlc3NpbmdTdGFydC5mb3JtYXQoKSxcbiAgICAgICAgZmluaXNoOiB0b3RhbFByb2Nlc3NpbmdGaW5pc2guZm9ybWF0KCksXG4gICAgICAgIGR1cmF0aW9uOiBtb21lbnQuZHVyYXRpb24odG90YWxQcm9jZXNzaW5nRmluaXNoLmRpZmYoYm9va2tlZXBpbmdQYXJhbXMudG90YWxQcm9jZXNzaW5nU3RhcnQpKS5hc1NlY29uZHMoKSArICcgc2Vjb25kcydcbiAgICB9O1xuXG4gICAgLy8gcGFzcyByZXN1bHQgdG8gY2xpZW50LXNpZGUgcGxvdHRpbmcgZnVuY3Rpb25zXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBkYXRhOiBkYXRhc2V0LFxuICAgICAgICBvcHRpb25zOiByZXN1bHRPcHRpb25zLFxuICAgICAgICBiYXNpczoge1xuICAgICAgICAgICAgcGxvdFBhcmFtczogcGxvdFBhcmFtcyxcbiAgICAgICAgICAgIHF1ZXJpZXM6IGJvb2trZWVwaW5nUGFyYW1zLmRhdGFSZXF1ZXN0c1xuICAgICAgICB9XG4gICAgfTtcblxufTtcblxuY29uc3QgcHJvY2Vzc0RhdGFDb250b3VyID0gZnVuY3Rpb24gKGRhdGFzZXQsIGN1cnZlSW5mb1BhcmFtcywgcGxvdFBhcmFtcywgYm9va2tlZXBpbmdQYXJhbXMpIHtcbiAgICB2YXIgZXJyb3IgPSBcIlwiO1xuICAgIGNvbnN0IGFwcE5hbWUgPSBtYXRzQ29sbGVjdGlvbnMuYXBwTmFtZS5maW5kT25lKHt9KS5hcHA7XG4gICAgdmFyIHN0YXRpc3RpY1NlbGVjdCA9IGFwcE5hbWUuaW5kZXhPZihcImFub21hbHljb3JcIikgIT09IC0xID8gXCJBQ0NcIiA6IGN1cnZlSW5mb1BhcmFtcy5jdXJ2ZVswXVsnc3RhdGlzdGljJ107XG4gICAgdmFyIGRhdGEgPSBkYXRhc2V0WzBdO1xuICAgIGNvbnN0IGxhYmVsID0gZGF0YXNldFswXS5sYWJlbDtcblxuICAgIGlmIChkYXRhLnhBeGlzS2V5LmluZGV4T2YoXCJEYXRlXCIpICE9PSAtMSkge1xuICAgICAgICBkYXRhLnggPSBkYXRhLngubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQudXRjKHZhbCAqIDEwMDApLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW1cIik7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGF0YS55QXhpc0tleS5pbmRleE9mKFwiRGF0ZVwiKSAhPT0gLTEpIHtcbiAgICAgICAgZGF0YS55ID0gZGF0YS55Lm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LnV0Yyh2YWwgKiAxMDAwKS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgajtcbiAgICB2YXIgY3Vyclg7XG4gICAgdmFyIGN1cnJZO1xuICAgIHZhciBjdXJyVGV4dDtcbiAgICB2YXIgY3VycllUZXh0QXJyYXk7XG4gICAgZm9yIChqID0gMDsgaiA8IGRhdGEueS5sZW5ndGg7IGorKykge1xuICAgICAgICBjdXJyWSA9IGRhdGEueVtqXTtcbiAgICAgICAgY3VycllUZXh0QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEueC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VyclggPSBkYXRhLnhbaV07XG4gICAgICAgICAgICBjdXJyVGV4dCA9IGxhYmVsICtcbiAgICAgICAgICAgICAgICBcIjxicj5cIiArIGRhdGFbJ3hBeGlzS2V5J10gKyBcIjogXCIgKyBkYXRhLnhbaV0gK1xuICAgICAgICAgICAgICAgIFwiPGJyPlwiICsgZGF0YVsneUF4aXNLZXknXSArIFwiOiBcIiArIGRhdGEueVtqXSArXG4gICAgICAgICAgICAgICAgXCI8YnI+XCIgKyBzdGF0aXN0aWNTZWxlY3QgKyBcIjogXCIgKyAoZGF0YS56W2pdW2ldID09PSB1bmRlZmluZWQgfHwgZGF0YS56W2pdW2ldID09PSBudWxsIHx8IGRhdGEueltqXVtpXSA9PT0gJ251bGwnID8gbnVsbCA6IGRhdGEueltqXVtpXS50b1ByZWNpc2lvbig0KSkgK1xuICAgICAgICAgICAgICAgIFwiPGJyPm46IFwiICsgZGF0YVsnbiddW2pdW2ldO1xuICAgICAgICAgICAgY3VycllUZXh0QXJyYXkucHVzaChjdXJyVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS50ZXh0LnB1c2goY3VycllUZXh0QXJyYXkpO1xuICAgIH1cblxuICAgIC8vIGdlbmVyYXRlIHBsb3Qgb3B0aW9uc1xuICAgIGNvbnN0IHJlc3VsdE9wdGlvbnMgPSBtYXRzRGF0YVBsb3RPcHNVdGlscy5nZW5lcmF0ZUNvbnRvdXJQbG90T3B0aW9ucyhkYXRhc2V0LCBjdXJ2ZUluZm9QYXJhbXMuYXhpc01hcCk7XG5cbiAgICB2YXIgdG90YWxQcm9jZXNzaW5nRmluaXNoID0gbW9tZW50KCk7XG4gICAgYm9va2tlZXBpbmdQYXJhbXMuZGF0YVJlcXVlc3RzW1widG90YWwgcmV0cmlldmFsIGFuZCBwcm9jZXNzaW5nIHRpbWUgZm9yIGN1cnZlIHNldFwiXSA9IHtcbiAgICAgICAgYmVnaW46IGJvb2trZWVwaW5nUGFyYW1zLnRvdGFsUHJvY2Vzc2luZ1N0YXJ0LmZvcm1hdCgpLFxuICAgICAgICBmaW5pc2g6IHRvdGFsUHJvY2Vzc2luZ0ZpbmlzaC5mb3JtYXQoKSxcbiAgICAgICAgZHVyYXRpb246IG1vbWVudC5kdXJhdGlvbih0b3RhbFByb2Nlc3NpbmdGaW5pc2guZGlmZihib29ra2VlcGluZ1BhcmFtcy50b3RhbFByb2Nlc3NpbmdTdGFydCkpLmFzU2Vjb25kcygpICsgJyBzZWNvbmRzJ1xuICAgIH07XG5cbiAgICAvLyBwYXNzIHJlc3VsdCB0byBjbGllbnQtc2lkZSBwbG90dGluZyBmdW5jdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGRhdGE6IGRhdGFzZXQsXG4gICAgICAgIG9wdGlvbnM6IHJlc3VsdE9wdGlvbnMsXG4gICAgICAgIGJhc2lzOiB7XG4gICAgICAgICAgICBwbG90UGFyYW1zOiBwbG90UGFyYW1zLFxuICAgICAgICAgICAgcXVlcmllczogYm9va2tlZXBpbmdQYXJhbXMuZGF0YVJlcXVlc3RzXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWF0c0RhdGFQcm9jZXNzVXRpbHMgPSB7XG5cbiAgICBwcm9jZXNzRGF0YVhZQ3VydmU6IHByb2Nlc3NEYXRhWFlDdXJ2ZSxcbiAgICBwcm9jZXNzRGF0YVByb2ZpbGU6IHByb2Nlc3NEYXRhUHJvZmlsZSxcbiAgICBwcm9jZXNzRGF0YVJlbGlhYmlsaXR5OiBwcm9jZXNzRGF0YVJlbGlhYmlsaXR5LFxuICAgIHByb2Nlc3NEYXRhSGlzdG9ncmFtOiBwcm9jZXNzRGF0YUhpc3RvZ3JhbSxcbiAgICBwcm9jZXNzRGF0YUNvbnRvdXI6IHByb2Nlc3NEYXRhQ29udG91clxuXG59IiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbmltcG9ydCB7TWV0ZW9yfSBmcm9tIFwibWV0ZW9yL21ldGVvclwiO1xuaW1wb3J0IHtcbiAgICBtYXRzQ29sbGVjdGlvbnMsXG4gICAgbWF0c0RhdGFDdXJ2ZU9wc1V0aWxzLFxuICAgIG1hdHNEYXRhRGlmZlV0aWxzLFxuICAgIG1hdHNEYXRhUHJvY2Vzc1V0aWxzLFxuICAgIG1hdHNEYXRhUXVlcnlVdGlscyxcbiAgICBtYXRzRGF0YVV0aWxzLFxuICAgIG1hdHNNZXRob2RzLFxuICAgIG1hdHNQYXJhbVV0aWxzLFxuICAgIG1hdHNUeXBlc1xufSBmcm9tICdtZXRlb3IvcmFuZHlwOm1hdHMtY29tbW9uJztcbmltcG9ydCB7bXlzcWx9IGZyb20gJ21ldGVvci9wY2VsOm15c3FsJztcbmltcG9ydCB7bW9tZW50fSBmcm9tICdtZXRlb3IvbW9tZW50anM6bW9tZW50JztcblxuY29uc3Qgc3RhdE12VHJhbnNsYXRpb24gPSB7XG4gICAgJ0FDQyc6IFwiQU5PTV9DT1JSXCIsXG4gICAgJ1JNUyc6ICdSTVNFJyxcbiAgICAnQmlhcyAoTW9kZWwgLSBPYnMpJzogJ01FJyxcbiAgICAnTW9kZWwgYXZlcmFnZSc6IFwiRkJBUlwiLFxuICAgICdPYnMgYXZlcmFnZSc6IFwiT0JBUlwiXG59O1xuXG5jb25zdCB4bWxCdWlsZGVyID0gcmVxdWlyZSgneG1sYnVpbGRlcicpO1xuXG5jb25zdCBfcGFkID0gZnVuY3Rpb24obnVtLCBzaXplKXtcbiAgICB2YXIgcyA9IG51bStcIlwiO1xuICAgIHdoaWxlIChzLmxlbmd0aCA8IHNpemUpIHMgPSBcIjBcIiArIHM7XG4gICAgcmV0dXJuIHM7XG59XG5cbmNvbnN0IF90aXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAobWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzID09PSB1bmRlZmluZWQgfHwgbWF0c0NvbGxlY3Rpb25zLlNldHRpbmdzLmZpbmRPbmUoe30sIHtmaWVsZHM6IHtUaXRsZTogMX19KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuZmluZE9uZSh7fSwge2ZpZWxkczoge1RpdGxlOiAxfX0pLlRpdGxlO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoc29tZUVycm9yKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn07XG5cbmNvbnN0IF9wbG90VGV4dCA9IGZ1bmN0aW9uIChwbG90UGFyYW1zKSB7XG4gICAgdmFyIGZvcm1hdCA9IHBsb3RQYXJhbXMucGxvdEZvcm1hdDtcblxuICAgIGlmIChtYXRzQ29sbGVjdGlvbnMuUGxvdFBhcmFtcy5maW5kT25lKHtuYW1lOiAncGxvdEZvcm1hdCd9KSAmJlxuICAgICAgICBtYXRzQ29sbGVjdGlvbnMuUGxvdFBhcmFtcy5maW5kT25lKHtuYW1lOiAncGxvdEZvcm1hdCd9KS5vcHRpb25zTWFwICYmXG4gICAgICAgIG1hdHNDb2xsZWN0aW9ucy5QbG90UGFyYW1zLmZpbmRPbmUoe25hbWU6ICdwbG90Rm9ybWF0J30pLm9wdGlvbnNNYXBbcGxvdFBhcmFtcy5wbG90Rm9ybWF0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvcm1hdCA9IG1hdHNDb2xsZWN0aW9ucy5QbG90UGFyYW1zLmZpbmRPbmUoe25hbWU6ICdwbG90Rm9ybWF0J30pLm9wdGlvbnNNYXBbcGxvdFBhcmFtcy5wbG90Rm9ybWF0XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvcm1hdCA9IFwiVW5tYXRjaGVkXCI7XG4gICAgfVxuICAgIGNvbnN0IHBsb3RUeXBlID0gKF8uaW52ZXJ0KHBsb3RQYXJhbXMucGxvdFR5cGVzKSlbdHJ1ZV07XG4gICAgc3dpdGNoIChwbG90VHlwZSkge1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMudGltZVNlcmllczpcbiAgICAgICAgICAgIHJldHVybiBcIlRpbWVTZXJpZXMgXCIgKyBwbG90UGFyYW1zLmRhdGVzICsgXCIgOiBcIiArIGZvcm1hdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMucHJvZmlsZTpcbiAgICAgICAgICAgIHJldHVybiBcIlByb2ZpbGU6IFwiICsgZm9ybWF0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kaWVvZmY6XG4gICAgICAgICAgICByZXR1cm4gXCJEaWVPZmY6IFwiICsgZm9ybWF0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy50aHJlc2hvbGQ6XG4gICAgICAgICAgICByZXR1cm4gXCJUaHJlc2hvbGQ6IFwiICsgZm9ybWF0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy52YWxpZHRpbWU6XG4gICAgICAgICAgICByZXR1cm4gXCJWYWxpZFRpbWU6IFwiICsgZm9ybWF0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kYWlseU1vZGVsQ3ljbGU6XG4gICAgICAgICAgICByZXR1cm4gXCJEYWlseU1vZGVsQ3ljbGUgXCIgKyBwbG90UGFyYW1zLmRhdGVzICsgXCIgOiBcIiArIGZvcm1hdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMucmVsaWFiaWxpdHk6XG4gICAgICAgICAgICByZXR1cm4gXCJSZWxpYWJpbGl0eTogXCIgKyBmb3JtYXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLm1hcDpcbiAgICAgICAgICAgIHJldHVybiBcIk1hcCBcIiArIHBsb3RQYXJhbXMuZGF0ZXMgKyBcIiBcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMuaGlzdG9ncmFtOlxuICAgICAgICAgICAgcmV0dXJuIFwiSGlzdG9ncmFtOiBcIiArIGZvcm1hdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiU2NhdHRlcjogXCIgKyBwbG90UGFyYW1zLmRhdGVzICsgXCIgOiBcIiArIGZvcm1hdDtcbiAgICB9XG59XG5cbmNvbnN0IF9jb21wb25lbnRUb0hleCA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgaGV4ID0gYy50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggPT0gMSA/IFwiMFwiICsgaGV4IDogaGV4O1xufTtcblxuY29uc3QgX3JnYlRvSGV4ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICBjb25zdCBjUGFydHMgPSBjb2xvci5yZXBsYWNlKCdyZ2IoJywnJykucmVwbGFjZSgnKScsJycpLnNwbGl0KCcsJyk7XG4gICAgY29uc3QgciA9IE51bWJlcihjUGFydHNbMF0pO1xuICAgIGNvbnN0IGcgPSBOdW1iZXIoY1BhcnRzWzFdKTtcbiAgICBjb25zdCBiID0gTnVtYmVyKGNQYXJ0c1syXSk7XG4gICAgcmV0dXJuIFwiI1wiICsgX2NvbXBvbmVudFRvSGV4KHIpICsgX2NvbXBvbmVudFRvSGV4KGcpICsgX2NvbXBvbmVudFRvSGV4KGIpO1xufTtcblxuXG5jb25zdCBfZ2V0VW5pcURhdGVzID0gZnVuY3Rpb24oZGF0ZXMsIGRhdGFiYXNlLCBtb2RlbCwgZGF0YVNvdXJjZSwgcmVnaW9uLCB2YXJpYWJsZSwgZm9yZWNhc3RMZW5ndGgsIGZyb21TZWNzLCB0b1NlY3MsIHZhbGlkVGltZXMgKSB7XG4gICAgdmFyIHJlZ2lvbnNDbGF1c2UgPSBcIlwiO1xuICAgIGlmIChyZWdpb24gIT0gbnVsbCkge1xuICAgICAgICByZWdpb24gPSBBcnJheS5pc0FycmF5KHJlZ2lvbikgPyByZWdpb24gOiBbcmVnaW9uXTtcbiAgICAgICAgaWYgKHJlZ2lvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZWdpb25zID0gcmVnaW9uLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIidcIiArIHIgKyBcIidcIjtcbiAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgICAgICAgIHJlZ2lvbnNDbGF1c2UgPSBcImFuZCBoLnZ4X21hc2sgSU4oXCIgKyByZWdpb25zICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGUgZm9yZWNhc3QgbGVuZ3RocyBhcHBlYXIgdG8gaGF2ZSBzb21ldGltZXMgYmVlbiBpbmNvbnNpc3RlbnQgKGJ5IGZvcm1hdCkgaW4gdGhlIHZhcmlhcyBkYXRhYmFzZXNcbiAgICAvLyBzbyB0aGV5IGhhdmUgYmVlbiBzYW5pdGl6ZWQgZm9yIGRpc3BsYXkgcHVycG9zZXMgaW4gdGhlIGZvcmVjYXN0VmFsdWVNYXAuXG4gICAgLy8gbm93IHdlIGhhdmUgdG8gZ28gZ2V0IHRoZSBkYW1uIG9sZSB1bnNhbml0YXJ5IG9uZXMgZm9yIHRoZSBkYXRhYmFzZS5cbiAgICB2YXIgZm9yZWNhc3RMZW5ndGhzQ2xhdXNlID0gXCJcIjtcbiAgICBpZiAoZm9yZWNhc3RMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBmb3JlY2FzdExlbmd0aCA9IEFycmF5LmlzQXJyYXkoZm9yZWNhc3RMZW5ndGgpID8gZm9yZWNhc3RMZW5ndGggOiBbZm9yZWNhc3RMZW5ndGhdO1xuICAgICAgICBpZiAoZm9yZWNhc3RMZW5ndGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZm9yZWNhc3RWYWx1ZU1hcCA9IG1hdHNDb2xsZWN0aW9ucy5DdXJ2ZVBhcmFtcy5maW5kT25lKHtuYW1lOiAnZm9yZWNhc3QtbGVuZ3RoJ30sIHt2YWx1ZXNNYXA6IDF9KVsndmFsdWVzTWFwJ11bZGF0YWJhc2VdW2RhdGFTb3VyY2VdO1xuICAgICAgICAgICAgY29uc3QgZm9yZWNhc3RMZW5ndGhzID0gZm9yZWNhc3RMZW5ndGgubWFwKGZ1bmN0aW9uIChmbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JlY2FzdFZhbHVlTWFwW2ZsXTtcbiAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgICAgICAgIGZvcmVjYXN0TGVuZ3Roc0NsYXVzZSA9IFwiYW5kIGxkLmZjc3RfbGVhZCBJTiAoXCIgKyBmb3JlY2FzdExlbmd0aHMgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdGF0ZW1lbnQgPSBcInNlbGVjdCBsZC5mY3N0X3ZhbGlkX2JlZyBhcyBhdnRpbWUgXCIgK1xuICAgICAgICBcImZyb20gXCIgKyBkYXRhYmFzZSArIFwiLnN0YXRfaGVhZGVyIGgsIFwiICsgZGF0YWJhc2UgKyBcIi5saW5lX2RhdGFfc2wxbDIgbGQgXCIgK1xuICAgICAgICBcIndoZXJlIDE9MSBhbmQgaC5tb2RlbCA9ICdcIiArIG1vZGVsICsgXCInIFwiICtcbiAgICAgICAgcmVnaW9uc0NsYXVzZSArXG4gICAgICAgIFwiYW5kIHVuaXhfdGltZXN0YW1wKGxkLmZjc3RfdmFsaWRfYmVnKSA+PSAnXCIgKyBmcm9tU2VjcyArIFwiJyBcIiArXG4gICAgICAgIFwiYW5kIHVuaXhfdGltZXN0YW1wKGxkLmZjc3RfdmFsaWRfYmVnKSA8PSAnXCIgKyB0b1NlY3MgKyBcIicgXCIgK1xuICAgICAgICBmb3JlY2FzdExlbmd0aHNDbGF1c2UgK1xuICAgICAgICBcImFuZCBoLmZjc3RfdmFyID0gJ1wiICsgdmFyaWFibGUgKyBcIicgXCIgK1xuICAgICAgICBcImFuZCBsZC5zdGF0X2hlYWRlcl9pZCA9IGguc3RhdF9oZWFkZXJfaWQgXCIgK1xuICAgICAgICBcImdyb3VwIGJ5IGF2dGltZSBvcmRlciBieSBhdnRpbWU7XCI7XG5cbiAgICB2YXIgcm93cyA9IG1hdHNEYXRhUXVlcnlVdGlscy5zaW1wbGVQb29sUXVlcnlXcmFwU3luY2hyb25vdXMobWV0YWRhdGFQb29sLCBzdGF0ZW1lbnQpO1xuICAgIGlmIChyb3dzID09PSB1bmRlZmluZWQgfHwgcm93cyA9PT0gbnVsbCB8fCByb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhtYXRzVHlwZXMuTWVzc2FnZXMuTk9fREFUQV9GT1VORCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93cy5sZW5ndGg7IHJvd0luZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRzdHJNb21lbnQgPSBtb21lbnQocm93c1tyb3dJbmRleF0uYXZ0aW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGRzdHIgPSBkc3RyTW9tZW50LmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbTpzcycpLnRyaW0oKTtcbiAgICAgICAgICAgIC8vIGFwcGx5IHRoZSB2YWxpZC10aW1lIGZpbHRlciBoZXJlLi4uLi5cbiAgICAgICAgICAgIHZhciB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodmFsaWRUaW1lcyAhPSBudWxsICYmIHZhbGlkVGltZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9tZW50U2RpSG91ciA9IE51bWJlcihkc3RyTW9tZW50LmZvcm1hdChcIkhIXCIpKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB2dGkgPSAwOyB2dGkgPCB2YWxpZFRpbWVzLmxlbmd0aDsgdnRpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhpc3Z0ID0gTnVtYmVyKHZhbGlkVGltZXNbdnRpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb21lbnRTZGlIb3VyID09PSB0aGlzdnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGlzIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxpZCA9PT0gdHJ1ZSAmJiBkYXRlcy5pbmRleE9mKGRzdHIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGRhdGVzLnB1c2goZHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGVzO1xufVxuXG5cbi8vIGFkZHMgZGF0ZSBlbGVtZW50cyB0byBhbiBlbGVtZW50IG9mIHRoZSBjdXJyZW50IHhtbCBiZXR3ZWVuIGEgc3RhcnQgYW5kIGFuIGVuZCBkYXRlLCBpbmNyZW1lbnRlZCBieSBzcGVjaWZpYyBzZWNvbmRzXG4vLyBzZXJpZXMgdmFyaWFibGVzIGNhbiBiZSBncm91cGVkIG9yIHVuZ3JvdXBlZC5cbi8vIGUuZy4gZ3JvdXBlZCAuLi4gICAgPHZhbD4yMDE4LTExLTAxIDAwOjAwOjAwLDIwMTgtMTEtMDEgMDY6MDA6MDAsMjAxOC0xMS0wMSAxMjowMDowMCwyMDE4LTExLTAxPC92YWw+XG4vLyBlLmcuIHVuZ3JvdXBlZCAuLi4gICAgPHZhbD4yMDE4LTExLTAxIDAwOjAwOjAwPC92YWw+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgPHZhbD4yMDE4LTExLTAxIDA2OjAwOjAwPC92YWw+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgPHZhbD4yMDE4LTExLTAxIDEyOjAwOjAwPC92YWw+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgPHZhbD4yMDE4LTExLTAxPC92YWw+XG5cbi8vIGZvciB0aW1lIHNlcmllcyB2YWxpZF9iZWcgaXMgYWx3YXlzIHVuZ3JvdXBlZC5cbmNvbnN0IF9nZXRTb3J0ZWREYXRlc0ZvckluZGVwUmFuZ2UgPSBmdW5jdGlvbihwbG90UGFyYW1zKSB7XG4gICAgY29uc3QgZGF0ZVJhbmdlID0gbWF0c0RhdGFVdGlscy5nZXREYXRlUmFuZ2UocGxvdFBhcmFtcy5kYXRlcyk7XG4gICAgY29uc3QgZnJvbVNlY3MgPSBkYXRlUmFuZ2UuZnJvbVNlY29uZHM7XG4gICAgY29uc3QgdG9TZWNzID0gZGF0ZVJhbmdlLnRvU2Vjb25kcztcbiAgICBjb25zdCBjdXJ2ZXMgPSBwbG90UGFyYW1zLmN1cnZlcztcbiAgICAvLyBoYXZlIHRvIGdldCBhbGwgdGhlIHZhbGlkIGRhdGVzIGZvciBlYWNoIGN1cnZlIHRoZW4gdW5pb24gdGhlbVxuICAgIC8vIHRvIGdldCBhIGNvbXBsZXRlIGRhdGUgbGlzdFxuICAgIHZhciBkYXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBjdXJ2ZXMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgIGlmIChjdXJ2ZXNbY2ldWydkaWZmRnJvbSddKSB7XG4gICAgICAgICAgICAvLyBjdXJycmVudGx5IHdlIGRvIG5vdCBkbyBtdiBkaWZmZXJlbmNpbmdcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJ2ZSA9IGN1cnZlc1tjaV07XG4gICAgICAgIGNvbnN0IHZhbGlkVGltZXMgPSBjdXJ2ZVsndmFsaWQtdGltZSddO1xuICAgICAgICBjb25zdCByZWdpb24gPSBjdXJ2ZVsncmVnaW9uJ107XG4gICAgICAgIGNvbnN0IGZvcmVjYXN0TGVuZ3RoID0gY3VydmVbJ2ZvcmVjYXN0LWxlbmd0aCddO1xuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IGN1cnZlWyd2YXJpYWJsZSddO1xuICAgICAgICAvL2V4YW1wbGUgMjAxOC0xMS0wNiAwMDowMDowMFxuICAgICAgICBjb25zdCBkYXRhYmFzZSA9IGN1cnZlWydkYXRhYmFzZSddO1xuICAgICAgICBjb25zdCBkYXRhU291cmNlID0gY3VydmVbJ2RhdGEtc291cmNlJ107XG4gICAgICAgIGNvbnN0IG1vZGVsID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLmZpbmRPbmUoe25hbWU6ICdkYXRhLXNvdXJjZSd9KS5vcHRpb25zTWFwW2RhdGFiYXNlXVtkYXRhU291cmNlXVswXTtcbiAgICAgICAgZGF0ZXMgPSBfZ2V0VW5pcURhdGVzKGRhdGVzLCBkYXRhYmFzZSwgbW9kZWwsIGRhdGFTb3VyY2UsIHJlZ2lvbiwgdmFyaWFibGUsIGZvcmVjYXN0TGVuZ3RoLCBmcm9tU2VjcywgdG9TZWNzLCB2YWxpZFRpbWVzKTtcbiAgICB9XG4gICAgLy8gc29ydCB0aGUgZGF0ZXNcbiAgICBjb25zdCBzb3J0ZWREYXRlcyA9IGRhdGVzLnNvcnQoXG4gICAgICAgIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1vbWVudChhKSAtIG5ldyBtb21lbnQoYik7XG4gICAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBzb3J0ZWREYXRlcztcbn1cblxuY29uc3QgX2dldFNvcnRlZEhvdXJzRm9ySW5kZXBSYW5nZSA9IGZ1bmN0aW9uKHBsb3RQYXJhbXMpIHtcbiAgICBjb25zdCBzb3J0ZWREYXRlcyA9IF9nZXRTb3J0ZWREYXRlc0ZvckluZGVwUmFuZ2UocGxvdFBhcmFtcyk7XG4gICAgdmFyIGhvdXJzID0gbmV3IFNldCgpO1xuICAgIGZvciAodmFyIGRpPTA7ZGk8c29ydGVkRGF0ZXMubGVuZ3RoO2RpKyspIHtcbiAgICAgICAgY29uc3QgaG91ciA9IG1vbWVudChzb3J0ZWREYXRlc1tkaV0pLmZvcm1hdChcIkhIXCIpO1xuICAgICAgICBob3Vycy5hZGQoaG91cik7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGhvdXJzKS5zb3J0KCk7XG59XG5cbmNvbnN0IF9nZXRTb3J0ZWREYXRlc0ZvckRlcFJhbmdlID0gZnVuY3Rpb24oY3VydmUpIHtcbiAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICBjb25zdCBkYXRlUmFuZ2UgPSBtYXRzRGF0YVV0aWxzLmdldERhdGVSYW5nZShjdXJ2ZVsnY3VydmUtZGF0ZXMnXSk7XG4gICAgY29uc3QgZnJvbVNlY3MgPSBkYXRlUmFuZ2UuZnJvbVNlY29uZHM7XG4gICAgY29uc3QgdG9TZWNzID0gZGF0ZVJhbmdlLnRvU2Vjb25kcztcbiAgICBjb25zdCB2YWxpZFRpbWVzID0gY3VydmVbJ3ZhbGlkLXRpbWUnXTtcbiAgICBjb25zdCByZWdpb24gPSBjdXJ2ZVsncmVnaW9uJ107XG4gICAgY29uc3QgZm9yZWNhc3RMZW5ndGggPSBjdXJ2ZVsnZm9yZWNhc3QtbGVuZ3RoJ107XG4gICAgY29uc3QgdmFyaWFibGUgPSBjdXJ2ZVsndmFyaWFibGUnXTtcbiAgICAvL2V4YW1wbGUgMjAxOC0xMS0wNiAwMDowMDowMFxuICAgIGNvbnN0IGRhdGFiYXNlID0gY3VydmVbJ2RhdGFiYXNlJ107XG4gICAgY29uc3QgZGF0YVNvdXJjZSA9IGN1cnZlWydkYXRhLXNvdXJjZSddO1xuICAgIGNvbnN0IG1vZGVsID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLmZpbmRPbmUoe25hbWU6ICdkYXRhLXNvdXJjZSd9KS5vcHRpb25zTWFwW2RhdGFiYXNlXVtkYXRhU291cmNlXVswXTtcbiAgICBkYXRlcyA9IF9nZXRVbmlxRGF0ZXMoZGF0ZXMsIGRhdGFiYXNlLCBtb2RlbCwgZGF0YVNvdXJjZSwgcmVnaW9uLCB2YXJpYWJsZSwgZm9yZWNhc3RMZW5ndGgsIGZyb21TZWNzLCB0b1NlY3MsIHZhbGlkVGltZXMpO1xuXG4gICAgLy8gc29ydCB0aGUgZGF0ZXNcbiAgICBjb25zdCBzb3J0ZWREYXRlcyA9IGRhdGVzLnNvcnQoXG4gICAgICAgIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1vbWVudChhKSAtIG5ldyBtb21lbnQoYik7XG4gICAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBzb3J0ZWREYXRlcztcbn1cblxuXG4vLyBmb3IgcHJvZmlsZXMgdmFsaWRfYmVnIGlzIGFsd2F5cyBncm91cGVkLlxuY29uc3QgYWRkSW5kZXBVbmdyb3VwZWREYXRlRWxlbWVudHNCZXR3ZWVuID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBsb3RQYXJhbXMpIHtcbiAgICBjb25zdCBzb3J0ZWREYXRlcyA9IF9nZXRTb3J0ZWREYXRlc0ZvckluZGVwUmFuZ2UocGxvdFBhcmFtcyk7XG4gICAgLy90aGVzZSBtdXN0IGJlIHVuZ3JvdXBlZFxuICAgIGZvciAodmFyIHNkaSA9IDA7IHNkaSA8IHNvcnRlZERhdGVzLmxlbmd0aDsgc2RpKyspIHtcbiAgICAgICAgZWxlbWVudC5lbGUoJ3ZhbCcsIHtcbiAgICAgICAgICAgICdsYWJlbCc6IHNvcnRlZERhdGVzW3NkaV0sXG4gICAgICAgICAgICAncGxvdF92YWwnOiBcIlwiXG4gICAgICAgIH0sIHNvcnRlZERhdGVzW3NkaV0pO1xuICAgIH1cbn1cblxuLy8gcGFyc2UgdGhlIGRhdGFiYXNlcyBmcm9tIHRoZSBjdXJ2ZXMgYW5kIGFkZCBhIGRhdGFiYXNlIHN0cmluZ1xuY29uc3QgYWRkRGF0YWJhc2VFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY3VydmVzKXtcbiAgICB0cnkge1xuICAgICAgICBkYXRhYmFzZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBjaT0wOyBjaSA8IGN1cnZlcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgIGlmIChjdXJ2ZXNbY2ldWydkaWZmRnJvbSddKSB7XG4gICAgICAgICAgICAgICAgLy8gY3VycnJlbnRseSB3ZSBkbyBub3QgZG8gbXYgZGlmZmVyZW5jaW5nXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFiYXNlcy5pbmNsdWRlcyhjdXJ2ZXNbY2ldLmRhdGFiYXNlKSkge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlcy5wdXNoKGN1cnZlc1tjaV0uZGF0YWJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGFiYXNlc1N0ciA9IGRhdGFiYXNlcy5qb2luKFwiJ1wiKTtcbiAgICAgICAgZWxlbWVudC5lbGUoJ2RhdGFiYXNlJyxkYXRhYmFzZXNTdHIpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IGNhdGNoIChzb21lRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufTtcblxuLy8gYWRkIHRoZSByZXF1aXJlZCBtZXR2aWV3ZXIgZm9sZGVyc1xuY29uc3QgYWRkRm9sZGVycyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBlbGVtZW50LmVsZSgncnNjcmlwdCcsIE1ldGVvci5zZXR0aW5ncy5wcml2YXRlLk1WX1JTQ1JJUFQpO1xuICAgICAgICB2YXIgZm9sZGVycyA9IGVsZW1lbnQuZWxlKCdmb2xkZXJzJyk7XG4gICAgICAgIGZvbGRlcnMuZWxlKCdyX3RtcGwnLCBtYXRzTWV0aG9kcy5NVl9ESVJTLkhPTUUgKyBcIi9SX3RtcGxcIik7XG4gICAgICAgIGZvbGRlcnMuZWxlKCdyX3dvcmsnLCBtYXRzTWV0aG9kcy5NVl9ESVJTLkhPTUUgKyBcIi9SX3dvcmtcIik7XG4gICAgICAgIGZvbGRlcnMuZWxlKCdwbG90cycsIG1hdHNNZXRob2RzLk1WX0RJUlMuUExPVFNESVIpO1xuICAgICAgICBmb2xkZXJzLmVsZSgnZGF0YScsIG1hdHNNZXRob2RzLk1WX0RJUlMuREFUQURJUik7XG4gICAgICAgIGZvbGRlcnMuZWxlKCdzY3JpcHRzJywgbWF0c01ldGhvZHMuTVZfRElSUy5TQ1JJUFRTRElSKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbn07XG5cbi8vIHN0YXJ0IHRoZSBwbG90c3BlY1xuY29uc3Qgc3RhcnRQbG90U3BlYyA9IGZ1bmN0aW9uKHBvb2wsIHBsb3RQYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgeG1sID0geG1sQnVpbGRlci5jcmVhdGUoJ3Bsb3Rfc3BlYycsIHt2ZXJzaW9uOiBcIjEuMFwiLCBlbmNvZGluZzogXCJVVEYtOFwiLCBzdGFuZGFsb25lOiBmYWxzZX0pO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHhtbC5lbGUoJ2Nvbm5lY3Rpb24nKTtcbiAgICAgICAgY29ubmVjdGlvbi5lbGUoJ2hvc3QnLCBzdW1Qb29sLmNvbmZpZy5jb25uZWN0aW9uQ29uZmlnLmhvc3QgKyBcIjpcIiArIHN1bVBvb2wuY29uZmlnLmNvbm5lY3Rpb25Db25maWcucG9ydCk7XG4gICAgICAgIGFkZERhdGFiYXNlRWxlbWVudChjb25uZWN0aW9uLCBwbG90UGFyYW1zLmN1cnZlcyk7XG4gICAgICAgIGNvbm5lY3Rpb24uZWxlKCd1c2VyJywgc3VtUG9vbC5jb25maWcuY29ubmVjdGlvbkNvbmZpZy51c2VyKTtcbiAgICAgICAgY29ubmVjdGlvbi5lbGUoJ3Bhc3N3b3JkJywgc3VtUG9vbC5jb25maWcuY29ubmVjdGlvbkNvbmZpZy5wYXNzd29yZCk7XG4gICAgICAgIGNvbnN0IG1hbmFnZW1lbnRfc3lzdGVtID0gTWV0ZW9yLnNldHRpbmdzLnByaXZhdGUuTVZfREJfTUFOQUdFTUVOVF9TWVNURU0gIT0gbnVsbCA/IE1ldGVvci5zZXR0aW5ncy5wcml2YXRlLk1WX0RCX01BTkFHRU1FTlRfU1lTVEVNIDogXCJteXNxbFwiO1xuICAgICAgICBjb25uZWN0aW9uLmVsZSgnbWFuYWdlbWVudF9zeXN0ZW0nLCBtYW5hZ2VtZW50X3N5c3RlbSk7XG4gICAgICAgIGFkZEZvbGRlcnMoeG1sKTtcbiAgICAgICAgdmFyIHBsb3QgPSB4bWwuZWxlKCdwbG90Jyk7XG4gICAgICAgIHJldHVybiB7eG1sOnhtbCxwbG90OnBsb3R9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG59O1xuXG5jb25zdCBhZGRQbG90Q2kgPSBmdW5jdGlvbihlbGVtZW50LHBsb3RQYXJhbXMpe1xuICAgIHRyeSB7IC8vZXhhbXBsZSBjKFwibm9uZVwiLFwibm9uZVwiKVxuICAgICAgICB2YXIgY3VydmVzID0gcGxvdFBhcmFtcy5jdXJ2ZXM7XG4gICAgICAgIHZhciBjTGlzdCA9IFtdO1xuICAgICAgICB2YXIgY0xpc3RTdHIgPSAnYygnO1xuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY3VydmVzLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgaWYgKGN1cnZlc1tjaV1bJ2RpZmZGcm9tJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJycmVudGx5IHdlIGRvIG5vdCBkbyBtdiBkaWZmZXJlbmNpbmdcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNMaXN0LnB1c2goJ1wibm9uZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY0xpc3RTdHIgKz0gY0xpc3Quam9pbignLCcpICsgJyknO1xuICAgICAgICBlbGVtZW50LmVsZSgncGxvdF9jaScsIGNMaXN0U3RyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxufTtcblxuY29uc3QgYWRkU2hvd1NpZ25pZiA9IGZ1bmN0aW9uKGVsZW1lbnQscGxvdFBhcmFtcyl7XG4gICAgdHJ5IHsgLy9leGFtcGxlIGMoRkFMU0UsRkFMU0UpXG4gICAgICAgIHZhciBjdXJ2ZXMgPSBwbG90UGFyYW1zLmN1cnZlcztcbiAgICAgICAgdmFyIGNMaXN0ID0gW107XG4gICAgICAgIHZhciBjTGlzdFN0ciA9ICdjKCc7XG4gICAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBjdXJ2ZXMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3VydmVzW2NpXVsnZGlmZkZyb20nXSkge1xuICAgICAgICAgICAgICAgIC8vIGN1cnJyZW50bHkgd2UgZG8gbm90IGRvIG12IGRpZmZlcmVuY2luZ1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY0xpc3QucHVzaCgnRkFMU0UnKTtcbiAgICAgICAgfVxuICAgICAgICBjTGlzdFN0ciArPSBjTGlzdC5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIGVsZW1lbnQuZWxlKCdzaG93X3NpZ25pZicsIGNMaXN0U3RyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxufTtcblxuY29uc3QgYWRkUGxvdERpc3AgPSBmdW5jdGlvbihlbGVtZW50LHBsb3RQYXJhbXMpe1xuICAgIHRyeSB7IC8vZXhhbXBsZSBjKFRSVUUsVFJVRSlcbiAgICAgICAgdmFyIGN1cnZlcyA9IHBsb3RQYXJhbXMuY3VydmVzO1xuICAgICAgICB2YXIgY0xpc3QgPSBbXTtcbiAgICAgICAgdmFyIGNMaXN0U3RyID0gJ2MoJztcbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGN1cnZlcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgIGNMaXN0LnB1c2goJ1RSVUUnKTtcbiAgICAgICAgfVxuICAgICAgICBjTGlzdFN0ciArPSBjTGlzdC5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIGVsZW1lbnQuZWxlKCdwbG90X2Rpc3AnLCBjTGlzdFN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbn07XG5cbmNvbnN0IGFkZENvbG9ycyA9IGZ1bmN0aW9uKGVsZW1lbnQscGxvdFBhcmFtcyl7XG4gICAgdHJ5IHsgLy8gIGV4YW1wbGUgICdjKFwiI2ZmMDAwMEZGXCIsXCIjODAwMGZmRkZcIiknXG4gICAgICAgIHZhciBjdXJ2ZXMgPSBwbG90UGFyYW1zLmN1cnZlcztcbiAgICAgICAgdmFyIGNMaXN0ID0gW107XG4gICAgICAgIHZhciBjTGlzdFN0ciA9ICdjKCc7XG4gICAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBjdXJ2ZXMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3VydmVzW2NpXVsnZGlmZkZyb20nXSkge1xuICAgICAgICAgICAgICAgIC8vIGN1cnJyZW50bHkgd2UgZG8gbm90IGRvIG12IGRpZmZlcmVuY2luZ1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoID0gX3JnYlRvSGV4KGN1cnZlc1tjaV0uY29sb3IpICsgXCJGRlwiO1xuICAgICAgICAgICAgY0xpc3QucHVzaCgnXCInICsgY2ggKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjTGlzdFN0ciArPSBjTGlzdC5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIGVsZW1lbnQuZWxlKCdjb2xvcnMnLCBjTGlzdFN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbn07XG5cbmNvbnN0IGFkZFBjaCA9IGZ1bmN0aW9uKGVsZW1lbnQscGxvdFBhcmFtcyl7XG4gICAgdHJ5IHsgLy9leGFtcGxlIGMoMjAsMjApXG4gICAgICAgIHZhciBjdXJ2ZXMgPSBwbG90UGFyYW1zLmN1cnZlcztcbiAgICAgICAgdmFyIGNMaXN0ID0gW107XG4gICAgICAgIHZhciBjTGlzdFN0ciA9ICdjKCc7XG4gICAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBjdXJ2ZXMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3VydmVzW2NpXVsnZGlmZkZyb20nXSkge1xuICAgICAgICAgICAgICAgIC8vIGN1cnJyZW50bHkgd2UgZG8gbm90IGRvIG12IGRpZmZlcmVuY2luZ1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY0xpc3QucHVzaCgnMjAnKTtcbiAgICAgICAgfVxuICAgICAgICBjTGlzdFN0ciArPSBjTGlzdC5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIGVsZW1lbnQuZWxlKCdwY2gnLCBjTGlzdFN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbn07XG5cbmNvbnN0IGFkZFR5cGUgPSBmdW5jdGlvbihlbGVtZW50LHBsb3RQYXJhbXMpe1xuICAgIHRyeSB7IC8vZXhhbXBsZSBjKFwiYlwiLFwiYlwiKVxuICAgICAgICB2YXIgY3VydmVzID0gcGxvdFBhcmFtcy5jdXJ2ZXM7XG4gICAgICAgIHZhciBjTGlzdCA9IFtdO1xuICAgICAgICB2YXIgY0xpc3RTdHIgPSAnYygnO1xuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY3VydmVzLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgaWYgKGN1cnZlc1tjaV1bJ2RpZmZGcm9tJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJycmVudGx5IHdlIGRvIG5vdCBkbyBtdiBkaWZmZXJlbmNpbmdcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNMaXN0LnB1c2goJ1wiYlwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY0xpc3RTdHIgKz0gY0xpc3Quam9pbignLCcpICsgJyknO1xuICAgICAgICBlbGVtZW50LmVsZSgndHlwZScsIGNMaXN0U3RyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxufTtcblxuY29uc3QgYWRkTHR5ID0gZnVuY3Rpb24oZWxlbWVudCxwbG90UGFyYW1zKXtcbiAgICB0cnkgeyAvLyBleGFtcGxlIGMoMSwxKVxuICAgICAgICB2YXIgY3VydmVzID0gcGxvdFBhcmFtcy5jdXJ2ZXM7XG4gICAgICAgIHZhciBjTGlzdCA9IFtdO1xuICAgICAgICB2YXIgY0xpc3RTdHIgPSAnYygnO1xuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY3VydmVzLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgaWYgKGN1cnZlc1tjaV1bJ2RpZmZGcm9tJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJycmVudGx5IHdlIGRvIG5vdCBkbyBtdiBkaWZmZXJlbmNpbmdcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNMaXN0LnB1c2goMSk7XG4gICAgICAgIH1cbiAgICAgICAgY0xpc3RTdHIgKz0gY0xpc3Quam9pbignLCcpICsgJyknO1xuICAgICAgICBlbGVtZW50LmVsZSgnbHR5JywgY0xpc3RTdHIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG59O1xuXG5jb25zdCBhZGRMd2QgPSBmdW5jdGlvbihlbGVtZW50LHBsb3RQYXJhbXMpe1xuICAgIHRyeSB7IC8vIGV4YW1wbGUgYygxLDEpXG4gICAgICAgIHZhciBjdXJ2ZXMgPSBwbG90UGFyYW1zLmN1cnZlcztcbiAgICAgICAgdmFyIGNMaXN0ID0gW107XG4gICAgICAgIHZhciBjTGlzdFN0ciA9ICdjKCc7XG4gICAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBjdXJ2ZXMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3VydmVzW2NpXVsnZGlmZkZyb20nXSkge1xuICAgICAgICAgICAgICAgIC8vIGN1cnJyZW50bHkgd2UgZG8gbm90IGRvIG12IGRpZmZlcmVuY2luZ1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY0xpc3QucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgICBjTGlzdFN0ciArPSBjTGlzdC5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIGVsZW1lbnQuZWxlKCdsd2QnLCBjTGlzdFN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbn07XG5cbmNvbnN0IGFkZENvblNlcmllcyA9IGZ1bmN0aW9uKGVsZW1lbnQscGxvdFBhcmFtcyl7XG4gICAgdHJ5IHsgLy8gZXhhbXBsZSBjKDEsMSlcbiAgICAgICAgdmFyIGN1cnZlcyA9IHBsb3RQYXJhbXMuY3VydmVzO1xuICAgICAgICB2YXIgY0xpc3QgPSBbXTtcbiAgICAgICAgdmFyIGNMaXN0U3RyID0gJ2MoJztcbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGN1cnZlcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgIGlmIChjdXJ2ZXNbY2ldWydkaWZmRnJvbSddKSB7XG4gICAgICAgICAgICAgICAgLy8gY3VycnJlbnRseSB3ZSBkbyBub3QgZG8gbXYgZGlmZmVyZW5jaW5nXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjTGlzdC5wdXNoKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNMaXN0U3RyICs9IGNMaXN0LmpvaW4oJywnKSArICcpJztcbiAgICAgICAgZWxlbWVudC5lbGUoJ2Nvbl9zZXJpZXMnLCBjTGlzdFN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbn07XG5cbmNvbnN0IGFkZE9yZGVyU2VyaWVzID0gZnVuY3Rpb24oZWxlbWVudCxwbG90UGFyYW1zKXtcbiAgICB0cnkgeyAvLyBleGFtcGxlIGMoMSwyKVxuICAgICAgICB2YXIgY3VydmVzID0gcGxvdFBhcmFtcy5jdXJ2ZXM7XG4gICAgICAgIHZhciBjTGlzdCA9IFtdO1xuICAgICAgICB2YXIgY0xpc3RTdHIgPSAnYygnO1xuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY3VydmVzLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgaWYgKGN1cnZlc1tjaV1bJ2RpZmZGcm9tJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJycmVudGx5IHdlIGRvIG5vdCBkbyBtdiBkaWZmZXJlbmNpbmdcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNMaXN0LnB1c2goY2kgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBjTGlzdFN0ciArPSBjTGlzdC5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIGVsZW1lbnQuZWxlKCdvcmRlcl9zZXJpZXMnLCBjTGlzdFN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbn07XG5cbmNvbnN0IGFkZExlZ2VuZCA9IGZ1bmN0aW9uKGVsZW1lbnQscGxvdFBhcmFtcyl7XG4gICAgdHJ5IHsgLy8gZXhhbXBsZSBjKFwiXCIsXCJcIilcbiAgICAgICAgdmFyIGN1cnZlcyA9IHBsb3RQYXJhbXMuY3VydmVzO1xuICAgICAgICB2YXIgY0xpc3QgPSBbXTtcbiAgICAgICAgdmFyIGNMaXN0U3RyID0gJ2MoJztcbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGN1cnZlcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgIGlmIChjdXJ2ZXNbY2ldWydkaWZmRnJvbSddKSB7XG4gICAgICAgICAgICAgICAgLy8gY3VycnJlbnRseSB3ZSBkbyBub3QgZG8gbXYgZGlmZmVyZW5jaW5nXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjTGlzdC5wdXNoKCdcIlwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY0xpc3RTdHIgKz0gY0xpc3Quam9pbignLCcpICsgJyknO1xuICAgICAgICBlbGVtZW50LmVsZSgnbGVnZW5kJywgY0xpc3RTdHIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG59O1xuXG5jb25zdCBhZGRTZXJpZXMgPSBmdW5jdGlvbihwbG90LCBkZXBlbmRlbnRBeGVzLCBwbG90UGFyYW1zKSB7XG4gICAgLyoqKlxuICAgICBkYXRhLXNvdXJjZShtb2RlbHMpLCByZWdpb24odnhfbWFzayksZm9yZWNhc3RfbGVuZ3RoIChmY3N0X2xlYWQpLCBhbmQgcHJlcy1sZXZlbChmY3N0X2xldilcbiAgICAgYXJlIHNlcmllcyB2YXJpYWJsZXMuIE11bHRpcGxlIHNlbGVjdGlvbnMgZm9yIGEgZ2l2ZW4gY3VydmUgYXJlIE1WIGdyb3VwZWQgKGpvaW4nZClcbiAgICAgTXVsdGlwbGUgc2VsZWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggZGlmZmVyZW50IGN1cnZlcyBhcmUgc2VwZXJhdGUgPHZhbD4gdGFncy5cblxuICAgICBBbGwgb2YgdGhlIG5vbiBncm91cGVkIGNvbWJpbmF0aW9ucyBhcmUgYWRkZWQgd2hpY2ggcmVzdWx0cyBpbiBwb3NzaWJseSB0b28gbWFueSBjdXJ2ZXMuIFRoZSByZWR1bmRhbnQgb25lcyBhcmUgbGF0ZXIgaGlkZGVuLlxuXG4gICAgIFRoZXkgY2FuIGFsc28gZ28gb24gdGhlIGF4aXMgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnZlIHRoYXQgdGhlIHJlZ2lvbiBwYXJhbWV0ZXIgaXMgb24uXG4gICAgIEluIG90aGVyIHdvcmRzIGZvcmNlIGEgbmV3IHNlcmllcy5cbiAgICAgaS5lLiBZMSBTZXJpZXMgdmFyaWFibGVzIG9yIFkyIFNlcmllcyB2YXJpYWJsZXNcblxuICAgICBzZXJpZXMgdmFyaWFibGVzIGNhbiBiZSBncm91cGVkIG9yIHVuZ3JvdXBlZC5cbiAgICAgZS5nLiBncm91cGVkIC4uLiAgICA8dmFsPjIwMTgtMTEtMDEgMDA6MDA6MDAsMjAxOC0xMS0wMSAwNjowMDowMCwyMDE4LTExLTAxIDEyOjAwOjAwLDIwMTgtMTEtMDE8L3ZhbD5cbiAgICAgZS5nLiB1bmdyb3VwZWQgLi4uICAgIDx2YWw+MjAxOC0xMS0wMSAwMDowMDowMDwvdmFsPlxuICAgICA8dmFsPjIwMTgtMTEtMDEgMDY6MDA6MDA8L3ZhbD5cbiAgICAgPHZhbD4yMDE4LTExLTAxIDEyOjAwOjAwPC92YWw+XG4gICAgIDx2YWw+MjAxOC0xMS0wMTwvdmFsPlxuICAgICBGb3IgTUFUUyBjdXJ2ZXMgdGhleSBhcmUgZ3JvdXBlZCBmb3IgZWFjaCBjdXJ2ZSBhbmQgYWRkZWQgYXNlIHNlcmllcyB2YXJpYWJsZXMuIFRoaXMgcmVzdWx0cyBpbiByZWR1bmRhbnQgY3VydmVzIGluIE1WIGFuZCBzbyB0aGVcbiAgICAgcmVkdW5kYW50IGN1cnZlcyB3aWxsIGJlIGhpZGRlbi5cbiAgICAgQ3VydmVzIHRoYXQgd2VyZSBhc3NpZ25lZCB0byBkaWZmZXJlbnQgYXhpcyB3ZXJlIGZpZ3VyZWQgb3V0IGFuZCBhc3NpZ25lZCBpbiBnZXREZXBlbmRlbnRzIGFuZCBhcmUgYXNzaWduZWQgaW4gdGhlIGRlcGVuZGVudEF4ZXMgc3RydWN0dXJlLlxuICAgICAqKiovXG4gICAgdmFyIGhpZGRlbkN1cnZlcyA9IFtdO1xuICAgIHZhciBzVmFycyA9IHsnZGF0YS1zb3VyY2UnOidtb2RlbCcsJ3JlZ2lvbic6J3Z4X21hc2snLCdmb3JlY2FzdC1sZW5ndGgnOidmY3N0X2xlYWQnLCdwcmVzLWxldmVsJzonZmNzdF9sZXYnfTtcbiAgICBjb25zdCB0eXBlID0gKF8uaW52ZXJ0KHBsb3RQYXJhbXMucGxvdFR5cGVzKSlbdHJ1ZV07XG4gICAgY29uc3Qgc2VyaWVzQXhpc01hcCA9IHsnc2VyaWVzMSc6J3kxJywgJ3NlcmllczInOid5Mid9O1xuICAgIE9iamVjdC5rZXlzKHNlcmllc0F4aXNNYXApLmZvckVhY2goZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICB2YXIgbW9kZWxzID0gW107XG4gICAgICAgIHZhciB2eF9tYXNrcyA9IFtdO1xuICAgICAgICB2YXIgZmNzdF9sZWFkcyA9IFtdO1xuICAgICAgICB2YXIgZmNzdF9sZXZscyA9IFtdO1xuICAgICAgICB2YXIgc2VyaWVzRWxlbSA9IHBsb3QuZWxlKHNlcmllcyk7XG4gICAgICAgIGNvbnN0IGF4aXMgPSBzZXJpZXNBeGlzTWFwW3Nlcmllc107XG4gICAgICAgIHZhciBpbml0SG91cnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRpbWVTZXJpZXM6XG4gICAgICAgICAgICAgICAgc1ZhcnMgPSB7J2RhdGEtc291cmNlJzonbW9kZWwnLCdyZWdpb24nOid2eF9tYXNrJywnZm9yZWNhc3QtbGVuZ3RoJzonZmNzdF9sZWFkJywncHJlcy1sZXZlbCc6J2Zjc3RfbGV2J307XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMuZGFpbHlNb2RlbEN5Y2xlOlxuICAgICAgICAgICAgICAgIHNWYXJzID0geydkYXRhLXNvdXJjZSc6J21vZGVsJywncmVnaW9uJzondnhfbWFzaycsJ2ZvcmVjYXN0LWxlbmd0aCc6J2Zjc3RfbGVhZCcsJ3ByZXMtbGV2ZWwnOidmY3N0X2xldid9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnByb2ZpbGU6XG4gICAgICAgICAgICAgICAgc1ZhcnMgPSB7J2RhdGEtc291cmNlJzonbW9kZWwnLCdyZWdpb24nOid2eF9tYXNrJywnZm9yZWNhc3QtbGVuZ3RoJzonZmNzdF9sZWFkJywnY3VydmUtZGF0ZXMnOidmY3N0X3ZhbGlkX2JlZyd9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLmRpZW9mZjpcbiAgICAgICAgICAgICAgICBzVmFycyA9IHsnZGF0YS1zb3VyY2UnOiAnbW9kZWwnLCAncmVnaW9uJzogJ3Z4X21hc2snLCAncHJlcy1sZXZlbCc6ICdmY3N0X2xldicsICdjdXJ2ZS1kYXRlcyc6ICdmY3N0X3ZhbGlkX2JlZyd9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNpPTA7IGNpIDwgcGxvdFBhcmFtcy5jdXJ2ZXMubGVuZ3RoO2NpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnZlc1tjaV1bJ2RpZmZGcm9tJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJyZW50bHkgd2UgZG8gbm90IGRvIG12IGRpZmZlcmVuY2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IHBsb3RQYXJhbXMuY3VydmVzW2NpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNbJ2RpZW9mZi10eXBlJ10gPT09ICdEaWVvZmYgZm9yIGEgc3BlY2lmaWVkIFVUQyBjeWNsZSBpbml0IGhvdXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0SG91cnMuYWRkKGNbJ3V0Yy1jeWNsZS1zdGFydCddKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjLmRpZW9mZiAtIHR5cGUgPT09IG1hdHNUeXBlcy5Gb3JlY2FzdFR5cGVzLnNpbmdsZUN5Y2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlciBmb3IgaWYgaXNzdWUgNjAzMTMgZ2V0cyByZXNvbHZlZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgaWYgKGluaXRIb3Vycy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgIHNWYXJzWyd1dGMtY3ljbGUtc3RhcnQnXSA9ICdpbml0X2hvdXInO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRocmVzaG9sZDpcbiAgICAgICAgICAgICAgICBzVmFycyA9IHsnZGF0YS1zb3VyY2UnOidtb2RlbCcsJ3JlZ2lvbic6J3Z4X21hc2snLCdmb3JlY2FzdC1sZW5ndGgnOidmY3N0X2xlYWQnLCdwcmVzLWxldmVsJzonZmNzdF9sZXYnLCdjdXJ2ZS1kYXRlcyc6J2Zjc3RfdmFsaWRfYmVnJ307XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMudmFsaWR0aW1lOlxuICAgICAgICAgICAgICAgIHNWYXJzID0geydkYXRhLXNvdXJjZSc6J21vZGVsJywncmVnaW9uJzondnhfbWFzaycsJ2ZvcmVjYXN0LWxlbmd0aCc6J2Zjc3RfbGVhZCcsJ3ByZXMtbGV2ZWwnOidmY3N0X2xldicsJ2N1cnZlLWRhdGVzJzonZmNzdF92YWxpZF9iZWcnfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5yZWxpYWJpbGl0eTpcbiAgICAgICAgICAgICAgICBzVmFycyA9IHsnZGF0YS1zb3VyY2UnOidtb2RlbCcsJ3JlZ2lvbic6J3Z4X21hc2snLCdmb3JlY2FzdC1sZW5ndGgnOidmY3N0X2xlYWQnLCdwcmVzLWxldmVsJzonZmNzdF9sZXYnLCdjdXJ2ZS1kYXRlcyc6J2Zjc3RfdmFsaWRfYmVnJ307XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMuaGlzdG9ncmFtOlxuICAgICAgICAgICAgICAgIHNWYXJzID0geydkYXRhLXNvdXJjZSc6J21vZGVsJywncmVnaW9uJzondnhfbWFzaycsJ2ZvcmVjYXN0LWxlbmd0aCc6J2Zjc3RfbGVhZCcsJ3ByZXMtbGV2ZWwnOidmY3N0X2xldicsJ2N1cnZlLWRhdGVzJzonZmNzdF92YWxpZF9iZWcnfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc1ZhcnMgPSB7J2RhdGEtc291cmNlJzonbW9kZWwnLCdyZWdpb24nOid2eF9tYXNrJywnZm9yZWNhc3QtbGVuZ3RoJzonZmNzdF9sZWFkJywncHJlcy1sZXZlbCc6J2Zjc3RfbGV2J307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gbWF0c1R5cGVzLlBsb3RUeXBlcy5wcm9maWxlKSB7XG4gICAgICAgICAgICBkZWxldGUgc1ZhcnNbJ3ByZXMtbGV2ZWwnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgY29uc2lkZXIgcHJlc3N1cmUgbGV2ZWxzIHdoZW4gaXQgaXNuJ3QgYSBwcm9maWxlXG4gICAgICAgICAgICBzVmFyc1sncHJlcy1sZXZlbCddID0gJ2Zjc3RfbGV2JztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VyaWVzRWxlbWVudHMgPSB7fTtcbiAgICAgICAgdmFyIHNlcmllc0VsZW1lbnRWYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZGFjaSA9IDA7IGRhY2kgPCBkZXBlbmRlbnRBeGVzW2F4aXNdLmxlbmd0aDsgZGFjaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJ2ZSA9IGRlcGVuZGVudEF4ZXNbYXhpc11bZGFjaV07XG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZSA9IGN1cnZlWydkYXRhYmFzZSddO1xuICAgICAgICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IGN1cnZlWydkYXRhLXNvdXJjZSddO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNWYXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHNWYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vZGVscyAtIG5vdCBtdWx0aXBsZSAtIHVuZ3JvdXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChzVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF0YS1zb3VyY2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGRhdGEtc291cmNlIHRvIHNpbmdsZSBlbGVtZW50IGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNWYWx1ZXMgPSBbbWF0c1BhcmFtVXRpbHMuZ2V0UGFyYW1ldGVyRm9yTmFtZShzVmFyKS5vcHRpb25zTWFwW2RhdGFiYXNlXVtkYXRhU291cmNlXVswXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2N1cnZlLWRhdGVzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc1ZhbHVlcyA9IF9nZXRTb3J0ZWREYXRlc0ZvckRlcFJhbmdlKGN1cnZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRjLWN5Y2xlLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IGN1cnZlWyd1dGMtY3ljbGUtc3RhcnQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGVkViA9IF9wYWQodiwyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc1ZhbHVlcyA9IFtwYWRkZWRWXTsgLy8gdHVybiBzaW5nbGUgc2VsZWN0aW9uIHBhZGRlZCB2YWx1ZSBpbnRvIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZvcmVjYXN0LWxlbmd0aCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNWYWx1ZXMgPSBjdXJ2ZVtzVmFyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNWYWx1ZXMgPT0gbnVsbCB8fCBzVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc1ZhbHVlcyA9IG1hdHNQYXJhbVV0aWxzLmdldFBhcmFtZXRlckZvck5hbWUoc1Zhcikub3B0aW9uc01hcFtkYXRhYmFzZV1bZGF0YVNvdXJjZV07IC8vIGhhdmUgdG8gYXNzaWduIGFsbCB0aGUgZmNzdCBsZWFkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcmVjYXN0VmFsdWVNYXAgPSBtYXRzUGFyYW1VdGlscy5nZXRQYXJhbWV0ZXJGb3JOYW1lKHNWYXIpLnZhbHVlc01hcFtkYXRhYmFzZV1bZGF0YVNvdXJjZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNWYWx1ZXMgPSBzVmFsdWVzLm1hcChmdW5jdGlvbiAoZmwpIHtyZXR1cm4gZm9yZWNhc3RWYWx1ZU1hcFtmbF19KS5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNWYWx1ZXMgPSBjdXJ2ZVtzVmFyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNWYWx1ZXMgPT0gbnVsbCB8fCBzVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc1ZhbHVlcyA9IG1hdHNQYXJhbVV0aWxzLmdldFBhcmFtZXRlckZvck5hbWUoc1Zhcikub3B0aW9uc01hcFtkYXRhYmFzZV1bZGF0YVNvdXJjZV07IC8vIGhhdmUgdG8gYXNzaWduIGFsbCB0aGUgcmVnaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBlbGVtZW50IHdhcyBhbHJlYWR5IGFkZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IGFkZGVkIHRoZW4gYWRkIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZWxlbWVudCB3YXMgYWxyZWFkeSBhZGRlZCBzZWUgaWYgd2UgbmVlZCB0byBhZGQgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG11bHRpcGxlcyBhcmUgYWx3YXlzIGdyb3VwZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc1ZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc1ZhbHVlcyA9IEFycmF5LmlzQXJyYXkoc1ZhbHVlcykgPyBzVmFsdWVzIDogW3NWYWx1ZXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc1ZhbHVlc1N0ciA9IHNWYWx1ZXMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc1ZhbHVlc1N0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGlzVmFyID0gc1ZhcnNbc1Zhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWVzRWxlbWVudHNbdGhpc1Zhcl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0VsZW1lbnRzW3RoaXNWYXJdID0gc2VyaWVzRWxlbS5lbGUoJ2ZpZWxkJywgeyduYW1lJzogc1ZhcnNbc1Zhcl19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNFbGVtZW50VmFsdWVzW3RoaXNWYXJdID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0VsZW1lbnRWYWx1ZXNbdGhpc1Zhcl0uYWRkKHNWYWx1ZXNTdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXNFbGVtZW50VmFsdWVzW3RoaXNWYXJdLmhhcyhzVmFsdWVzU3RyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzRWxlbWVudFZhbHVlc1t0aGlzVmFyXS5hZGQoc1ZhbHVlc1N0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWV0ZW9yLkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzRWxlbWVudEtleXMgPSBPYmplY3Qua2V5cyhzZXJpZXNFbGVtZW50cyk7XG4gICAgICAgIGZvciAodmFyIHNlaT0wOyBzZWkgPCBzRWxlbWVudEtleXMubGVuZ3RoOyBzZWkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2VWYXIgPSBzRWxlbWVudEtleXNbc2VpXTtcbiAgICAgICAgICAgIGNvbnN0IHN2YXJzID0gQXJyYXkuZnJvbShzZXJpZXNFbGVtZW50VmFsdWVzW3NlVmFyXSkuc29ydCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgc3ZpPTA7IHN2aSA8IHN2YXJzLmxlbmd0aDsgc3ZpKyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdmFyc1tzdmldO1xuICAgICAgICAgICAgICAgIGlmICh2ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0VsZW1lbnRzW3NlVmFyXS5lbGUoJ3ZhbCcsIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxufVxuXG5jb25zdCBnZXREZXBlbmRlbnRBeGlzID0gZnVuY3Rpb24ocGxvdFBhcmFtcykge1xuICAgIC8vIHRoZXJlIGFyZSB0d28gcG9zc2libGUgYXhpcyBmb3IgbWV0dmlld2VyLiBXZSB3YW50IHRvIGNvbGxlY3QgYWxsIHRoZSB2YXJpYWJsZXNcbiAgICAvLyBpbnRvIGdyb3Vwcy4gV2Ugd2lsbCB0YWtlIHRoZSB0d28gbGFyZ2VzdCBncm91cHMuXG4gICAgLy8gdmFyaWFibGVzIGFuZCBzdGF0aXN0aWNzIGdvIHRvZ2V0aGVyLiBUaGV5IGFyZSBkZXBlbmRlbnQgdmFyaWFiYWxlcyBpbiBNVi5cbiAgICAvLyBUaGUgdmFyaWFibGUvc3RhdCBwYWlycyBhbHdheXMgYXJlIGFzc29jaWF0ZWQgd2l0aCBkaWZmZXJlbnQgY3VydmVzLCBhbmQgd2lsbCBhbHdheXMgYmUgb24gZGlmZmVyZW50IGF4aXMsXG4gICAgLy8gaWYgcG9zc2libGUsIGJ1dCBtaWdodCBiZSBhc3NpZ25lZCBhbiBheGlzIHZpYSBhbiBheGVzIHBhcmFtZXRlci5cbiAgICBjb25zdCB5YXhlc0RlZmF1bHQgPSBcImF1dG8tYnktdmFyaWFibGVcIjtcbiAgICB2YXIgY3VydmVzID0gcGxvdFBhcmFtc1snY3VydmVzJ107XG4gICAgdmFyIGRlcGVuZGVudEF4ZXMgPSB7J3kxJzogW10sICd5Mic6IFtdfTtcbiAgICBkZXBlbmRlbnRBeGVzWyd5MSddLnB1c2goY3VydmVzWzBdKTtcbiAgICB2YXIgZGVwZW5kZW50QXhlc1ZhcmlhYmxlcyA9IHsneTEnOiBbY3VydmVzWzBdWyd2YXJpYWJsZSddXSwgJ3kyJzogW119O1xuICAgIGZvciAodmFyIGNpID0gMTsgY2kgPCBjdXJ2ZXMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgIGlmIChjdXJ2ZXNbY2ldWydkaWZmRnJvbSddKSB7XG4gICAgICAgICAgICAvLyBjdXJycmVudGx5IHdlIGRvIG5vdCBkbyBtdiBkaWZmZXJlbmNpbmdcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJ2ZXNbY2ldLnlheGVzICE9IHlheGVzRGVmYXVsdCkge1xuICAgICAgICAgICAgLy8gaXQgd2FzIGFzc2lnbmVkIGFuIGF4aXMgYnkgdGhlIGF4aXMgcGFyYW0gc28gc29ydCBpdCBpbnRvIGl0cyBzZWxlY3RlZFlheGVzXG4gICAgICAgICAgICBkZXBlbmRlbnRBeGVzW2N1cnZlc1tjaV0ueWF4ZXNdLnB1c2goY3VydmVzW2NpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzb3J0IGl0IGludG8gYW4gYXhpcyBieSBpdHMgdmFyaWFibGUvc3RhdCBjb21iaW5hdGlvblxuICAgICAgICAgICAgLy8gICAgIHZhcmlhYmxlczpcbiAgICAgICAgICAgIC8vICAgICB2YXJpYWJsZXMgdGhhdCBzaGFyZSBhbiBheGlzIGFyZSBkaWZmZXJlbnQgZGVwZW5kZW50IHZhcmlhYmxlcy4gUHV0IHRoZW0gaW4gZGVwMS5cbiAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIHZhcmlhYmxlIHdpdGggbXVsdGlwbGUgc3RhdHMuXG4gICAgICAgICAgICAvLyBkaWZmZXJlbnQgdmFyaWFibGUgd2l0aCBkaWZmZXJlbnQgc3RhdHMgdGhhdCBoYXZlIGRpZmZlcmluZyBheGlzIG11c3QgZ28gaW4gZGlmZmVyZW50IFkgYXhpcyB2YXJzIChhbmQgeW91IGNhbiBvbmx5IGhhdmUgdHdvIG9mIHRob3NlKVxuXG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IGN1cnZlc1tjaV0udmFyaWFibGU7XG4gICAgICAgICAgICBpZiAoZGVwZW5kZW50QXhlc1ZhcmlhYmxlc1sneTEnXS5pbmNsdWRlcyh2YXJpYWJsZSkpIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbnRBeGVzWyd5MSddLnB1c2goY3VydmVzW2NpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVudEF4ZXNbJ3kyJ10ucHVzaChjdXJ2ZXNbY2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW50QXhlcztcbn1cblxuZnVuY3Rpb24gYWRkRGVwcyhwbG90LCBkZXBlbmRlbnRBeGVzKSB7XG4gICAgdmFyIGRlcCA9IHBsb3QuZWxlKCdkZXAnKTtcbiAgICBjb25zdCBkZXBzID0ge1wiZGVwMVwiOlwieTFcIixcImRlcDJcIjpcInkyXCJ9O1xuICAgIGZvciAodmFyIGRpPTA7IGRpPE9iamVjdC5rZXlzKGRlcHMpLmxlbmd0aDtkaSsrKSB7ICAvLyBbZGVwMSwgZGVwMl1cbiAgICAgICAgdmFyIGRlcEtleSA9IE9iamVjdC5rZXlzKGRlcHMpW2RpXTsgIC8vIGRlcDEgb3IgZGVwMlxuICAgICAgICB2YXIgZGVwQXhpcyA9IGRlcHNbZGVwS2V5XTtcbiAgICAgICAgdmFyIHN1YkRlcCA9IGRlcC5lbGUoZGVwS2V5KTsgLy88ZGVwPjxkZXAxLz48ZGVwMi8+XG4gICAgICAgIHZhciB2YXJpYWJsZVN0YXRpc3RpY1BhaXJzID0ge307XG4gICAgICAgIGZvciAodmFyIGRhY2kgPSAwOyBkYWNpIDwgZGVwZW5kZW50QXhlc1tkZXBBeGlzXS5sZW5ndGg7IGRhY2krKykgeyAgICAvL1t5MSx5Ml1cbiAgICAgICAgICAgIC8vIHJlY29yZCB0aGUgdmFyaWFibGUtc3RhdGlzdGljIHBhaXJcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gZGVwZW5kZW50QXhlc1tkZXBBeGlzXVtkYWNpXVsndmFyaWFibGUnXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBzdGF0TXZUcmFuc2xhdGlvbltkZXBlbmRlbnRBeGVzW2RlcEF4aXNdW2RhY2ldWydzdGF0aXN0aWMnXV07XG4gICAgICAgICAgICBpZiAodmFyaWFibGVTdGF0aXN0aWNQYWlyc1t2YXJpYWJsZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlU3RhdGlzdGljUGFpcnNbdmFyaWFibGVdID0gW3N0YXRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZVN0YXRpc3RpY1BhaXJzW3ZhcmlhYmxlXS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2YXJzID0gT2JqZWN0LmtleXModmFyaWFibGVTdGF0aXN0aWNQYWlycyk7ICAvL1snVCcsJ0hHVCcsJ1dJTkQnLi4uXVxuICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IHZhcnMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhcmlhYmxlU3RhdGlzdGljUGFpcnNbdmFyc1t2XV0pKTtcbiAgICAgICAgICAgIHZhciBkZXBFbGVtID0gc3ViRGVwLmVsZSgnZmNzdF92YXInLCB7J25hbWUnOiB2YXJzW3ZdfSk7IC8vPGRlcD48ZGVwMT48ZmNzdF92YXIgbmFtZT0nVCc+PHN0YXQ+Uk1TPC9zdGF0PjwvZmNzdF92YXI+IDwvZGVwMT48ZGVwMi8+XG4gICAgICAgICAgICBmb3IgKHZhciBzaT0wO3NpPHN0YXRzLmxlbmd0aDtzaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVwRWxlbS5lbGUoJ3N0YXQnLHN0YXRzW3NpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZEFub21hbHljb3JyRGVwcyhwbG90LCBkZXBlbmRlbnRBeGVzKSB7XG4gICAgdmFyIGRlcCA9IHBsb3QuZWxlKCdkZXAnKTtcbiAgICBjb25zdCBkZXBzID0ge1wiZGVwMVwiOlwieTFcIixcImRlcDJcIjpcInkyXCJ9O1xuICAgIGZvciAodmFyIGRpPTA7IGRpPE9iamVjdC5rZXlzKGRlcHMpLmxlbmd0aDtkaSsrKSB7ICAvLyBbZGVwMSwgZGVwMl1cbiAgICAgICAgdmFyIGRlcEtleSA9IE9iamVjdC5rZXlzKGRlcHMpW2RpXTsgIC8vIGRlcDEgb3IgZGVwMlxuICAgICAgICB2YXIgZGVwQXhpcyA9IGRlcHNbZGVwS2V5XTtcbiAgICAgICAgdmFyIHN1YkRlcCA9IGRlcC5lbGUoZGVwS2V5KTsgLy88ZGVwPjxkZXAxLz48ZGVwMi8+XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAodmFyIGRhY2kgPSAwOyBkYWNpIDwgZGVwZW5kZW50QXhlc1tkZXBBeGlzXS5sZW5ndGg7IGRhY2krKykgeyAgICAvL1t5MSx5Ml1cbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gZGVwZW5kZW50QXhlc1tkZXBBeGlzXVtkYWNpXVsndmFyaWFibGUnXTtcbiAgICAgICAgICAgIHZhcmlhYmxlcy5hZGQodmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YXJzID0gQXJyYXkuZnJvbSh2YXJpYWJsZXMpO1xuICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IHZhcnMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICAgIHN1YkRlcC5lbGUoJ2Zjc3RfdmFyJywgeyduYW1lJzogdmFyc1t2XX0pLmVsZSgnc3RhdCcsJ0FOT01fQ09SUicpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBfYWRkU2VyaWVzTGFiZWxzID0gZnVuY3Rpb24oZWxlbWVudCxkZXBlbmRlbnRBeGVzLCBwbG90UGFyYW1zKSB7XG4gICAgY29uc3QgcGxvdFR5cGUgPSAoXy5pbnZlcnQocGxvdFBhcmFtcy5wbG90VHlwZXMpKVt0cnVlXTtcbiAgICB2YXIgbGFiZWw7XG4gICAgc3dpdGNoIChwbG90VHlwZSkge1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMudGltZVNlcmllczpcbiAgICAgICAgICAgIGxhYmVsID0gXCJUaW1lXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLmRpZW9mZjpcbiAgICAgICAgICAgIGxhYmVsID0gXCJGb3JlY2FzdCBIb3VyXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLmRhaWx5TW9kZWxDeWNsZTpcbiAgICAgICAgICAgIGxhYmVsID0gXCJUaW1lXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLmhpc3RvZ3JhbTpcbiAgICAgICAgICAgIGxhYmVsID0gXCJCaW5cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMudmFsaWR0aW1lOlxuICAgICAgICAgICAgbGFiZWwgPSBcIkhvdXIgb2YgRGF5XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnJlbGlhYmlsaXR5OlxuICAgICAgICAgICAgbGFiZWwgPSBcIlJlbGlhYmlsaXR5XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRocmVzaG9sZDpcbiAgICAgICAgICAgIGxhYmVsID0gXCJUaHJlc2hvbGRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMucHJvZmlsZTpcbiAgICAgICAgICAgIHZhciB2YXJzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgcGxvdFBhcmFtcy5jdXJ2ZXMuZm9yRWFjaChmdW5jdGlvbihjKXtcbiAgICAgICAgICAgICAgICB2YXJzLmFkZChjLnZhcmlhYmxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFiZWwgPSBBcnJheS5mcm9tKHZhcnMpLmpvaW4oJyAtICcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsYWJlbCA9IFwiVGltZVwiO1xuICAgIH1cbiAgICBlbGVtZW50LmVsZSgneF9sYWJlbCcsIGxhYmVsKTtcblxuICAgIHZhciB5MXZhcnMgPSBbXTtcbiAgICBmb3IgKHZhciB5MWk9MDsgeTFpIDwgZGVwZW5kZW50QXhlc1sneTEnXS5sZW5ndGg7IHkxaSsrKSB7XG4gICAgICAgIGlmICgheTF2YXJzLmluY2x1ZGVzKGRlcGVuZGVudEF4ZXNbJ3kxJ11beTFpXVsndmFyaWFibGUnXSkpIHtcbiAgICAgICAgICAgIHkxdmFycy5wdXNoKGRlcGVuZGVudEF4ZXNbJ3kxJ11beTFpXVsndmFyaWFibGUnXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudC5lbGUoJ3kxX2xhYmVsJywgeTF2YXJzLmpvaW4oJywnKSk7XG4gICAgdmFyIHkydmFycyA9IFtdO1xuICAgIGZvciAodmFyIHkyaT0wOyB5MmkgPCBkZXBlbmRlbnRBeGVzWyd5MiddLmxlbmd0aDsgeTJpKyspIHtcbiAgICAgICAgaWYgKCF5MnZhcnMuaW5jbHVkZXMoZGVwZW5kZW50QXhlc1sneTInXVt5MmldWyd2YXJpYWJsZSddKSkge1xuICAgICAgICAgICAgeTJ2YXJzLnB1c2goZGVwZW5kZW50QXhlc1sneTInXVt5MmldWyd2YXJpYWJsZSddKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50LmVsZSgneTJfbGFiZWwnLCB5MnZhcnMuam9pbignLCcpKTtcbn1cblxuY29uc3QgYWRkVGVtcGxhdGUgPSBmdW5jdGlvbihwbG90LHRlbXBsYXRlU3RyKVxue1xuICAgIHBsb3QuZWxlKCd0ZW1wbGF0ZScsIHRlbXBsYXRlU3RyKTtcbn1cblxuY29uc3QgYWRkSW5kZXBEYXRlcyA9IGZ1bmN0aW9uKHBsb3QsIHBsb3RQYXJhbXMpIHtcbiAgICB2YXIgaW5kZXAgPSBwbG90LmVsZSgnaW5kZXAnLCB7J2VxdWFsaXplJzogJ2ZhbHNlJywgJ25hbWUnOiAnZmNzdF92YWxpZF9iZWcnfSk7XG4gICAgYWRkSW5kZXBVbmdyb3VwZWREYXRlRWxlbWVudHNCZXR3ZWVuKGluZGVwLCBwbG90UGFyYW1zKTtcbn1cblxuY29uc3QgYWRkSW5kZXBMZXZlbHMgPSBmdW5jdGlvbihwbG90LCBwbG90UGFyYW1zKSB7XG4gICAgLy8gZm9yIHByb2ZpbGVzIHdlIHVzZSBhIHVuaW9uIG9mIGFsbCB0aGUgbGV2ZWxzIGF2YWlsYWJsZSBmb3IgYWxsIHRoZSBkYXRhLXNvdXJjZXNcbiAgICB2YXIgaW5kZXAgPSBwbG90LmVsZSgnaW5kZXAnLCB7J2VxdWFsaXplJzogJ2ZhbHNlJywgJ25hbWUnOiAnZmNzdF9sZXYnfSk7XG4gICAgdmFyIGN1cnZlcyA9IHBsb3RQYXJhbXMuY3VydmVzO1xuICAgIHZhciBsdmxTZXQgPSBuZXcgU2V0KCk7IC8vIHVzZSBhIHNldCB0byBhY2N1bXVsYXRlIGFsbCB0aGUgbGV2ZWxzXG4gICAgZm9yICh2YXIgY2k9MDsgY2k8Y3VydmVzLmxlbmd0aDtjaSsrKSB7XG4gICAgICAgIGlmIChjdXJ2ZXNbY2ldWydkaWZmRnJvbSddKSB7XG4gICAgICAgICAgICAvLyBjdXJycmVudGx5IHdlIGRvIG5vdCBkbyBtdiBkaWZmZXJlbmNpbmdcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnZlID0gY3VydmVzW2NpXTtcbiAgICAgICAgY29uc3QgZGF0YWJhc2UgPSBjdXJ2ZVsnZGF0YWJhc2UnXTtcbiAgICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IGN1cnZlWydkYXRhLXNvdXJjZSddO1xuICAgICAgICBjb25zdCBsZXZlbFZhbHMgPSBtYXRzQ29sbGVjdGlvbnMuQ3VydmVQYXJhbXMuZmluZE9uZSh7bmFtZTogJ2RhdGEtc291cmNlJ30pWydsZXZlbHNNYXAnXVtkYXRhYmFzZV1bZGF0YVNvdXJjZV07XG4gICAgICAgIGx2bFNldC5hZGQobGV2ZWxWYWxzKTtcbiAgICB9XG4gICAgLy8gb25seSBhZGQgdGhlIGZjc3RfbGV2IHRhZyBpZiB0aGVyZSBhcmUgcHJlcy1sZXZlbHMgcmVxdWVzdGVkIC0gbGVhdmluZyBpdCBvdXQgd2lsbCBnZXQgdGhlbSBhbGxcbiAgICBjb25zdCBsdmxzID0gQXJyYXkuZnJvbShsdmxTZXQpWzBdO1xuICAgIGZvciAodmFyIGxpPTA7IGxpPGx2bHMubGVuZ3RoO2xpKyspIHtcbiAgICAgICAgdmFyIHZhbCA9IGluZGVwLmVsZSgndmFsJyxsdmxzW2xpXSk7XG4gICAgICAgIHZhbC5hdHQoJ2xhYmVsJyxsdmxzW2xpXSk7XG4gICAgICAgIHZhbC5hdHQoJ3Bsb3RfdmFsJyxcIlwiKTtcbiAgICB9XG59XG5cbmNvbnN0IGFkZEluZGVwVmFsaWRIb3VycyA9IGZ1bmN0aW9uKHBsb3QsIHBsb3RQYXJhbXMpIHtcbiAgICAvLyBmb3IgdmFsaWRUaW1lcyB3ZSB1c2UgYSB1bmlvbiBvZiBhbGwgdGhlIHZ0cyBhdmFpbGFibGUgZm9yIGFsbCB0aGUgZGF0YS1zb3VyY2VzXG4gICAgdmFyIGluZGVwID0gcGxvdC5lbGUoJ2luZGVwJywgeydlcXVhbGl6ZSc6ICdmYWxzZScsICduYW1lJzogJ3ZhbGlkX2hvdXInfSk7XG4gICAgY29uc3QgaG91cnMgPSBfZ2V0U29ydGVkSG91cnNGb3JJbmRlcFJhbmdlKHBsb3RQYXJhbXMpO1xuICAgIGZvciAodmFyIGhpPTA7IGhpPGhvdXJzLmxlbmd0aDtoaSsrKSB7XG4gICAgICAgIHZhciB2YWwgPSBpbmRlcC5lbGUoJ3ZhbCcsaG91cnNbaGldKTtcbiAgICAgICAgdmFsLmF0dCgnbGFiZWwnLGhvdXJzW2hpXSk7XG4gICAgICAgIHZhbC5hdHQoJ3Bsb3RfdmFsJyxcIlwiKTtcbiAgICB9XG59XG5cbmNvbnN0IGFkZEluZGVwRm9yZWNhc3RIb3VycyA9IGZ1bmN0aW9uKHBsb3QsIHBsb3RQYXJhbXMpIHtcbiAgICAvLyBmb3IgZGllb2ZmcyB3ZSB1c2UgYSB1bmlvbiBvZiBhbGwgdGhlIGZocnMgYXZhaWxhYmxlIGZvciBhbGwgdGhlIGRhdGEtc291cmNlc1xuICAgIHZhciBpbmRlcCA9IHBsb3QuZWxlKCdpbmRlcCcsIHsnZXF1YWxpemUnOiAnZmFsc2UnLCAnbmFtZSc6ICdmY3N0X2xlYWQnfSk7XG4gICAgdmFyIGN1cnZlcyA9IHBsb3RQYXJhbXMuY3VydmVzO1xuICAgIHZhciBsZWFkU2V0ID0gbmV3IFNldCgpOyAvLyB1c2UgYSBzZXQgdG8gYWNjdW11bGF0ZSBhbGwgdGhlIGxldmVsc1xuICAgIGZvciAodmFyIGNpPTA7IGNpPGN1cnZlcy5sZW5ndGg7Y2krKykge1xuICAgICAgICBpZiAoY3VydmVzW2NpXVsnZGlmZkZyb20nXSkge1xuICAgICAgICAgICAgLy8gY3VycnJlbnRseSB3ZSBkbyBub3QgZG8gbXYgZGlmZmVyZW5jaW5nXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJ2ZSA9IGN1cnZlc1tjaV07XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlID0gY3VydmVbJ2RhdGFiYXNlJ107XG4gICAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBjdXJ2ZVsnZGF0YS1zb3VyY2UnXTtcbiAgICAgICAgY29uc3QgZm9yZWNhc3RMZW5ndGhzID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLmZpbmRPbmUoe25hbWU6ICdmb3JlY2FzdC1sZW5ndGgnfSlbJ29wdGlvbnNNYXAnXVtkYXRhYmFzZV1bZGF0YVNvdXJjZV07XG4gICAgICAgIGxlYWRTZXQuYWRkKGZvcmVjYXN0TGVuZ3Rocyk7XG4gICAgfVxuICAgIGNvbnN0IGxlYWRzID0gQXJyYXkuZnJvbShsZWFkU2V0KVswXTtcbiAgICBmb3IgKHZhciBsaT0wOyBsaTxsZWFkcy5sZW5ndGg7bGkrKykge1xuICAgICAgICB2YXIgdmFsID0gaW5kZXAuZWxlKCd2YWwnLGxlYWRzW2xpXSk7XG4gICAgICAgIHZhbC5hdHQoJ2xhYmVsJyxsZWFkc1tsaV0pO1xuICAgICAgICB2YWwuYXR0KCdwbG90X3ZhbCcsXCJcIik7XG4gICAgfVxufVxuXG5jb25zdCBhZGRUbXBsID0gZnVuY3Rpb24ocGxvdCwga2V5LCBwbG90UGFyYW1zLCBkZXBlbmRlbnRBeGVzKSB7XG4gICAgdmFyIHRtcGwgPSBwbG90LmVsZSgndG1wbCcpO1xuICAgIHRtcGwuZWxlKCdkYXRhX2ZpbGUnLCBrZXkgKyAnLmRhdGEnKTtcbiAgICB0bXBsLmVsZSgncGxvdF9maWxlJywga2V5ICsgJy5wbmcnKTtcbiAgICB0bXBsLmVsZSgncl9maWxlJywga2V5ICsgJy5SJyk7XG4gICAgdG1wbC5lbGUoJ3RpdGxlJywgX3RpdGxlKCkgKyBcIiA6IFwiICsgX3Bsb3RUZXh0KHBsb3RQYXJhbXMpICsgXCIgXCIgKyBwbG90UGFyYW1zLnBsb3RBY3Rpb24pO1xuICAgIF9hZGRTZXJpZXNMYWJlbHModG1wbCwgZGVwZW5kZW50QXhlcywgcGxvdFBhcmFtcyk7XG4gICAgdG1wbC5lbGUoJ2NhcHRpb24nKTtcbiAgICB0bXBsLmVsZSgnam9iX3RpdGxlJyk7XG4gICAgdG1wbC5lbGUoJ2tlZXBfcmV2aXNpb25zJywgJ2ZhbHNlJyk7XG4gICAgdG1wbC5lbGUoJ2xpc3RkaWZmc2VyaWVzMScsICdsaXN0KCknKTtcbiAgICB0bXBsLmVsZSgnbGlzdGRpZmZzZXJpZXMyJywgJ2xpc3QoKScpO1xufVxuXG5jb25zdCBhZGRQbG90Rml4ID0gZnVuY3Rpb24ocGxvdCkge1xuICAgIHBsb3QuZWxlKCdwbG90X2ZpeCcpO1xufVxuXG5jb25zdCBhZGRQbG90Q29uZCA9IGZ1bmN0aW9uKHBsb3QscGxvdFBhcmFtcylcbntcbiAgICBwbG90LmVsZSgncGxvdF9jb25kJyk7XG59XG5cbmNvbnN0IGFkZENhbGNTdGF0ID0gZnVuY3Rpb24ocGxvdCxzdGF0VHlwZSl7XG4gICAgcGxvdC5lbGUoJ2NhbGNfc3RhdCcpLmVsZShzdGF0VHlwZSx0cnVlKTtcbn0gLy8gdW51c2VkIGZvciB0aW1lIHNlcmllc1xuXG5jb25zdCBhZGRQbG90U3RhdCA9IGZ1bmN0aW9uKHBsb3Qsc3RhdCl7XG4gICAgLy9TdGF0aXN0aWNzIC0tLSBXZSBhbHdheXMgZG8gU3VtbWFyeSB3aXRoIE1lYW4gLSBzbyB0aGVyZVxuICAgIHBsb3QuZWxlKCdwbG90X3N0YXQnLHN0YXQpO1xufVxuXG5cbmNvbnN0IGFkZFBsb3RDbWQgPSBmdW5jdGlvbiAocGxvdCl7XG4gICAgcGxvdC5lbGUoJ3Bsb3RfY21kJyk7XG59XG5jb25zdCBhZGRZMUxpbSA9IGZ1bmN0aW9uKHBsb3Qpe1xuICAgIHBsb3QuZWxlKCd5MV9saW0nLCdjKCknKTtcbn1cbmNvbnN0IGFkZFkxQnVmciA9IGZ1bmN0aW9uKHBsb3Qpe1xuICAgIHBsb3QuZWxlKCd5MV9idWZyJywnMC4wNCcpO1xufVxuY29uc3QgYWRkWTJMaW0gPSBmdW5jdGlvbihwbG90KSB7XG4gICAgcGxvdC5lbGUoJ3kyX2xpbScsJ2MoKScpO1xufVxuXG5jb25zdCBhZGRNaXNjZWxsYW5lb3VzID0gZnVuY3Rpb24ocGxvdCxwbG90UGFyYW1zKSB7XG4gICAgcGxvdC5lbGUoJ2V2ZW50X2VxdWFsJywgJ2ZhbHNlJyk7XG5cbiAgICBjb25zdCBwbG90VHlwZSA9IChfLmludmVydChwbG90UGFyYW1zLnBsb3RUeXBlcykpW3RydWVdO1xuICAgIHN3aXRjaCAocGxvdFR5cGUpIHtcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRpbWVTZXJpZXM6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kaWVvZmY6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5kYWlseU1vZGVsQ3ljbGU6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5oaXN0b2dyYW06XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy52YWxpZHRpbWU6XG4gICAgICAgIGNhc2UgbWF0c1R5cGVzLlBsb3RUeXBlcy5yZWxpYWJpbGl0eTpcbiAgICAgICAgY2FzZSBtYXRzVHlwZXMuUGxvdFR5cGVzLnRocmVzaG9sZDpcbiAgICAgICAgICAgIHBsb3QuZWxlKCd2ZXJ0X3Bsb3QnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIHBsb3QuZWxlKCd4X3JldmVyc2UnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG1hdHNUeXBlcy5QbG90VHlwZXMucHJvZmlsZTpcbiAgICAgICAgICAgIHBsb3QuZWxlKCd2ZXJ0X3Bsb3QnLCAndHJ1ZScpO1xuICAgICAgICAgICAgcGxvdC5lbGUoJ3hfcmV2ZXJzZScsICd0cnVlJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBsb3QuZWxlKCd2ZXJ0X3Bsb3QnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIHBsb3QuZWxlKCd4X3JldmVyc2UnLCAnZmFsc2UnKTtcbiAgICB9XG5cbiAgICBwbG90LmVsZSgnbnVtX3N0YXRzJywgJ2ZhbHNlJyk7XG4gICAgcGxvdC5lbGUoJ2luZHkxX3N0YWcnLCAnZmFsc2UnKTtcbiAgICBwbG90LmVsZSgnaW5keTJfc3RhZycsICdmYWxzZScpO1xuICAgIHBsb3QuZWxlKCdncmlkX29uJywgJ3RydWUnKTtcbiAgICBwbG90LmVsZSgnc3luY19heGVzJywgJ2ZhbHNlJyk7XG4gICAgcGxvdC5lbGUoJ2R1bXBfcG9pbnRzMScsICd0cnVlJyk7XG4gICAgcGxvdC5lbGUoJ2R1bXBfcG9pbnRzMicsICd0cnVlJyk7XG4gICAgcGxvdC5lbGUoJ2xvZ195MScsICdmYWxzZScpO1xuICAgIHBsb3QuZWxlKCdsb2dfeTInLCAnZmFsc2UnKTtcbiAgICBwbG90LmVsZSgndmFyaWFuY2VpbmZsYXRpb25mYWN0b3InLCAnZmFsc2UnKTtcbiAgICBwbG90LmVsZSgncGxvdF90eXBlJywgJ3BuZzE2bScpO1xuICAgIHBsb3QuZWxlKCdwbG90X2hlaWdodCcsICc4LjUnKTtcbiAgICBwbG90LmVsZSgncGxvdF93aWR0aCcsICcxMScpO1xuICAgIHBsb3QuZWxlKCdwbG90X3JlcycsICc3MicpO1xuICAgIHBsb3QuZWxlKCdwbG90X3VuaXRzJywgJ2luJyk7XG4gICAgcGxvdC5lbGUoJ21hcicsICdjKDgsNCw1LDQpJyk7XG4gICAgcGxvdC5lbGUoJ21ncCcsICdjKDEsMSwwKScpO1xuICAgIHBsb3QuZWxlKCdjZXgnLCAnMScpO1xuICAgIHBsb3QuZWxlKCd0aXRsZV93ZWlnaHQnLCAnMicpO1xuICAgIHBsb3QuZWxlKCd0aXRsZV9zaXplJywgJzEuNCcpO1xuICAgIHBsb3QuZWxlKCd0aXRsZV9vZmZzZXQnLCAnLTInKTtcbiAgICBwbG90LmVsZSgndGl0bGVfYWxpZ24nLCAnMC41Jyk7XG4gICAgcGxvdC5lbGUoJ3h0bGFiX29yaWVudCcsICcxJyk7XG4gICAgcGxvdC5lbGUoJ3h0bGFiX3BlcnAnLCAnLTAuNzUnKTtcbiAgICBwbG90LmVsZSgneHRsYWJfaG9yaXonLCAnMC41Jyk7XG4gICAgcGxvdC5lbGUoJ3h0bGFiX2ZyZXEnLCAnMCcpO1xuICAgIHBsb3QuZWxlKCd4dGxhYl9zaXplJywgJzEnKTtcbiAgICBwbG90LmVsZSgneGxhYl93ZWlnaHQnLCAnMScpO1xuICAgIHBsb3QuZWxlKCd4bGFiX3NpemUnLCAnMScpO1xuICAgIHBsb3QuZWxlKCd4bGFiX29mZnNldCcsICcyJyk7XG4gICAgcGxvdC5lbGUoJ3hsYWJfYWxpZ24nLCAnMC41Jyk7XG4gICAgcGxvdC5lbGUoJ3l0bGFiX29yaWVudCcsICcxJyk7XG4gICAgcGxvdC5lbGUoJ3l0bGFiX3BlcnAnLCAnMC41Jyk7XG4gICAgcGxvdC5lbGUoJ3l0bGFiX2hvcml6JywgJzAuNScpO1xuICAgIHBsb3QuZWxlKCd5dGxhYl9zaXplJywgJzEnKTtcbiAgICBwbG90LmVsZSgneWxhYl93ZWlnaHQnLCAnMScpO1xuICAgIHBsb3QuZWxlKCd5bGFiX3NpemUnLCAnMScpO1xuICAgIHBsb3QuZWxlKCd5bGFiX29mZnNldCcsICctMicpO1xuICAgIHBsb3QuZWxlKCd5bGFiX2FsaWduJywgJzAuNScpO1xuICAgIHBsb3QuZWxlKCdncmlkX2x0eScsICczJyk7XG4gICAgcGxvdC5lbGUoJ2dyaWRfY29sJywgJyNjY2NjY2MnKTtcbiAgICBwbG90LmVsZSgnZ3JpZF9sd2QnLCAnMScpO1xuICAgIHBsb3QuZWxlKCdncmlkX3gnLCAnbGlzdFgnKTtcbiAgICBwbG90LmVsZSgneDJ0bGFiX29yaWVudCcsICcxJyk7XG4gICAgcGxvdC5lbGUoJ3gydGxhYl9wZXJwJywgJzEnKTtcbiAgICBwbG90LmVsZSgneDJ0bGFiX2hvcml6JywgJzAuNScpO1xuICAgIHBsb3QuZWxlKCd4MnRsYWJfc2l6ZScsICcwLjgnKTtcbiAgICBwbG90LmVsZSgneDJsYWJfc2l6ZScsICcwLjgnKTtcbiAgICBwbG90LmVsZSgneDJsYWJfb2Zmc2V0JywgJy0wLjUnKTtcbiAgICBwbG90LmVsZSgneDJsYWJfYWxpZ24nLCAnMC41Jyk7XG4gICAgcGxvdC5lbGUoJ3kydGxhYl9vcmllbnQnLCAnMScpO1xuICAgIHBsb3QuZWxlKCd5MnRsYWJfcGVycCcsICcwLjUnKTtcbiAgICBwbG90LmVsZSgneTJ0bGFiX2hvcml6JywgJzAuNScpO1xuICAgIHBsb3QuZWxlKCd5MnRsYWJfc2l6ZScsICcxJyk7XG4gICAgcGxvdC5lbGUoJ3kybGFiX3NpemUnLCAnMScpO1xuICAgIHBsb3QuZWxlKCd5MmxhYl9vZmZzZXQnLCAnMScpO1xuICAgIHBsb3QuZWxlKCd5MmxhYl9hbGlnbicsICcwLjUnKTtcbiAgICBwbG90LmVsZSgnbGVnZW5kX2JveCcsICdvJyk7XG4gICAgcGxvdC5lbGUoJ2xlZ2VuZF9pbnNldCcsICdjKDAsIC0uMjUpJyk7XG4gICAgcGxvdC5lbGUoJ2xlZ2VuZF9uY29sJywgJzMnKTtcbiAgICBwbG90LmVsZSgnbGVnZW5kX3NpemUnLCAnMC44Jyk7XG4gICAgcGxvdC5lbGUoJ2NhcHRpb25fd2VpZ2h0JywgJzEnKTtcbiAgICBwbG90LmVsZSgnY2FwdGlvbl9jb2wnLCAnIzMzMzMzMycpO1xuICAgIHBsb3QuZWxlKCdjYXB0aW9uX3NpemUnLCAnMC44Jyk7XG4gICAgcGxvdC5lbGUoJ2NhcHRpb25fb2Zmc2V0JywgJzMnKTtcbiAgICBwbG90LmVsZSgnY2FwdGlvbl9hbGlnbicsICcwJyk7XG4gICAgcGxvdC5lbGUoJ2NpX2FscGhhJywgJzAuMDUnKTtcbn1cblxuY29uc3QgZW5kUGxvdFNwZWMgPSBmdW5jdGlvbih4bWwpIHtcbiAgICB4bWwuZW5kKHtwcmV0dHk6IHRydWV9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWF0c1Bsb3RTcGVjVXRpbHMgPSB7XG4gICAgc3RhcnRQbG90U3BlYzpzdGFydFBsb3RTcGVjLFxuICAgIGFkZERlcHM6YWRkRGVwcyxcbiAgICBhZGRBbm9tYWx5Y29yckRlcHM6YWRkQW5vbWFseWNvcnJEZXBzLFxuICAgIGdldERlcGVuZGVudEF4aXM6Z2V0RGVwZW5kZW50QXhpcyxcbiAgICBhZGREYXRhYmFzZUVsZW1lbnQ6YWRkRGF0YWJhc2VFbGVtZW50LFxuICAgIGFkZEZvbGRlcnM6YWRkRm9sZGVycyxcbiAgICBhZGRQbG90Q2k6YWRkUGxvdENpLFxuICAgIGFkZFNob3dTaWduaWY6YWRkU2hvd1NpZ25pZixcbiAgICBhZGRQbG90RGlzcDphZGRQbG90RGlzcCxcbiAgICBhZGRDb2xvcnM6YWRkQ29sb3JzLFxuICAgIGFkZFBjaDphZGRQY2gsXG4gICAgYWRkVHlwZTphZGRUeXBlLFxuICAgIGFkZEx0eTphZGRMdHksXG4gICAgYWRkTHdkOmFkZEx3ZCxcbiAgICBhZGRDb25TZXJpZXM6YWRkQ29uU2VyaWVzLFxuICAgIGFkZE9yZGVyU2VyaWVzOmFkZE9yZGVyU2VyaWVzLFxuICAgIGFkZExlZ2VuZDphZGRMZWdlbmQsXG4gICAgYWRkU2VyaWVzOmFkZFNlcmllcyxcbiAgICBhZGRUZW1wbGF0ZTphZGRUZW1wbGF0ZSxcbiAgICBhZGRJbmRlcERhdGVzOmFkZEluZGVwRGF0ZXMsXG4gICAgYWRkVG1wbDphZGRUbXBsLFxuICAgIGFkZFBsb3RGaXg6YWRkUGxvdEZpeCxcbiAgICBhZGRQbG90Q29uZDphZGRQbG90Q29uZCxcbiAgICBhZGRDYWxjU3RhdDphZGRDYWxjU3RhdCxcbiAgICBhZGRQbG90U3RhdDphZGRQbG90U3RhdCxcbiAgICBhZGRQbG90Q21kOmFkZFBsb3RDbWQsXG4gICAgYWRkWTFMaW06YWRkWTFMaW0sXG4gICAgYWRkWTFCdWZyOmFkZFkxQnVmcixcbiAgICBhZGRZMkxpbTphZGRZMkxpbSxcbiAgICBhZGRNaXNjZWxsYW5lb3VzOmFkZE1pc2NlbGxhbmVvdXMsXG4gICAgZW5kUGxvdFNwZWM6ZW5kUGxvdFNwZWMsXG4gICAgYWRkSW5kZXBMZXZlbHM6YWRkSW5kZXBMZXZlbHMsXG4gICAgYWRkSW5kZXBGb3JlY2FzdEhvdXJzOmFkZEluZGVwRm9yZWNhc3RIb3VycyxcbiAgICBhZGRJbmRlcFZhbGlkSG91cnM6YWRkSW5kZXBWYWxpZEhvdXJzXG59IiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qKlxuICogQ3JlYXRlZCBieSBwaWVyY2Ugb24gOC8zMS8xNi5cbiAqL1xuaW1wb3J0ICcuL3B1YmxpY2F0aW9ucy5qcyc7XG5pbXBvcnQgJy4vZGF0YV91dGlsLmpzJztcbmltcG9ydCAnLi9kYXRhX3F1ZXJ5X3V0aWwuanMnO1xuaW1wb3J0ICcuL2RhdGFfZGlmZl91dGlsLmpzJztcbmltcG9ydCAnLi9kYXRhX21hdGNoX3V0aWwuanMnO1xuaW1wb3J0ICcuL2RhdGFfY3VydmVfb3BzX3V0aWwuanMnO1xuaW1wb3J0ICcuL2RhdGFfcGxvdF9vcHNfdXRpbC5qcyc7XG5pbXBvcnQgJy4vZGF0YV9wcm9jZXNzX3V0aWwuanMnO1xuaW1wb3J0ICcuL3Bsb3Rfc3BlY191dGlsLmpzJztcbmltcG9ydCAnLi9jYWNoZS5qcyc7XG5pbXBvcnQgJy4uL2JvdGgnO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbmltcG9ydCB7IE1ldGVvciB9IGZyb20gJ21ldGVvci9tZXRlb3InO1xuaW1wb3J0IHttYXRzQ29sbGVjdGlvbnN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuXG5pZiAoTWV0ZW9yLmlzU2VydmVyKSB7XG4gICAgTWV0ZW9yLnB1Ymxpc2goXCJDdXJ2ZVBhcmFtc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLmZpbmQoe30pO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZHkoKTtcbiAgICB9KTtcbiAgICBNZXRlb3IucHVibGlzaChcIkN1cnZlVGV4dFBhdHRlcm5zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRzQ29sbGVjdGlvbnMuQ3VydmVUZXh0UGF0dGVybnMuZmluZCh7fSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuICAgIH0pO1xuICAgIE1ldGVvci5wdWJsaXNoKFwiU2NhdHRlckF4aXNUZXh0UGF0dGVyblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLlNjYXR0ZXJBeGlzVGV4dFBhdHRlcm4uZmluZCh7fSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuICAgIH0pO1xuICAgIE1ldGVvci5wdWJsaXNoKFwiU2F2ZWRDdXJ2ZVBhcmFtc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLlNhdmVkQ3VydmVQYXJhbXMuZmluZCh7fSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuICAgIH0pO1xuICAgIE1ldGVvci5wdWJsaXNoKFwiUGxvdFBhcmFtc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLlBsb3RQYXJhbXMuZmluZCh7fSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuICAgIH0pO1xuICAgIE1ldGVvci5wdWJsaXNoKFwiU2NhdHRlcjJkUGFyYW1zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRzQ29sbGVjdGlvbnMuU2NhdHRlcjJkUGFyYW1zLmZpbmQoe30pO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZHkoKTtcbiAgICB9KTtcbiAgICBNZXRlb3IucHVibGlzaChcIlBsb3RHcmFwaEZ1bmN0aW9uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLlBsb3RHcmFwaEZ1bmN0aW9ucy5maW5kKHt9KTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWR5KCk7XG4gICAgfSk7XG4gICAgTWV0ZW9yLnB1Ymxpc2goXCJSZWdpb25zUGVyTW9kZWxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdHNDb2xsZWN0aW9ucy5SZWdpb25zUGVyTW9kZWwuZmluZCh7fSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuICAgIH0pO1xuICAgIE1ldGVvci5wdWJsaXNoKFwiU2l0ZXNQZXJNb2RlbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLlNpdGVzUGVyTW9kZWwuZmluZCh7fSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuICAgIH0pO1xuICAgIE1ldGVvci5wdWJsaXNoKFwiUmVnaW9uRGVzY3JpcHRpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRzQ29sbGVjdGlvbnMuUmVnaW9uRGVzY3JpcHRpb25zLmZpbmQoe30pO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZHkoKTtcbiAgICB9KTtcbiAgICBNZXRlb3IucHVibGlzaChcIk1vZGVsc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLk1vZGVscy5maW5kKHt9KTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWR5KCk7XG4gICAgfSk7XG4gICAgTWV0ZW9yLnB1Ymxpc2goXCJGY3N0TGVuc1Blck1vZGVsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRzQ29sbGVjdGlvbnMuRmNzdExlbnNQZXJNb2RlbC5maW5kKHt9KTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWR5KCk7XG4gICAgfSk7XG4gICAgTWV0ZW9yLnB1Ymxpc2goXCJDb2xvclNjaGVtZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLkNvbG9yU2NoZW1lLmZpbmQoe30pO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZHkoKTtcbiAgICB9KTtcbiAgICBNZXRlb3IucHVibGlzaChcIlNldHRpbmdzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRzQ29sbGVjdGlvbnMuU2V0dGluZ3MuZmluZCh7fSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuICAgIH0pO1xuICAgIE1ldGVvci5wdWJsaXNoKFwiQ3VydmVTZXR0aW5nc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlU2V0dGluZ3MuZmluZCh7fSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuICAgIH0pO1xuICAgIE1ldGVvci5wdWJsaXNoKFwiU2VudEFkZHJlc3Nlc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLlNlbnRBZGRyZXNzZXMuZmluZCh7dXNlcklkOiB0aGlzLnVzZXJJZH0pO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZHkoKTtcbiAgICB9KTtcbi8vIGRvIG5vdCBwdWJsaXNoIHJvbGVzXG4vLyBNZXRlb3IucHVibGlzaChcIlJvbGVzXCIsIGZ1bmN0aW9uICgpIHtcbi8vICAgICB2YXIgZGF0YSA9IG1hdHNDb2xsZWN0aW9ucy5Sb2xlcy5maW5kKHt9KTtcbi8vICAgICBpZiAoZGF0YSkge1xuLy8gICAgICAgICByZXR1cm4gZGF0YTtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIHRoaXMucmVhZHkoKTtcbi8vIH0pO1xuXG4vLyBkbyBub3QgcHVibGlzaCBBdXRob3JpemF0aW9uXG4vLyBNZXRlb3IucHVibGlzaChcIkF1dGhvcml6YXRpb25cIiwgZnVuY3Rpb24gKCkge1xuLy8gICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLkF1dGhvcml6YXRpb24uZmluZCh7fSk7XG4vLyAgICAgaWYgKGRhdGEpIHtcbi8vICAgICAgICAgcmV0dXJuIGRhdGE7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiB0aGlzLnJlYWR5KCk7XG4vLyB9KTtcblxuLy8gZG8gbm90IHB1Ymxpc2ggY3JlZGVudGlhbHNcbi8vIE1ldGVvci5wdWJsaXNoKFwiQ3JlZGVudGlhbHNcIiwgZnVuY3Rpb24gKCkge1xuLy8gICAgIHZhciBkYXRhID0gbWF0c0NvbGxlY3Rpb25zLkNyZWRlbnRpYWxzLmZpbmQoe30pO1xuLy8gICAgIGlmIChkYXRhKSB7XG4vLyAgICAgICAgIHJldHVybiBkYXRhO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuLy8gfSk7XG5cbi8vZG8gbm90IHB1Ymxpc2ggZGF0YWJhc2VzXG4vLyBNZXRlb3IucHVibGlzaChcIkRhdGFiYXNlc1wiLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgdmFyIGRhdGEgPSBtYXRzQ29sbGVjdGlvbnMuRGF0YWJhc2VzLmZpbmQoe30pO1xuLy8gICAgIGlmIChkYXRhKSB7XG4vLyAgICAgICAgIHJldHVybiBkYXRhO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuLy8gfSk7XG4gICAgTWV0ZW9yLnB1Ymxpc2goXCJTaXRlTWFwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRzQ29sbGVjdGlvbnMuU2l0ZU1hcC5maW5kKHt9KTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWR5KCk7XG4gICAgfSk7XG4gICAgTWV0ZW9yLnB1Ymxpc2goXCJTdGF0aW9uTWFwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRzQ29sbGVjdGlvbnMuU3RhdGlvbk1hcC5maW5kKHt9KTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWR5KCk7XG4gICAgfSk7XG4gICAgTWV0ZW9yLnB1Ymxpc2goXCJhcHBOYW1lXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRzQ29sbGVjdGlvbnMuYXBwTmFtZS5maW5kKHt9KTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWR5KCk7XG4gICAgfSk7XG59IiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBDb2xvcmFkbyBTdGF0ZSBVbml2ZXJzaXR5IGFuZCBSZWdlbnRzIG9mIHRoZSBVbml2ZXJzaXR5IG9mIENvbG9yYWRvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbmltcG9ydCB7TWV0ZW9yfSBmcm9tIFwibWV0ZW9yL21ldGVvclwiO1xuaW1wb3J0IHttYXRzQ29sbGVjdGlvbnN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaWYgKE1ldGVvci5pc1NlcnZlcikge1xuICAgIGNvbnN0IFJlc3VsdHMgPSByZXF1aXJlKCdub2RlLWZpbGUtY2FjaGUnKS5jcmVhdGUoe2ZpbGU6J2ZpbGVDYWNoZScsIGxpZmU6IDggKiAzNjAwfSk7XG4gICAgdmFyIGdldFJlc3VsdCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYXNrZWQgdG8gZ2V0IHJlc3VsdCBmcm9tIGNhY2hlIGZvciBrZXk6Jywga2V5KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFJlc3VsdHMuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBzdG9yZVJlc3VsdCA9IGZ1bmN0aW9uIChrZXksIHJlc3VsdCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdhc2tlZCB0byBzZXQgcmVzdWx0IGluIGNhY2hlIGZvciBhcHA6ICcscHJvY2Vzcy5lbnYuUFdELCAnIGtleTonLCBrZXkpO1xuICAgICAgICBSZXN1bHRzLnNldChrZXksIHJlc3VsdCk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3NldCByZXN1bHQgaW4gY2FjaGUgZm9yIGFwcDogJywgcHJvY2Vzcy5lbnYuUFdELCAna2V5OicsIGtleSk7XG4gICAgfVxuICAgIHZhciBjbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYXNrZWQgdG8gY2xlYXIgcmVzdWx0IGNhY2hlJyk7XG4gICAgICAgIFJlc3VsdHMuY2xlYXIoKTtcbiAgICB9XG4gICAgdmFyIGV4cGlyZUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdhc2tlZCB0byBjbGVhciByZXN1bHQgY2FjaGUgZm9yIGtleSAnLCBrZXkpO1xuICAgICAgICBSZXN1bHRzLmV4cGlyZShrZXkpO1xuICAgIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdFxuICAgIG1hdHNDYWNoZSA9IHtcbiAgICAgICAgZ2V0UmVzdWx0OiBnZXRSZXN1bHQsXG4gICAgICAgIHN0b3JlUmVzdWx0OiBzdG9yZVJlc3VsdCxcbiAgICAgICAgY2xlYXI6IGNsZWFyLFxuICAgICAgICBleHBpcmVLZXk6IGV4cGlyZUtleVxuICAgIH1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgQ29sb3JhZG8gU3RhdGUgVW5pdmVyc2l0eSBhbmQgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuICAgIHZhciBnYXVzc2lhbkVsaW1pbmF0aW9uID0gZnVuY3Rpb24oYSwgbykge1xuICAgICAgICAgICB2YXIgaSA9IDAsIGogPSAwLCBrID0gMCwgbWF4cm93ID0gMCwgdG1wID0gMCwgbiA9IGEubGVuZ3RoIC0gMSwgeCA9IG5ldyBBcnJheShvKTtcbiAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICBtYXhyb3cgPSBpO1xuICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYVtpXVtqXSkgPiBNYXRoLmFicyhhW2ldW21heHJvd10pKVxuICAgICAgICAgICAgICAgICAgICBtYXhyb3cgPSBqO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoayA9IGk7IGsgPCBuICsgMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgIHRtcCA9IGFba11baV07XG4gICAgICAgICAgICAgICAgIGFba11baV0gPSBhW2tdW21heHJvd107XG4gICAgICAgICAgICAgICAgIGFba11bbWF4cm93XSA9IHRtcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgICBmb3IgKGsgPSBuOyBrID49IGk7IGstLSkge1xuICAgICAgICAgICAgICAgICAgICBhW2tdW2pdIC09IGFba11baV0gKiBhW2ldW2pdIC8gYVtpXVtpXTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgZm9yIChqID0gbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgIHRtcCA9IDA7XG4gICAgICAgICAgICAgIGZvciAoayA9IGogKyAxOyBrIDwgbjsgaysrKVxuICAgICAgICAgICAgICAgICB0bXAgKz0gYVtrXVtqXSAqIHhba107XG4gICAgICAgICAgICAgIHhbal0gPSAoYVtuXVtqXSAtIHRtcCkgLyBhW2pdW2pdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiAoeCk7XG4gICAgfTtcblxuICAgIHZhciBtZXRob2RzID0ge1xuICAgICAgICAgICAgbGluZWFyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bSA9IFswLCAwLCAwLCAwLCAwXSwgbiA9IDAsIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBuIDwgZGF0YS5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbbl1bMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdW1bMF0gKz0gZGF0YVtuXVswXTtcbiAgICAgICAgICAgICAgICAgICAgc3VtWzFdICs9IGRhdGFbbl1bMV07XG4gICAgICAgICAgICAgICAgICAgIHN1bVsyXSArPSBkYXRhW25dWzBdICogZGF0YVtuXVswXTtcbiAgICAgICAgICAgICAgICAgICAgc3VtWzNdICs9IGRhdGFbbl1bMF0gKiBkYXRhW25dWzFdO1xuICAgICAgICAgICAgICAgICAgICBzdW1bNF0gKz0gZGF0YVtuXVsxXSAqIGRhdGFbbl1bMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gKG4gKiBzdW1bM10gLSBzdW1bMF0gKiBzdW1bMV0pIC8gKG4gKiBzdW1bMl0gLSBzdW1bMF0gKiBzdW1bMF0pO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcmNlcHQgPSAoc3VtWzFdIC8gbikgLSAoZ3JhZGllbnQgKiBzdW1bMF0pIC8gbjtcbiAgICAgICAgICAgICAgLy8gIHZhciBjb3JyZWxhdGlvbiA9IChuICogc3VtWzNdIC0gc3VtWzBdICogc3VtWzFdKSAvIE1hdGguc3FydCgobiAqIHN1bVsyXSAtIHN1bVswXSAqIHN1bVswXSkgKiAobiAqIHN1bVs0XSAtIHN1bVsxXSAqIHN1bVsxXSkpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSBbZGF0YVtpXVswXSwgZGF0YVtpXVswXSAqIGdyYWRpZW50ICsgaW50ZXJjZXB0XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNvb3JkaW5hdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSAneSA9ICcgKyBNYXRoLnJvdW5kKGdyYWRpZW50KjEwMCkgLyAxMDAgKyAneCArICcgKyBNYXRoLnJvdW5kKGludGVyY2VwdCoxMDApIC8gMTAwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtlcXVhdGlvbjogW2dyYWRpZW50LCBpbnRlcmNlcHRdLCBwb2ludHM6IHJlc3VsdHMsIHN0cmluZzogc3RyaW5nfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGxpbmVhclRocm91Z2hPcmlnaW46IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gWzAsIDBdLCBuID0gMCwgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IG4gPCBkYXRhLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW25dWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bVswXSArPSBkYXRhW25dWzBdICogZGF0YVtuXVswXTsgLy9zdW1TcVhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bVsxXSArPSBkYXRhW25dWzBdICogZGF0YVtuXVsxXTsgLy9zdW1YWVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gc3VtWzFdIC8gc3VtWzBdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSBbZGF0YVtpXVswXSwgZGF0YVtpXVswXSAqIGdyYWRpZW50XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNvb3JkaW5hdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSAneSA9ICcgKyBNYXRoLnJvdW5kKGdyYWRpZW50KjEwMCkgLyAxMDAgKyAneCc7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge2VxdWF0aW9uOiBbZ3JhZGllbnRdLCBwb2ludHM6IHJlc3VsdHMsIHN0cmluZzogc3RyaW5nfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGV4cG9uZW50aWFsOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bSA9IFswLCAwLCAwLCAwLCAwLCAwXSwgbiA9IDAsIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAobGVuID0gZGF0YS5sZW5ndGg7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbbl1bMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdW1bMF0gKz0gZGF0YVtuXVswXTtcbiAgICAgICAgICAgICAgICAgICAgc3VtWzFdICs9IGRhdGFbbl1bMV07XG4gICAgICAgICAgICAgICAgICAgIHN1bVsyXSArPSBkYXRhW25dWzBdICogZGF0YVtuXVswXSAqIGRhdGFbbl1bMV07XG4gICAgICAgICAgICAgICAgICAgIHN1bVszXSArPSBkYXRhW25dWzFdICogTWF0aC5sb2coZGF0YVtuXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHN1bVs0XSArPSBkYXRhW25dWzBdICogZGF0YVtuXVsxXSAqIE1hdGgubG9nKGRhdGFbbl1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBzdW1bNV0gKz0gZGF0YVtuXVswXSAqIGRhdGFbbl1bMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gKHN1bVsxXSAqIHN1bVsyXSAtIHN1bVs1XSAqIHN1bVs1XSk7XG4gICAgICAgICAgICAgICAgdmFyIEEgPSBNYXRoLnBvdyhNYXRoLkUsIChzdW1bMl0gKiBzdW1bM10gLSBzdW1bNV0gKiBzdW1bNF0pIC8gZGVub21pbmF0b3IpO1xuICAgICAgICAgICAgICAgIHZhciBCID0gKHN1bVsxXSAqIHN1bVs0XSAtIHN1bVs1XSAqIHN1bVszXSkgLyBkZW5vbWluYXRvcjtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlID0gW2RhdGFbaV1bMF0sIEEgKiBNYXRoLnBvdyhNYXRoLkUsIEIgKiBkYXRhW2ldWzBdKV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjb29yZGluYXRlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gJ3kgPSAnICsgTWF0aC5yb3VuZChBKjEwMCkgLyAxMDAgKyAnZV4oJyArIE1hdGgucm91bmQoQioxMDApIC8gMTAwICsgJ3gpJztcblxuICAgICAgICAgICAgICAgIHJldHVybiB7ZXF1YXRpb246IFtBLCBCXSwgcG9pbnRzOiByZXN1bHRzLCBzdHJpbmc6IHN0cmluZ307XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsb2dhcml0aG1pYzogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBzdW0gPSBbMCwgMCwgMCwgMF0sIG4gPSAwLCByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxlbiA9IGRhdGEubGVuZ3RoOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhW25dWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtWzBdICs9IE1hdGgubG9nKGRhdGFbbl1bMF0pO1xuICAgICAgICAgICAgICAgICAgICBzdW1bMV0gKz0gZGF0YVtuXVsxXSAqIE1hdGgubG9nKGRhdGFbbl1bMF0pO1xuICAgICAgICAgICAgICAgICAgICBzdW1bMl0gKz0gZGF0YVtuXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgc3VtWzNdICs9IE1hdGgucG93KE1hdGgubG9nKGRhdGFbbl1bMF0pLCAyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgQiA9IChuICogc3VtWzFdIC0gc3VtWzJdICogc3VtWzBdKSAvIChuICogc3VtWzNdIC0gc3VtWzBdICogc3VtWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgQSA9IChzdW1bMl0gLSBCICogc3VtWzBdKSAvIG47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IFtkYXRhW2ldWzBdLCBBICsgQiAqIE1hdGgubG9nKGRhdGFbaV1bMF0pXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNvb3JkaW5hdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSAneSA9ICcgKyBNYXRoLnJvdW5kKEEqMTAwKSAvIDEwMCArICcgKyAnICsgTWF0aC5yb3VuZChCKjEwMCkgLyAxMDAgKyAnIGxuKHgpJztcblxuICAgICAgICAgICAgICAgIHJldHVybiB7ZXF1YXRpb246IFtBLCBCXSwgcG9pbnRzOiByZXN1bHRzLCBzdHJpbmc6IHN0cmluZ307XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwb3dlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBzdW0gPSBbMCwgMCwgMCwgMF0sIG4gPSAwLCByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxlbiA9IGRhdGEubGVuZ3RoOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhW25dWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtWzBdICs9IE1hdGgubG9nKGRhdGFbbl1bMF0pO1xuICAgICAgICAgICAgICAgICAgICBzdW1bMV0gKz0gTWF0aC5sb2coZGF0YVtuXVsxXSkgKiBNYXRoLmxvZyhkYXRhW25dWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgc3VtWzJdICs9IE1hdGgubG9nKGRhdGFbbl1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBzdW1bM10gKz0gTWF0aC5wb3coTWF0aC5sb2coZGF0YVtuXVswXSksIDIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBCID0gKG4gKiBzdW1bMV0gLSBzdW1bMl0gKiBzdW1bMF0pIC8gKG4gKiBzdW1bM10gLSBzdW1bMF0gKiBzdW1bMF0pO1xuICAgICAgICAgICAgICAgIHZhciBBID0gTWF0aC5wb3coTWF0aC5FLCAoc3VtWzJdIC0gQiAqIHN1bVswXSkgLyBuKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlID0gW2RhdGFbaV1bMF0sIEEgKiBNYXRoLnBvdyhkYXRhW2ldWzBdICwgQildO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY29vcmRpbmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSAneSA9ICcgKyBNYXRoLnJvdW5kKEEqMTAwKSAvIDEwMCArICd4XicgKyBNYXRoLnJvdW5kKEIqMTAwKSAvIDEwMDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7ZXF1YXRpb246IFtBLCBCXSwgcG9pbnRzOiByZXN1bHRzLCBzdHJpbmc6IHN0cmluZ307XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwb2x5bm9taWFsOiBmdW5jdGlvbihkYXRhLCBvcmRlcikge1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBvcmRlciA9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIHZhciBsaHMgPSBbXSwgcmhzID0gW10sIHJlc3VsdHMgPSBbXSwgYSA9IDAsIGIgPSAwLCBpID0gMCwgayA9IG9yZGVyICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgbCA8IGxlbjsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtsXVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBNYXRoLnBvdyhkYXRhW2xdWzBdLCBpKSAqIGRhdGFbbF1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxocy5wdXNoKGEpLCBhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBsIDwgbGVuOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtsXVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgKz0gTWF0aC5wb3coZGF0YVtsXVswXSwgaSArIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnB1c2goYiksIGIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaHMucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByaHMucHVzaChsaHMpO1xuXG4gICAgICAgICAgICAgICB2YXIgZXF1YXRpb24gPSBnYXVzc2lhbkVsaW1pbmF0aW9uKHJocywgayk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnN3ZXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBlcXVhdGlvbi5sZW5ndGg7IHcrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuc3dlciArPSBlcXVhdGlvblt3XSAqIE1hdGgucG93KGRhdGFbaV1bMF0sIHcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFtkYXRhW2ldWzBdLCBhbnN3ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSAneSA9ICc7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gZXF1YXRpb24ubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKXtcbiAgICAgICAgICAgICAgICAgICAgICBpZihpID4gMSkgc3RyaW5nICs9IE1hdGgucm91bmQoZXF1YXRpb25baV0gKiBNYXRoLnBvdygxMCwgaSkpIC8gTWF0aC5wb3coMTAsIGkpICArICd4XicgKyBpICsgJyArICc7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSAxKSBzdHJpbmcgKz0gTWF0aC5yb3VuZChlcXVhdGlvbltpXSoxMDApIC8gMTAwICsgJ3gnICsgJyArICc7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBzdHJpbmcgKz0gTWF0aC5yb3VuZChlcXVhdGlvbltpXSoxMDApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge2VxdWF0aW9uOiBlcXVhdGlvbiwgcG9pbnRzOiByZXN1bHRzLCBzdHJpbmc6IHN0cmluZ307XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsYXN0dmFsdWU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGxhc3R2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldWzFdKSB7XG4gICAgICAgICAgICAgICAgICBsYXN0dmFsdWUgPSBkYXRhW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFtkYXRhW2ldWzBdLCBkYXRhW2ldWzFdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFtkYXRhW2ldWzBdLCBsYXN0dmFsdWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4ge2VxdWF0aW9uOiBbbGFzdHZhbHVlXSwgcG9pbnRzOiByZXN1bHRzLCBzdHJpbmc6IFwiXCIgKyBsYXN0dmFsdWV9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgZXhwb3J0IGRlZmF1bHQgIHJlZ3Jlc3Npb24gPSBmdW5jdGlvbihtZXRob2QsIGRhdGEsIG9yZGVyKSB7XG4gICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXShkYXRhLCBvcmRlcik7XG4gICAgICAgfVxuICAgIH07XG5cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgQ29sb3JhZG8gU3RhdGUgVW5pdmVyc2l0eSBhbmQgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5pbXBvcnQge21hdHNUeXBlc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNDb2xsZWN0aW9uc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNDdXJ2ZVV0aWxzfSBmcm9tICdtZXRlb3IvcmFuZHlwOm1hdHMtY29tbW9uJztcbmltcG9ydCB7bWF0c1Bsb3RVdGlsc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21vbWVudH0gZnJvbSAnbWV0ZW9yL21vbWVudGpzOm1vbWVudCdcblxuLy8gZ2V0IHRoZSBkb2N1bWVudCBpZCBmb3IgdGhlIGNvbnRyb2wgYnV0dG9uIGVsZW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGFyYW0gbmFtZVxuY29uc3QgZ2V0Q29udHJvbEJ1dHRvbklkRm9yUGFyYW1OYW1lID0gZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgIC8vIHNjYXR0ZXIgYXhpcyBkb24ndCByZWFsbHkgZXhpc3QgaW4gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zIGJ1dCB0aGV5IGFyZSBlbGVtZW50c1xuICAgIGNvbnN0IHBuYW1lID0gcGFyYW1OYW1lLnJlcGxhY2UoL14uYXhpcy0vLCAnJyk7XG4gICAgY29uc3QgcGFyYW0gPSBtYXRzQ29sbGVjdGlvbnMuQ3VydmVQYXJhbXMuZmluZE9uZSh7bmFtZTogcG5hbWV9KTtcbiAgICBpZiAocGFyYW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBpZCA9IFwiY29udHJvbEJ1dHRvbi1cIiArIHBhcmFtLm5hbWU7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG59O1xuXG4vLyBnZXQgdGhlIGNvbnRyb2wgQnV0dG9uIEVsZW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGFyYW0gbmFtZVxuY29uc3QgZ2V0Q29udHJvbEVsZW1lbnRGb3JQYXJhbU5hbWUgPSBmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgLy8gc2NhdHRlciBheGlzIGRvbid0IHJlYWxseSBleGlzdCBpbiBtYXRzQ29sbGVjdGlvbnMuQ3VydmVQYXJhbXMgYnV0IHRoZXkgYXJlIGVsZW1lbnRzXG4gICAgY29uc3QgcG5hbWUgPSBwYXJhbU5hbWUucmVwbGFjZSgvXi5heGlzLS8sICcnKTtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ2V0Q29udHJvbEJ1dHRvbklkRm9yUGFyYW1OYW1lKHBuYW1lKSk7XG59O1xuXG4vLyBnZXQgdGhlIGRvY3VtZW50IGVsZW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGFyYW0gbmFtZVxuY29uc3QgZ2V0VmFsdWVFbGVtZW50Rm9yUGFyYW1OYW1lID0gZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgIC8vIHNjYXR0ZXIgYXhpcyBkb24ndCByZWFsbHkgZXhpc3QgaW4gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zIGJ1dCB0aGV5IGFyZSBlbGVtZW50c1xuICAgIGNvbnN0IHBuYW1lID0gcGFyYW1OYW1lLnJlcGxhY2UoL14uYXhpcy0vLCAnJyk7XG4gICAgY29uc3QgdmFsID0gZ2V0VmFsdWVJZEZvclBhcmFtTmFtZShwbmFtZSk7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHZhbCk7XG59O1xuXG4vLyBnZXQgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgdmFsdWUgaW4gdGhlIGRvY3VtZW50IGVsZW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGFyYW0gbmFtZVxuLy8gTm90ZSB0aGF0IHRoZSB2YWx1ZSBzaG91bGQgYmUgcmVmbGVjdGVkIGluIHRoZSBhZGpvaW5pbmcgY29udHJvbCBidXR0b24gdmFsdWUgdGV4dENvbnRlbnQuXG5jb25zdCBnZXRWYWx1ZUZvclBhcmFtTmFtZSA9IGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBlbGVtID0gZ2V0VmFsdWVFbGVtZW50Rm9yUGFyYW1OYW1lKHBhcmFtTmFtZSk7XG4gICAgICAgIHJldHVybiBnZXRWYWx1ZUVsZW1lbnRGb3JQYXJhbU5hbWUocGFyYW1OYW1lKS50ZXh0Q29udGVudC50cmltKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vLyBnZXQgdGhlIFZBTFVFIEJPWCBpZCBmb3IgdGhlIGVsZW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGFyYW0gbmFtZVxuY29uc3QgZ2V0VmFsdWVJZEZvclBhcmFtTmFtZSA9IGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICAvLyBzY2F0dGVyIGF4aXMgZG9uJ3QgcmVhbGx5IGV4aXN0IGluIG1hdHNDb2xsZWN0aW9ucy5DdXJ2ZVBhcmFtcyBidXQgdGhleSBhcmUgZWxlbWVudHNcbiAgICBjb25zdCBwbmFtZSA9IHBhcmFtTmFtZS5yZXBsYWNlKC9eLmF4aXMtLywgJycpO1xuICAgIHJldHVybiBcImNvbnRyb2xCdXR0b24tXCIgKyBwbmFtZSArIFwiLXZhbHVlXCI7XG59O1xuXG4vLyBzZXQgdGhlIFZBTFVFIEJPWCB0ZXh0IGZvciB0aGUgZWxlbWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBwYXJhbSBuYW1lXG5jb25zdCBzZXRWYWx1ZVRleHRGb3JQYXJhbU5hbWUgPSBmdW5jdGlvbiAocGFyYW1OYW1lLCB0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRleHQgPSB0ZXh0O1xuICAgICAgICB2YXIgcGFyYW0gPSBtYXRzQ29sbGVjdGlvbnMuQ3VydmVQYXJhbXMuZmluZE9uZSh7bmFtZTogcGFyYW1OYW1lfSk7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbSA9IG1hdHNDb2xsZWN0aW9ucy5QbG90UGFyYW1zLmZpbmRPbmUoe25hbWU6IHBhcmFtTmFtZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHBhcmFtLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uLiBpZiBtdWx0aSBzZWxlY3RlZCAgZ2V0IHRoZSBmaXJzdCAuLiBsYXN0XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZ2V0SW5wdXRFbGVtZW50Rm9yUGFyYW1OYW1lKHBhcmFtTmFtZSkuc2VsZWN0ZWRPcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb24ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHNlbGVjdGlvblswXS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gc2VsZWN0aW9uWzBdLnRleHRDb250ZW50ICsgXCIgLi4gXCIgKyBzZWxlY3Rpb25bc2VsZWN0aW9uLmxlbmd0aCAtIDFdLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtID0gZ2V0VmFsdWVFbGVtZW50Rm9yUGFyYW1OYW1lKHBhcmFtTmFtZSk7XG4gICAgICAgIGlmIChlbGVtLnRleHRDb250ZW50ICE9PSB0ZXh0KSB7XG4gICAgICAgICAgICBlbGVtLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3I6IGNvdWxkIG5vdCBmaW5kIHBhcmFtOiBcIiArIHBhcmFtTmFtZSk7XG4gICAgfVxufTtcblxuLy8gZ2V0IHRoZSBkb2N1bWVudCBpZCBmb3IgdGhlIGVsZW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGFyYW0gbmFtZVxuY29uc3QgZ2V0SW5wdXRJZEZvclBhcmFtTmFtZSA9IGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICAvLyBzY2F0dGVyIGF4aXMgZG9uJ3QgcmVhbGx5IGV4aXN0IGluIG1hdHNDb2xsZWN0aW9ucy5DdXJ2ZVBhcmFtcyBidXQgdGhleSBhcmUgZWxlbWVudHNcbiAgICBjb25zdCBwbmFtZSA9IHBhcmFtTmFtZS5yZXBsYWNlKC9eLmF4aXMtLywgJycpO1xuICAgIHZhciBwYXJhbSA9IG1hdHNDb2xsZWN0aW9ucy5DdXJ2ZVBhcmFtcy5maW5kT25lKHtuYW1lOiBwbmFtZX0pO1xuICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtID0gbWF0c0NvbGxlY3Rpb25zLlBsb3RQYXJhbXMuZmluZE9uZSh7bmFtZTogcG5hbWV9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW0gPSBtYXRzQ29sbGVjdGlvbnMuU2NhdHRlcjJkUGFyYW1zLmZpbmRPbmUoe25hbWU6IHBuYW1lfSk7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbS50eXBlID09PSBtYXRzVHlwZXMuSW5wdXRUeXBlcy5kYXRlUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIChcImVsZW1lbnQtXCIgKyBwYXJhbS5uYW1lKS5yZXBsYWNlKC8gL2csICctJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChwYXJhbS5uYW1lICsgXCItXCIgKyBwYXJhbS50eXBlKS5yZXBsYWNlKC8gL2csICctJyk7XG4gICAgfVxufTtcblxuXG4vLyBnZXQgdGhlIHBhcmFtZXRlciBmb3IgdGhlIGVsZW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGFyYW0gbmFtZVxuY29uc3QgZ2V0UGFyYW1ldGVyRm9yTmFtZSA9IGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICAvLyBzY2F0dGVyIGF4aXMgZG9uJ3QgcmVhbGx5IGV4aXN0IGluIG1hdHNDb2xsZWN0aW9ucy5DdXJ2ZVBhcmFtcyBidXQgdGhleSBhcmUgZWxlbWVudHNcbiAgICBjb25zdCBwbmFtZSA9IHBhcmFtTmFtZS5yZXBsYWNlKC9eLmF4aXMtLywgJycpO1xuXG4gICAgdmFyIHBhcmFtID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLmZpbmRPbmUoe25hbWU6IHBuYW1lfSk7XG4gICAgaWYgKHBhcmFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW0gPSBtYXRzQ29sbGVjdGlvbnMuUGxvdFBhcmFtcy5maW5kT25lKHtuYW1lOiBwbmFtZX0pO1xuICAgIH1cbiAgICBpZiAocGFyYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbSA9IG1hdHNDb2xsZWN0aW9ucy5TY2F0dGVyMmRQYXJhbXMuZmluZE9uZSh7bmFtZTogcG5hbWV9KTtcbiAgICAgICAgaWYgKHBhcmFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChwYXJhbSk7XG59O1xuXG4vLyBnZXQgdGhlIGRvY3VtZW50IGVsZW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGFyYW0gbmFtZVxuY29uc3QgZ2V0SW5wdXRFbGVtZW50Rm9yUGFyYW1OYW1lID0gZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgIGNvbnN0IG5hbWUgPSBwYXJhbU5hbWUucmVwbGFjZSgvXi5heGlzLS8sICcnKTtcbiAgICBjb25zdCBpZCA9IGdldElucHV0SWRGb3JQYXJhbU5hbWUobmFtZSk7XG4gICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbn07XG5cbi8vIGdldCBhIHBhcmFtIGRpc2FibGVkT3B0aW9ucyBsaXN0IC0gaWYgYW55LlxuY29uc3QgZ2V0RGlzYWJsZWRPcHRpb25zRm9yUGFyYW1OYW1lID0gZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgIGNvbnN0IG5hbWUgPSBwYXJhbU5hbWUucmVwbGFjZSgvXi5heGlzLS8sICcnKTtcbiAgICBjb25zdCBpZCA9IGdldElucHV0SWRGb3JQYXJhbU5hbWUobmFtZSk7XG4gICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW0gPSBnZXRQYXJhbWV0ZXJGb3JOYW1lKG5hbWUpO1xuICAgIGlmICghcGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtLmRpc2FibGVkT3B0aW9ucztcbn07XG5cbi8vIHNldCB0aGUgaW5wdXQgZm9yIHRoZSBlbGVtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHBhcmFtIG5hbWVcbi8vIGFsc28gc2V0cyBhIGRhdGEtbWF0cy1jdXJyZW50VmFsdWUgYXR0cmlidXRlXG5jb25zdCBzZXRJbnB1dEZvclBhcmFtTmFtZSA9IGZ1bmN0aW9uIChwYXJhbU5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgcGFyYW0gPSBnZXRQYXJhbWV0ZXJGb3JOYW1lKHBhcmFtTmFtZSk7XG4gICAgY29uc3QgaWQgPSBnZXRJbnB1dElkRm9yUGFyYW1OYW1lKHBhcmFtTmFtZSk7XG4gICAgY29uc3QgaWRTZWxlY3RvclN0ciA9IFwiI1wiICsgaWQ7XG4gICAgY29uc3QgaWRTZWxlY3RvciA9ICQoaWRTZWxlY3RvclN0cik7XG5cbiAgICAvLyBTSE9VTEQgREVBTCBXSVRIIENIRUNLQk9YRVMgSEVSRVxuICAgIGlmIChwYXJhbS50eXBlID09PSBtYXRzVHlwZXMuSW5wdXRUeXBlcy5yYWRpb0dyb3VwKSB7XG4gICAgICAgICQoXCIjXCIgKyBpZCArIFwiLVwiICsgdmFsdWUpLnByb3AoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlkU2VsZWN0b3IudmFsKHZhbHVlKTtcbiAgICAgICAgc2V0VmFsdWVUZXh0Rm9yUGFyYW1OYW1lKHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgIH1cbn07XG5cbmNvbnN0IGdldEVsZW1lbnRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgY3VydmVQYXJhbXM6IHt9LFxuICAgICAgICBwbG90UGFyYW1zOiB7fSxcbiAgICAgICAgc2NhdHRlclBhcmFtczoge31cbiAgICB9O1xuICAgIGNvbnN0IGF4aXMgPSBbJ3hheGlzLScsICd5YXhpcy0nXTtcbiAgICB2YXIgcGFyYW1zID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLmZpbmQoe30pLmZldGNoKCk7XG4gICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHZhciB2YWwgPSBcIlwiO1xuICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMucmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gXCJpbnB1dDpyYWRpb1tuYW1lPSdcIiArIHBhcmFtLm5hbWUgKyBcIiddOmNoZWNrZWRcIjtcbiAgICAgICAgICAgIHZhbCA9ICQoc2VsZWN0b3IpLnZhbCgpXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMuY2hlY2tCb3hHcm91cCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gXCJpbnB1dFtuYW1lPSdcIiArIHBhcmFtLm5hbWUgKyBcIiddOmNoZWNrZWRcIjtcbiAgICAgICAgICAgIHZhbCA9ICQoc2VsZWN0b3IpLm1hcChmdW5jdGlvbiAoXywgZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJChlbCkudmFsKCk7XG4gICAgICAgICAgICB9KS5nZXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbS50eXBlID09PSBtYXRzVHlwZXMuSW5wdXRUeXBlcy5kYXRlUmFuZ2UpIHtcbiAgICAgICAgICAgIHZhbCA9IGdldFZhbHVlRm9yUGFyYW1OYW1lKHBhcmFtLm5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGlkU2VsZWN0ID0gJyMnICsgZ2V0SW5wdXRJZEZvclBhcmFtTmFtZShwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIHZhbCA9ICQoaWRTZWxlY3QpLnZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuY3VydmVQYXJhbXNbcGFyYW0ubmFtZV0gPSB2YWw7XG4gICAgICAgIGlmIChtYXRzUGxvdFV0aWxzLmdldFBsb3RUeXBlKCkgPT0gbWF0c1R5cGVzLlBsb3RUeXBlcy5zY2F0dGVyMmQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgYXhpcy5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF4aXNTdHIgPSBheGlzW2FdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBheGlzU3RyICsgcGFyYW0ubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMucmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBcImlucHV0OnJhZGlvW25hbWU9J1wiICsgbmFtZSArIFwiJ106Y2hlY2tlZFwiO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAkKHNlbGVjdG9yKS52YWwoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMuY2hlY2tCb3hHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBcImlucHV0W25hbWU9J1wiICsgbmFtZSArIFwiJ106Y2hlY2tlZFwiO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAkKHNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKF8sIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChlbCkudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmdldCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZFNlbGVjdCA9ICcjJyArIGdldElucHV0SWRGb3JQYXJhbU5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9ICQoaWRTZWxlY3QpLnZhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLmN1cnZlUGFyYW1zW25hbWVdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwYXJhbXMgPSBtYXRzQ29sbGVjdGlvbnMuUGxvdFBhcmFtcy5maW5kKHt9KS5mZXRjaCgpO1xuICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgdmFsID0gXCJcIjtcbiAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IG1hdHNUeXBlcy5JbnB1dFR5cGVzLnJhZGlvR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IFwiaW5wdXQ6cmFkaW9bbmFtZT0nXCIgKyBwYXJhbS5uYW1lICsgXCInXTpjaGVja2VkXCI7XG4gICAgICAgICAgICB2YWwgPSAkKHNlbGVjdG9yKS52YWwoKVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IG1hdHNUeXBlcy5JbnB1dFR5cGVzLmNoZWNrQm94R3JvdXApIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IFwiaW5wdXRbbmFtZT0nXCIgKyBwYXJhbS5uYW1lICsgXCInXTpjaGVja2VkXCI7XG4gICAgICAgICAgICB2YWwgPSAkKHNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKF8sIGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQoZWwpLnZhbCgpO1xuICAgICAgICAgICAgfSkuZ2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaWRTZWxlY3QgPSAnIycgKyBnZXRJbnB1dElkRm9yUGFyYW1OYW1lKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgdmFsID0gJChpZFNlbGVjdCkudmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wbG90UGFyYW1zW3BhcmFtLm5hbWVdID0gdmFsO1xuICAgIH0pO1xuXG4gICAgcGFyYW1zID0gbWF0c0NvbGxlY3Rpb25zLlNjYXR0ZXIyZFBhcmFtcy5maW5kKHt9KS5mZXRjaCgpO1xuICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgdmFsID0gXCJcIjtcbiAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IG1hdHNUeXBlcy5JbnB1dFR5cGVzLnJhZGlvR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IFwiaW5wdXQ6cmFkaW9bbmFtZT0nXCIgKyBwYXJhbS5uYW1lICsgXCInXTpjaGVja2VkXCI7XG4gICAgICAgICAgICB2YWwgPSAkKHNlbGVjdG9yKS52YWwoKVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IG1hdHNUeXBlcy5JbnB1dFR5cGVzLmNoZWNrQm94R3JvdXApIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IFwiaW5wdXRbbmFtZT0nXCIgKyBwYXJhbS5uYW1lICsgXCInXTpjaGVja2VkXCI7XG4gICAgICAgICAgICB2YWwgPSAkKHNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKF8sIGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQoZWwpLnZhbCgpO1xuICAgICAgICAgICAgfSkuZ2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaWRTZWxlY3QgPSAnIycgKyBnZXRJbnB1dElkRm9yUGFyYW1OYW1lKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgdmFsID0gJChpZFNlbGVjdCkudmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5zY2F0dGVyUGFyYW1zW3BhcmFtLm5hbWVdID0gdmFsO1xuICAgICAgICBpZiAobWF0c1Bsb3RVdGlscy5nZXRQbG90VHlwZSgpID09IG1hdHNUeXBlcy5QbG90VHlwZXMuc2NhdHRlcjJkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGF4aXMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1N0ciA9IGF4aXNbYV07XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBheGlzU3RyICsgcGFyYW0ubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMucmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBcImlucHV0OnJhZGlvW25hbWU9J1wiICsgbmFtZSArIFwiJ106Y2hlY2tlZFwiO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAkKHNlbGVjdG9yKS52YWwoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMuY2hlY2tCb3hHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBcImlucHV0W25hbWU9J1wiICsgbmFtZSArIFwiJ106Y2hlY2tlZFwiO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAkKHNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKF8sIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChlbCkudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmdldCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZFNlbGVjdCA9ICcjJyArIGdldElucHV0SWRGb3JQYXJhbU5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9ICQoaWRTZWxlY3QpLnZhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnNjYXR0ZXJQYXJhbXNbbmFtZV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG5cbmNvbnN0IGV4cGFuZFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBtYXRzQ29sbGVjdGlvbnMuQ3VydmVQYXJhbXMuZmluZCh7fSkuZmV0Y2goKTtcbiAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IG1hdHNUeXBlcy5JbnB1dFR5cGVzLnNlbGVjdE1hcCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBcImVsZW1lbnRcIiArIFwiLVwiICsgcGFyYW0ubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmFtLm5hbWUgKyBcIi1cIiArIHBhcmFtLnR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhRWxlbSAmJiBkYXRhRWxlbS5vcHRpb25zICYmIGRhdGFFbGVtLnNlbGVjdGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhRWxlbS5vcHRpb25zW2RhdGFFbGVtLnNlbGVjdGVkSW5kZXhdLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5jb25zdCBjb2xsYXBzZVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBtYXRzQ29sbGVjdGlvbnMuQ3VydmVQYXJhbXMuZmluZCh7fSkuZmV0Y2goKTtcbiAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IG1hdHNUeXBlcy5JbnB1dFR5cGVzLnNlbGVjdE1hcCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBcImVsZW1lbnRcIiArIFwiLVwiICsgcGFyYW0ubmFtZTtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvcikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5jb25zdCBjb2xsYXBzZVBhcmFtID0gZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgIGNvbnN0IHBhcmFtID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLmZpbmRPbmUoe25hbWU6IHBhcmFtTmFtZX0pO1xuICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhcmFtLnR5cGUgIT09IG1hdHNUeXBlcy5JbnB1dFR5cGVzLnNlbGVjdE1hcCkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IFwiZWxlbWVudFwiICsgXCItXCIgKyBwYXJhbS5uYW1lO1xuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvcikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgdHlwZVNvcnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoaXNOYU4oTnVtYmVyKGEpICYmIGlzTmFOKE51bWJlcihiKSkpKSB7IC8vIHN0cmluZyBjb21wYXJlXG4gICAgICAgICAgICBjb25zdCBBID0gYS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgQiA9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChBIDwgQikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQSA+IEIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oTnVtYmVyKGEpIHx8IGlzTmFOKE51bWJlcihiKSkpKSB7ICAgLy8gbnVtYmVyIGFsd2F5cyBwcmVjZWRlc1xuICAgICAgICAgICAgaWYgKGlzTmFOKE51bWJlcihhKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7ICAvLyBudW1lcmljYWwgY29tcGFyZVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5jb25zdCBzZXREZWZhdWx0Rm9yUGFyYW1OYW1lID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgY29uc3QgcGFyYW1OYW1lID0gcGFyYW0ubmFtZTtcbiAgICBjb25zdCB0eXBlID0gcGFyYW0udHlwZTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBwYXJhbS5kZWZhdWx0O1xuICAgIGlmIChwYXJhbU5hbWUgPT0gJ2xhYmVsJykge1xuICAgICAgICBzZXRJbnB1dEZvclBhcmFtTmFtZShwYXJhbU5hbWUsIFNlc3Npb24uZ2V0KCdOZXh0Q3VydmVMYWJlbCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBtYXRzVHlwZXMuSW5wdXRUeXBlcy5zZWxlY3QgJiYgKGRlZmF1bHRWYWx1ZSA9PT0gLTEgfHwgZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQgfHwgZGVmYXVsdFZhbHVlID09PSBtYXRzVHlwZXMuSW5wdXRUeXBlcy51bnVzZWQpKSB7XG4gICAgICAgICAgICAgICAgc2V0SW5wdXRGb3JQYXJhbU5hbWUocGFyYW1OYW1lLCBtYXRzVHlwZXMuSW5wdXRUeXBlcy51bnVzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SW5wdXRGb3JQYXJhbU5hbWUocGFyYW1OYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgZ2V0RGVmYXVsdERhdGVSYW5nZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgZGF0ZVBhcmFtID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLmZpbmRPbmUoe25hbWU6IG5hbWV9KTtcbiAgICBpZiAoZGF0ZVBhcmFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0ZVBhcmFtID0gbWF0c0NvbGxlY3Rpb25zLlBsb3RQYXJhbXMuZmluZE9uZSh7bmFtZTogbmFtZX0pO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEluaXQgPSBkYXRlUGFyYW0uc3RhcnREYXRlO1xuICAgIGNvbnN0IHN0b3BJbml0ID0gZGF0ZVBhcmFtLnN0b3BEYXRlO1xuICAgIGNvbnN0IGRzdHIgPSBkYXRlUGFyYW0uZGVmYXVsdDtcbiAgICByZXR1cm4ge3N0YXJ0RGF0ZTpzdGFydEluaXQsc3RvcERhdGU6c3RvcEluaXQsZHN0cjpkc3RyfTtcbn07XG5cbmNvbnN0IGdldE1pbk1heERhdGVzID0gZnVuY3Rpb24obWluRGF0ZSwgbWF4RGF0ZSkge1xuICAgIHZhciBtaW5Nb21lbnQgPSBtb21lbnQobWluRGF0ZSxcIk1NL0REL1lZWVkgSEg6bW1cIik7XG4gICAgdmFyIG1heE1vbWVudCA9IG1vbWVudChtYXhEYXRlLCBcIk1NL0REL1lZWVkgSEg6bW1cIik7XG4gICAgaWYgKG1heE1vbWVudC5kaWZmKG1pbk1vbWVudCwgJ2RheXMnKSA+IDMwKSB7XG4gICAgICAgIG1pbkRhdGUgPSBtb21lbnQobWF4TW9tZW50LnN1YnRyYWN0KDMwLCAnZGF5cycpKS5mb3JtYXQoXCJNTS9ERC9ZWVlZIEhIOm1tXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge21pbkRhdGU6bWluRGF0ZSxtYXhEYXRlOm1heERhdGV9O1xufTtcblxuY29uc3Qgc2V0QWxsUGFyYW1zVG9EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGRlZmF1bHQgdGhlIHN1cGVyaW9ycyBhbmQgcmVmcmVzaCB0aGVtIHNvIHRoYXQgdGhleSBjYXVzZSB0aGUgZGVwZW5kZW50IG9wdGlvbnMgdG8gcmVmcmVzaFxuICAgIHZhciBwYXJhbXMgPSBtYXRzQ29sbGVjdGlvbnMuQ3VydmVQYXJhbXMuZmluZCh7fSkuZmV0Y2goKTtcblxuICAgIGNvbnN0IHN1cGVyaW9ycyA9IG1hdHNDb2xsZWN0aW9ucy5DdXJ2ZVBhcmFtcy5maW5kKHtcImRlcGVuZGVudE5hbWVzXCI6IHtcIiRleGlzdHNcIjogdHJ1ZX19KS5mZXRjaCgpO1xuICAgIHN1cGVyaW9ycy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICBzZXREZWZhdWx0Rm9yUGFyYW1OYW1lKHBhcmFtKTtcbiAgICAgICAgLy8gYWN0dWFsbHkgY2FsbCB0aGUgcmVmcmVzaCBkaXJlY3RseSAtIGRvbid0IHVzZSBhbiBldmVudCwgYmVjYXVzZSB3ZSB3YW50IHRoaXMgYWxsIHRvIGJlIHN5bmNocm9ub3VzXG4gICAgICAgIG1hdHNTZWxlY3RVdGlscy5yZWZyZXNoKG51bGwsIHBhcmFtLm5hbWUpO1xuICAgICAgICAvLyByZW1vdmUgZnJvbSBwYXJhbXMgbGlzdCAtIGFjdHVhbGx5IHJld3JpdGUgcGFyYW1zIGxpc3QgTk9UIHdpdGggdGhpcyBwYXJhbVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubmFtZSAhPT0gcGFyYW0ubmFtZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gcmVmcmVzaCBhbGwgdGhlIG5vbiBzdXBlcmlvcnMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXNcbiAgICBjb25zdCBub25EZXBlbmRlbnRzID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlUGFyYW1zLmZpbmQoe1wic3VwZXJpb3JOYW1lc1wiOiB7XCIkZXhpc3RzXCI6IHRydWV9fSkuZmV0Y2goKTtcbiAgICBub25EZXBlbmRlbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHNldERlZmF1bHRGb3JQYXJhbU5hbWUocGFyYW0pO1xuICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gbWF0c1R5cGVzLklucHV0VHlwZXMuZGF0ZVJhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBkc3RyID0gZ2V0RGVmYXVsdERhdGVSYW5nZShwYXJhbS5uYW1lKS5kc3RyO1xuICAgICAgICAgICAgc2V0VmFsdWVUZXh0Rm9yUGFyYW1OYW1lKHBhcmFtLm5hbWUsIGRzdHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0c1NlbGVjdFV0aWxzLnJlZnJlc2gobnVsbCwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBwYXJhbXMgbGlzdCAtIGFjdHVhbGx5IHJld3JpdGUgcGFyYW1zIGxpc3QgTk9UIHdpdGggdGhpcyBwYXJhbVxuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai5uYW1lICE9PSBwYXJhbS5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyByZXNldCBldmVyeXRoaW5nIGVsc2VcbiAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IG1hdHNUeXBlcy5JbnB1dFR5cGVzLmRhdGVSYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgZHN0ciA9IGdldERlZmF1bHREYXRlUmFuZ2UocGFyYW0ubmFtZSkuZHN0cjtcbiAgICAgICAgICAgIHNldFZhbHVlVGV4dEZvclBhcmFtTmFtZShwYXJhbS5uYW1lLCBkc3RyKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbS50eXBlID09PSBtYXRzVHlwZXMuSW5wdXRUeXBlcy5zZWxlY3RNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldElkID0gcGFyYW0ubmFtZSArICctJyArIHBhcmFtLnR5cGU7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRNYXBFdmVudCA9IG5ldyBDdXN0b21FdmVudChcInJlc2V0XCIsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmRWxlbWVudDogbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5kaXNwYXRjaEV2ZW50KHJlc2V0TWFwRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0RGVmYXVsdEZvclBhcmFtTmFtZShwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtYXRzQ29sbGVjdGlvbnMuUGxvdFBhcmFtcy5maW5kKHt9KS5mZXRjaCgpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbS50eXBlID09PSBtYXRzVHlwZXMuSW5wdXRUeXBlcy5kYXRlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGRzdHIgPSBnZXREZWZhdWx0RGF0ZVJhbmdlKHBhcmFtLm5hbWUpLmRzdHI7XG4gICAgICAgICAgICBzZXRWYWx1ZVRleHRGb3JQYXJhbU5hbWUocGFyYW0ubmFtZSwgZHN0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXREZWZhdWx0Rm9yUGFyYW1OYW1lKHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG59O1xuLy8gaXMgdGhlIGlucHV0IGVsZW1lbnQgZGlzcGxheWluZz8gdXNlZCBieSBjdXJ2ZV9wYXJhbV9pdGVtX2dyb3VwXG5jb25zdCBpc0lucHV0RWxlbWVudFZpc2libGUgPSBmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgY29uc3QgbmFtZSA9IHBhcmFtTmFtZS5yZXBsYWNlKC9eLmF4aXMtLywgJycpOyAvLyBuZWVkIHRvIGFjb3VudCBmb3Igc2NhdHRlciBwbG90cyBwYXJhbXNcbiAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBnZXRJbnB1dEVsZW1lbnRGb3JQYXJhbU5hbWUobmFtZSk7XG4gICAgcmV0dXJuICQoaW5wdXRFbGVtZW50KS5pcygnOnZpc2libGUnKTtcbn07XG5cbi8vIGlzIHRoZSBpbnB1dCBlbGVtZW50IGRpc3BsYXlpbmc/IHVzZWQgYnkgY3VydmVfcGFyYW1faXRlbV9ncm91cFxuY29uc3QgaXNQYXJhbVZpc2libGUgPSBmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgY29uc3QgbmFtZSA9IHBhcmFtTmFtZS5yZXBsYWNlKC9eLmF4aXMtLywgJycpOyAvLyBuZWVkIHRvIGFjb3VudCBmb3Igc2NhdHRlciBwbG90cyBwYXJhbXNcbiAgICBjb25zdCBwYXJhbVJlZiA9IFwiI1wiICsgbmFtZSArIFwiLWl0ZW1cIjtcbiAgICByZXR1cm4gJChwYXJhbVJlZikuaXMoJzp2aXNpYmxlJyk7XG59O1xuXG4vLyBpcyB0aGUgaW5wdXQgZWxlbWVudCBkaXNwbGF5aW5nPyB1c2VkIGJ5IGN1cnZlX3BhcmFtX2l0ZW1fZ3JvdXBcbmNvbnN0IGlzQ29udHJvbEJ1dHRvblZpc2libGUgPSBmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgY29uc3QgbmFtZSA9IHBhcmFtTmFtZS5yZXBsYWNlKC9eLmF4aXMtLywgJycpOyAvLyBuZWVkIHRvIGFjb3VudCBmb3Igc2NhdHRlciBwbG90cyBwYXJhbXNcbiAgICBjb25zdCBwYXJhbVJlZiA9IFwiI2NvbnRyb2xCdXR0b24tXCIgKyBuYW1lO1xuICAgIHJldHVybiAkKHBhcmFtUmVmKS5pcygnOnZpc2libGUnKTtcbn07XG5cbmNvbnN0IHNldElucHV0VmFsdWVGb3JQYXJhbUFuZHRyaWdnZXJDaGFuZ2UgPSBmdW5jdGlvbiAocGFyYW1OYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGVsZW0gPSBnZXRJbnB1dEVsZW1lbnRGb3JQYXJhbU5hbWUocGFyYW1OYW1lKTtcbiAgICBlbGVtLnZhbHVlID0gdmFsdWU7XG4gICAgc2V0VmFsdWVUZXh0Rm9yUGFyYW1OYW1lKHBhcmFtTmFtZSwgZWxlbS52YWx1ZSk7XG4gICAgJChlbGVtKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbn07XG5cbmNvbnN0IGdldE9wdGlvbnNNYXBGb3JQYXJhbSA9IGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICBjb25zdCBwYXJhbSA9IG1hdHNDb2xsZWN0aW9ucy5DdXJ2ZVBhcmFtcy5maW5kT25lKHtuYW1lOiBwYXJhbU5hbWV9KTtcbiAgICByZXR1cm4gcGFyYW0ub3B0aW9uc01hcDtcbn07XG5cbmNvbnN0IGdldE9wdGlvbnNGb3JQYXJhbSA9IGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICBjb25zdCBwYXJhbSA9IG1hdHNDb2xsZWN0aW9ucy5DdXJ2ZVBhcmFtcy5maW5kT25lKHtuYW1lOiBwYXJhbU5hbWV9KTtcbiAgICByZXR1cm4gcGFyYW0ub3B0aW9ucztcbn07XG5cbmNvbnN0IGdldEFwcE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXBwID0gbWF0c0NvbGxlY3Rpb25zLmFwcE5hbWUuZmluZE9uZSh7fSkuYXBwO1xuICAgIHJldHVybiBhcHA7XG59O1xuXG5jb25zdCBnZXRDdXJ2ZUl0ZW1WYWx1ZUZvclBhcmFtTmFtZSA9IGZ1bmN0aW9uIChjdXJ2ZU51bWJlciwgcGFyYW1OYW1lKSB7XG4gICAgLy9NT0RFTC1jdXJ2ZS0wLUl0ZW1cbi8vICAgIGNvbnN0IGlkID0gcGFyYW1OYW1lLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSArIFwiLWN1cnZlLVwiICsgY3VydmVOdW1iZXIgKyBcIi1JdGVtXCI7IC8vIHRoZSBpZCBvZiB0aGUgdGV4dCBzcGFuIGZvciBhIGN1cnZlSXRlbVxuLy8gICAgcmV0dXJuIHRleHQgPSDigIzigIxkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkuaW5uZXJUZXh0O1xuICAgIC8vIGNvbnN0IGVsZW0gPSAkKFwiI1wiICsgaWQpO1xuICAgIC8vIHZhciB0ZXh0ID0gdW5kZWZpbmVkO1xuICAgIC8vIGlmIChlbGVtKSB7XG4gICAgLy8gICAgIHRleHQgPSBlbGVtLnRleHQoKTtcbiAgICAvLyB9XG59O1xuY29uc3QgdmlzaWJpbGl0eUNvbnRyb2xsZXJGb3JQYXJhbSA9IGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICAvKlxuICAgIE5lZWQgdG8gaXRlcmF0ZSBhbGwgdGhlIHBhcmFtcyBsb29raW5nIGZvciBvbmUgdGhhdCBoYXMgdGhpcyBwYXJhbU5hbWUgYXMgYSBrZXkgaW4gaXRzXG4gICAgaGlkZU90aGVyRm9yIG1hcC5cbiAgICBJZiBpdCBleGlzdHMsIHRoYXQgcGFyYW0gaXMgcmV0dXJuZWQuIE90aGVyd2lzZSByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIHZhciBwYXJhbXMgPSBtYXRzQ29sbGVjdGlvbnMuQ3VydmVQYXJhbXMuZmluZCh7fSkuZmV0Y2goKTtcbiAgICB2YXIgZm91bmQgPSB1bmRlZmluZWQ7XG4gICAgcGFyYW1zLnNvbWUoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbS5oaWRlT3RoZXJGb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBLZXlzID0gT2JqZWN0LmtleXMocGFyYW0uaGlkZU90aGVyRm9yKTtcbiAgICAgICAgICAgIGlmIChwS2V5cy5pbmRleE9mKHBhcmFtTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hdHNQYXJhbVV0aWxzID0ge1xuICAgIGdldERpc2FibGVkT3B0aW9uc0ZvclBhcmFtTmFtZTogZ2V0RGlzYWJsZWRPcHRpb25zRm9yUGFyYW1OYW1lLFxuICAgIGdldENvbnRyb2xCdXR0b25JZEZvclBhcmFtTmFtZTogZ2V0Q29udHJvbEJ1dHRvbklkRm9yUGFyYW1OYW1lLFxuICAgIGdldENvbnRyb2xFbGVtZW50Rm9yUGFyYW1OYW1lOiBnZXRDb250cm9sRWxlbWVudEZvclBhcmFtTmFtZSxcbiAgICBnZXRWYWx1ZUVsZW1lbnRGb3JQYXJhbU5hbWU6IGdldFZhbHVlRWxlbWVudEZvclBhcmFtTmFtZSxcbiAgICBnZXRWYWx1ZUZvclBhcmFtTmFtZTogZ2V0VmFsdWVGb3JQYXJhbU5hbWUsXG4gICAgc2V0VmFsdWVUZXh0Rm9yUGFyYW1OYW1lOiBzZXRWYWx1ZVRleHRGb3JQYXJhbU5hbWUsXG4gICAgZ2V0VmFsdWVJZEZvclBhcmFtTmFtZTogZ2V0VmFsdWVJZEZvclBhcmFtTmFtZSxcbiAgICBnZXRJbnB1dElkRm9yUGFyYW1OYW1lOiBnZXRJbnB1dElkRm9yUGFyYW1OYW1lLFxuICAgIGdldElucHV0RWxlbWVudEZvclBhcmFtTmFtZTogZ2V0SW5wdXRFbGVtZW50Rm9yUGFyYW1OYW1lLFxuICAgIGdldEVsZW1lbnRWYWx1ZXM6IGdldEVsZW1lbnRWYWx1ZXMsXG4gICAgc2V0SW5wdXRGb3JQYXJhbU5hbWU6IHNldElucHV0Rm9yUGFyYW1OYW1lLFxuICAgIGV4cGFuZFBhcmFtczogZXhwYW5kUGFyYW1zLFxuICAgIGNvbGxhcHNlUGFyYW1zOiBjb2xsYXBzZVBhcmFtcyxcbiAgICBjb2xsYXBzZVBhcmFtOiBjb2xsYXBzZVBhcmFtLFxuICAgIGdldFBhcmFtZXRlckZvck5hbWU6IGdldFBhcmFtZXRlckZvck5hbWUsXG4gICAgc2V0RGVmYXVsdEZvclBhcmFtTmFtZTogc2V0RGVmYXVsdEZvclBhcmFtTmFtZSxcbiAgICBzZXRBbGxQYXJhbXNUb0RlZmF1bHQ6IHNldEFsbFBhcmFtc1RvRGVmYXVsdCxcbiAgICB0eXBlU29ydDogdHlwZVNvcnQsXG4gICAgaXNJbnB1dEVsZW1lbnRWaXNpYmxlOiBpc0lucHV0RWxlbWVudFZpc2libGUsXG4gICAgaXNQYXJhbVZpc2libGU6IGlzUGFyYW1WaXNpYmxlLFxuICAgIGlzQ29udHJvbEJ1dHRvblZpc2libGU6IGlzQ29udHJvbEJ1dHRvblZpc2libGUsXG4gICAgc2V0SW5wdXRWYWx1ZUZvclBhcmFtQW5kdHJpZ2dlckNoYW5nZTogc2V0SW5wdXRWYWx1ZUZvclBhcmFtQW5kdHJpZ2dlckNoYW5nZSxcbiAgICBnZXRPcHRpb25zRm9yUGFyYW06IGdldE9wdGlvbnNGb3JQYXJhbSxcbiAgICBnZXRPcHRpb25zTWFwRm9yUGFyYW06IGdldE9wdGlvbnNNYXBGb3JQYXJhbSxcbiAgICBnZXRDdXJ2ZUl0ZW1WYWx1ZUZvclBhcmFtTmFtZTogZ2V0Q3VydmVJdGVtVmFsdWVGb3JQYXJhbU5hbWUsXG4gICAgdmlzaWJpbGl0eUNvbnRyb2xsZXJGb3JQYXJhbTogdmlzaWJpbGl0eUNvbnRyb2xsZXJGb3JQYXJhbSxcbiAgICBnZXRBcHBOYW1lOiBnZXRBcHBOYW1lLFxuICAgIGdldERlZmF1bHREYXRlUmFuZ2U6Z2V0RGVmYXVsdERhdGVSYW5nZSxcbiAgICBnZXRNaW5NYXhEYXRlczpnZXRNaW5NYXhEYXRlc1xufTsiLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IENvbG9yYWRvIFN0YXRlIFVuaXZlcnNpdHkgYW5kIFJlZ2VudHMgb2YgdGhlIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHttYXRzQ29sbGVjdGlvbnN9IGZyb20gJ21ldGVvci9yYW5keXA6bWF0cy1jb21tb24nO1xuaW1wb3J0IHttYXRzUGFyYW1VdGlsc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5pbXBvcnQge21hdHNUeXBlc30gZnJvbSAnbWV0ZW9yL3JhbmR5cDptYXRzLWNvbW1vbic7XG5cbi8vIGRldGVybWluZSB0aGUgYXhpc1RleHQgKHVzZWQgaW4gc2NhdHRlcl9heGlzLmpzIGZvciBleGFtcGxlKVxuLy8gYWNjb3JkaW5nIHRvIHRoZSBTY2F0dGVyIEF4aXMgVGV4dCBQYXR0ZXJucyBQYXR0ZXJuIGRlZmluZWQgaW5cbi8vIFNjYXR0ZXJBeGlzVGV4dFBhdHRlcm5zIGFjY29yZGluZyB0byBwbG90VHlwZSAtIGFuZCBkZXJpdmVkIGZyb21cbi8vIGN1cnJlbnRseSBzZWxlY3RlZCBpbnB1dHMgaW4gdGhlIGRvY3VtZW50LlxuY29uc3QgZ2V0QXhpc1RleHQgPSBmdW5jdGlvbiAocGxvdFR5cGUpIHtcbiAgICB2YXIgc2NhdHRlckF4aXNUZXh0UGF0dGVybiA9IG1hdHNDb2xsZWN0aW9ucy5TY2F0dGVyQXhpc1RleHRQYXR0ZXJuLmZpbmRPbmUoe3Bsb3RUeXBlOiBnZXRQbG90VHlwZSgpfSk7XG4gICAgdmFyIHRleHRQYXR0ZXJuID0gc2NhdHRlckF4aXNUZXh0UGF0dGVybiA/IG1hdHNDb2xsZWN0aW9ucy5TY2F0dGVyQXhpc1RleHRQYXR0ZXJuLmZpbmRPbmUoe3Bsb3RUeXBlOiBnZXRQbG90VHlwZSgpfSkudGV4dFBhdHRlcm4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNjYXR0ZXJBeGlzVGV4dFBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIHRleHQgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NhdHRlckF4aXNUZXh0UGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcE5hbWUgPSBzY2F0dGVyQXhpc1RleHRQYXR0ZXJuW2ldWzBdO1xuICAgICAgICB2YXIgZGVsaW1pdGVyID0gc2NhdHRlckF4aXNUZXh0UGF0dGVybltpXVsxXTtcbiAgICAgICAgdmFyIHZhbHVlID0gbWF0c1BhcmFtVXRpbHMuZ2V0VmFsdWVGb3JQYXJhbU5hbWUocE5hbWUpO1xuICAgICAgICB0ZXh0ICs9IHZhbHVlICs9IGRlbGltaXRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59O1xuXG4vLyBkZXRlcm1pbmUgdGhlIGN1cnZlVGV4dCAodXNlZCBpbiBjdXJ2ZUl0ZW0gZm9yIGV4YW1wbGUpIGZvciBhIGdpdmVuIGN1cnZlIChmcm9tIFNlc3Npb24uZ2V0KCdjdXJ2ZXMnKSlcbi8vIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBhZGRlZFxuY29uc3QgZ2V0Q3VydmVUZXh0ID0gZnVuY3Rpb24gKHBsb3RUeXBlLCBjdXJ2ZSkge1xuICAgIHZhciBjdXJ2ZVRleHRQYXR0ZXJuID0gbWF0c0NvbGxlY3Rpb25zLkN1cnZlVGV4dFBhdHRlcm5zLmZpbmRPbmUoe3Bsb3RUeXBlOiBwbG90VHlwZX0pLnRleHRQYXR0ZXJuO1xuICAgIHZhciB0ZXh0ID0gXCJcIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmVUZXh0UGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYSA9IGN1cnZlVGV4dFBhdHRlcm5baV07XG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbCB8fCBjdXJ2ZVthWzFdXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ICs9IGFbMF07XG4gICAgICAgIGlmIChjdXJ2ZVthWzFdXSBpbnN0YW5jZW9mIEFycmF5ICYmIChjdXJ2ZVthWzFdXS5sZW5ndGggPiAyKSkge1xuICAgICAgICAgICAgdGV4dCArPSBjdXJ2ZVthWzFdXVswXSArIFwiLi5cIiArIGN1cnZlW2FbMV1dW2N1cnZlW2FbMV1dLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCArPSBjdXJ2ZVthWzFdXTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ICs9IGFbMl07XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufTtcblxuLy8gZGV0ZXJtaW5lIHdoaWNoIHBsb3RUeXBlIHJhZGlvIGJ1dHRvbiBpcyBjaGVja2VkXG5jb25zdCBnZXRQbG90VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnV0dG9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCdwbG90LXR5cGUnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYnV0dG9uc1tpXS5jaGVja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uc1tpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjsgICAgLy8gZXJyb3IgY29uZGl0aW9uIGFjdHVhbGx5IC0gc2hvdWxkbid0IGV2ZXIgaGFwcGVuXG59O1xuXG4vLyBkZXRlcm1pbmUgd2hpY2ggcGxvdEZvcm1hdCByYWRpbyBidXR0b24gaXMgY2hlY2tlZFxuY29uc3QgZ2V0UGxvdEZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnV0dG9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCdwbG90Rm9ybWF0Jyk7XG4gICAgaWYgKGJ1dHRvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gXCJcIjsgLy8gYXBwIG1heSBub3QgaGF2ZSBwbG90Rm9ybWF0P1xuICAgIH1cbiAgICB2YXIgcGxvdEZvcm1hdFBhcmFtID0gbWF0c0NvbGxlY3Rpb25zLlBsb3RQYXJhbXMuZmluZE9uZSh7bmFtZTogJ3Bsb3RGb3JtYXQnfSk7XG4gICAgaWYgKHBsb3RGb3JtYXRQYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBcIlwiOyAvLyBhcHAgbWF5IG5vdCBoYXZlIHBsb3RGb3JtYXQ/XG4gICAgfVxuICAgIHZhciBvcHRpb25zTWFwID0gcGxvdEZvcm1hdFBhcmFtLm9wdGlvbnNNYXA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1dHRvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGJ1dHRvbnNbaV0uY2hlY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbnNbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7ICAvLyBlcnJvciBjb25kaXRpb24gYWN0dWFsbHkgLSBzaG91bGRuJ3QgZXZlciBoYXBwZW5cbn07XG5cbi8vIERldGVybWluZSB3aGljaCBCZXN0Rml0IHJhZGlvIGJ1dHRvbiBpcyBjaGVja2VkXG5jb25zdCBnZXRCZXN0Rml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBidXR0b25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoJ0ZpdCBUeXBlJyk7XG4gICAgdmFyIG9wdGlvbnNNYXAgPSBtYXRzQ29sbGVjdGlvbnMuUGxvdFBhcmFtcy5maW5kT25lKHtuYW1lOiAnYmVzdEZpdCd9KS5vcHRpb25zTWFwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidXR0b25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChidXR0b25zW2ldLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25zW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiOyAgLy8gZXJyb3IgY29uZGl0aW9uIGFjdHVhbGx5IC0gc2hvdWxkbid0IGV2ZXIgaGFwcGVuXG59O1xuXG5jb25zdCBjb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHBvaW50QXJyYXksIHBvaW50KSB7XG4gICAgdmFyIGxhdCA9IHBvaW50WzBdO1xuICAgIHZhciBsb24gPSBwb2ludFsxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBMYXQgPSBwb2ludEFycmF5W2ldWzBdO1xuICAgICAgICB2YXIgcExvbiA9IHBvaW50QXJyYXlbaV1bMV07XG4gICAgICAgIGlmIChsYXQgPT09IHBMYXQgJiYgbG9uID09PSBwTG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGRpc2FibGUgdGhlIGFjdGlvbiBidXR0b25zIHdoaWxlIHRoZSBxdWVyeSBhbmQgcGxvdCByb3V0aW5lcyBhcmUgcHJvY2Vzc2luZywgdGhlbiByZS1lbmFibGUgdGhlbSBhZnRlcndhcmRzXG5jb25zdCBkaXNhYmxlQWN0aW9uQnV0dG9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxvdE1hdGNoZWQnKS5kaXNhYmxlZCA9IHRydWU7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3RVbm1hdGNoZWQnKS5kaXNhYmxlZCA9IHRydWU7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZCcpLmRpc2FibGVkID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3ZlLWFsbCcpLmRpc2FibGVkID0gdHJ1ZTtcbn07XG5jb25zdCBlbmFibGVBY3Rpb25CdXR0b25zID0gZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbG90TWF0Y2hlZCcpLmRpc2FibGVkID0gZmFsc2U7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bsb3RVbm1hdGNoZWQnKS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZGQnKS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZW1vdmUtYWxsJykuZGlzYWJsZWQgPSBmYWxzZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdHNQbG90VXRpbHMgPSB7XG4gICAgZ2V0QXhpc1RleHQ6IGdldEF4aXNUZXh0LFxuICAgIGdldEN1cnZlVGV4dDogZ2V0Q3VydmVUZXh0LFxuICAgIGdldFBsb3RUeXBlOiBnZXRQbG90VHlwZSxcbiAgICBnZXRQbG90Rm9ybWF0OiBnZXRQbG90Rm9ybWF0LFxuICAgIGdldEJlc3RGaXQ6IGdldEJlc3RGaXQsXG4gICAgY29udGFpbnNQb2ludDogY29udGFpbnNQb2ludCxcbiAgICBkaXNhYmxlQWN0aW9uQnV0dG9uczogZGlzYWJsZUFjdGlvbkJ1dHRvbnMsXG4gICAgZW5hYmxlQWN0aW9uQnV0dG9uczogZW5hYmxlQWN0aW9uQnV0dG9uc1xufTsiLCJcbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgQ29sb3JhZG8gU3RhdGUgVW5pdmVyc2l0eSBhbmQgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKlxuZ2VuZXJpYyBNYXRoIEZ1bmN0aW9uc1xuICovXG52YXIgaXNOdW0gPSBmdW5jdGlvbiAoYXJncylcbntcbiAgICBpZiAoYXJncyA9PSBudWxsIHx8IGFyZ3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXJncyA9IGFyZ3MudG9TdHJpbmcoKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7ICBpPGFyZ3MubGVuZ3RoOyAgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKChhcmdzLnN1YnN0cmluZyhpLGkrMSkgPCBcIjBcIiB8fCBhcmdzLnN1YnN0cmluZyhpLCBpKzEpID4gXCI5XCIpICYmIGFyZ3Muc3Vic3RyaW5nKGksIGkrMSkgIT0gXCIuXCImJiBhcmdzLnN1YnN0cmluZyhpLCBpKzEpICE9IFwiLVwiKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBtZWFuID0gZnVuY3Rpb24gKGFycilcbntcbiAgICB2YXIgbGVuID0gMDtcbiAgICB2YXIgc3VtID0gMDtcblxuICAgIGZvcih2YXIgaT0wO2k8YXJyLmxlbmd0aDtpKyspXG4gICAge1xuICAgICAgICBpZiAoYXJyW2ldID09IFwiXCIpe31cbiAgICAgICAgZWxzZSBpZiAoIWlzTnVtKGFycltpXSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vYWxlcnQoYXJyW2ldICsgXCIgaXMgbm90IG51bWJlciFcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOiB2YWx1ZSBhdCBwb3NpdGlvbjogXCIgKyBpICsgXCIgaXMgbm90IG51bWJlciEgTWVhbiBDYWxjdWxhdGlvbiBmYWlsZWQhXCIgKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbGVuID0gbGVuICsgMTtcbiAgICAgICAgICAgIHN1bSA9IHN1bSArIHBhcnNlRmxvYXQoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtIC8gbGVuO1xufTtcblxudmFyIHZhcmlhbmNlID0gZnVuY3Rpb24gKGFycilcbntcbiAgICB2YXIgbGVuID0gMDtcbiAgICB2YXIgc3VtPTA7XG4gICAgZm9yKHZhciBpPTA7aTxhcnIubGVuZ3RoO2krKylcbiAgICB7XG4gICAgICAgIGlmIChhcnJbaV0gPT0gXCJcIil7fVxuICAgICAgICBlbHNlIGlmICghaXNOdW0oYXJyW2ldKSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy9hbGVydChhcnJbaV0gKyBcIiBpcyBub3QgbnVtYmVyLCBWYXJpYW5jZSBDYWxjdWxhdGlvbiBmYWlsZWQhXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2cgKFwidmFsdWUgYXQgcG9zaXRpb24gXCIgKyBpICsgXCIgaXMgbm90IG51bWJlciwgVmFyaWFuY2UgQ2FsY3VsYXRpb24gZmFpbGVkIVwiKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbGVuID0gbGVuICsgMTtcbiAgICAgICAgICAgIHN1bSA9IHN1bSArIHBhcnNlRmxvYXQoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2ID0gMDtcbiAgICBpZiAobGVuID4gMSlcbiAgICB7XG4gICAgICAgIHZhciBtZWFuID0gc3VtIC8gbGVuO1xuICAgICAgICBmb3IodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID09IFwiXCIpe31cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2ID0gdiArIChhcnJbaV0gLSBtZWFuKSAqIChhcnJbaV0gLSBtZWFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2IC8gbGVuO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5cbnZhciBtZWRpYW4gPSBmdW5jdGlvbiAoYXJyKVxue1xuICAgIGFyci5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0pO1xuXG4gICAgdmFyIG1lZGlhbiA9IDA7XG5cbiAgICBpZiAoYXJyLmxlbmd0aCAlIDIgPT0gMSlcbiAgICB7XG4gICAgICAgIG1lZGlhbiA9IGFyclsoYXJyLmxlbmd0aCsxKS8yIC0gMV07XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIG1lZGlhbiA9ICgxICogYXJyW2Fyci5sZW5ndGgvMiAtIDFdICsgMSAqIGFyclthcnIubGVuZ3RoLzJdICkvMjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVkaWFuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXRzTWF0aFV0aWxzID0ge1xuICAgIGlzTnVtOmlzTnVtLFxuICAgIG1lYW46bWVhbixcbiAgICB2YXJpYW5jZTp2YXJpYW5jZSxcbiAgICBtZWRpYW46bWVkaWFuXG59Il19
