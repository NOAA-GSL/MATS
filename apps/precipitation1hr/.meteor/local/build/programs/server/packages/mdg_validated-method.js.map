{"version":3,"sources":["meteor://ðŸ’»app/packages/mdg:validated-method/validated-method.js"],"names":["module","export","ValidatedMethod","check","Match","link","v","constructor","options","mixins","Function","name","String","applyMixins","connection","Meteor","validate","applyOptions","ObjectIncluding","run","Object","defaultApplyOptions","returnStubValue","throwStubExceptions","assign","method","methods","args","Any","methodInvocation","_execute","call","callback","apply","err","validateResult","bind","Error","forEach","mixin","test","functionName","toString","match","msg"],"mappings":"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","file":"/packages/mdg_validated-method.js","sourcesContent":["import { check, Match } from 'meteor/check';\n\nexport class ValidatedMethod {\n  constructor(options) {\n    // Default to no mixins\n    options.mixins = options.mixins || [];\n    check(options.mixins, [Function]);\n    check(options.name, String);\n    options = applyMixins(options, options.mixins);\n\n    // connection argument defaults to Meteor, which is where Methods are defined on client and\n    // server\n    options.connection = options.connection || Meteor;\n\n    // Allow validate: null shorthand for methods that take no arguments\n    if (options.validate === null) {\n      options.validate = function () {};\n    }\n\n    // If this is null/undefined, make it an empty object\n    options.applyOptions = options.applyOptions || {};\n\n    check(options, Match.ObjectIncluding({\n      name: String,\n      validate: Function,\n      run: Function,\n      mixins: [Function],\n      connection: Object,\n      applyOptions: Object,\n    }));\n\n    // Default options passed to Meteor.apply, can be overridden with applyOptions\n    const defaultApplyOptions = {\n      // Make it possible to get the ID of an inserted item\n      returnStubValue: true,\n\n      // Don't call the server method if the client stub throws an error, so that we don't end\n      // up doing validations twice\n      throwStubExceptions: true,\n    };\n\n    options.applyOptions = {\n      ...defaultApplyOptions,\n      ...options.applyOptions\n    };\n\n    // Attach all options to the ValidatedMethod instance\n    Object.assign(this, options);\n\n    const method = this;\n    this.connection.methods({\n      [options.name](args) {\n        // Silence audit-argument-checks since arguments are always checked when using this package\n        check(args, Match.Any);\n        const methodInvocation = this;\n\n        return method._execute(methodInvocation, args);\n      }\n    });\n  }\n\n  call(args, callback) {\n    // Accept calling with just a callback\n    if ( typeof args === 'function' ) {\n      callback = args;\n      args = {};\n    }\n\n    try {\n      return this.connection.apply(this.name, [args], this.applyOptions, callback);\n    } catch (err) {\n      if (callback) {\n        // Get errors from the stub in the same way as from the server-side method\n        callback(err);\n      } else {\n        // No callback passed, throw instead of silently failing; this is what\n        // \"normal\" Methods do if you don't pass a callback.\n        throw err;\n      }\n    }\n  }\n\n  _execute(methodInvocation = {}, args) {\n    // Add `this.name` to reference the Method name\n    methodInvocation.name = this.name;\n\n    const validateResult = this.validate.bind(methodInvocation)(args);\n\n    if (typeof validateResult !== 'undefined') {\n      throw new Error(`Returning from validate doesn't do anything; \\\nperhaps you meant to throw an error?`);\n    }\n\n    return this.run.bind(methodInvocation)(args);\n  }\n};\n\n// Mixins get a chance to transform the arguments before they are passed to the actual Method\nfunction applyMixins(args, mixins) {\n  // Save name of the method here, so we can attach it to potential error messages\n  const { name } = args;\n\n  mixins.forEach((mixin) => {\n    args = mixin(args);\n\n    if(!Match.test(args, Object)) {\n      const functionName = mixin.toString().match(/function\\s(\\w+)/);\n      let msg = 'One of the mixins';\n\n      if(functionName) {\n        msg = `The function '${functionName[1]}'`;\n      }\n\n      throw new Error(`Error in ${name} method: ${msg} didn't return the options object.`);\n    }\n  });\n\n  return args;\n}\n"]}