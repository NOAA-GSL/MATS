//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
// Source maps are supported by all recent versions of Chrome, Safari,  //
// and Firefox, and by Internet Explorer 11.                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var global = Package.meteor.global;
var meteorEnv = Package.meteor.meteorEnv;
var SimpleSchema = Package['aldeed:simple-schema'].SimpleSchema;
var MongoObject = Package['aldeed:simple-schema'].MongoObject;
var ValidatedMethod = Package['mdg:validated-method'].ValidatedMethod;
var meteorInstall = Package.modules.meteorInstall;
var Template = Package['templating-runtime'].Template;
var Session = Package.session.Session;
var Hooks = Package['differential:event-hooks'].Hooks;
var EventHooksMonitoringCollection = Package['differential:event-hooks'].EventHooksMonitoringCollection;
var Log = Package.logging.Log;
var Reload = Package.reload.Reload;
var Random = Package.random.Random;
var EJSON = Package.ejson.EJSON;
var Spacebars = Package.spacebars.Spacebars;
var check = Package.check.check;
var Match = Package.check.Match;
var Picker = Package['meteorhacks:picker'].Picker;
var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;
var Promise = Package.promise.Promise;
var Accounts = Package['accounts-base'].Accounts;
var Google = Package['google-oauth'].Google;
var Symbol = Package['ecmascript-runtime-client'].Symbol;
var Map = Package['ecmascript-runtime-client'].Map;
var Set = Package['ecmascript-runtime-client'].Set;
var Blaze = Package.blaze.Blaze;
var UI = Package.blaze.UI;
var Handlebars = Package.blaze.Handlebars;
var HTML = Package.htmljs.HTML;

/* Package-scope variables */
var matsTypes, matsCollections, matsMethods, plotResultData, matsCurveUtils, matsGraphUtils, matsSelectUtils, si, matsDataUtils, matsDataQueryUtils, matsDataDiffUtils, data, matsDataMatchUtils, matsDataCurveOpsUtils, matsDataPlotOpsUtils, matsDataProcessUtils, databases, databasesStr, matsPlotSpecUtils, matsCache, setError, clearError, getError, getStack, setInfo, clearInfo, getInfo, regression, matsParamUtils, matsPlotUtils, matsMathUtils, versionStr, pfuncs, graphPlotly, label, filterParams, dbs, errorMessage, i, authList;

var require = meteorInstall({"node_modules":{"meteor":{"randyp:mats-common":{"client":{"main.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/client/main.js                                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("../imports/startup/client");
module.link("../imports/startup/both");
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"error.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/client/error.js                                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */
setError = function (error) {
  var myError = "";
  var myStackTrace = "";

  if (typeof error === "string" || error instanceof String) {
    myError = new Error(error);
  } else {
    myError = error;
  }

  if (myError.toLocaleString().indexOf("INFO:") !== -1) {
    var strinfo = myError && myError.error && myError.error.replace("INFO:", "");
    setInfo(strinfo);
    return;
  }

  Session.set('errorMessage', myError.message);

  if (myError.stack) {
    myStackTrace = myError.stack;
  } else {
    myStackTrace = "StackTrace unavailable";
  }

  Session.set('stackTrace', myStackTrace);
  $("#error").modal('show');
};

clearError = function (message) {
  Session.set('errorMessage', '');
  Session.set('stackTrace', '');
  $("#error").modal('hide');
};

getError = function () {
  return Session.get('errorMessage');
};

getStack = function () {
  return Session.get('stackTrace');
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"info.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/client/info.js                                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */
setInfo = function (info) {
  Session.set('infoMessage', info);
  $("#info").modal('show');
};

clearInfo = function (info) {
  Session.set('infoMessage', '');
  $("#info").modal('hide');
};

getInfo = function () {
  return Session.get('infoMessage');
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"imports":{"startup":{"both":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/both/index.js                                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("./mats-collections.js");
module.link("./mats-types.js");
module.link("../api/matsMethods.js");
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"mats-types.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/both/mats-types.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */

/**
 * Created by pierce on 8/31/16.
 */
var DatabaseRoles = {
  MODEL_DATA: 'model_data',
  META_DATA: 'meta_data',
  SUMS_DATA: 'sums_data',
  SITE_DATA: 'site_data'
};
var AppTypes = {
  mats: 'mats',
  metexpress: 'metexpress',
  mats4met: 'mats4met'
};
var InputTypes = {
  textInput: 'textInput',
  select: 'select',
  selectOrderEnforced: 'selectOrderEnforced',
  numberSpinner: 'numberSpinner',
  dateRange: 'dateRange',
  radioGroup: 'radioGroup',
  checkBoxGroup: 'checkBoxGroup',
  resetButton: 'resetButton',
  controlButton: 'controlButton',
  element: 'element',
  selectMap: 'selectMap',
  custom: 'custom',
  unused: "unused",
  forecastSingleCycle: 'forecasts single cycle',
  forecastMultiCycle: 'forecasts multi cycle'
};
var PlotTypes = {
  timeSeries: "TimeSeries",
  profile: "Profile",
  dieoff: "DieOff",
  threshold: "Threshold",
  validtime: "ValidTime",
  dailyModelCycle: "DailyModelCycle",
  reliability: "Reliability",
  map: "Map",
  histogram: "Histogram",
  contour: "Contour",
  contourDiff: "ContourDiff",
  scatter2d: "Scatter2d"
};
var ForecastTypes = {
  dieoff: "dieoff",
  utcCycle: "utc cycle",
  singleCycle: "single cycle"
};
var PlotFormats = {
  none: "none",
  matching: "matching",
  pairwise: "pairwise",
  absolute: "absolute"
};
var PlotActions = {
  matched: "matched",
  unmatched: "unmatched"
};
var BestFits = {
  none: 'none',
  linear: 'linear',
  linearThroughOrigin: 'linearThroughOrigin',
  exponential: 'exponential',
  logarithmic: 'logarithmic',
  power: 'power'
};
var MatchFormats = {
  none: "none",
  time: "time",
  level: "level",
  site: "site"
};
var PlotAxisFilters = {
  none: "none",
  level: "level",
  site: "site"
};
var PlotView = {
  graph: "graph",
  textSeries: "text"
};
var ReservedWords = {
  Zero: "Zero",
  zero: "zero",
  ideal0: "ideal0",
  ideal1: "ideal1",
  ideal2: "ideal2",
  ideal3: "ideal3",
  ideal4: "ideal4",
  ideal5: "ideal5",
  ideal6: "ideal6",
  ideal7: "ideal7",
  ideal8: "ideal8",
  ideal9: "ideal9",
  perfectReliability: "Perfect Reliability",
  noSkill: "No Skill",
  blueCurveText: "blueCurveText",
  blackCurveText: "blackCurveText",
  redCurveText: "redCurveText"
};
var Messages = {
  NO_DATA_FOUND: "INFO:0 data records found"
}; //hide non-timeseries selectors at startup

var selectorsToHide = ['dieoff-type', 'utc-cycle-start', 'histogram-bin-controls', 'histogram-yaxis-controls', 'bin-number', 'bin-pivot', 'bin-start', 'bin-stride', 'bin-bounds', 'x-axis-parameter', 'y-axis-parameter'];
/*
Class for holding metaData records. These are stored in an array. An app can have multiple metadata databases and each database has a pool for connections.
These pools are global (although for future reference the access might be from this collection.). They are refenced in this script via the pool name.
This class enforces the types of the poolName (in case someone accidentally tries to store the whole pool object), and the database name and a list
of table names. The internal list can be appended. The getRecords returns the internal list.
 */

var MetaDataDBRecord =
/*#__PURE__*/
function () {
  function MetaDataDBRecord(poolName, dbName, tables) {
    if (!(0, _typeof2.default)(poolName) === "string") {
      throw new Error("MetaDataDBRecord.constructor : poolName is not a string");
    }

    if (!(0, _typeof2.default)(dbName) === "string") {
      throw new Error("MetaDataDBRecord.constructor : dbName is not a string");
    }

    if (!tables instanceof Array) {
      throw new Error("MetaDataDBRecord.constructor : tables is not an array");
    }

    this._records = [];
    var record = {
      'pool': poolName,
      'name': dbName,
      'tables': tables
    };

    this._records.push(record);
  }

  var _proto = MetaDataDBRecord.prototype;

  _proto.addRecord = function () {
    function addRecord(poolName, dbName, tables) {
      if (!(0, _typeof2.default)(poolName) === "string") {
        throw new Error("MetaDataDBRecord.constructor : poolName is not a string");
      }

      if (!(0, _typeof2.default)(dbName) === "string") {
        throw new Error("MetaDataDBRecord.constructor : dbName is not a string");
      }

      if (!tables instanceof Array) {
        throw new Error("MetaDataDBRecord.constructor : tables is not an array");
      }

      var record = {
        'pool': poolName,
        'name': dbName,
        'tables': tables
      };

      this._records.push(record);
    }

    return addRecord;
  }();

  _proto.getRecords = function () {
    function getRecords() {
      return this._records;
    }

    return getRecords;
  }();

  return MetaDataDBRecord;
}();

module.exportDefault(matsTypes = {
  InputTypes: InputTypes,
  PlotTypes: PlotTypes,
  PlotFormats: PlotFormats,
  PlotActions: PlotActions,
  BestFits: BestFits,
  MatchFormats: MatchFormats,
  PlotAxisFilters: PlotAxisFilters,
  PlotView: PlotView,
  Messages: Messages,
  ForecastTypes: ForecastTypes,
  ReservedWords: ReservedWords,
  selectorsToHide: selectorsToHide,
  MetaDataDBRecord: MetaDataDBRecord,
  AppTypes: AppTypes,
  DatabaseRoles: DatabaseRoles
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"mats-collections.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/both/mats-collections.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Mongo;
module.link("meteor/mongo", {
  Mongo: function (v) {
    Mongo = v;
  }
}, 0);
var CurveParams = new Mongo.Collection("CurveParams");
var Scatter2dParams = new Mongo.Collection("Scatter2dParams");
var CurveTextPatterns = new Mongo.Collection("CurveTextPatterns");
var ScatterAxisTextPattern = new Mongo.Collection("ScatterAxisTextPattern");
var SavedCurveParams = new Mongo.Collection("SavedCurveParams");
var PlotParams = new Mongo.Collection("PlotParams");
var SavedPlotParams = new Mongo.Collection("SavedPlotParams");
var PlotGraphFunctions = new Mongo.Collection("PlotGraphFunctions");
var SavedPlotGraphFunctions = new Mongo.Collection("SavedPlotGraphFunctions");
var RegionsPerModel = new Mongo.Collection("RegionsPerModel");
var SitesPerModel = new Mongo.Collection("SitesPerModel");
var RegionDescriptions = new Mongo.Collection("RegionDescriptions");
var Models = new Mongo.Collection("Models");
var Instruments = new Mongo.Collection("Instruments");
var FcstLensPerModel = new Mongo.Collection("FcstLensPerModel");
var CurveSettings = new Mongo.Collection("CurveSettings");
var Settings = new Mongo.Collection("Settings");
var ColorScheme = new Mongo.Collection("ColorScheme");
var SentAddresses = new Mongo.Collection("SentAddresses");
var Authorization = new Mongo.Collection("Authorization");
var Roles = new Mongo.Collection("Roles");
var SavedRoles = new Mongo.Collection("SavedRoles");
var Databases = new Mongo.Collection("Databases");
var SavedDatabases = new Mongo.Collection("SavedDatabases");
var Credentials = new Mongo.Collection("Credentials");
var SavedCredentials = new Mongo.Collection("SavedCredentials");
var SiteMap = new Mongo.Collection("SiteMap");
var StationMap = new Mongo.Collection("StationMap");
var appName = new Mongo.Collection("appName");
module.exportDefault(matsCollections = {
  CurveParams: CurveParams,
  Scatter2dParams: Scatter2dParams,
  CurveTextPatterns: CurveTextPatterns,
  ScatterAxisTextPattern: ScatterAxisTextPattern,
  SavedCurveParams: SavedCurveParams,
  PlotParams: PlotParams,
  SavedPlotParams: SavedPlotParams,
  PlotGraphFunctions: PlotGraphFunctions,
  SavedPlotGraphFunctions: SavedPlotGraphFunctions,
  RegionsPerModel: RegionsPerModel,
  SitesPerModel: SitesPerModel,
  RegionDescriptions: RegionDescriptions,
  Models: Models,
  Instruments: Instruments,
  FcstLensPerModel: FcstLensPerModel,
  CurveSettings: CurveSettings,
  Settings: Settings,
  ColorScheme: ColorScheme,
  SentAddresses: SentAddresses,
  Authorization: Authorization,
  Roles: Roles,
  SavedRoles: SavedRoles,
  Databases: Databases,
  SavedDatabases: SavedDatabases,
  Credentials: Credentials,
  SavedCredentials: SavedCredentials,
  SiteMap: SiteMap,
  StationMap: StationMap,
  appName: appName
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"api":{"matsMethods.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/api/matsMethods.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var ValidatedMethod;
module.link("meteor/mdg:validated-method", {
  ValidatedMethod: function (v) {
    ValidatedMethod = v;
  }
}, 1);
var SimpleSchema;
module.link("meteor/aldeed:simple-schema", {
  SimpleSchema: function (v) {
    SimpleSchema = v;
  }
}, 2);
var matsCache, matsCollections, matsDataQueryUtils, matsDataUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCache: function (v) {
    matsCache = v;
  },
  matsCollections: function (v) {
    matsCollections = v;
  },
  matsDataQueryUtils: function (v) {
    matsDataQueryUtils = v;
  },
  matsDataUtils: function (v) {
    matsDataUtils = v;
  },
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 3);
var mysql;
module.link("meteor/pcel:mysql", {
  mysql: function (v) {
    mysql = v;
  }
}, 4);
var url;
module.link("url", {
  url: function (v) {
    url = v;
  }
}, 5);
var Mongo;
module.link("meteor/mongo", {
  Mongo: function (v) {
    Mongo = v;
  }
}, 6);
// PRIVATE
// local collection used to keep the table update times for refresh - won't ever be synchronized or persisted.
var metaDataTableUpdates = new Mongo.Collection(null);
var LayoutStoreCollection = new Mongo.Collection("LayoutStoreCollection"); // initialize collection used for pop-out window functionality

var DownSampleResults = new Mongo.Collection("DownSampleResults");
var MV_DIRS = {}; // Define routes for server

if (Meteor.isServer) {
  if (Meteor.settings.private !== undefined && Meteor.settings.private !== null) {
    var _MV_OUT = Meteor.settings.private.MV_OUTPUT;
    var _MV_HOME = Meteor.settings.private.MV_HOME;

    var _MV_LOGDIR = _MV_OUT + "/xml/";

    var _MV_ERRDIR = _MV_OUT + "/xml/";

    var _MV_DATADIR = _MV_OUT + "/data/";

    var _MV_SQLDIR = _MV_OUT + "/xml/"; // sql output goes with the xml output


    var _MV_XMLDIR = _MV_OUT + "/xml/";

    var _MV_SCRIPTSDIR = _MV_OUT + "/scripts/";

    var _MV_PLOTSSDIR = _MV_OUT + "/plots/";

    process.env.JAVA_HOME = Meteor.settings.private.JAVA_HOME;
    process.env.MV_HOME = Meteor.settings.private.MV_HOME;
    MV_DIRS = {
      LOGDIR: _MV_LOGDIR,
      ERRDIR: _MV_ERRDIR,
      DATADIR: _MV_DATADIR,
      SQLDIR: _MV_SQLDIR,
      XMLDIR: _MV_XMLDIR,
      SCRIPTSDIR: _MV_SCRIPTSDIR,
      PLOTSDIR: _MV_PLOTSSDIR,
      HOME: _MV_HOME
    };
  } // add indexes to result and axes collections


  DownSampleResults.rawCollection().createIndex({
    "createdAt": 1
  }, {
    expireAfterSeconds: 3600 * 8
  }); // 8 hour expiration

  LayoutStoreCollection.rawCollection().createIndex({
    "createdAt": 1
  }, {
    expireAfterSeconds: 900
  }); // 15 min expiration
  // set the default proxy prefix path to ""

  if (Meteor.settings.public != null && Meteor.settings.public.proxy_prefix_path == null) {
    Meteor.settings.public.proxy_prefix_path = "";
  }

  Picker.route('/_getCSV/:key', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/_getCSV/:key', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/app:/_getCSV/:key', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route('/CSV/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/CSV/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/CSV/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getCSV(params, req, res, next));
  });
  Picker.route('/_getJSON/:key', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/_getJSON/:key', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/app:/_getJSON/:key', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route('/JSON/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/JSON/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/JSON/:f/:key/:m/:a', function (params, req, res, next) {
    Picker.middleware(_getJSON(params, req, res, next));
  });
  Picker.route('/clearCache', function (params, req, res, next) {
    Picker.middleware(_clearCache(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/clearCache', function (params, req, res, next) {
    Picker.middleware(_clearCache(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/clearCache', function (params, req, res, next) {
    Picker.middleware(_clearCache(params, req, res, next));
  });
  Picker.route('/refreshMetadata', function (params, req, res, next) {
    Picker.middleware(_refreshMetadataMWltData(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/refreshMetadata', function (params, req, res, next) {
    Picker.middleware(_refreshMetadataMWltData(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/refreshMetadata', function (params, req, res, next) {
    Picker.middleware(_refreshMetadataMWltData(params, req, res, next));
  }); // create picker routes for metviewer middleware static files

  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvdata/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetData(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvpoints1/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetPoints1(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvpoints2/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetPoints2(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvxml/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetXml(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvplot/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetPlot(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvscript/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetScript(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvsql/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetSql(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mvlog/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetLog(params, req, res, next));
  });
  Picker.route(Meteor.settings.public.proxy_prefix_path + '/:app/mverr/:key', function (params, req, res, next) {
    Picker.middleware(_mvGetErr(params, req, res, next));
  });
} // private - used to see if the main page needs to update its selectors


var _checkMetaDataRefresh = function () {
  // This routine compares the current last modified time of the tables used for curveParameter metadata
  // with the last update time to determine if an update is necessary. We really only do this for Curveparams

  /*
      metaDataTableUpdates:
      {
          name: dataBaseName,
          tables: [tableName1, tableName2 ..],
          lastRefreshed : timestamp
      }
   */
  var refresh = false;
  var tableUpdates = metaDataTableUpdates.find({}).fetch();

  for (var tui = 0; tui < tableUpdates.length; tui++) {
    var id = tableUpdates[tui]._id;
    var poolName = tableUpdates[tui].pool;
    var dbName = tableUpdates[tui].name;
    var tableNames = tableUpdates[tui].tables;
    var lastRefreshed = tableUpdates[tui]['lastRefreshed'];
    var updatedEpoch = Number.MAX_VALUE;

    for (var ti = 0; ti < tableNames.length; ti++) {
      var tName = tableNames[ti];
      var rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(global[poolName], "SELECT UNIX_TIMESTAMP(UPDATE_TIME)" + "    FROM   information_schema.tables" + "    WHERE  TABLE_SCHEMA = '" + dbName + "'" + "    AND TABLE_NAME = '" + tName + "'");

      for (var i = 0; i < rows.length; i++) {
        try {
          updatedEpoch = rows[i]['UNIX_TIMESTAMP(UPDATE_TIME)'];
          break;
        } catch (e) {
          throw new Error("_checkMetaDataRefresh - cannot find last update time for database: " + dbName + " and table: " + tName + " ERROR:" + e.message);
        }

        if (updatedEpoch === Number.MAX_VALUE) {
          throw new Error("_checkMetaDataRefresh - cannot find last update time for database: " + dbName + " and table: " + tName);
        }
      }

      var lastRefreshedEpoch = moment(lastRefreshed).valueOf() / 1000;

      if (lastRefreshedEpoch < updatedEpoch) {
        refresh = true;
        console.log("Refreshing the metadata in the app selectors because table " + dbName + "." + tName + " was updated at " + moment.utc(updatedEpoch * 1000).format("YYYY-MM-DD HH:mm:ss") + " while the metadata was last refreshed at " + moment.utc(lastRefreshedEpoch * 1000).format("YYYY-MM-DD HH:mm:ss"));
        break;
      }
    }

    if (refresh === true) {
      // refresh the app metadata
      // app specific routines
      //const asrKeys = Object.keys(appSpecificResetRoutines);
      var _asrKeys = appSpecificResetRoutines;

      for (var ai = 0; ai < _asrKeys.length; ai++) {
        global.appSpecificResetRoutines[ai]();
      } // remember that we updated ALL the metadata tables just now


      metaDataTableUpdates.update({
        _id: id
      }, {
        $set: {
          lastRefreshed: moment().format()
        }
      });
    }
  }

  return true;
}; // private middleware for clearing the cache


var _clearCache = function (params, req, res, next) {
  if (Meteor.isServer) {
    matsCache.clear();
    res.end("<body><h1>clearCache Done!</h1></body>");
  }
}; // private middleware for _getCSV route


var _getCSV = function (params, req, res, next) {
  if (Meteor.isServer) {
    var stringify = require('csv-stringify');

    var csv = "";

    try {
      var result = _getFlattenedResultData(params.key, 0, -1000);

      var statArray = Object.values(result.stats);
      var dataArray = Object.values(result.data);
      var statResultArray = [];
      var dataResultArray = [];

      for (var si = 0; si < statArray.length; si++) {
        statResultArray.push(Object.keys(statArray[si])); // push the stat header for this curve(keys)

        statResultArray.push(statArray[si]['n'] === 0 ? [statArray[si].label] : Object.values(statArray[si])); // push the stats for this curve
      }

      for (var di = 0; di < dataArray.length; di++) {
        var dataSubArray = Object.values(dataArray[di]);
        var dataHeader = dataSubArray[0] === undefined ? statArray[di].label : Object.keys(dataSubArray[0]); //dataHeader[0] = 'label';

        dataHeader[0] = dataSubArray[0] === undefined ? "NO DATA" : Object.keys(dataSubArray[0]).filter(function (key) {
          return key.indexOf('Curve') != -1;
        })[0];
        dataResultArray.push(dataHeader); // push this curve data header (keys)

        if (dataSubArray[0] === undefined) {
          continue;
        }

        for (var dsi = 0; dsi < dataSubArray.length; dsi++) {
          // push this curves data
          dataResultArray.push(Object.values(dataSubArray[dsi]));
        }
      }

      var fileName = "matsplot-" + moment.utc().format('YYYYMMDD-HH.mm.ss') + ".csv";
      res.setHeader('Content-disposition', 'attachment; filename=' + fileName);
      res.setHeader('Content-Type', 'attachment.ContentType');
      stringify(statResultArray, {
        header: true
      }, function (err, output) {
        if (err) {
          console.log("error in _getCSV:", err);
          res.write("error," + err.toLocaleString());
          res.end("<body><h1>_getCSV Error! " + err.toLocaleString() + "</h1></body>");
          return;
        }

        res.write(output);
        stringify(dataResultArray, {
          header: true
        }, function (err, output) {
          if (err) {
            console.log("error in _getCSV:", err);
            res.write("error," + err.toLocaleString());
            res.end("<body><h1>_getCSV Error! " + err.toLocaleString() + "</h1></body>");
            return;
          }

          res.write(output);
          res.end();
        });
        delete result;
        delete statResultArray;
        delete dataResultArray;
      });
    } catch (e) {
      console.log('error retrieving data: ', e);
      csv = "error," + e.toLocaleString();
      res.setHeader('Content-disposition', 'attachment; filename=matsplot.csv');
      res.setHeader('Content-Type', 'attachment.ContentType');
      res.end("<body><h1>_getCSV Error! " + csv + "</h1></body>");
    }
  }
}; // private middleware for _getJSON route


var _getJSON = function (params, req, res, next) {
  if (Meteor.isServer) {
    var flatJSON = "";

    try {
      var result = _getPagenatedData(params.key, 0, -1000);

      flatJSON = JSON.stringify(result);
    } catch (e) {
      console.log('error retrieving data: ', e);
      flatJSON = JSON.stringify({
        error: e
      });
      delete flatJSON.dsiRealPageIndex;
      delete flatJSON.dsiTextDirection;
    }

    res.setHeader('Content-Type', 'application/json');
    res.write(flatJSON);
    res.end();
    delete flatJSON;
    delete result;
  }
}; // private method for getting pagenated results and flattening them in order to be appropriate for text display.


var _getFlattenedResultData = function (rk, p, np) {
  if (Meteor.isServer) {
    var resp;

    try {
      var r = rk;
      var p = p;
      var np = np; // get the pagenated data

      var result = _getPagenatedData(r, p, np); // find the type


      var plotTypes = result.basis.plotParams.plotTypes;

      var plotType = _.invert(plotTypes)[true]; // extract data


      var data = result.data;
      var dsiRealPageIndex = result.dsiRealPageIndex;
      var dsiTextDirection = result.dsiTextDirection;

      switch (plotType) {
        case matsTypes.PlotTypes.timeSeries:
        case matsTypes.PlotTypes.dailyModelCycle:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          /*
          returnData is
          {
              stats: {
                          curve0: {label:someLabel, mean:someMean,sd:someSd....}
                          curve1: {label:someLabel, mean:someMean,sd:someSd....}
                          ...
                      }
              data: {
                          curve0: [
                                      {time:someTime, stat: someStat, sd: someSd,....},
                                      {time:someTime, stat: someStat, sd: someSd,....},
                                      ....
                                  ],
                          curve1: [
                                      {time:someTime, stat: someStat, sd: someSd,....},
                                      {time:someTime, stat: someStat, sd: someSd,....},
                                      ....
                                  ],
                                  ...
                    }
          }
           */

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            // if the curve label is a reserved word do not process the curve (its a zero or max curve)
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['mean'] = data[ci].glob_stats.d_mean;
            stats['standard deviation'] = data[ci].glob_stats.sd;
            stats['n'] = data[ci].glob_stats.n_good;
            stats['standard error'] = data[ci].glob_stats.stde_betsy;
            stats['lag1'] = data[ci].glob_stats.lag1;
            stats['minimum'] = data[ci].glob_stats.minVal;
            stats['maximum'] = data[ci].glob_stats.maxVal;
            returnData.stats[data[ci].label] = stats;
            var curveData = []; // map of maps

            for (var cdi = 0; cdi < data[ci].x.length; cdi++) {
              //for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + ' time'] = data[ci].x[cdi];
              curveDataElement['raw stat from query'] = data[ci].stats[cdi].raw_stat;
              curveDataElement['plotted stat'] = data[ci].y[cdi];
              curveDataElement['std dev'] = data[ci].stats[cdi].sd;
              curveDataElement['std error'] = data[ci].stats[cdi].stde_betsy;
              curveDataElement['lag1'] = data[ci].stats[cdi].lag1;
              curveDataElement['n'] = data[ci].stats[cdi].n_good;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.profile:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of map

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['mean'] = data[ci].glob_stats.d_mean;
            stats['standard deviation'] = data[ci].glob_stats.sd;
            stats['n'] = data[ci].glob_stats.n_good;
            stats['standard error'] = data[ci].glob_stats.stde_betsy;
            stats['lag1'] = data[ci].glob_stats.lag1;
            stats['minimum'] = data[ci].glob_stats.minVal;
            stats['maximum'] = data[ci].glob_stats.maxVal;
            returnData.stats[data[ci].label] = stats;
            var cdata = data[ci].data;
            var curveData = []; // array of maps

            for (var cdi = 0; cdi < data[ci].x.length; cdi++) {
              // for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + ' level'] = data[ci].y[cdi];
              curveDataElement['raw stat from query'] = data[ci].stats[cdi].raw_stat;
              curveDataElement['plotted stat'] = data[ci].x[cdi];
              curveDataElement['std dev'] = data[ci].stats[cdi].sd;
              curveDataElement['std error'] = data[ci].stats[cdi].stde_betsy;
              curveDataElement['lag1'] = data[ci].stats[cdi].lag1;
              curveDataElement['n'] = data[ci].stats[cdi].n_good;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.dieoff:
        case matsTypes.PlotTypes.threshold:
        case matsTypes.PlotTypes.validtime:
          var labelSuffix;

          switch (plotType) {
            case matsTypes.PlotTypes.dieoff:
              labelSuffix = " forecast lead time";
              break;

            case matsTypes.PlotTypes.validtime:
              labelSuffix = " hour of day";
              break;

            case matsTypes.PlotTypes.threshold:
              labelSuffix = " threshold (in)";
              break;
          }

          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['mean'] = data[ci].glob_stats.d_mean;
            stats['standard deviation'] = data[ci].glob_stats.sd;
            stats['n'] = data[ci].glob_stats.n_good;
            stats['minimum'] = data[ci].glob_stats.minVal;
            stats['maximum'] = data[ci].glob_stats.maxVal;
            returnData.stats[data[ci].label] = stats;
            var curveData = []; // map of maps

            for (var cdi = 0; cdi < data[ci].x.length; cdi++) {
              // for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + labelSuffix] = data[ci].x[cdi];
              curveDataElement['raw stat from query'] = data[ci].stats[cdi].raw_stat;
              curveDataElement['plotted stat'] = data[ci].y[cdi];
              curveDataElement['std dev'] = data[ci].stats[cdi].sd;
              curveDataElement['n'] = data[ci].stats[cdi].n_good;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.reliability:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of map

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['sample climo'] = data[ci].glob_stats.sample_climo;
            returnData.stats[data[ci].label] = stats;
            var cdata = data[ci].data;
            var curveData = []; // array of maps

            for (var cdi = 0; cdi < data[ci].y.length; cdi++) {
              // for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + ' probability bin'] = data[ci].stats[cdi].prob_bin;
              curveDataElement['hit rate'] = data[ci].stats[cdi].hit_rate;
              curveDataElement['oy'] = data[ci].stats[cdi].obs_y;
              curveDataElement['on'] = data[ci].stats[cdi].obs_n;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.map:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          var stats = {};
          stats['label'] = data[0].label;
          stats['total number of obs'] = data[0].stats.reduce(function (prev, curr) {
            return prev + curr.N_times;
          }, 0);
          stats['mean difference'] = matsDataUtils.average(data[0].queryVal);
          stats['standard deviation'] = matsDataUtils.stdev(data[0].queryVal);
          stats['minimum time'] = data[0].stats.reduce(function (prev, curr) {
            return prev < curr.min_time ? prev : curr.min_time;
          });
          stats['minimum time'] = moment.utc(stats['minimum time'] * 1000).format('YYYY-MM-DD HH:mm');
          stats['maximum time'] = data[0].stats.reduce(function (prev, curr) {
            return prev > curr.max_time ? prev : curr.max_time;
          });
          stats['maximum time'] = moment.utc(stats['maximum time'] * 1000).format('YYYY-MM-DD HH:mm');
          returnData.stats[data[0].label] = stats;
          var curveData = []; // map of maps

          for (var si = 0; si < data[0].siteName.length; si++) {
            var curveDataElement = {};
            curveDataElement['Site Name'] = data[0].siteName[si];
            curveDataElement['Number of Times'] = data[0].stats[si].N_times;
            curveDataElement['Start Date'] = moment.utc(data[0].stats[si].min_time * 1000).format('YYYY-MM-DD HH:mm');
            curveDataElement['End Date'] = moment.utc(data[0].stats[si].max_time * 1000).format('YYYY-MM-DD HH:mm');
            curveDataElement['Average Difference'] = data[0].queryVal[si];
            curveData.push(curveDataElement);
          }

          returnData.data[data[0].label] = curveData;
          break;

        case matsTypes.PlotTypes.histogram:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          for (var ci = 0; ci < data.length; ci++) {
            // for each curve
            var reservedWords = Object.values(matsTypes.ReservedWords);

            if (reservedWords.indexOf(data[ci].label) >= 0) {
              continue; // don't process the zero or max curves
            }

            var stats = {};
            stats['label'] = data[ci].label;
            stats['mean'] = data[ci].glob_stats.glob_mean;
            stats['standard deviation'] = data[ci].glob_stats.glob_sd;
            stats['n'] = data[ci].glob_stats.glob_n;
            stats['minimum'] = data[ci].glob_stats.glob_min;
            stats['maximum'] = data[ci].glob_stats.glob_max;
            returnData.stats[data[ci].label] = stats;
            var curveData = []; // map of maps

            for (var cdi = 0; cdi < data[ci].x.length; cdi++) {
              // for each datapoint
              var curveDataElement = {};
              curveDataElement[data[ci].label + ' bin range'] = data[ci].bin_stats[cdi]['binLabel'];
              curveDataElement['n'] = data[ci].bin_stats[cdi].bin_n;
              curveDataElement['bin rel freq'] = data[ci].bin_stats[cdi].bin_rf;
              curveDataElement['bin lower bound'] = data[ci].bin_stats[cdi].binLowBound;
              curveDataElement['bin upper bound'] = data[ci].bin_stats[cdi].binUpBound;
              curveDataElement['bin mean'] = data[ci].bin_stats[cdi].bin_mean;
              curveDataElement['bin std dev'] = data[ci].bin_stats[cdi].bin_sd;
              curveData.push(curveDataElement);
            }

            returnData.data[data[ci].label] = curveData;
          }

          break;

        case matsTypes.PlotTypes.contour:
        case matsTypes.PlotTypes.contourDiff:
          var returnData = {};
          returnData.stats = {}; // map of maps

          returnData.data = {}; // map of arrays of maps

          var stats = {};
          stats['label'] = data[0].label;
          stats['total number of points'] = data[0].glob_stats.n;
          stats['mean stat'] = data[0].glob_stats.mean;
          stats['minimum time'] = data[0].glob_stats.minDate;
          stats['minimum time'] = moment.utc(stats['minimum time'] * 1000).format('YYYY-MM-DD HH:mm');
          stats['maximum time'] = data[0].glob_stats.maxDate;
          stats['maximum time'] = moment.utc(stats['maximum time'] * 1000).format('YYYY-MM-DD HH:mm');
          returnData.stats[data[0].label] = stats;
          var curveData = []; // map of maps

          for (var si = 0; si < data[0].xTextOutput.length; si++) {
            var curveDataElement = {};
            curveDataElement['xVal'] = data[0].xTextOutput[si];
            curveDataElement['yVal'] = data[0].yTextOutput[si];
            curveDataElement['stat'] = data[0].zTextOutput[si];
            curveDataElement['N'] = data[0].nTextOutput[si];
            curveDataElement['Start Date'] = moment.utc(data[0].minDateTextOutput[si] * 1000).format('YYYY-MM-DD HH:mm');
            curveDataElement['End Date'] = moment.utc(data[0].maxDateTextOutput[si] * 1000).format('YYYY-MM-DD HH:mm');
            curveData.push(curveDataElement);
          }

          returnData.data[data[0].label] = curveData;
          break;

        case matsTypes.PlotTypes.scatter2d:
          var returnData = {}; // returns a map of arrays of maps

          /*
          returnData = {
                          curve0: [
                                      {
                                      xval: number,
                                      yval: number,
                                      bestfit: number || none
                                      },
                                      {
                                      xval: number,
                                      yval: number,
                                      bestfit: number || none
                                      },
                                     .....
                                  ],
                           curve1: [
                                      {
                                      xval: number,
                                      yval: number,
                                      bestfit: number || none
                                      },
                                      {
                                      xval: number,
                                      yval: number,
                                      bestfit: number || none
                                      },
                                     .....
                                  ],
                                  ....
                      }
           */

          var firstBestFitIndex = -1;
          var bestFitIndexes = {};

          for (var ci = 0; ci < data.length; ci++) {
            if (ci == firstBestFitIndex) {
              break; // best fit curves are at the end so do not do further processing
            }

            var curveData = data[ci]; // look for a best fit curve - only have to look at curves with higher index than this one

            var bestFitIndex = -1;

            for (var cbi = ci + 1; cbi < data.length; cbi++) {
              if (data[cbi].label.indexOf(curveData.label) !== -1 && data[cbi].label.indexOf("-best fit") != -1) {
                bestFitIndexes[ci] = cbi;

                if (firstBestFitIndex == -1) {
                  firstBestFitIndex = cbi;
                }

                break;
              }
            }

            var curveTextData = [];

            for (var cdi = 0; cdi < curveData.data.length; cdi++) {
              var element = {};
              element['xAxis'] = curveData.data[cdi][0];
              element['yAxis'] = curveData.data[cdi][1];

              if (bestFitIndexes[ci] === undefined) {
                element['best fit'] = "none;";
              } else {
                element['best fit'] = data[bestFitIndexes[ci]].data[cdi][1];
              }

              curveTextData.push(element);
            }

            returnData[curveData.label] = curveTextData;
          }

          break;

        default:
          return undefined;
      }

      returnData.dsiRealPageIndex = dsiRealPageIndex;
      returnData.dsiTextDirection = dsiTextDirection;
      return returnData;
    } catch (error) {
      throw new Meteor.Error("Error in _getFlattenedResultData function: " + error.message);
    }
  }
}; // private method for getting pagenated data
// a newPageIndex of -1000 means get all the data (used for export)
// a newPageIndex of -2000 means get just the last page


var _getPagenatedData = function (rky, p, np) {
  if (Meteor.isServer) {
    var key = rky;
    var myPageIndex = p;
    var newPageIndex = np;
    var ret;
    var rawReturn;

    try {
      var result = matsCache.getResult(key);
      rawReturn = result === undefined ? undefined : result.result; // getResult structure is {key:something, result:resultObject}
    } catch (e) {
      console.log("_getPagenatedData: Error - ", e);
      return undefined;
    }

    ret = rawReturn === undefined ? undefined : JSON.parse(JSON.stringify(rawReturn));
    var start;
    var end;
    var direction = 1;

    if (newPageIndex === -1000) {
      // all the data
      start = 0;
      end = Number.MAX_VALUE;
    } else if (newPageIndex === -2000) {
      // just the last page
      start = -2000;
      direction = -1;
    } else if (myPageIndex <= newPageIndex) {
      // proceed forward
      start = (newPageIndex - 1) * 100;
      end = newPageIndex * 100;
    } else {
      // move back
      direction = -1;
      start = newPageIndex * 100;
      end = (newPageIndex + 1) * 100;
    }

    var dsiStart;
    var dsiEnd;

    for (var csi = 0; csi < ret.data.length; csi++) {
      if (ret.data[csi].x == null || ret.data[csi].x.length <= 100) {
        continue; // don't bother pagenating datasets less than or equal to a page - ret is rawReturn
      }

      dsiStart = start;
      dsiEnd = end;

      if (dsiStart > ret.data[csi].x.length || dsiStart === -2000) {
        // show the last page if we either requested it specifically or are trying to navigate past it
        dsiStart = Math.floor(rawReturn.data[csi].x.length / 100) * 100;
        dsiEnd = rawReturn.data[csi].x.length;

        if (dsiEnd === dsiStart) {
          // make sure the last page isn't empty--if rawReturn.data[csi].data.length/100 produces a whole number,
          // dsiStart and dsiEnd would be the same. This makes sure that the last full page is indeed the last page, without a phantom empty page afterwards
          dsiStart = dsiEnd - 100;
        }
      }

      if (dsiStart < 0) {
        // show the first page if we are trying to navigate before it
        dsiStart = 0;
        dsiEnd = 100;
      }

      if (dsiEnd < dsiStart) {
        // make sure that the end is after the start
        dsiEnd = dsiStart + 100;
      }

      if (dsiEnd > ret.data[csi].x.length) {
        // make sure we don't request past the end -- if results are one page, this should convert the
        // start and end from 0 and 100 to 0 and whatever the end is.
        dsiEnd = ret.data[csi].x.length;
      }

      ret.data[csi].x = rawReturn.data[csi].x.slice(dsiStart, dsiEnd);
      ret.data[csi].y = rawReturn.data[csi].y.slice(dsiStart, dsiEnd);
      ret.data[csi].stats = rawReturn.data[csi].stats.slice(dsiStart, dsiEnd);
      ret.data[csi].glob_stats = rawReturn.data[csi].glob_stats;
    }

    delete rawReturn;

    if (direction === 1) {
      ret.dsiRealPageIndex = Math.floor(dsiEnd / 100);
    } else {
      ret.dsiRealPageIndex = Math.floor(dsiStart / 100);
    }

    ret.dsiTextDirection = direction;
    return ret;
  }
}; //private middleware for getting metviewer data file


var _mvGetData = function (params, req, res, next) {
  var fse = require("fs-extra");

  var filePath = MV_DIRS.DATADIR;
  var baseName = params.key + ".data";
  var fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting data file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer points1 file


var _mvGetPoints1 = function (params, req, res, next) {
  var fse = require("fs-extra");

  var filePath = MV_DIRS.DATADIR;
  var baseName = params.key + ".points1";
  var fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting data file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer points1 file


var _mvGetPoints2 = function (params, req, res, next) {
  var fse = require("fs-extra");

  var filePath = MV_DIRS.DATADIR;
  var baseName = params.key + ".points2";
  var fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting data file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer xml file


var _mvGetXml = function (params, req, res, next) {
  var fse = require("fs-extra");

  var filePath = MV_DIRS.XMLDIR;
  var baseName = params.key + ".xml";
  var fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting xml file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer plot file


var _mvGetPlot = function (params, req, res, next) {
  var fse = require("fs-extra");

  var filePath = MV_DIRS.PLOTSDIR;
  var baseName = params.key + ".png";
  var fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'image/png');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'application/txt');
    res.write("Error Error getting plot file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer script file


var _mvGetScript = function (params, req, res, next) {
  var fse = require("fs-extra");

  var filePath = MV_DIRS.SCRIPTSDIR;
  var baseName = params.key + ".R";
  var fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting script file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer sql file


var _mvGetSql = function (params, req, res, next) {
  var fse = require("fs-extra");

  var filePath = MV_DIRS.SQLDIR;
  var baseName = params.key + ".sql";
  var fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/sql');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting sql file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer log file


var _mvGetLog = function (params, req, res, next) {
  var fse = require("fs-extra");

  var filePath = MV_DIRS.LOGDIR;
  var baseName = params.key + ".log";
  var fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        console.log(err);
      } // Fail if the file can't be read.


      res.end(data); // Send the file data to the browser.
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting log file :" + baseName);
    res.end();
  }
}; //private middleware for getting metviewer err file


var _mvGetErr = function (params, req, res, next) {
  var fse = require("fs-extra");

  var filePath = MV_DIRS.ERRDIR;
  var baseName = params.key + ".err";
  var fileName = filePath + '/' + baseName;

  try {
    fse.readFile(fileName, function (err, data) {
      res.setHeader('Content-Type', 'text/plain');

      if (err) {
        res.setHeader('Content-Type', 'text/plain');
        res.write("Error Error getting err file :" + baseName);
        res.end();
      } else {
        res.end(data); // Send the file data to the browser.
      }
    });
  } catch (error) {
    res.setHeader('Content-Type', 'text/plain');
    res.write("Error Error getting plot file :" + baseName);
    res.end();
  }
}; // private define a middleware for refreshing the metadata


var _refreshMetadataMWltData = function (params, req, res, next) {
  if (Meteor.isServer) {
    _checkMetaDataRefresh();

    res.end("<body><h1>refreshMetadata Done!</h1></body>");
  }
}; // private save the result from the query into mongo and downsample if that result's size is greater than 1Mb


var _saveResultData = function (result) {
  if (Meteor.isServer) {
    var sizeof = require('object-sizeof');

    var hash = require('object-hash');

    var key = hash(result.basis.plotParams);
    var threshold = 1000000;
    var ret = {};

    try {
      var dSize = sizeof(result.data); //console.log("result.basis.data size is ", dSize);
      // TimeSeries and DailyModelCycle are the only plot types that require downSampling

      if (dSize > threshold && (result.basis.plotParams.plotTypes.TimeSeries || result.basis.plotParams.plotTypes.DailyModelCycle)) {
        // greater than threshold need to downsample
        // downsample and save it in DownSampleResult
        console.log("DownSampling");

        var downsampler = require("downsample-lttb");

        var totalPoints = 0;

        for (var di = 0; di < result.data.length; di++) {
          totalPoints += result.data[di].x_epoch.length;
        }

        var allowedNumberOfPoints = threshold / dSize * totalPoints;
        var downSampleResult = result === undefined ? undefined : JSON.parse(JSON.stringify(result));

        for (var ci = 0; ci < result.data.length; ci++) {
          var dsData = {};
          var xyDataset = result.data[ci].x_epoch.map(function (d, index) {
            return [result.data[ci].x_epoch[index], result.data[ci].y[index]];
          });
          var ratioTotalPoints = xyDataset.length / totalPoints;
          var myAllowedPoints = Math.round(ratioTotalPoints * allowedNumberOfPoints); // downsample the array

          var downsampledSeries;

          if (myAllowedPoints < xyDataset.length && xyDataset.length > 2) {
            downsampledSeries = downsampler.processData(xyDataset, myAllowedPoints); // replace the y attributes (tooltips etc.) with the y attributes from the nearest x

            var originalIndex = 0; // skip through the original dataset capturing each downSampled data point

            var arrayKeys = [];
            var nonArrayKeys = [];
            var keys = Object.keys(result.data[ci]);

            for (var ki = 0; ki < keys.length; ki++) {
              if (keys[ki] !== 'x_epoch') {
                if (Array.isArray(result.data[ci][keys[ki]])) {
                  arrayKeys.push(keys[ki]);
                  dsData[keys[ki]] = [];
                } else {
                  nonArrayKeys.push(keys[ki]);
                }
              }
            } // We only ever downsample series plots - never profiles and series plots only ever have error_y arrays.
            // This is a little hacky but what is happening is we putting error_y.array on the arrayKeys list so that it gets its
            // downsampled equivalent values.


            for (ki = 0; ki < nonArrayKeys.length; ki++) {
              dsData[nonArrayKeys[ki]] = result.data[ci][nonArrayKeys[ki]];
            } // remove the original error_y array data.


            dsData['error_y'].array = [];

            for (var dsi = 0; dsi < downsampledSeries.length; dsi++) {
              while (originalIndex < result.data[ci].x_epoch.length && result.data[ci].x_epoch[originalIndex] < downsampledSeries[dsi][0]) {
                originalIndex++;
              } // capture the stuff related to this downSampled data point (downSampled data points are always a subset of original data points)


              for (ki = 0; ki < arrayKeys.length; ki++) {
                dsData[arrayKeys[ki]][dsi] = result.data[ci][arrayKeys[ki]][originalIndex];
              }

              dsData['error_y']['array'][dsi] = result.data[ci]['error_y']['array'][originalIndex];
            } // add downsampled annotation to curve options


            downSampleResult[ci] = dsData;
            downSampleResult[ci].annotation += "   **DOWNSAMPLED**";
          } else {
            downSampleResult[ci] = result.data[ci];
          }

          downSampleResult.data[ci] = downSampleResult[ci];
        }

        DownSampleResults.rawCollection().insert({
          "createdAt": new Date(),
          key: key,
          result: downSampleResult
        }); // createdAt ensures expiration set in mats-collections

        ret = {
          key: key,
          result: downSampleResult
        };
      } else {
        ret = {
          key: key,
          result: result
        };
      } // save original dataset in the matsCache


      if (result.basis.plotParams.plotTypes.TimeSeries || result.basis.plotParams.plotTypes.DailyModelCycle) {
        for (var ci = 0; ci < result.data.length; ci++) {
          delete result.data[ci]['x_epoch']; // we only needed this as an index for downsampling
        }
      }

      matsCache.storeResult(key, {
        key: key,
        result: result
      }); // lifespan is handled by lowDb (internally) in matscache
    } catch (error) {
      if (error.toLocaleString().indexOf("larger than the maximum size") != -1) {
        throw new Meteor.Error(+": Requesting too much data... try averaging");
      }
    }

    return ret;
  }
}; // PUBLIC METHODS
//administration tools


var addSentAddress = new ValidatedMethod({
  name: 'matsMethods.addSentAddress',
  validate: new SimpleSchema({
    toAddress: {
      type: String
    }
  }).validator(),
  run: function (toAddress) {
    if (!Meteor.userId()) {
      throw new Meteor.Error(401, "not-logged-in");
    }

    matsCollections.SentAddresses.upsert({
      address: toAddress
    }, {
      address: toAddress,
      userId: Meteor.userId()
    });
    return false;
  }
}); //  administation tool

var applyAuthorization = new ValidatedMethod({
  name: 'matsMethods.applyAuthorization',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),
  run: function (settings) {
    if (Meteor.isServer) {
      var roles;
      var roleName;
      var authorization;
      var userRoleName = settings.userRoleName;
      var userRoleDescription = settings.userRoleDescription;
      var authorizationRole = settings.authorizationRole;
      var newUserEmail = settings.newUserEmail;
      var existingUserEmail = settings.existingUserEmail;

      if (authorizationRole) {
        // existing role - the role roleName - no need to verify as the selection list came from the database
        roleName = authorizationRole;
      } else if (userRoleName && userRoleDescription) {
        // possible new role - see if it happens to already exist
        var role = matsCollections.Roles.findOne({
          name: userRoleName
        });

        if (role === undefined) {
          // need to add new role using description
          matsCollections.Roles.upsert({
            name: userRoleName
          }, {
            $set: {
              description: userRoleDescription
            }
          });
          roleName = userRoleName;
        } else {
          // see if the description matches...
          roleName = role.name;
          var description = role.description;

          if (description != userRoleDescription) {
            // have to update the description
            matsCollections.Roles.upsert({
              name: userRoleName
            }, {
              $set: {
                description: userRoleDescription
              }
            });
          }
        }
      } // now we have a role roleName - now we need an email


      if (existingUserEmail) {
        // existing user -  no need to verify as the selection list came from the database
        // see if it already has the role
        authorization = matsCollections.Authorization.findOne({
          email: existingUserEmail
        });
        roles = authorization.roles;

        if (roles.indexOf(roleName) == -1) {
          // have to add the role
          if (roleName) {
            roles.push(roleName);
          }

          matsCollections.Authorization.upsert({
            email: existingUserEmail
          }, {
            $set: {
              roles: roles
            }
          });
        }
      } else if (newUserEmail) {
        // possible new authorization - see if it happens to exist
        authorization = matsCollections.Authorization.findOne({
          email: newUserEmail
        });

        if (authorization !== undefined) {
          // authorization exists - add role to roles if necessary
          roles = authorization.roles;

          if (roles.indexOf(roleName) == -1) {
            // have to add the role
            if (roleName) {
              roles.push(roleName);
            }

            matsCollections.Authorization.upsert({
              email: existingUserEmail
            }, {
              $set: {
                roles: roles
              }
            });
          }
        } else {
          // need a new authorization
          roles = [];

          if (roleName) {
            roles.push(roleName);
          }

          if (newUserEmail) {
            matsCollections.Authorization.upsert({
              email: newUserEmail
            }, {
              $set: {
                roles: roles
              }
            });
          }
        }
      }

      return false;
    }
  }
}); // database controls

var applyDatabaseSettings = new ValidatedMethod({
  name: 'matsMethods.applyDatabaseSettings',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),
  run: function (settings) {
    if (Meteor.isServer) {
      if (settings.name) {
        matsCollections.Databases.upsert({
          name: settings.name
        }, {
          $set: {
            name: settings.name,
            role: settings.role,
            status: settings.status,
            host: settings.host,
            database: settings.database,
            user: settings.user,
            password: settings.password
          }
        });
      }

      return false;
    }
  }
}); //administration tools

var deleteSettings = new ValidatedMethod({
  name: 'matsMethods.deleteSettings',
  validate: new SimpleSchema({
    name: {
      type: String
    }
  }).validator(),
  run: function (params) {
    if (!Meteor.userId()) {
      throw new Meteor.Error("not-logged-in");
    }

    if (Meteor.isServer) {
      matsCollections.CurveSettings.remove({
        name: params.name
      });
    }
  }
}); //administration tools

var emailImage = new ValidatedMethod({
  name: 'matsMethods.emailImage',
  validate: new SimpleSchema({
    imageStr: {
      type: String
    },
    toAddress: {
      type: String
    },
    subject: {
      type: String
    }
  }).validator(),
  run: function (params) {
    var imageStr = params.imageStr;
    var toAddress = params.toAddress;
    var subject = params.subject;

    if (!Meteor.userId()) {
      throw new Meteor.Error(401, "not-logged-in");
    }

    var fromAddress = Meteor.user().services.google.email; // these come from google - see
    // http://masashi-k.blogspot.fr/2013/06/sending-mail-with-gmail-using-xoauth2.html
    //http://stackoverflow.com/questions/24098461/nodemailer-gmail-what-exactly-is-a-refresh-token-and-how-do-i-get-one/24123550
    // the gmail account for the credentials is mats.mail.daemon@gmail.com - pwd mats2015!
    //var clientId = "339389735380-382sf11aicmgdgn7e72p4end5gnm9sad.apps.googleusercontent.com";
    //var clientSecret = "7CfNN-tRl5QAL595JTW2TkRl";
    //var refresh_token = "1/PDql7FR01N2gmq5NiTfnrT-OlCYC3U67KJYYDNPeGnA";

    var credentials = matsCollections.Credentials.findOne({
      name: "oauth_google"
    }, {
      clientId: 1,
      clientSecret: 1,
      refresh_token: 1
    });
    var clientId = credentials.clientId;
    var clientSecret = credentials.clientSecret;
    var refresh_token = credentials.refresh_token;
    var smtpTransporter;

    try {
      smtpTransporter = Nodemailer.createTransport("SMTP", {
        service: "Gmail",
        auth: {
          XOAuth2: {
            user: "mats.gsd@noaa.gov",
            clientId: clientId,
            clientSecret: clientSecret,
            refreshToken: refresh_token
          }
        }
      });
    } catch (e) {
      throw new Meteor.Error(401, "Transport error " + e.message());
    }

    try {
      var mailOptions = {
        sender: fromAddress,
        replyTo: fromAddress,
        from: fromAddress,
        to: toAddress,
        subject: subject,
        attachments: [{
          filename: "graph.png",
          contents: new Buffer(imageStr.split("base64,")[1], "base64")
        }]
      };
      smtpTransporter.sendMail(mailOptions, function (error, response) {
        if (error) {
          console.log("smtpTransporter error " + error + " from:" + fromAddress + " to:" + toAddress);
        } else {
          console.log(response + " from:" + fromAddress + " to:" + toAddress);
        }

        smtpTransporter.close();
      });
    } catch (e) {
      throw new Meteor.Error(401, "Send error " + e.message());
    }

    return false;
  }
}); // administation tool

var getAuthorizations = new ValidatedMethod({
  name: 'matsMethods.getAuthorizations',
  validate: new SimpleSchema({}).validator(),
  run: function () {
    var roles = [];

    if (Meteor.isServer) {
      var userEmail = Meteor.user().services.google.email.toLowerCase();
      roles = matsCollections.Authorization.findOne({
        email: userEmail
      }).roles;
    }

    return roles;
  }
}); // administration tool

var getDataFunctionFileList = new ValidatedMethod({
  name: 'matsMethods.getDataFunctionFileList',
  validate: new SimpleSchema({}).validator(),
  run: function () {
    if (Meteor.isServer) {}
  }
}); // retrieves the saved query results (or downsampled results)

var getGraphData = new ValidatedMethod({
  name: 'matsMethods.getGraphData',
  validate: new SimpleSchema({
    plotParams: {
      type: Object,
      blackbox: true
    },
    plotType: {
      type: String
    },
    expireKey: {
      type: Boolean
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      var plotGraphFunction = matsCollections.PlotGraphFunctions.findOne({
        plotType: params.plotType
      });
      var dataFunction = plotGraphFunction.dataFunction;
      var ret;

      try {
        var hash = require('object-hash');

        var key = hash(params.plotParams);

        if (process.env.NODE_ENV === "development" || params.expireKey) {
          matsCache.expireKey(key);
        }

        var results = matsCache.getResult(key);

        if (results === undefined) {
          // results aren't in the cache - need to process data routine
          var Future = require('fibers/future');

          var future = new Future();
          global[dataFunction](params.plotParams, function (results) {
            ret = _saveResultData(results);
            future["return"](ret);
          });
          return future.wait();
        } else {
          // results were already in the matsCache (same params and not yet expired)
          // are results in the downsampled collection?
          var dsResults = DownSampleResults.findOne({
            key: key
          }, {}, {
            disableOplog: true
          });

          if (dsResults !== undefined) {
            // results are in the mongo cache downsampled collection - returned the downsampled graph data
            ret = dsResults; // update the expire time in the downsampled collection - this requires a new Date

            DownSampleResults.rawCollection().update({
              key: key
            }, {
              $set: {
                "createdAt": new Date()
              }
            });
          } else {
            ret = results; // {key:someKey, result:resultObject}
            // refresh expire time. The only way to perform a refresh on matsCache is to re-save the result.

            matsCache.storeResult(results.key, results);
          }

          var sizeof = require('object-sizeof');

          console.log("result.data size is ", sizeof(results));
          return ret;
        }
      } catch (dataFunctionError) {
        if (dataFunctionError.toLocaleString().indexOf("INFO:") !== -1) {
          throw new Meteor.Error(dataFunctionError.message);
        } else {
          throw new Meteor.Error("Error in getGraphData function:" + dataFunction + " : " + dataFunctionError.message);
        }
      }

      return undefined; // probably won't get here
    }
  }
}); // retrieves the saved query results (or downsampled results) for a specific key

var getGraphDataByKey = new ValidatedMethod({
  name: 'matsMethods.getGraphDataByKey',
  validate: new SimpleSchema({
    resultKey: {
      type: String
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      var ret;
      var key = params.resultKey;

      try {
        var dsResults = DownSampleResults.findOne({
          key: key
        }, {}, {
          disableOplog: true
        });

        if (dsResults !== undefined) {
          ret = dsResults;
        } else {
          ret = matsCache.getResult(key); // {key:someKey, result:resultObject}
        }

        var sizeof = require('object-sizeof');

        console.log("getGraphDataByKey results size is ", sizeof(dsResults));
        return ret;
      } catch (error) {
        throw new Meteor.Error("Error in getGraphDataByKey function:" + key + " : " + error.message);
      }

      return undefined;
    }
  }
}); // administration tool

var getGraphFunctionFileList = new ValidatedMethod({
  name: 'matsMethods.getGraphFunctionFileList',
  validate: new SimpleSchema({}).validator(),
  run: function () {
    if (Meteor.isServer) {}
  }
});
var getLayout = new ValidatedMethod({
  name: 'matsMethods.getLayout',
  validate: new SimpleSchema({
    resultKey: {
      type: String
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      var ret;
      var key = params.resultKey;

      try {
        ret = LayoutStoreCollection.rawCollection().findOne({
          key: key
        });
        return ret;
      } catch (error) {
        throw new Meteor.Error("Error in getLayout function:" + key + " : " + error.message);
      }

      return undefined;
    }
  }
}); // retrieves the saved artifacts (file urls) that were generated by nvBatch for a specific key

var getMvArtifactsByKey = new ValidatedMethod({
  name: 'matsMethods.getMvArtifactsByKey',
  validate: new SimpleSchema({
    key: {
      type: String
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      var ret;
      var key = params.key;

      try {
        ret = matsCache.getResult(key); // {key:someKey, result:resultObject}

        return ret;
      } catch (error) {
        throw new Meteor.Error("Error in getMvArtifactsByKey function:" + key + " : " + error.message);
      }

      return undefined;
    }
  }
});
/*
getPlotResult is used by the graph/text_*_output templates which are used to display textual results.
Because the data isn't being rendered graphically this data is always full size, i.e. NOT downsampled.
That is why it only finds it in the Result file cache, never the DownSampleResult collection.

Because the dataset can be so large ... e.g. megabytes the data retrieval is pagenated. The index is
applied to the underlying datasets.The data gets stripped down and flattened to only contain the data neccesary for text presentation.
A new page index of -1000 means get all the data i.e. no pagenation.
 */

var getPlotResult = new ValidatedMethod({
  name: 'matsMethods.getPlotResult',
  validate: new SimpleSchema({
    resultKey: {
      type: String
    },
    pageIndex: {
      type: Number
    },
    newPageIndex: {
      type: Number
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      var rKey = params.resultKey;
      var pi = params.pageIndex;
      var npi = params.newPageIndex;
      var ret = {};

      try {
        ret = _getFlattenedResultData(rKey, pi, npi);
      } catch (e) {
        console.log(e);
      }

      return ret;
    }
  }
});
var getReleaseNotes = new ValidatedMethod({
  name: 'matsMethods.getReleaseNotes',
  validate: new SimpleSchema({}).validator(),
  run: function () {
    //     return Assets.getText('public/MATSReleaseNotes.html');
    // }
    if (Meteor.isServer) {
      var future = require('fibers/future');

      var fse = require('fs-extra');

      var dFuture = new future();
      var fData;
      console.log(process.env.PWD);
      var file;

      if (process.env.NODE_ENV === "development") {
        file = process.env.PWD + "/../../meteor_packages/mats-common/public/MATSReleaseNotes.html";
      } else {
        file = process.env.PWD + "/programs/server/assets/packages/randyp_mats-common/public/MATSReleaseNotes.html";
      }

      try {
        fse.readFile(file, 'utf8', function (err, data) {
          if (err) {
            fData = err.message;
            dFuture["return"]();
          } else {
            fData = data;
            dFuture["return"]();
          }
        });
      } catch (e) {
        fData = e.message;
        dFuture["return"]();
      }

      dFuture.wait();
      return fData;
    }
  }
}); // administration tool

var getUserAddress = new ValidatedMethod({
  name: 'matsMethods.getUserAddress',
  validate: new SimpleSchema({}).validator(),
  run: function () {
    if (Meteor.isServer) {
      return Meteor.user().services.google.email.toLowerCase();
    }
  }
}); // app utility

var insertColor = new ValidatedMethod({
  name: 'matsMethods.insertColor',
  validate: new SimpleSchema({
    newColor: {
      type: String
    },
    insertAfterIndex: {
      type: Number
    }
  }).validator(),
  run: function (params) {
    if (params.newColor == "rgb(255,255,255)") {
      return false;
    }

    var colorScheme = matsCollections.ColorScheme.findOne({});
    colorScheme.colors.splice(params.insertAfterIndex, 0, newColor);
    matsCollections.update({}, colorScheme);
    return false;
  }
}); // checks to see if the mv artifacts are cached (based on plotspec hash) if not execs an mvbatch and caches the results

var mvBatch = new ValidatedMethod({
  name: 'matsMethods.mvBatch',
  validate: new SimpleSchema({
    plotParams: {
      type: Object,
      blackbox: true
    },
    plotType: {
      type: String
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      var mvbatch = MV_DIRS.HOME + "/bin/mv_batch.sh";
      var plotGraphFunction = matsCollections.PlotGraphFunctions.findOne({
        plotType: params.plotType
      });
      var plotSpecFunction = plotGraphFunction.plotSpecFunction;
      var ret;
      var _appName = matsCollections.appName.findOne({}).app;

      var fse = require('fs-extra'); // generate the key from the params


      var hash = require('object-hash');

      var key = hash(params.plotParams); // generate the server router (Picker) urls according to the hash key.

      var artifacts = {};

      if (process.env.NODE_ENV === "development") {
        artifacts = {
          png: _appName + "/mvplot/" + key,
          xml: _appName + "/mvxml/" + key,
          sql: _appName + "/mvsql/" + key,
          log: _appName + "/mvlog/" + key,
          err: _appName + "/mverr/" + key,
          R: _appName + "/mvscript/" + key,
          data: _appName + "/mvdata/" + key,
          points1: _appName + "/mvpoints1/" + key,
          points2: _appName + "/mvpoints2/" + key
        };
      } else {
        // in production the appName is already at the end of the location.href
        // - which is used to form a url for retrieving the artifact
        artifacts = {
          png: "/mvplot/" + key,
          xml: "/mvxml/" + key,
          sql: "/mvsql/" + key,
          log: "/mvlog/" + key,
          err: "/mverr/" + key,
          R: "/mvscript/" + key,
          data: "/mvdata/" + key,
          points1: "/mvpoints1/" + key,
          points2: "/mvpoints2/" + key
        };
      } // generate the real file paths (these are not exposed to clients)


      var plotSpecFilePath = MV_DIRS.XMLDIR + key + ".xml";
      var pngFilePath = MV_DIRS.PLOTSDIR + key + ".png";
      var sqlFilePath = MV_DIRS.SQLDIR + key + ".sql";
      var logFilePath = MV_DIRS.LOGDIR + key + ".log";
      var errFilePath = MV_DIRS.ERRDIR + key + ".err";
      var scriptFilePath = MV_DIRS.SCRIPTSDIR + key + ".R";
      var dataFilePath = MV_DIRS.DATADIR + key + ".data";
      var points1Path = MV_DIRS.DATADIR + key + ".points1";
      var points2Path = MV_DIRS.DATADIR + key + ".points2"; // NOTE: the plotParams should include an mvPlot:true parameter.
      // This should have been set in the caller. This makes the mv plotSpec cache entry unique from a MATS plot

      if (params.plotParams.mvPlot !== true) {
        throw new Meteor.Error("Error in mvBatch: Not an mv plot request: no plotParams.mvPlot:true");
      }

      if (process.env.NODE_ENV === "development" || params.expireKey) {
        matsCache.expireKey(key); // in development just blow away the files too

        try {
          fse.unlinkSync(plotSpecFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(pngFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(sqlFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(logFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(errFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(scriptFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(dataFilePath);
        } catch (ignore) {}

        try {
          fse.unlinkSync(points1Path);
        } catch (ignore) {}

        try {
          fse.unlinkSync(points2Path);
        } catch (ignore) {}
      } // try to get the key from the cache


      var artifactPaths = matsCache.getResult(key);
      var filesExist = false;

      if (artifactPaths != null) {
        // artifact paths were already cached
        // do the files exist?
        // check for file existence
        var xmlSpecExists = fse.existsSync(plotSpecFilePath);
        var plotExists = fse.existsSync(pngFilePath);
        var scriptExists = fse.existsSync(scriptFilePath);
        var dataExists = fse.existsSync(dataFilePath);
        var sqlExists = fse.existsSync(sqlFilePath);
        var logExists = fse.existsSync(logFilePath);
        filesExist = xmlSpecExists && plotExists && scriptExists && dataExists && sqlExists && logExists;
      } // either the artifacts were cached but the files don't exist or the artifacts were not cached


      if (artifactPaths == null || filesExist === false) {
        // artifactPaths are not in the cache - or the files are not there - need to process plotSpecFunction routine
        // translate the plotparams to a plotSpec and use the key in the plotSpec reference
        global[plotSpecFunction](params.plotParams, key, function (err, plotSpec) {
          // callback
          if (err) {
            console.log(err, "plotspecFunction:", plotSpecFunction);
            throw new Meteor.Error(err + "plotspecFunction: " + plotSpecFunction);
          } else {
            // no error and we have a plot spec
            // see if the artifacts exist as files. They might have been run before and are still hanging around.
            // NOTE: the MV_OUTPUT aren't cached at all (i.e. no expiration) -
            // therefore the expiration of the MATS cache plotSpec and the actual artifacts is sloppy.
            // check for file existence
            var xmlSpecExists = fse.existsSync(plotSpecFilePath);
            var plotExists = fse.existsSync(pngFilePath);
            var scriptExists = fse.existsSync(scriptFilePath);
            var dataExists = fse.existsSync(dataFilePath);
            var sqlExists = fse.existsSync(sqlFilePath);
            var logExists = fse.existsSync(logFilePath);
            var filesExist = xmlSpecExists && plotExists && scriptExists && dataExists && sqlExists && logExists;

            if (!filesExist) {
              var mvBatchCmd = MV_DIRS.HOME + "/bin/mv_batch.sh " + ' ' + plotSpecFilePath;

              var cp = require('child_process'); // save the plotSpec


              fse.outputFileSync(plotSpecFilePath, plotSpec); // exec mv batch with this plotSpec - this should be synchronous

              cp.execSync(mvBatchCmd, function (error, stdout, stderr) {
                if (stderr) {
                  fse.outputFileSync(errFilePath, stderr, function (err) {
                    if (err) {
                      console.log("Error:couldn't write error file" + err); //null
                    }
                  });
                } else {
                  fse.outputFileSync(errFilePath, "no stderr for key: " + key, function (err) {
                    if (err) {
                      console.log("Error:couldn't write error file" + err); //null
                    }
                  });
                }

                if (stdout) {
                  if (stdout.match(/ERROR/)) {
                    fse.outputFileSync(errFilePath, stdout, function (err) {
                      if (err) {
                        console.log("Error:couldn't write log/err file" + err);
                      }
                    });
                  }

                  fse.outputFileSync(logFilePath, stdout, function (err) {
                    if (err) {
                      console.log("Error:couldn't write log file" + err);
                    }
                  });
                  var sqlout = stdout.match(/[\s\S]*#*(SELECT[\s\S]*)Database/) == null ? null : stdout.match(/[\s\S]*#*(SELECT[\s\S]*)Database/)[1];

                  if (sqlout == null) {
                    fse.outputFileSync(sqlFilePath, "no sql statement found in output for key: " + key, function (err) {
                      if (err) {
                        console.log("Error:couldn't write sql file" + err);
                      }
                    });
                  } else {
                    fse.outputFileSync(sqlFilePath, sqlout, function (err) {
                      if (err) {
                        console.log("Error:couldn't write sql file" + err);
                      }
                    });
                  }
                } else {
                  fse.outputFileSync(logFilePath, "No stdout captured for: " + key, function (err) {
                    if (err) {
                      console.log("Error:couldn't write log file" + err);
                    }
                  });
                } // no error - check for the files and cache the spec and filePaths


                var xmlSpecExists = fse.existsSync(plotSpecFilePath);
                var plotExists = fse.existsSync(pngFilePath);
                var scriptExists = fse.existsSync(scriptFilePath);
                var dataExists = fse.existsSync(dataFilePath);
                var sqlExists = fse.existsSync(sqlFilePath);
                var logExists = fse.existsSync(logFilePath);
                var filesExist = xmlSpecExists && plotExists && scriptExists && dataExists && sqlExists && logExists;

                if (!filesExist) {
                  console.error('exec error: expected files do not exist');
                }

                matsCache.storeResult(key, artifacts);
                /*
                    The mvbatch should have saved the plot artifacts according to the following plotSpec elements
                        <data_file>key.data</data_file>
                        <plot_file>key.png</plot_file>
                        <r_file>key.R</r_file>
                    where key is the same as the key for the matsCache
                    The stored artifacts shoulkd be like ...
                        MV_OUTPUT/plots/key.png
                        MV_OUTPUT/xml/key.xml
                        MV_OUTPUT/xml/key.sql
                        MV_OUTPUT/xml/key.log
                        MV_OUTPUT/scripts/key.R
                        MV_OUTPUT/data/key.data
                        MV_OUTPUT/data/key.sum_stat.info
                        MV_OUTPUT/data/key.data.sum_stat
                         MV_OUTPUT/xml/key.xml is the plotSpec
                */

                return {
                  'key': key,
                  'artifacts': artifacts
                };
              }); //ret = {key:key, result:{artifacts:artifacts}}
              // return the key and the artifacts
            } // plotspec did not exist
            else {
                // the files actually already existed but we needed the plotspec
                // so just refresh the cache and return the key right away
                matsCache.storeResult(key, artifacts);
                return {
                  'key': key,
                  'artifacts': artifacts
                };
              }
          }
        });
      } // either artifactPaths == null || filesExist === false
      else {
          // artifacts existed and plotspec existed - refresh the cache
          matsCache.storeResult(key, artifacts);
          return {
            'key': key,
            'artifacts': artifacts
          };
        }

      return {
        'key': key,
        'artifacts': artifacts
      };
    } // if Meteor is Server

  } // run

}); // administration tool

var readFunctionFile = new ValidatedMethod({
  name: 'matsMethods.readFunctionFile',
  validate: new SimpleSchema({}).validator(),
  run: function () {
    if (Meteor.isServer) {
      var future = require('fibers/future');

      var fse = require('fs-extra');

      var path = "";
      var fData;

      if (type == "data") {
        path = "/web/static/dataFunctions/" + file;
        console.log('exporting data file: ' + path);
      } else if (type == "graph") {
        path = "/web/static/displayFunctions/" + file;
        console.log('exporting graph file: ' + path);
      } else {
        return "error - wrong type";
      }

      fse.readFile(path, function (err, data) {
        if (err) throw err;
        fData = data.toString();
        future["return"](fData);
      });
      return future.wait();
    }
  }
}); // refreshes the metadata for the app that's running

var refreshMetaData = new ValidatedMethod({
  name: 'matsMethods.refreshMetaData',
  validate: new SimpleSchema({}).validator(),
  run: function () {
    if (Meteor.isServer) {
      try {
        //console.log("Asked to refresh metadata");
        _checkMetaDataRefresh();
      } catch (e) {
        console.log(e);
        throw new Meteor.Error("Server error: ", e.message);
      }
    }

    return metaDataTableUpdates.find({}).fetch();
  }
}); // administation tool

var removeAuthorization = new ValidatedMethod({
  name: 'matsMethods.removeAuthorization',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),
  run: function (settings) {
    if (Meteor.isServer) {
      var email;
      var roleName;
      var userRoleName = settings.userRoleName;
      var authorizationRole = settings.authorizationRole;
      var newUserEmail = settings.newUserEmail;
      var existingUserEmail = settings.existingUserEmail;

      if (authorizationRole) {
        // existing role - the role roleName - no need to verify as the selection list came from the database
        roleName = authorizationRole;
      } else if (userRoleName) {
        roleName = userRoleName;
      }

      if (existingUserEmail) {
        email = existingUserEmail;
      } else {
        email = newUserEmail;
      } // if user and role remove the role from the user


      if (email && roleName) {
        matsCollections.Authorization.update({
          email: email
        }, {
          $pull: {
            roles: roleName
          }
        });
      } // if user and no role remove the user


      if (email && !roleName) {
        matsCollections.Authorization.remove({
          email: email
        });
      } // if role and no user remove role and remove role from all users


      if (roleName && !email) {
        // remove the role
        matsCollections.Roles.remove({
          name: roleName
        }); // remove the roleName role from all the authorizations

        matsCollections.Authorization.update({
          roles: roleName
        }, {
          $pull: {
            roles: roleName
          }
        }, {
          multi: true
        });
      }

      return false;
    }
  }
}); // app utility

var removeColor = new ValidatedMethod({
  name: 'matsMethods.removeColor',
  validate: new SimpleSchema({
    removeColor: {
      type: String
    }
  }).validator(),
  run: function (removeColor) {
    var colorScheme = matsCollections.ColorScheme.findOne({});
    var removeIndex = colorScheme.colors.indexOf(removeColor);
    colorScheme.colors.splice(removeIndex, 1);
    matsCollections.ColorScheme.update({}, colorScheme);
    return false;
  }
}); // database controls

var removeDatabase = new ValidatedMethod({
  name: 'matsMethods.removeDatabase',
  validate: new SimpleSchema({
    dbName: {
      type: String
    }
  }).validator(),
  run: function (dbName) {
    if (Meteor.isServer) {
      matsCollections.Databases.remove({
        name: dbName
      });
    }
  }
}); // makes sure all of the parameters display appropriate selections in relation to one another

var resetApp = function (appRef) {
  var fse = require('fs-extra');

  var metaDataTableRecords = appRef.appMdr;
  var type = appRef.appType;
  var appName = appRef.app;
  var dep_env = process.env.NODE_ENV; // set some defaults for python processing - these can be overridden

  if (Meteor.settings.private != null && Meteor.settings.private.PYTHON_PATH == null) {
    Meteor.settings.private.PYTHON_PATH = "/usr/bin/python";
  }

  if (Meteor.settings.private != null && Meteor.settings.private.process != null && Meteor.settings.private.process.RUN_ENV != null) {
    switch (Meteor.settings.private.process.RUN_ENV) {
      case "development":
      case "integration":
      case "production":
        dep_env = Meteor.settings.private.process.RUN_ENV;
        break;

      default:
        dep_env = process.env.NODE_ENV;
        break;
    }
  }

  var deployment;
  var deploymentText = Assets.getText('public/deployment/deployment.json');

  if (deploymentText == null) {// equivilent to deploymentText === null || deploymentText === undefined
  }

  deployment = JSON.parse(deploymentText);
  var app = {};

  for (var ai = 0; ai < deployment.length; ai++) {
    var dep = deployment[ai];

    if (dep.deployment_environment == dep_env) {
      app = dep.apps.filter(function (app) {
        return app.app === appName;
      })[0];
    }
  }

  var appVersion = app ? app.version : "unknown";
  var appTitle = app ? app.title : "unknown";
  var buildDate = app ? app.buildDate : "unknown";
  var appType = type ? type : matsTypes.AppTypes.mats;
  matsCollections.appName.upsert({
    app: appName
  }, {
    $set: {
      app: appName
    }
  }); // remember that we updated the metadata tables just now - create metaDataTableUpdates

  /*
      metaDataTableUpdates:
      {
          name: dataBaseName,
          tables: [tableName1, tableName2 ..],
          lastRefreshed : timestamp
      }
   */
  // only create metadata tables if the resetApp was called with a real metaDataTables object

  if (metaDataTableRecords instanceof matsTypes.MetaDataDBRecord) {
    var metaDataTables = metaDataTableRecords.getRecords();

    for (var mdti = 0; mdti < metaDataTables.length; mdti++) {
      var metaDataRef = metaDataTables[mdti];
      metaDataRef.lastRefreshed = moment().format();

      if (metaDataTableUpdates.find({
        name: metaDataRef.name
      }).count() == 0) {
        metaDataTableUpdates.update({
          name: metaDataRef.name
        }, metaDataRef, {
          upsert: true
        });
      }
    }
  } else {
    throw new Meteor.Error("Server error: ", "resetApp: bad pool-database entry");
  }

  matsCollections.Roles.remove({});
  matsDataUtils.doRoles();
  matsCollections.Authorization.remove({});
  matsDataUtils.doAuthorization();
  matsCollections.Credentials.remove({});
  matsDataUtils.doCredentials();
  matsCollections.PlotGraphFunctions.remove({});
  matsCollections.ColorScheme.remove({});
  matsDataUtils.doColorScheme();
  matsCollections.Settings.remove({});
  matsDataUtils.doSettings(appTitle, appVersion, buildDate, appType);
  matsCollections.CurveParams.remove({});
  matsCollections.PlotParams.remove({});
  matsCollections.CurveTextPatterns.remove({}); // app specific routines
  //const asrKeys = Object.keys(appSpecificResetRoutines);

  var asrKeys = appSpecificResetRoutines;

  for (var ai = 0; ai < asrKeys.length; ai++) {
    global.appSpecificResetRoutines[ai]();
  }

  matsCache.clear();
}; // administration tool


var restoreFromFile = new ValidatedMethod({
  name: 'matsMethods.restoreFromFile',
  validate: new SimpleSchema({
    type: {
      type: String
    },
    name: {
      type: String
    },
    data: {
      type: Object,
      blackbox: true
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      console.log("restoring " + params.type + " file " + params.name);
      var path = "";

      if (params.type == "data") {
        path = "/web/static/dataFunctions/" + params.name;
      } else if (params.ype == "graph") {
        path = "/web/static/displayFunctions/" + params.name;
      } else {
        return "error - wrong tyoe";
      }

      console.log('importing ' + params.type + ' file: ' + path);

      var fse = require('fs-extra');

      fse.writeFile(path, params.data.toString(), function (err) {
        if (err) {
          return err.toLocaleString();
        }

        console.log('imported ' + params.type + ' file: ' + path);
      });
    }
  }
}); // administration tool

var restoreFromParameterFile = new ValidatedMethod({
  name: 'matsMethods.restoreFromParameterFile',
  validate: new SimpleSchema({
    name: {
      type: String
    },
    data: {
      type: Object,
      blackbox: true
    }
  }).validator(),
  run: function (params) {
    var data = params.data;

    if (Meteor.isServer) {
      var d = [];

      if (data.CurveParams) {
        matsCollections.CurveParams.remove({});
        d = _.map(data.CurveParams, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.CurveParams.insert(o);
        });
      }

      if (data.PlotParams) {
        matsCollections.PlotParams.remove({});
        d = _.map(data.PlotParams, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.PlotParams.insert(o);
        });
      }

      if (data.PlotGraphFunctions) {
        matsCollections.PlotGraphFunctions.remove({});
        d = _.map(data.PlotGraphFunctions, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.PlotGraphFunctions.insert(o);
        });
      }

      if (data.Settings) {
        matsCollections.Settings.remove({});
        d = _.map(data.Settings, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Settings.insert(o);
        });
      }

      if (data.ColorScheme) {
        matsCollections.ColorScheme.remove({});
        d = _.map(data.ColorScheme, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.ColorScheme.insert(o);
        });
      }

      if (data.Authorization) {
        matsCollections.Authorization.remove({});
        d = _.map(data.Authorization, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Authorization.insert(o);
        });
      }

      if (data.Roles) {
        matsCollections.Roles.remove({});
        d = _.map(data.Roles, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Roles.insert(o);
        });
      }

      if (data.Databases) {
        matsCollections.Databases.remove({});
        d = _.map(data.Databases, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Databases.insert(o);
        });
      }

      if (data.Credentials) {
        matsCollections.Credentials.remove({});
        d = _.map(data.Credentials, function (o) {
          return _.omit(o, '_id');
        });
        d.forEach(function (o) {
          matsCollections.Credentials.insert(o);
        });
      }
    }
  }
});
var saveLayout = new ValidatedMethod({
  name: 'matsMethods.saveLayout',
  validate: new SimpleSchema({
    resultKey: {
      type: String
    },
    layout: {
      type: Object,
      blackbox: true
    },
    curveOpsUpdate: {
      type: Object,
      blackbox: true
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      var key = params.resultKey;
      var layout = params.layout;
      var curveOpsUpdate = params.curveOpsUpdate;

      try {
        LayoutStoreCollection.upsert({
          key: key
        }, {
          $set: {
            "createdAt": new Date(),
            layout: layout,
            curveOpsUpdate: curveOpsUpdate
          }
        });
      } catch (error) {
        throw new Meteor.Error("Error in saveLayout function:" + key + " : " + error.message);
      }
    }
  }
}); //administration tools

var saveSettings = new ValidatedMethod({
  name: 'matsMethods.saveSettings',
  validate: new SimpleSchema({
    saveAs: {
      type: String
    },
    p: {
      type: Object,
      blackbox: true
    },
    permission: {
      type: String
    }
  }).validator(),
  run: function (params) {
    var user = "anonymous";
    matsCollections.CurveSettings.upsert({
      name: params.saveAs
    }, {
      created: moment().format("MM/DD/YYYY HH:mm:ss"),
      name: params.saveAs,
      data: params.p,
      owner: Meteor.userId() == null ? "anonymous" : Meteor.userId(),
      permission: params.permission,
      savedAt: new Date(),
      savedBy: Meteor.user() == null ? "anonymous" : user
    });
  }
}); // administation tool

var setCredentials = new ValidatedMethod({
  name: 'matsMethods.setCredentials',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),
  run: function (settings) {
    if (Meteor.isServer) {
      var name = settings.name;
      var clientId = settings.clientId;
      var clientSecret = settings.clientSecret;
      var clientRefreshToken = settings.clientRefreshToken;
      matsCollections.Credentials.update({}, {
        $set: {
          name: name,
          clientId: clientId,
          clientSecret: clientSecret,
          refresh_token: clientRefreshToken
        }
      });
      return false;
    }
  }
});
var setSettings = new ValidatedMethod({
  name: 'matsMethods.setSettings',
  validate: new SimpleSchema({
    settings: {
      type: Object,
      blackbox: true
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      var settings = params.settings;
      var labelPrefix = settings.labelPrefix;
      var title = settings.title;
      var lineWidth = settings.lineWidth;
      var nullFillString = settings.nullFillString;
      var resetFromCode = settings.resetFromCode;
      matsCollections.Settings.update({}, {
        $set: {
          LabelPrefix: labelPrefix,
          Title: title,
          LineWidth: lineWidth,
          NullFillString: nullFillString,
          resetFromCode: resetFromCode
        }
      });
    }

    return false;
  }
});
/* test methods */

var testGetMetaDataTableUpdates = new ValidatedMethod({
  name: 'matsMethods.testGetMetaDataTableUpdates',
  validate: new SimpleSchema({}).validator(),
  run: function () {
    return metaDataTableUpdates.find({}).fetch();
  }
});
var testGetTables = new ValidatedMethod({
  name: 'matsMethods.testGetTables',
  validate: new SimpleSchema({
    host: {
      type: String
    },
    user: {
      type: String
    },
    password: {
      type: String
    },
    database: {
      type: String
    }
  }).validator(),
  run: function (params) {
    if (Meteor.isServer) {
      var Future = require('fibers/future');

      var queryWrap = Future.wrap(function (callback) {
        var connection = mysql.createConnection({
          host: params.host,
          user: params.user,
          password: params.password,
          database: params.database
        });
        connection.query("show tables;", function (err, result) {
          var tables = result.map(function (a) {
            return a.Tables_in_ruc_ua_sums2;
          });
          return callback(err, tables);
        });
        connection.end(function (err) {
          if (err) {
            console.log("testGetTables cannot end connection");
          }
        });
      });
      return queryWrap().wait();
    }
  }
});
var testSetMetaDataTableUpdatesLastRefreshedBack = new ValidatedMethod({
  name: 'matsMethods.testSetMetaDataTableUpdatesLastRefreshedBack',
  validate: new SimpleSchema({}).validator(),
  run: function () {
    var mtu = metaDataTableUpdates.find({}).fetch();
    var id = mtu[0]._id;
    metaDataTableUpdates.update({
      _id: id
    }, {
      $set: {
        lastRefreshed: 0
      }
    });
    return metaDataTableUpdates.find({}).fetch();
  }
});
module.exportDefault(matsMethods = {
  addSentAddress: addSentAddress,
  applyAuthorization: applyAuthorization,
  applyDatabaseSettings: applyDatabaseSettings,
  deleteSettings: deleteSettings,
  emailImage: emailImage,
  getAuthorizations: getAuthorizations,
  getDataFunctionFileList: getDataFunctionFileList,
  getGraphData: getGraphData,
  getGraphDataByKey: getGraphDataByKey,
  getGraphFunctionFileList: getGraphFunctionFileList,
  getLayout: getLayout,
  getMvArtifactsByKey: getMvArtifactsByKey,
  getPlotResult: getPlotResult,
  getReleaseNotes: getReleaseNotes,
  getUserAddress: getUserAddress,
  insertColor: insertColor,
  mvBatch: mvBatch,
  readFunctionFile: readFunctionFile,
  refreshMetaData: refreshMetaData,
  removeAuthorization: removeAuthorization,
  removeColor: removeColor,
  removeDatabase: removeDatabase,
  resetApp: resetApp,
  restoreFromFile: restoreFromFile,
  restoreFromParameterFile: restoreFromParameterFile,
  saveLayout: saveLayout,
  saveSettings: saveSettings,
  setCredentials: setCredentials,
  setSettings: setSettings,
  testGetMetaDataTableUpdates: testGetMetaDataTableUpdates,
  testGetTables: testGetTables,
  testSetMetaDataTableUpdatesLastRefreshedBack: testSetMetaDataTableUpdatesLastRefreshedBack,
  MV_DIRS: MV_DIRS
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"ui":{"layouts":{"template.notFound.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/ui/layouts/template.notFound.js                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("notFound");
Template["notFound"] = new Template("Template.notFound", (function() {
  var view = this;
  return HTML.Raw("<h1>404</h1>\n    <p>No such page.</p>");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"appBody.html":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/imports/startup/ui/layouts/appBody.html                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("./template.appBody.js", { "*": "*+" });

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.appBody.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/ui/layouts/template.appBody.js                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("AppBody");
Template["AppBody"] = new Template("Template.AppBody", (function() {
  var view = this;
  return HTML.DIV("\n        ", Blaze._TemplateWith(function() {
    return {
      template: Spacebars.call(view.lookup("main"))
    };
  }, function() {
    return Spacebars.include(function() {
      return Spacebars.call(Template.__dynamic);
    });
  }), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"appBody.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/ui/layouts/appBody.js                                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Template;
module.link("meteor/templating", {
  Template: function (v) {
    Template = v;
  }
}, 0);
var FlowRouter;
module.link("meteor/ostrio:flow-router-extra", {
  FlowRouter: function (v) {
    FlowRouter = v;
  }
}, 1);
module.link("./appBody.html");
Template.AppBody.onCreated(function () {
  console.log("in AppBody onCreated");
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}},"client":{"curve_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/curve_util.js                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 2);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 3);
var Info;
module.link("meteor/randyp:mats-common", {
  Info: function (v) {
    Info = v;
  }
}, 4);
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 5);

/*
 global dataset variable - container for graph dataset.
 This (plotResult) is very important. It isn't "var" because it needs to be a meteor global scope.
 The page is rendered whe the graph page comes up, but the data from the data processing callback
 in plotList.js or curveList.js may not have set the global variable
 PlotResult.
 */
//var plotResultData = null; -- this was the global variable for the text output data, but now it is set elsewhere
var graphResult = null; // this is the global variable for the data on the graph

var plot;

var sizeof = function (_1) {
  var _2 = [_1];
  var _3 = 0;

  for (var _4 = 0; _4 < _2.length; _4++) {
    switch ((0, _typeof2.default)(_2[_4])) {
      case "boolean":
        _3 += 4;
        break;

      case "number":
        _3 += 8;
        break;

      case "string":
        _3 += 2 * _2[_4].length;
        break;

      case "object":
        if (Object.prototype.toString.call(_2[_4]) != "[object Array]") {
          for (var _5 in meteorBabelHelpers.sanitizeForInObject(_2[_4])) {
            _3 += 2 * _5.length;
          }
        }

        for (var _5 in meteorBabelHelpers.sanitizeForInObject(_2[_4])) {
          var _6 = false;

          for (var _7 = 0; _7 < _2.length; _7++) {
            if (_2[_7] === _2[_4][_5]) {
              _6 = true;
              break;
            }
          }

          if (!_6) {
            _2.push(_2[_4][_5]);
          }
        }

    }
  }

  return _3;
}; // Retrieves the globally stored plotResultData for the text output and other things.
// Re-sets the plotResultData if the requested page range has changed, or if it has not been previously set.


var getPlotResultData = function () {
  var pageIndex = Session.get("pageIndex");
  var newPageIndex = Session.get("newPageIndex");

  if (plotResultData === undefined || plotResultData === null || Session.get('textRefreshNeeded') === true) {
    setPlotResultData();
  }

  return plotResultData;
}; // Sets the global plotResultData variable for the text output to the requested range from the Results data stored in mongo, via a MatsMethod.


var setPlotResultData = function () {
  var pageIndex = Session.get("pageIndex");
  var newPageIndex = Session.get("newPageIndex");

  if (Session.get('textRefreshNeeded') === true) {
    showSpinner();
    matsMethods.getPlotResult.call({
      resultKey: Session.get("plotResultKey"),
      pageIndex: pageIndex,
      newPageIndex: newPageIndex
    }, function (error, result) {
      if (error !== undefined) {
        setError(new Error("matsMethods.getPlotResult failed : error: " + error));
        Session.set('textRefreshNeeded', false);
      }

      if (result == undefined) {
        plotResultData = undefined;
        Session.set('textRefreshNeeded', false);
        hideSpinner();
        return;
      }

      plotResultData = result;
      Session.set("pageIndex", result.dsiRealPageIndex);
      Session.set("pageTextDirection", result.dsiTextDirection);
      Session.set('textLoaded', new Date());
      console.log("size of plotResultData is ", sizeof(plotResultData));
      Session.set('textRefreshNeeded', false);
      hideSpinner();
    });
  }
}; // resets the global plotResultData variable for the text output to null


var resetPlotResultData = function () {
  plotResultData = null;
  Session.set('textLoaded', new Date());
}; // gets the global graphResult variable, which is the data object for the (possibly downsampled) data on the graph


var getGraphResult = function () {
  if (graphResult === undefined || graphResult === null) {
    return [];
  }

  return graphResult;
}; // sets the global graphResult variable to the (possibly downsampled) data object returned from MatsMethods, in order to make the graph


var setGraphResult = function (result) {
  graphResult = result;
  Session.set('graphDataLoaded', new Date());
  console.log("size of graphResultData is", sizeof(graphResult));
}; // resets the global graphResult variable to null


var resetGraphResult = function () {
  graphResult = null;
  Session.set('graphDataLoaded', new Date());
};
/*
 Curve utilities - used to determine curve labels and colors etc.
 */


var getUsedLabels = function () {
  if (Session.get('UsedLabels') === undefined) {
    return [];
  }

  return Session.get('UsedLabels');
};

var getNextCurveLabel = function () {
  if (Session.get('NextCurveLabel') === undefined) {
    setNextCurveLabel();
  }

  return Session.get('NextCurveLabel');
}; // determine the next curve Label and set it in the session
// private, not exported


var setNextCurveLabel = function () {
  var usedLabels = Session.get('UsedLabels');
  var settings = matsCollections.Settings.findOne({}, {
    fields: {
      LabelPrefix: 1
    }
  });

  if (settings === undefined) {
    return false;
  }

  var labelPrefix = settings.LabelPrefix; // find all the labels that start with our prefix (some could be custom)

  var prefixLabels = _.filter(usedLabels, function (l) {
    return l && l.lastIndexOf(labelPrefix, 0) === 0 && l.match(new RegExp(labelPrefix, 'g')).length == 1;
  });

  var lastUsedLabel = _.last(prefixLabels);

  var lastLabelNumber = -1;

  if (lastUsedLabel !== undefined) {
    var minusPrefix = lastUsedLabel.replace(labelPrefix, '');
    var tryNum = parseInt(minusPrefix, 10);

    if (!isNaN(tryNum)) {
      lastLabelNumber = tryNum;
    }
  }

  var newLabelNumber = lastLabelNumber + 1;
  var nextCurveLabel = labelPrefix + newLabelNumber; // the label might be one from a removed curve so the next ones might be used

  while (_.indexOf(usedLabels, nextCurveLabel) != -1) {
    newLabelNumber++;
    nextCurveLabel = labelPrefix + newLabelNumber;
  }

  Session.set('NextCurveLabel', nextCurveLabel);
}; // determine the next curve color and set it in the session
// private - not exported


var setNextCurveColor = function () {
  var usedColors = Session.get('UsedColors');
  var colors = matsCollections.ColorScheme.findOne({}, {
    fields: {
      colors: 1
    }
  }).colors;
  var lastUsedIndex = -1;

  if (usedColors !== undefined) {
    lastUsedIndex = _.indexOf(colors, _.last(usedColors));
  }

  var nextCurveColor;

  if (lastUsedIndex !== undefined && lastUsedIndex != -1) {
    if (lastUsedIndex < colors.length - 1) {
      var newIndex = lastUsedIndex + 1;
      nextCurveColor = colors[newIndex]; // the color might be one from a removed curve so the next ones might be used

      while (_.indexOf(usedColors, nextCurveColor) != -1) {
        newIndex++;
        nextCurveColor = colors[newIndex];
      }
    } else {
      // out of defaults
      var rint = Math.round(0xffffff * Math.random());
      nextCurveColor = 'rgb(' + (rint >> 16) + ',' + (rint >> 8 & 255) + ',' + (rint & 255) + ')';
    }
  } else {
    nextCurveColor = colors[0];
  }

  Session.set('NextCurveColor', nextCurveColor);
}; // get the next curve color from the session
// private - not exported


var getNextCurveColor = function () {
  if (Session.get('NextCurveColor') === undefined) {
    setNextCurveColor();
  }

  return Session.get('NextCurveColor');
}; // clear a used label and set the nextCurveLabel to the one just cleared


var clearUsedLabel = function (label) {
  var usedLabels = Session.get('UsedLabels');

  var newUsedLabels = _.reject(usedLabels, function (l) {
    return l == label;
  });

  Session.set('UsedLabels', newUsedLabels);
  Session.set('NextCurveLabel', label);
}; // clear a used color and set the nextCurveColor to the one just cleared


var clearUsedColor = function (color) {
  var usedColors = Session.get('UsedColors');

  var newUsedColors = _.reject(usedColors, function (c) {
    return c == color;
  });

  Session.set('UsedColors', newUsedColors);
  Session.set('NextCurveColor', color);
}; // clear all the used colors and labels and set the nextCurve values
// to the first in the scheme and the first of the labelPrefix.
// This is used by the removeAll


var clearAllUsed = function () {
  Session.set('UsedColors', undefined);
  var colors = matsCollections.ColorScheme.findOne({}, {
    fields: {
      colors: 1
    }
  }).colors;
  Session.set('NextCurveColor', colors[0]);
  Session.set('UsedLabels', undefined);
  var labelPrefix = matsCollections.Settings.findOne({}, {
    fields: {
      LabelPrefix: 1
    }
  }).LabelPrefix;
  Session.set('NextCurveLabel', labelPrefix + 0);
  Session.set('Curves', []);
}; // use curves in session to determine which defaults are already used
// and to set the usedColors in the session
// this is used on restore settings to set up the usedColors
// private - not exported
//setUsedDefaults = function() {


var setUsedColors = function () {
  var curves = Session.get('Curves');
  var usedColors = [];

  for (var i = 0; i < curves.length; i++) {
    var color = curves[i].color;
    usedColors.push(color);
  }

  Session.set('UsedColors', usedColors);
  setNextCurveColor();
}; // private - not exported


var setUsedLabels = function () {
  var curves = Session.get('Curves');
  var usedLabels = [];

  for (var i = 0; i < curves.length; i++) {
    var label = curves[i].label;
    usedLabels.push(label);
  }

  Session.set('UsedLabels', usedLabels);
  setNextCurveLabel();
};

var setUsedColorsAndLabels = function () {
  setUsedColors();
  setUsedLabels();
};

var resetScatterApply = function () {
  if (matsPlotUtils.getPlotType() == matsTypes.PlotTypes.scatter2d) {
    Session.set('axisCurveIcon', 'fa-asterisk');
    Session.set('xaxisCurveText', 'XAXIS NOT YET APPLIED');
    Session.set('yaxisCurveText', 'YAXIS NOT YET APPLIED');
    Session.set('xaxisCurveColor', 'red');
    Session.set('yaxisCurveColor', 'red');

    if (document.getElementById('Fit-Type-radioGroup-none') !== null) {
      document.getElementById('Fit-Type-radioGroup-none').checked = true;
    }
  }
}; // add the difference curves
// private - not exported


var addDiffs = function () {
  var curves = Session.get('Curves');
  var newCurves = Session.get('Curves'); // diffs is checked -- have to add diff curves

  var curvesLength = curves.length;

  if (curvesLength <= 1) {
    setInfo("You cannot difference less than two curves!");
    return false;
  }

  switch (matsPlotUtils.getPlotFormat()) {
    case matsTypes.PlotFormats.matching:
      var baseIndex = 0; // This will probably not default to curve 0 in the future

      for (var ci = 1; ci < curves.length; ci++) {
        var newCurve = $.extend(true, {}, curves[ci]);
        newCurve.label = curves[ci].label + "-" + curves[0].label;
        newCurve.color = getNextCurveColor();
        newCurve.diffFrom = [ci, baseIndex]; // do not create extra diff if it already exists

        if (_.findWhere(curves, {
          label: newCurve.label
        }) === undefined) {
          newCurves.push(newCurve);
          Session.set('Curves', newCurves);
          setUsedColorsAndLabels();
        }
      }

      break;

    case matsTypes.PlotFormats.pairwise:
      var baseIndex = 0; // This will probably not default to curve 0 in the future

      for (var ci = 1; ci < curves.length; ci++) {
        if (ci % 2 != 0) {
          // only diff on odd curves against previous curve
          var base_index = ci - 1;
          var newCurve = $.extend(true, {}, curves[ci]);
          newCurve.label = curves[ci].label + "-" + curves[base_index].label;
          newCurve.color = getNextCurveColor();
          newCurve.diffFrom = [ci, baseIndex]; // do not create extra diff if it already exists

          if (_.findWhere(curves, {
            label: newCurve.label
          }) === undefined) {
            newCurves.push(newCurve);
            Session.set('Curves', newCurves);
            setUsedColorsAndLabels();
          }
        }
      }

      break;

    case matsTypes.PlotFormats.absolute:
      var baseIndex = 0; // This will probably not default to curve 0 in the future

      for (var ci = 1; ci < curves.length; ci++) {
        var newCurve = $.extend(true, {}, curves[ci]);
        newCurve.label = curves[ci].label + "-" + curves[0].label;
        newCurve.color = getNextCurveColor();
        newCurve.diffFrom = [ci, baseIndex]; // do not create extra diff if it already exists

        if (_.findWhere(curves, {
          label: newCurve.label
        }) === undefined) {
          newCurves.push(newCurve);
          Session.set('Curves', newCurves);
          setUsedColorsAndLabels();
        }
      }

      break;
  }
}; // remove difference curves
// private - not exported


var removeDiffs = function () {
  var curves = Session.get('Curves');

  var newCurves = _.reject(curves, function (curve) {
    return curve.diffFrom != null;
  });

  Session.set('Curves', newCurves);
  setUsedColorsAndLabels();
}; // resolve the difference curves
// (used after adding or removing a curve while the show diffs box is checked)


var checkDiffs = function () {
  var curves = Session.get('Curves');

  if (matsPlotUtils.getPlotType() == matsTypes.PlotTypes.scatter2d) {
    // scatter plots have no concept of difference curves.
    return;
  }

  var plotFormat = matsPlotUtils.getPlotFormat();

  if (curves.length > 1) {
    if (plotFormat !== matsTypes.PlotFormats.none) {
      removeDiffs();
      addDiffs();
    } else {
      removeDiffs();
    }
  }
}; // method to display the appropriate selectors for a timeseries curve


var showTimeseriesFace = function () {
  // move dates selector to plot parameters - one date range for all curves
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.timeSeries).checked === true) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'block',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.timeSeries); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a profile curve


var showProfileFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.profile).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'none',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.profile); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a dieoff curve


var showDieOffFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.dieoff).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'none',
      'dieoff-type': 'block',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    } // reset the value for dieoff-type, so that the checkHideOther routine will work


    var param = matsParamUtils.getParameterForName('dieoff-type');
    matsParamUtils.setValueTextForParamName(param.name, param.default);
    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.dieoff); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a threshold curve


var showThresholdFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.threshold).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'none',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.threshold); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a valid time curve


var showValidTimeFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.validtime).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'none',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.validtime); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a daily model cycle curve


var showDailyModelCycleFace = function () {
  // move dates selector to plot parameters - one date range for all curves
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.dailyModelCycle).checked === true) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'none',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'none',
      'utc-cycle-start': 'block',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.dailyModelCycle); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a reliability curve


var showReliabilityFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.reliability).checked === true) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'block',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'none',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.reliability); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a map


var showMapFace = function () {
  // move dates selector to plot parameters - one date range for all curves
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.map).checked === true) {
    var faceOptions;
    faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'none',
      'statistic': 'none',
      'threshold': 'none',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'none',
      'sites': 'block',
      'sitesMap': 'block',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.map); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a histogram


var showHistogramFace = function () {
  // move dates selector to curve parameters - one date range for each curve
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.histogram).checked === true) {
    var faceOptions = {
      'curve-dates': 'block',
      'dates': 'none',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'block',
      'histogram-yaxis-controls': 'block',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    Session.set('plotType', matsTypes.PlotTypes.histogram); // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a contour plot


var showContourFace = function () {
  // move dates selector to plot parameters - one date range for all curves
  var isContour = document.getElementById('plot-type-' + matsTypes.PlotTypes.contour) !== null && document.getElementById('plot-type-' + matsTypes.PlotTypes.contour).checked === true;
  var isContourDiff = document.getElementById('plot-type-' + matsTypes.PlotTypes.contourDiff) !== null && document.getElementById('plot-type-' + matsTypes.PlotTypes.contourDiff).checked === true;

  if (isContour || isContourDiff) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'block',
      'y-axis-parameter': 'block'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    } // //need to be consistent with the x and y axis 'hideOtherFor' settings
    // const xAxisVal = matsParamUtils.getValueForParamName('x-axis-parameter');
    // const yAxisVal = matsParamUtils.getValueForParamName('y-axis-parameter');
    // if (xAxisVal === 'Fcst lead time' || yAxisVal === 'Fcst lead time') {
    //     elem = document.getElementById('forecast-length-item');
    //     if (elem && elem.style) {
    //         elem.style.display = 'none';
    //     }
    // }
    // if (xAxisVal === 'Valid UTC hour' || yAxisVal === 'Valid UTC hour') {
    //     elem = document.getElementById('valid-time-item');
    //     if (elem && elem.style) {
    //         elem.style.display = 'none';
    //     }
    // }
    // if (xAxisVal === 'Pressure level' || yAxisVal === 'Pressure level') {
    //     elem = document.getElementById('pres-level-item');
    //     if (elem && elem.style) {
    //         elem.style.display = 'none';
    //     }
    // }


    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "none";
    }

    if (isContour) {
      Session.set('plotType', matsTypes.PlotTypes.contour);
    } else {
      Session.set('plotType', matsTypes.PlotTypes.contourDiff);
    } // matsParamUtils.setAllParamsToDefault();


    Session.set('lastUpdate', Date.now());
  }
}; // method to display the appropriate selectors for a scatter plot


var showScatterFace = function () {
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.scatter2d).checked === true) {
    var faceOptions = {
      'curve-dates': 'none',
      'dates': 'block',
      'region': 'block',
      'statistic': 'block',
      'threshold': 'block',
      'pres-level': 'block',
      'forecast-length': 'block',
      'dieoff-type': 'none',
      'average': 'none',
      'valid-time': 'block',
      'utc-cycle-start': 'none',
      'histogram-bin-controls': 'none',
      'histogram-yaxis-controls': 'none',
      'bin-number': 'none',
      'bin-bounds': 'none',
      'truth': 'block',
      'sites': 'none',
      'sitesMap': 'none',
      'x-axis-parameter': 'none',
      'y-axis-parameter': 'none'
    };
    var faceSelectors = Object.keys(faceOptions);
    var elem;

    for (var fidx = 0; fidx < faceSelectors.length; fidx++) {
      elem = document.getElementById(faceSelectors[fidx] + '-item');

      if (elem && elem.style) {
        elem.style.display = faceOptions[faceSelectors[fidx]];
      }
    }

    elem = document.getElementById(matsTypes.PlotTypes.scatter2d);

    if (elem && elem.style) {
      elem.style.display = "block";
    }

    Session.set('plotType', matsTypes.PlotTypes.scatter2d);
    Session.set('lastUpdate', Date.now()); // force curveParams to re-render
    // matsParamUtils.setAllParamsToDefault();

    Session.set('lastUpdate', Date.now());
  }
}; // this is no longer used, but it was once employed by the text output routines to calculate the stats for the entire curve


var get_err = function (sVals, sSecs) {
  /* THIS IS DIFFERENT FROM THE ONE IN DATA_UTILS,
     This one does not throw away outliers and it captures minVal and maxVal
     refer to perl error_library.pl sub  get_stats
      to see the perl implementation of these statics calculations.
      These should match exactly those, except that they are processed in reverse order.
   */
  var subVals = [];
  var subSecs = [];
  var sVals = sVals;
  var sSecs = sSecs;
  var n = sVals.length;
  var n_good = 0;
  var sum_d = 0;
  var sum2_d = 0;
  var error = "";
  var i;

  for (i = 0; i < n; i++) {
    if (sVals[i] !== null) {
      n_good = n_good + 1;
      sum_d = sum_d + sVals[i];
      sum2_d = sum2_d + sVals[i] * sVals[i];
      subVals.push(sVals[i]);
      subSecs.push(sSecs[i]);
    }
  }

  var d_mean = sum_d / n_good;
  var sd2 = sum2_d / n_good - d_mean * d_mean;
  var sd = sd2 > 0 ? Math.sqrt(sd2) : sd2;
  var sd_limit = 3 * sd; //console.log("see error_library.pl l208 These are processed in reverse order to the perl code -  \nmean is " + d_mean + " sd_limit is +/- " + sd_limit + " n_good is " + n_good + " sum_d is" + sum_d + " sum2_d is " + sum2_d);
  // find minimum delta_time, if any value missing, set null

  var last_secs = Number.MIN_VALUE;
  var minDelta = Number.MAX_VALUE;
  var minSecs = Number.MAX_VALUE;
  var max_secs = Number.MIN_VALUE;
  var minVal = Number.MAX_VALUE;
  var maxVal = Number.MIN_VALUE;

  for (i = 0; i < subSecs.length; i++) {
    var secs = subSecs[i];
    var delta = Math.abs(secs - last_secs);

    if (delta < minDelta) {
      minDelta = delta;
    }

    if (secs < minSecs) {
      minSecs = secs;
    }

    if (secs > max_secs) {
      max_secs = secs;
    }

    last_secs = secs;
  }

  var data_wg = [];
  var n_gaps = 0;
  n_good = 0;
  var sum = 0;
  var sum2 = 0;
  var loopTime = minSecs;

  if (minDelta < 0) {
    error = "Invalid time interval - minDelta: " + minDelta;
  } // remove data more than $sd_limit from mean


  for (i = 0; i < subVals.length; i++) {
    minVal = minVal < subVals[i] ? minVal : subVals[i];
    maxVal = maxVal > subVals[i] ? maxVal : subVals[i];
    n_good++;
  } //console.log("new mean after throwing away outliers is " + sd + " n_good is " + n_good + " sum is " + sum  + " sum2 is " + sum2 + " d_mean is " + d_mean);
  // look for gaps.... per Bill, we only need one gap per series of gaps...


  var lastSecond = Number.MIN_VALUE;

  for (i = 0; i < subSecs.length; i++) {
    var sec = subSecs[i];

    if (lastSecond >= 0) {
      if (sec - lastSecond > minDelta) {
        // insert a gap
        data_wg.push(null);
        n_gaps++;
      }
    }

    lastSecond = sec;
    data_wg.push(subVals[i]);
  } //console.log ("n_gaps: " + n_gaps +  " time gaps in subseries");
  //from http://www.itl.nist.gov/div898/handbook/eda/section3/eda35c.htm


  var r = [];

  for (var lag = 0; lag <= 1; lag++) {
    r[lag] = 0;
    var n_in_lag = 0;

    for (var t = 0; t < n + n_gaps - lag; t++) {
      if (data_wg[t] != null && data_wg[t + lag] != null) {
        r[lag] += +(data_wg[t] - d_mean) * (data_wg[t + lag] - d_mean);
        n_in_lag++;
      }
    }

    if (n_in_lag > 0 && sd > 0) {
      r[lag] /= n_in_lag * sd * sd;
    } else {
      r[lag] = null;
    } //console.log('r for lag ' + lag + " is " + r[lag] + " n_in_lag is " + n_in_lag + " n_good is " + n_good);

  } // Betsy Weatherhead's correction, based on lag 1


  if (r[1] >= 1) {
    r[1] = .99999;
  }

  var betsy = Math.sqrt((n_good - 1) * (1 - r[1]));
  var stde_betsy;

  if (betsy != 0) {
    stde_betsy = sd / betsy;
  } else {
    stde_betsy = null;
  }

  var stats = {
    d_mean: d_mean,
    stde_betsy: stde_betsy,
    sd: sd,
    n_good: n_good,
    lag1: r[1],
    min: minSecs,
    max: max_secs,
    minVal: minVal,
    maxVal: maxVal,
    sum: sum_d
  }; //console.log("stats are " + JSON.stringify(stats));
  // stde_betsy is standard error with auto correlation
  //console.log("---------\n\n");

  return stats;
};

var showSpinner = function () {
  if (document.getElementById("spinner")) {
    document.getElementById("spinner").style.display = "block";
  }
};

var hideSpinner = function () {
  if (document.getElementById("spinner")) {
    document.getElementById("spinner").style.display = "none";
  }
};

module.exportDefault(matsCurveUtils = {
  resetScatterApply: resetScatterApply,
  getUsedLabels: getUsedLabels,
  getNextCurveLabel: getNextCurveLabel,
  getNextCurveColor: getNextCurveColor,
  clearAllUsed: clearAllUsed,
  clearUsedLabel: clearUsedLabel,
  clearUsedColor: clearUsedColor,
  setUsedLabels: setUsedLabels,
  setUsedColorsAndLabels: setUsedColorsAndLabels,
  addDiffs: addDiffs,
  removeDiffs: removeDiffs,
  checkDiffs: checkDiffs,
  showScatterFace: showScatterFace,
  showTimeseriesFace: showTimeseriesFace,
  showProfileFace: showProfileFace,
  showDieOffFace: showDieOffFace,
  showThresholdFace: showThresholdFace,
  showValidTimeFace: showValidTimeFace,
  showDailyModelCycleFace: showDailyModelCycleFace,
  showReliabilityFace: showReliabilityFace,
  showMapFace: showMapFace,
  showHistogramFace: showHistogramFace,
  showContourFace: showContourFace,
  get_err: get_err,
  getPlotResultData: getPlotResultData,
  //setPlotResultData: setPlotResultData,
  resetPlotResultData: resetPlotResultData,
  getGraphResult: getGraphResult,
  setGraphResult: setGraphResult,
  resetGraphResult: resetGraphResult,
  showSpinner: showSpinner,
  hideSpinner: hideSpinner
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"graph_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/graph_util.js                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);

// set the label for the hide show buttons (NO DATA) for the initial time here
var setNoDataLabels = function (dataset) {
  for (var c = 0; c < dataset.length; c++) {
    if (dataset[c].x.length === 0) {
      Session.set(dataset[c].curveId + "hideButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["color"] = "white";
      }

      Session.set(dataset[c].curveId + "pointsButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-points')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["color"] = "white";
      }

      Session.set(dataset[c].curveId + "errorBarButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["color"] = "white";
      }

      Session.set(dataset[c].curveId + "barChartButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-bars')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["color"] = "white";
      }

      Session.set(dataset[c].curveId + "annotateButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["color"] = "white";
      }
    } else {
      Session.set(dataset[c].curveId + "hideButtonText", 'hide curve');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide').value = 'hide curve';
        document.getElementById(dataset[c].curveId + '-curve-show-hide').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide').style["color"] = dataset[c].marker.color;
      }

      Session.set(dataset[c].curveId + "pointsButtonText", 'hide points');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-points')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').value = 'hide points';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-points').style["color"] = dataset[c].marker.color;
      }

      Session.set(dataset[c].curveId + "errorBarButtonText", 'hide error bars');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').value = 'hide error bars';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-errorbars').style["color"] = dataset[c].marker.color;
      }

      Session.set(dataset[c].curveId + "barChartButtonText", 'hide bars');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-bars')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').value = 'hide bars';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-bars').style["color"] = dataset[c].marker.color;
      }

      Session.set(dataset[c].curveId + "annotateButtonText", 'hide annotation');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').value = 'hide annotation';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["border-color"] = dataset[c].marker.color;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-annotate').style["color"] = dataset[c].marker.color;
      }
    }
  }
};

var setNoDataLabelsMap = function (dataset) {
  for (var c = 0; c < dataset.length; c++) {
    if (dataset[c].lat.length === 0) {
      Session.set(dataset[c].curveId + "heatMapButtonText", 'NO DATA');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').value = 'NO DATA';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').disabled = true;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["background-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["border-color"] = "black";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["color"] = "white";
      }
    } else {
      Session.set(dataset[c].curveId + "heatMapButtonText", 'show heat map');

      if (document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap')) {
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').value = 'show heat map';
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').disabled = false;
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["background-color"] = "white";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["border-color"] = "red";
        document.getElementById(dataset[c].curveId + '-curve-show-hide-heatmap').style["color"] = "red";
      }
    }
  }
}; // plot width helper used in multiple places


var width = function (plotType) {
  switch (plotType) {
    case matsTypes.PlotTypes.profile:
    case matsTypes.PlotTypes.scatter2d:
      // set the width square
      return squareWidthHeight();
      break;

    case matsTypes.PlotTypes.timeSeries:
    case matsTypes.PlotTypes.dailyModelCycle:
    case matsTypes.PlotTypes.dieoff:
    case matsTypes.PlotTypes.threshold:
    case matsTypes.PlotTypes.validtime:
    case matsTypes.PlotTypes.reliability:
    case matsTypes.PlotTypes.map:
    case matsTypes.PlotTypes.histogram:
    case matsTypes.PlotTypes.contour:
    case matsTypes.PlotTypes.contourDiff:
    default:
      // set the width wide
      return rectangleWidth();
      break;
  }
}; // plot height helper used in multiple places


var height = function (plotType) {
  switch (plotType) {
    case matsTypes.PlotTypes.profile:
    case matsTypes.PlotTypes.scatter2d:
      // set the height square
      return squareWidthHeight();
      break;

    case matsTypes.PlotTypes.timeSeries:
    case matsTypes.PlotTypes.dailyModelCycle:
    case matsTypes.PlotTypes.dieoff:
    case matsTypes.PlotTypes.threshold:
    case matsTypes.PlotTypes.validtime:
    case matsTypes.PlotTypes.reliability:
    case matsTypes.PlotTypes.map:
    case matsTypes.PlotTypes.histogram:
    case matsTypes.PlotTypes.contour:
    case matsTypes.PlotTypes.contourDiff:
    default:
      // set the height wide
      return rectangleHeight();
      break;
  }
};

var standAloneWidth = function () {
  var vpw = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);
  return (.9 * vpw).toString() + "px";
};

var standAloneHeight = function () {
  var vph = Math.min(document.documentElement.clientHeight, window.innerHeight || 0);
  return (.825 * vph).toString() + "px";
};

var squareWidthHeight = function () {
  var vpw = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);
  var vph = Math.min(document.documentElement.clientHeight, window.innerHeight || 0);
  var min = Math.min(vpw, vph);

  if (min < 400) {
    return (.9 * min).toString() + "px";
  } else {
    return (.7 * min).toString() + "px";
  }
};

var rectangleWidth = function () {
  var vpw = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);

  if (vpw < 400) {
    return (.9 * vpw).toString() + "px";
  } else {
    return (.9 * vpw).toString() + "px";
  }
};

var rectangleHeight = function () {
  var vph = Math.min(document.documentElement.clientHeight, window.innerHeight || 0);

  if (vph < 400) {
    return (.8 * vph).toString() + "px";
  } else {
    return (.7 * vph).toString() + "px";
  }
};

var resizeGraph = function (plotType) {
  document.getElementById('placeholder').style.width = width(plotType);
  document.getElementById('placeholder').style.height = height(plotType);
}; // helper to bring up the text page


var setTextView = function (plotType) {
  //shows text page and proper text output, hides everything else
  document.getElementById('placeholder').style.width = width(plotType);
  document.getElementById('placeholder').style.height = height(plotType);
  document.getElementById("text-page-button-group").style.display = "block";
  document.getElementById("plot-page-button-group").style.display = "none";
  document.getElementById("curves").style.display = "none";
  document.getElementById("graphView").style.display = "none";
  document.getElementById("textView").style.display = "block";
  document.getElementById('plot-control-button-group').style.display = "none";
}; // helper to bring up the graph page


var setGraphView = function (plotType) {
  document.getElementById('placeholder').style.width = width(plotType);
  document.getElementById('placeholder').style.height = height(plotType); //shows graph page, hides everything else

  document.getElementById('graph-container').style.display = 'block';
  document.getElementById('plotType').style.display = 'none';
  document.getElementById('paramList').style.display = 'none';
  document.getElementById('plotList').style.display = 'none';
  document.getElementById('curveList').style.display = 'none';

  if (document.getElementById("plotTypeContainer")) {
    document.getElementById("plotTypeContainer").style.display = "none";
  }

  if (document.getElementById("scatter2d")) {
    document.getElementById("scatter2d").style.display = "none";
  }

  if (document.getElementById("scatterView")) {
    document.getElementById("scatterView").style.display = "none";
  }

  document.getElementById("text-page-button-group").style.display = "none";
  document.getElementById("plot-page-button-group").style.display = "block";
  document.getElementById("curves").style.display = "block";
  document.getElementById("graphView").style.display = "block";
  document.getElementById("textView").style.display = "none";

  if (Session.get('plotType') !== matsTypes.PlotTypes.map) {
    document.getElementById('plot-control-button-group').style.display = "block";
  } else {
    document.getElementById('plot-control-button-group').style.display = "none";
  }
}; // helper to bring up the graph page in a pop-up window


var standAloneSetGraphView = function () {
  //shows graph page, hides everything else
  document.getElementById('placeholder').style.width = standAloneWidth();
  document.getElementById('placeholder').style.height = standAloneHeight();
  document.getElementById('graph-container').style.display = 'block';
  document.getElementById("curves").style.display = "block";
  document.getElementById("graphView").style.display = "block";
}; // helper to bring up the main selector page


var setDefaultView = function () {
  // show elements of the main page
  if (document.getElementById('paramList')) {
    document.getElementById('paramList').style.display = 'block';
  }

  if (document.getElementById('plotList')) {
    document.getElementById('plotList').style.display = 'block';
  }

  if (document.getElementById('curveList')) {
    document.getElementById('curveList').style.display = 'block';
  }

  if (document.getElementById("plotTypeContainer")) {
    document.getElementById("plotTypeContainer").style.display = "block";
  }

  if (document.getElementById("scatterView")) {
    document.getElementById("scatterView").style.display = "block";
  }

  if (document.getElementById("scatter2d")) {
    document.getElementById("scatter2d").style.display = "block";
  } // hide graph page


  if (document.getElementById('graph-container')) {
    document.getElementById('graph-container').style.display = 'none';
  }

  document.getElementById("plot-page-button-group").style.display = "block";
  document.getElementById('plot-control-button-group').style.display = "block"; // hide text page

  document.getElementById("textView").style.display = "none";
};

var downloadFile = function (fileURL, fileName) {
  // for non-IE
  if (!window.ActiveXObject) {
    var save = document.createElement('a');
    save.href = fileURL;
    save.target = '_blank';
    var filename = fileURL.substring(fileURL.lastIndexOf('/') + 1);
    save.download = fileName || filename;

    if (navigator.userAgent.toLowerCase().match(/(ipad|iphone|safari)/) && navigator.userAgent.search("Chrome") < 0) {
      document.location = save.href; // window event not working here
    } else {
      var evt = new MouseEvent('click', {
        'view': window,
        'bubbles': true,
        'cancelable': false
      });
      save.dispatchEvent(evt);
      (window.URL || window.webkitURL).revokeObjectURL(save.href);
    }
  } // for IE < 11
  else if (!!window.ActiveXObject && document.execCommand) {
      var _window = window.open(fileURL, '_blank');

      _window.document.close();

      _window.document.execCommand('SaveAs', true, fileName || fileURL);

      _window.close();
    }
};

module.exportDefault(matsGraphUtils = {
  setNoDataLabels: setNoDataLabels,
  setNoDataLabelsMap: setNoDataLabelsMap,
  width: width,
  height: height,
  standAloneWidth: standAloneWidth,
  standAloneHeight: standAloneHeight,
  resizeGraph: resizeGraph,
  setTextView: setTextView,
  setGraphView: setGraphView,
  standAloneSetGraphView: standAloneSetGraphView,
  setDefaultView: setDefaultView,
  downloadFile: downloadFile
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"select_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/select_util.js                                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections, matsMethods, matsParamUtils, matsPlotUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  },
  matsMethods: function (v) {
    matsMethods = v;
  },
  matsParamUtils: function (v) {
    matsParamUtils = v;
  },
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  },
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);

// method to refresh the peers of the current selector
var refreshPeer = function (event, param) {
  try {
    var peerName = param.peerName;

    if (peerName !== undefined) {
      // refresh the peer
      var targetParam = matsParamUtils.getParameterForName(peerName);
      var targetId = targetParam.name + '-' + targetParam.type;
      var targetElem = document.getElementById(targetId);
      var refreshMapEvent = new CustomEvent("refresh", {
        detail: {
          refElement: null
        }
      });
      targetElem.dispatchEvent(refreshMapEvent);
    }

    refreshDependents(event, param);
  } catch (e) {
    e.message = "INFO: Error in select.js refreshPeer: " + e.message;
    setInfo(e.message);
  }
}; // method to refresh the dependents of the current selector


var refreshDependents = function (event, param) {
  try {
    var dependentNames = param.dependentNames;

    if (dependentNames && Object.prototype.toString.call(dependentNames) === '[object Array]' && dependentNames.length > 0) {
      // refresh the dependents
      var selectAllbool = false;

      for (var i = 0; i < dependentNames.length; i++) {
        var name = dependentNames[i];
        var targetParam = matsParamUtils.getParameterForName(name);
        var targetId;

        if (targetParam.type === matsTypes.InputTypes.dateRange) {
          targetId = "element-" + targetParam.name;
        } else {
          targetId = targetParam.name + '-' + targetParam.type;
        }

        var targetElem = document.getElementById(targetId);

        if (document.getElementById('selectAll')) {
          selectAllbool = document.getElementById('selectAll').checked;
        }

        try {
          targetElem.dispatchEvent(new CustomEvent("refresh"));
        } catch (re) {
          re.message = "INFO: refreshDependents of: " + param.name + " dependent: " + targetParam.name + " - error: " + re.message;
          setInfo(re.message);
        }

        var elements = targetElem.options;
        var select = true;

        if (targetElem.multiple && elements !== undefined && elements.length > 0) {
          if (selectAllbool) {
            for (var i1 = 0; i1 < elements.length; i1++) {
              elements[i1].selected = select;
            }

            matsParamUtils.setValueTextForParamName(name, "");
          } else {
            var previously_selected = Session.get('selected');

            for (var i2 = 0; i2 < elements.length; i2++) {
              if (_.indexOf(previously_selected, elements[i2].text) != -1) {
                elements[i2].selected = select;
              }
            }
          }
        }
      }
    }
  } catch (e) {
    e.message = "INFO: Error in select.js refreshDependents: " + e.message;
    setInfo(e.message);
  }
}; // check for enable controlled - This select might have control of another selector


var checkDisableOther = function (param, firstRender) {
  try {
    if (param.disableOtherFor !== undefined) {
      // this param controls the enable/disable properties of at least one other param.
      // Use the options to enable disable that param.
      var controlledSelectors = Object.keys(param.disableOtherFor);

      for (var i = 0; i < controlledSelectors.length; i++) {
        var elem = matsParamUtils.getInputElementForParamName(param.name);

        if (!elem) {
          return;
        }

        var selectedOptions = elem.selectedOptions;
        var selectedText = selectedOptions && selectedOptions.length > 0 ? selectedOptions[0].text : "";

        if (firstRender == true && param.default == param.hideOtherFor[controlledSelectors[i]] || param.disableOtherFor[controlledSelectors[i]] === matsTypes.InputTypes.unused && selectedText === "" || $.inArray(selectedText, param.disableOtherFor[controlledSelectors[i]]) !== -1) {
          matsParamUtils.getInputElementForParamName(controlledSelectors[i]).disabled = true;
          matsParamUtils.setValueTextForParamName(controlledSelectors[i], matsTypes.InputTypes.unused);
        } else {
          matsParamUtils.getInputElementForParamName(controlledSelectors[i]).disabled = false;
        }
      }
    }
  } catch (e) {
    e.message = "INFO: Error in select.js checkDisableOther: " + e.message;
    setInfo(e.message);
  }
}; // check for hide controlled - This select might have control of another selector's visibility


var checkHideOther = function (param, firstRender) {
  try {
    if (param.hideOtherFor !== undefined) {
      // this param controls the visibility of at least one other param.
      var controlledSelectors = Object.keys(param.hideOtherFor);

      for (var i = 0; i < controlledSelectors.length; i++) {
        var elem = matsParamUtils.getInputElementForParamName(param.name);

        if (!elem) {
          return;
        }

        var selectedOptions = elem.selectedOptions;
        var selectedText = selectedOptions && selectedOptions.length > 0 ? selectedOptions[0].text : "";
        var otherInputElement = matsParamUtils.getInputElementForParamName(controlledSelectors[i]);
        var selectorControlElem;

        if (firstRender == true && param.default == param.hideOtherFor[controlledSelectors[i]] || param.hideOtherFor[controlledSelectors[i]] === matsTypes.InputTypes.unused && selectedText === "" || $.inArray(selectedText, param.hideOtherFor[controlledSelectors[i]]) !== -1) {
          selectorControlElem = document.getElementById(controlledSelectors[i] + '-item');

          if (selectorControlElem && selectorControlElem.style) {
            selectorControlElem.style.display = "none";
          }

          matsParamUtils.setValueTextForParamName(controlledSelectors[i], matsTypes.InputTypes.unused);
        } else {
          selectorControlElem = document.getElementById(controlledSelectors[i] + '-item');

          if (selectorControlElem && selectorControlElem.style) {
            selectorControlElem.style.display = "block";
          }

          otherInputElement && otherInputElement.options && otherInputElement.selectedIndex >= 0 && otherInputElement.options[otherInputElement.selectedIndex].scrollIntoView();
        }
      }

      matsSelectUtils.checkDisableOther(param), firstRender;
    }
  } catch (e) {
    e.message = "INFO: Error in select.js checkHideOther: " + e.message;
    setInfo(e.message);
  }
}; // refresh the selector in question to the appropriate options indicated by the values of any superior selectors


var refresh = function (event, paramName) {
  if (paramName.search('axis') === 1) {
    // this is a "brother" (hidden) scatterplot param. There is no need to refresh it or add event listeners etc.
    return;
  }

  var param = matsParamUtils.getParameterForName(paramName);
  var elem = matsParamUtils.getInputElementForParamName(paramName);
  /*
  OptionsGroups are a mechanism for displaying the select options in groups.
  A disabled option is used for the group header. Disabled options simply show up
  in the selector list in bold font and act as group titles. They are disabled so that
  they cannot be clicked. DisabledOptions are the headers that the options are to be grouped under.
  disabledOptions are optional so if there are disabledOptions they are the keys in the optionsGroups
  and they are the sort order of those keys.
  */

  var disabledOptions = matsParamUtils.getDisabledOptionsForParamName(paramName);
  var optionsGroups = param.optionsGroups;
  var optionsMap = param.optionsMap;
  var superiorNames = param.superiorNames;
  var superiorDimensionality = superiorNames !== undefined && superiorNames !== null && superiorNames.length > 0 && Array.isArray(superiorNames[0]) ? superiorNames.length : 1;
  var superiors = []; // get a list of the current superior selected values - in order of superiority i.e. [databaseValue,dataSourceValue]

  var sNames;

  if (superiorNames !== undefined) {
    if (superiorDimensionality === 1) {
      sNames = superiorNames;
    } else {
      sNames = superiorNames[0];
    }

    for (var sn = 0; sn < sNames.length; sn++) {
      var superiorElement = matsParamUtils.getInputElementForParamName(sNames[sn]);
      var selectedSuperiorValue = superiorElement.options[superiorElement.selectedIndex] === undefined ? matsParamUtils.getParameterForName(sNames[sn]).default : superiorElement.options[superiorElement.selectedIndex].text;
      superiors[0] = superiors[0] === undefined ? [] : superiors[0];
      superiors[0].push({
        element: superiorElement,
        value: selectedSuperiorValue
      });
    }

    for (var sNameIndex = 1; sNameIndex < superiorDimensionality; sNameIndex++) {
      sNames = superiorNames[sNameIndex];

      for (var sn = 0; sn < sNames.length; sn++) {
        var superiorElement = matsParamUtils.getInputElementForParamName(sNames[sn]);
        var selectedSuperiorValue = superiorElement.options[superiorElement.selectedIndex] === undefined ? matsParamUtils.getParameterForName(sNames[sn]).default : superiorElement.options[superiorElement.selectedIndex].text;
        superiors[sNameIndex] = superiors[sNameIndex] === undefined ? [] : superiors[sNameIndex];
        superiors[sNameIndex].push({
          element: superiorElement,
          value: selectedSuperiorValue
        });
      }
    }
  }
  /*
  So what are superiors now.....
  superiors = [[{element:anElement,value:aValue},{element:anElement,value:aValue}...]]
  or they might be [[{element:anElement,value:aValue},{element:anElement,value:aValue}...],[{element:anElement,value:aValue},{element:anElement,value:aValue}...],...]
     Axis-brothers:
   Axis-brothers are for scatter plots. They are a second hidden set of parameters that apply to a different axis.
   Because there may be axis "brothers" This refresh must go and
   see if there are any brother elements that are essentially hidden copies
   of this one, and also refresh their options lists
    Superior Heirarchy:
   There can be a heirarchy of superiors and dependents. The superiorNames are a list of paramNames. The most superior has the 0th index and
   the least superior has the highest index.
   The Refresh uses the superiors to get the appropriate options for a given options map.
   The way it works is that superiors are always refreshed first. The superior heirarchy selections are then used by a
   dependent to retrieve its appropriate optionsMap from the superiorOptionsMap.
   superiorsOptionsMap = {
      mostSuperiorValue0: {  // optionsMap for the most superior first value
          nextSuperiorValue0: [value0,value1,value2,value3,...],
          nextSuperiorValue1: [value0,value1,value2,value3,...],
          nextSuperiorValue2: [value0,value1,value2,value3,...],
          ...
      },
      mostSuperiorValue1:{  // optionsMap for the most superior second value
          nextSuperiorValue0: [value0,value1,value2,value3,...],
          nextSuperiorValue1: [value0,value1,value2,value3,...],
          nextSuperiorValue2: [value0,value1,value2,value3,...],
          ...
      },
      ...,
      mostSuperiorValue2:{  // optionsMap for the most superior third value
          nextSuperiorValue0: [value0,value1,value2,value3,...],
          nextSuperiorValue1: [value0,value1,value2,value3,...],
          nextSuperiorValue2: [value0,value1,value2,value3,...],
          ...
      },
   }
   */
  // find all the elements that have ids like .... "x|y|z" + "axis-" + this.name


  var name = param.name;
  var elems = document.getElementsByClassName("data-input") === undefined ? [] : document.getElementsByClassName("data-input");
  Session.set('selected', $(elem).val());

  if (elem && elem.options) {
    if (elem.selectedIndex === undefined || elem.selectedIndex === -1) {
      if (param.default !== matsTypes.InputTypes.unused) {
        elem.selectedIndex = 0;
      }
    }

    var selectedText = elem.selectedIndex >= 0 ? elem.options[elem.selectedIndex].text : matsTypes.InputTypes.unused;
    var brothers = [];

    for (var i = 0; i < elems.length; i++) {
      if (elems[i].id.indexOf(name) >= 0 && elems[i].id !== elem.id) brothers.push(elems[i]);
    }

    var myOptions = [];
    var selectedSuperiorValues = [];

    try {
      // index down through the options for the list of superiors
      // starting with the most superior down through the least superior
      // and get the options list for the first set of superiors.
      // These are the ancestral options.
      if (param.optionsMap) {
        var firstSuperiorOptions = optionsMap;
        var theseSuperiors = superiors === undefined || superiors.length === 0 ? [] : superiors[0];

        for (var theseSuperiorsIndex = 0; theseSuperiorsIndex < theseSuperiors.length; theseSuperiorsIndex++) {
          var superior = theseSuperiors[theseSuperiorsIndex];
          var selectedSuperiorValue = superior.value;
          firstSuperiorOptions = firstSuperiorOptions[selectedSuperiorValue];
        }

        myOptions = Array.isArray(firstSuperiorOptions) ? firstSuperiorOptions : Object.keys(firstSuperiorOptions);
      } else {
        myOptions = param.options;
      } // need to get the ancestral truth options because we may need to intersect the options

      /* tricky little bit here:
      SuperiorDimensionality:
       It is possible to have two superior options maps.. i.e. datasource and truth.
       In that case the superiorNames won't look like ["something","somethingelse"],
       instead it will look like [["something","somethingelse"],["someotherthing","someotherthingelse"]]
       i.e. it will be a multidimensional array.
        If the controlButton for one of these multi-dimensional superior elements is hidden ....
       matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent !== null
       it has been hidden because it has a visibility dependency on another param
       i.e. truth-data-source and truth-variable (for mean there would be no truth, but for bias
       there must always be truth...).
       In this case these are dependent upon statistic such that if the statistic is "mean" the truth-data-source and truth-variable
       are hidden. See the wfip2 main.js statistic param as an example....
       "disableOtherFor:{'truth-data-source':[statisticOptionsMap.mean][0]},"
       and
       "hideOtherFor:{'truth-data-source':[statisticOptionsMap.mean][0]},"
       are the fields that cause the truth-data-source to be hidden when statistic is set to "mean".
       In that condition (the controlButton is hidden) the superior should not be used as an intersection in the selected sites.
       matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent will be null if the controlButton
       for this element (this superior) is hidden. That is the tricky part ... it will be null.
        Also the unused superior is tested against the superior according to the truth table...
       used && unused  -> use the used
       unused and used -> use the used
       used and used -> use the intersection
       unused and unused - set the options to []
        A select may have a list of disabledOptions. These are used as optionGroup markers.
       */
      // need to get the actual options here


      for (var sNameIndex = 1; sNameIndex < superiorDimensionality; sNameIndex++) {
        // index down through the options for the list of superiors
        // starting with the most superior down through the least superior
        // and get the options list for the first set of superiors.
        // These are the ancestral options.
        var nextSuperiorOptions = optionsMap;
        var theseSuperiors = superiors === undefined || superiors.length === 0 ? [] : superiors[sNameIndex];

        for (var theseSuperiorsIndex = 0; theseSuperiorsIndex < theseSuperiors.length; theseSuperiorsIndex++) {
          var superior = theseSuperiors[theseSuperiorsIndex];
          var selectedSuperiorValue = superior.value;
          nextSuperiorOptions = nextSuperiorOptions[selectedSuperiorValue];
        } // since we now have multiple options we have to intersect them


        myOptions = _.intersection(myOptions, nextSuperiorOptions);
      }

      if (myOptions === []) {
        // none used - set to []
        matsParamUtils.setValueTextForParamName(name, matsTypes.InputTypes.unused);
      }
    } catch (e) {
      e.message = "INFO: Error in select.js refresh: determining options from superiors: " + e.message;
      setInfo(e.message);
    }

    try {
      // reset the options of the select
      // if the options are null it might be that this is the initial setup.
      // so use the optionsmap and the default options for the map
      // it might also mean that there are no superiors for this param
      if (myOptions == null) {
        // get the default options
        if (optionsGroups) {
          // optionGroups are an ordered map. It probably has options that are in the disabledOption list
          // which are used as markers in the select options pulldown. This is typical for models
          var optionsGroupsKeys = Object.keys(optionsGroups);

          for (var k = 0; k < optionsGroupsKeys.length; k++) {
            if (myOptions === null) {
              myOptions = [];
              myOptions.push(optionsGroupsKeys[k]);
              myOptions = myOptions.concat(optionsGroups[optionsGroupsKeys[k]]); // the primary group does not get sorted
            } else {
              myOptions.push(optionsGroupsKeys[k]);
              myOptions = myOptions.concat(optionsGroups[optionsGroupsKeys[k]].sort()); // non primary  groups get sorted
            }
          }
        } else {
          myOptions = param.options;
        }
      }

      var optionsAsString = "";

      if (myOptions === undefined || myOptions == null) {
        return;
      }

      var firstGroup = true;

      for (var i = 0; i < myOptions.length; i++) {
        var dIndex = disabledOptions === undefined ? -1 : disabledOptions.indexOf(myOptions[i]);

        if (dIndex >= 0) {
          // the option was found in the disabled options so it needs to be an optgroup label
          // disabled option
          if (firstGroup === true) {
            // first in group
            optionsAsString += "<optgroup label=" + myOptions[i] + ">";
            firstGroup = false;
          } else {
            optionsAsString += "</optgroup>";
            optionsAsString += "<optgroup label=" + myOptions[i] + ">";
          }
        } else {
          //regular option - the option was not found in the disabled options
          optionsAsString += "<option value='" + myOptions[i] + "'>" + myOptions[i] + "</option>";
        }
      }

      if (disabledOptions !== undefined) {
        optionsAsString += "</optgroup>";
      }

      $('select[name="' + name + '"]').empty().append(optionsAsString); //reset the selected index if it had been set prior (the list may have changed so the index may have changed)

      var selectedOptionIndex;

      if (selectedText === 'initial') {
        selectedOptionIndex = myOptions.indexOf(param.default);
      } else {
        selectedOptionIndex = myOptions.indexOf(selectedText);
      }

      var sviText = "";

      if (selectedOptionIndex == -1 && elem.selectedIndex >= 0) {
        for (var svi = 0; svi < selectedSuperiorValues.length; svi++) {
          superior = superiors[svi];

          if (matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent !== null) {
            if (svi > 0) {
              sviText += " and ";
            }

            sviText += selectedSuperiorValues[svi];
          }
        }

        setInfo("I changed your selected " + name + ": '" + selectedText + "' to '" + myOptions[0] + "' because '" + selectedText + "' is no longer an option for " + sviText);
      } // if the selectedText existed in the new options list then the selectedOptionIndex won't be -1 and we have to choose the default option


      if (selectedOptionIndex === -1) {
        // if the param default is unused set it to unused
        // else just choose the 0th element in the element options. default?
        if (param.default === matsTypes.InputTypes.unused) {
          matsParamUtils.setValueTextForParamName(name, matsTypes.InputTypes.unused);
        } else {
          elem.selectedIndex = 0;
          elem && elem.options && elem.selectedIndex >= 0 && elem.options[elem.selectedIndex].scrollIntoView();
          elem && elem.options && elem.selectedIndex >= 0 && matsParamUtils.setValueTextForParamName(name, elem.options[elem.selectedIndex].text);
        }
      } else {
        elem.selectedIndex = selectedOptionIndex;
        elem && elem.options && elem.selectedIndex >= 0 && elem.options[elem.selectedIndex].scrollIntoView();
        elem && elem.options && elem.selectedIndex >= 0 && matsParamUtils.setValueTextForParamName(name, elem.options[elem.selectedIndex].text);
      }

      for (var i = 0; i < brothers.length; i++) {
        var belem = brothers[i];
        var belemSelectedOptions = $(belem.selectedOptions).map(function () {
          return this.value;
        }).get();

        if (belemSelectedOptions === undefined || belemSelectedOptions.length === 0) {
          belem.options = [];

          for (var i1 = 0; i1 < myOptions.length; i1++) {
            belem.options[belem.options.length] = new Option(myOptions[i1], myOptions[i1], i1 == 0, i1 == 0);
          }
        }
      }
    } catch (e) {
      e.message = "INFO: Error in select.js refresh: resetting selected options: " + e.message;
      setInfo(e.message);
    }
  }

  refreshPeer(event, param);
}; // refresh function


module.exportDefault(matsSelectUtils = {
  refresh: refresh,
  refreshPeer: refreshPeer,
  refreshDependents: refreshDependents,
  checkDisableOther: checkDisableOther,
  checkHideOther: checkHideOther
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/index.js                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("./curve_util.js");
module.link("./graph_util.js");
module.link("./select_util.js");
module.link("./init.js");
module.link("../both");
module.link("./routes.js");
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"init.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/init.js                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  "default": function (v) {
    matsCollections = v;
  }
}, 1);

if (Meteor.isClient) {
  Meteor.subscribe("CurveParams");
  Meteor.subscribe("Scatter2dParams");
  Meteor.subscribe("SavedCurveParams");
  Meteor.subscribe("PlotParams");
  Meteor.subscribe("PlotGraphFunctions");
  Meteor.subscribe("RegionsPerModel");
  Meteor.subscribe("SitesPerModel");
  Meteor.subscribe("RegionDescriptions");
  Meteor.subscribe("Models");
  Meteor.subscribe("FcstLensPerModel");
  Meteor.subscribe("ColorScheme");
  Meteor.subscribe("Settings");
  Meteor.subscribe("CurveSettings");
  Meteor.subscribe("SentAddresses");
  Meteor.subscribe("Roles");
  Meteor.subscribe("Authorization");
  Meteor.subscribe("Credentials");
  Meteor.subscribe("Databases");
  Meteor.subscribe("CurveTextPatterns");
  Meteor.subscribe("ScatterAxisTextPattern");
  Meteor.subscribe("RangePerDescriptor");
  Meteor.subscribe("SiteMap");
  Meteor.subscribe("StationMap");
  Meteor.subscribe("appName");
  Meteor.subscribe("LayoutStoreCollection");
  Session.set('Curves', []);
  Session.set('PlotParams', []);
  Accounts.ui.config({
    requestOfflineToken: {
      google: true
    }
  });
  var ref = location.href;
  var pathArray = location.href.split('/');
  var protocol = pathArray[0];
  var hostport = pathArray[2];
  var hostName = hostport.split(':')[0];
  var app = pathArray[3] == "" ? "/" : pathArray[3];
  var matsRef = protocol + "//" + hostport;
  var helpRef = ref.endsWith('/') ? ref + "help" : ref + "/help";
  Session.set("app", {
    appName: app,
    matsref: matsRef,
    appref: ref,
    helpref: helpRef,
    hostName: hostName
  });
  var collections = Object.keys(matsCollections).map(function (key) {
    return matsCollections[key];
  });
  Session.set("Mongol", {
    'collections': collections,
    'display': false,
    'opacity_normal': ".7",
    'opacity_expand': ".9",
    'disable_warning': true
  });
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"routes.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/client/routes.js                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var FlowRouter;
module.link("meteor/ostrio:flow-router-extra", {
  FlowRouter: function (v) {
    FlowRouter = v;
  }
}, 1);
//localhost routes
FlowRouter.route('/', {
  name: 'main',
  action: function () {
    this.render('Home');
  }
});
FlowRouter.route('/CSV/:graphFunction/:key/:matching/:appName', {
  name: 'csv',
  action: function (params) {
    console.log("in csv route");
    window.location.href = FlowRouter.path;
  }
});
FlowRouter.route('/JSON/:graphFunction/:key/:matching/:appName', {
  name: 'json',
  action: function (params) {
    console.log("in json route");
    window.location.href = FlowRouter.path;
  }
});
FlowRouter.route('/preview/:graphFunction/:key/:matching/:appName', {
  name: 'preview',
  action: function (params) {
    console.log("in preview route- setting params", params);
    this.render('GraphStandAlone', params);
  }
}); //prefix routes

FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/', {
  name: 'main',
  action: function () {
    this.render('Home');
  }
});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/CSV/:graphFunction/:key/:matching/:appName', {
  name: 'csv',
  action: function (params) {
    console.log("in csv route");
    window.location.href = FlowRouter.path;
  }
});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/JSON/:graphFunction/:key/:matching/:appName', {
  name: 'json',
  action: function (params) {
    console.log("in json route");
    window.location.href = FlowRouter.path;
  }
});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/preview/:graphFunction/:key/:matching/:appName', {
  name: 'preview',
  action: function (params) {
    console.log("in preview route- setting params", params);
    this.render('GraphStandAlone', params);
  }
}); // appname routes

FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/:appName', {
  name: 'main',
  action: function () {
    this.render('Home');
  }
});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/*/CSV/:graphFunction/:key/:matching/:appName', {
  name: 'csv',
  action: function (params) {
    console.log("in csv route");
    window.location.href = FlowRouter.path;
  }
});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/*/JSON/:graphFunction/:key/:matching/:appName', {
  name: 'json',
  action: function (params) {
    console.log("in json route");
    window.location.href = FlowRouter.path;
  }
});
FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/*/preview/:graphFunction/:key/:matching/:appName', {
  name: 'preview',
  action: function (params) {
    console.log("in preview route- setting params", params);
    this.render('GraphStandAlone', params);
  }
}); // exception routes

FlowRouter.route(Meteor.settings.public.proxy_prefix_path + '/*/', {
  name: 'main',
  action: function () {
    this.render('notFound');
  }
});
FlowRouter.route('*', {
  action: function () {
    console.log('route: ' + ' not found');
    this.render('notFound');
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"server":{"data_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_util.js                                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 2);

//this function checks if two JSON objects are identical
var areObjectsEqual = function (o, p) {
  if (o && !p || p && !o) {
    return false;
  }

  if (JSON.stringify(o) === JSON.stringify(p)) {
    return true;
  } else {
    return false;
  }
}; //this function checks if values of subArray are also in superArray


var arrayContainsArray = function (superArray, subArray) {
  superArray.sort(function (a, b) {
    return Number(a) - Number(b);
  });
  subArray.sort(function (a, b) {
    return Number(a) - Number(b);
  });
  var i, j;

  for (i = 0, j = 0; i < superArray.length && j < subArray.length;) {
    if (superArray[i] < subArray[j]) {
      ++i;
    } else if (superArray[i] === subArray[j]) {
      ++i;
      ++j;
    } else {
      // subArray[j] not in superArray, so superArray does not contain all elements of subArray
      return false;
    }
  } // make sure there are no elements left in sub


  return j === subArray.length;
}; //this function checks if the entire array subArray is contained in superArray


var arrayContainsSubArray = function (superArray, subArray) {
  var i, j, current;

  for (i = 0; i < superArray.length; ++i) {
    if (subArray.length === superArray[i].length) {
      current = superArray[i];

      for (j = 0; j < subArray.length && subArray[j] === current[j]; ++j) {
        ;
      }

      if (j === subArray.length) return true;
    }
  }

  return false;
}; //this function checks if two arrays are identical


var arraysEqual = function (a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length !== b.length) return false;

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }

  return true;
};

var arrayUnique = function (a) {
  var arr = [];

  for (var i = 0; i < a.length; i++) {
    if (!arr.includes(a[i])) {
      arr.push(a[i]);
    }
  }

  return arr;
}; //this function finds the position of the array subArray in superArray


var findArrayInSubArray = function (superArray, subArray) {
  var i, j, current;

  for (i = 0; i < superArray.length; ++i) {
    if (subArray.length === superArray[i].length) {
      current = superArray[i];

      for (j = 0; j < subArray.length && subArray[j] === current[j]; ++j) {
        ;
      }

      if (j === subArray.length) return i;
    }
  }

  return -1;
}; //this function checks if an object is a value in another object


var objectContainsObject = function (superObject, subObject) {
  var superObjectKeys = Object.keys(superObject);
  var currentObject;

  for (var i = 0; i < superObjectKeys.length; i++) {
    currentObject = superObject[superObjectKeys[i]];

    if (areObjectsEqual(subObject, currentObject)) {
      return true;
    }
  } // if the loop completes, the subObject was not found


  return false;
}; //utility for calculating the average of an array


var average = function (data) {
  var sum = data.reduce(function (sum, value) {
    return value == null ? sum : sum + value;
  }, 0);
  var avg = sum / data.length;
  return avg;
}; //utility for calculating the stdev of an array


var stdev = function (data) {
  var avg = average(data);
  var squareDiffs = data.map(function (value) {
    var diff = value - avg;
    return diff * diff;
  });
  var avgSquareDiff = average(squareDiffs);
  var stdDev = Math.sqrt(avgSquareDiff);
  return stdDev;
}; //this function makes sure date strings are in the correct format


var dateConvert = function (dStr) {
  if (dStr === undefined || dStr === " ") {
    var now = new Date();
    var date = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
    var yr = date.getUTCFullYear();
    var day = date.getUTCDate();
    var month = date.getUTCMonth();
    var hour = date.getUTCHours();
    var minute = date.getUTCMinutes();
    return month + "/" + day + '/' + yr + ' ' + hour + ":" + minute;
  }

  var dateParts = dStr.split(' ');
  var dateArray = dateParts[0].split(/[\-\/]/); // split on - or /    01-01-2017 OR 01/01/2017

  var month = dateArray[0];
  var day = dateArray[1];
  var yr = dateArray[2];
  var hour = 0;
  var minute = 0;

  if (dateParts[1]) {
    var timeArray = dateParts[1].split(":");
    hour = timeArray[0];
    minute = timeArray[1];
  }

  return month + "/" + day + '/' + yr + ' ' + hour + ":" + minute;
}; //splits the date range string from the date selector into standardized fromDate/toDate strings,
// plus the epochs for the fromDate and toDate


var getDateRange = function (dateRange) {
  var dates = dateRange.split(' - ');
  var fromDateStr = dates[0];
  var fromDate = dateConvert(fromDateStr);
  var toDateStr = dates[1];
  var toDate = dateConvert(toDateStr);
  var fromSecs = secsConvert(fromDateStr);
  var toSecs = secsConvert(toDateStr);
  return {
    fromDate: fromDate,
    toDate: toDate,
    fromSeconds: fromSecs,
    toSeconds: toSecs
  };
}; //this function converts a date string into an epoch


var secsConvert = function (dStr) {
  if (dStr === undefined || dStr === " ") {
    var now = new Date();
    return now.getTime() / 1000;
  } else {
    var dateParts = dStr.split(' ');
    var dateArray = dateParts[0].split(/[\-\/]/); // split on - or /    01-01-2017 OR 01/01/2017

    var month = dateArray[0];
    var day = dateArray[1];
    var yr = dateArray[2];
    var hour = 0;
    var minute = 0;

    if (dateParts[1]) {
      var timeArray = dateParts[1].split(":");
      hour = timeArray[0];
      minute = timeArray[1];
    }

    var my_date = new Date(Date.UTC(yr, month - 1, day, hour, minute, 0)); // to UTC time, not local time

    var date_in_secs = my_date.getTime();
  } // to UTC time, not local time
  //return date_in_secs/1000 -3600*6;


  return date_in_secs / 1000;
}; //function to manage authorized logins for MATS


var doAuthorization = function () {
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.Authorization.remove({});
  }

  if (matsCollections.Authorization.find().count() == 0) {
    matsCollections.Authorization.insert({
      email: "randy.pierce@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "kirk.l.holub@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "jeffrey.a.hamilton@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "bonny.strong@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "molly.b.smith@noaa.gov",
      roles: ["administrator"]
    });
    matsCollections.Authorization.insert({
      email: "mats.gsd@noaa.gov",
      roles: ["administrator"]
    });
  }
}; //master list of colors for MATS curves


var doColorScheme = function () {
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.ColorScheme.remove({});
  }

  if (matsCollections.ColorScheme.find().count() == 0) {
    matsCollections.ColorScheme.insert({
      colors: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,165,0)", "rgb(128,128,128)", "rgb(238,130,238)", "rgb(238,130,238)", "rgb(0,0,139)", "rgb(148,0,211)", "rgb(105,105,105)", "rgb(255,140,0)", "rgb(235,92,92)", "rgb(82,92,245)", "rgb(133,143,143)", "rgb(235,143,92)", "rgb(190,120,120)", "rgb(225,82,92)", "rgb(72,82,245)", "rgb(123,133,143)", "rgb(225,133,92)", "rgb(180,120,120)"]
    });
  }
}; //utility for google login capabilities in MATS -- broken for esrl.noaa.gov/gsd/mats?


var doCredentials = function () {
  // the gmail account for the credentials is mats.mail.daemon@gmail.com - pwd mats2015!
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.Credentials.remove({});
  }

  if (matsCollections.Credentials.find().count() == 0) {
    matsCollections.Credentials.insert({
      name: "oauth_google",
      clientId: "499180266722-aai2tddo8s9edv4km1pst88vebpf9hec.apps.googleusercontent.com",
      clientSecret: "xdU0sc7SbdOOEzSyID_PTIRE",
      refresh_token: "1/3bhWyvCMMfwwDdd4F3ftlJs3-vksgg7G8POtiOBwYnhIgOrJDtdun6zK6XiATCKT"
    });
  }
}; //another utility to assist at logging into MATS


var doRoles = function () {
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.Roles.remove({});
  }

  if (matsCollections.Roles.find().count() == 0) {
    matsCollections.Roles.insert({
      name: "administrator",
      description: "administrator privileges"
    });
  }
}; //for use in matsMethods.resetApp() to establish default settings


var doSettings = function (title, version, buildDate, appType) {
  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {
    matsCollections.Settings.remove({});
  }

  if (matsCollections.Settings.find().count() == 0) {
    matsCollections.Settings.insert({
      LabelPrefix: "Curve",
      Title: title,
      appVersion: version,
      buildDate: buildDate,
      appType: appType,
      LineWidth: 3.5,
      NullFillString: "---",
      resetFromCode: false
    });
  } // always update the version, roles, and the hostname, not just if it doesn't exist...


  var settings = matsCollections.Settings.findOne({});
  var deploymentRoles = {
    "mats-dev": "development",
    "mats-int": "integration",
    "mats": "production"
  };
  var settingsId = settings._id;

  var os = Npm.require('os');

  var hostname = os.hostname().split('.')[0];
  settings['appVersion'] = version;
  settings['hostname'] = hostname;
  settings['deploymentRoles'] = JSON.stringify(deploymentRoles);
  matsCollections.Settings.update(settingsId, {
    $set: settings
  });
}; //Utility for transferring client-side parameters to the server-side methods via the "PlotParams" object in the stack.
//Add values to this object in the 'click .submit-params' event handler in plot_list.js


var getPlotParamsFromStack = function () {
  var params = {};
  var err = new Error();
  Error.captureStackTrace(err, arguments.callee.arguments.callee);
  var stack = err.stack;
  var stackElems = stack.split("\n");

  for (si = 0; si < stackElems.length; si++) {
    var sElem = stackElems[si].trim();

    if (sElem.indexOf('dataFunctions') !== -1 && sElem.startsWith("at data")) {
      var dataFunctionName = sElem.split('at ')[1];

      try {
        params = global[sElem.split('at ')[1].split(' ')[0]].arguments[0];
      } catch (noJoy) {}

      break;
    }
  }

  return params;
}; //calculates mean, stdev, and other statistics for curve data points in all apps and plot types


var get_err = function (sVals, sSecs, sLevs) {
  /* refer to perl error_library.pl sub  get_stats
   to see the perl implementation of these statics calculations.
   These should match exactly those, except that they are processed in reverse order.
   */
  var autocorr_limit = 0.95;
  var hasLevels = sLevs.length > 0;
  var plotParams = getPlotParamsFromStack();
  var outlierQCParam;

  if (plotParams["outliers"] !== "all") {
    outlierQCParam = Number(plotParams["outliers"]);
  } else {
    outlierQCParam = 100;
  }

  var subVals = [];
  var subSecs = [];
  var subLevs = [];
  var n = sVals.length;
  var n_good = 0;
  var sum_d = 0;
  var sum2_d = 0;
  var error = "";
  var i;

  for (i = 0; i < n; i++) {
    if (sVals[i] !== null && !isNaN(sVals[i])) {
      n_good = n_good + 1;
      sum_d = sum_d + sVals[i];
      sum2_d = sum2_d + sVals[i] * sVals[i];
      subVals.push(sVals[i]);
      subSecs.push(sSecs[i]);

      if (hasLevels) {
        subLevs.push(sLevs[i]);
      }
    }
  }

  var d_mean = sum_d / n_good;
  var sd2 = sum2_d / n_good - d_mean * d_mean;
  var sd = sd2 > 0 ? Math.sqrt(sd2) : sd2;
  var sd_limit = outlierQCParam * sd; //console.log("see error_library.pl l208 These are processed in reverse order to the perl code -  \nmean is " + d_mean + " sd_limit is +/- " + sd_limit + " n_good is " + n_good + " sum_d is" + sum_d + " sum2_d is " + sum2_d);
  // find minimum delta_time, if any value missing, set null

  var last_secs = 0;
  var minDelta = Number.MAX_VALUE;
  var minSecs = Number.MAX_VALUE;
  var max_secs = Number.MIN_VALUE;
  var minVal = Number.MAX_VALUE;
  var maxVal = -1 * Number.MAX_VALUE;
  var secs;
  var delta;

  for (i = 0; i < subSecs.length; i++) {
    secs = subSecs[i];
    delta = Math.abs(secs - last_secs);

    if (delta > 0 && delta < minDelta) {
      minDelta = delta;
    }

    if (secs < minSecs) {
      minSecs = secs;
    }

    if (secs > max_secs) {
      max_secs = secs;
    }

    last_secs = secs;
  }

  var data_wg = [];
  var n_gaps = 0;
  n_good = 0;
  var sum = 0;
  var sum2 = 0;

  if (minDelta < 0) {
    error = "Invalid time interval - minDelta: " + minDelta;
    console.log("matsDataUtil.getErr: Invalid time interval - minDelta: " + minDelta);
  } // remove data more than $sd_limit from mean


  var qaCorrected = [];

  for (i = 0; i < subVals.length; i++) {
    if (Math.abs(subVals[i] - d_mean) > sd_limit) {
      qaCorrected.push("removing datum " + i + " with value " + subVals[i] + " because it exceeds " + outlierQCParam + " standard deviations from the mean - mean: " + d_mean + " " + outlierQCParam + " * sd: " + sd_limit + " delta: " + (subVals[i] - d_mean)); // console.log(qaCorrected.join('\n'));

      subVals[i] = null;
    } else {
      minVal = minVal < subVals[i] ? minVal : subVals[i];
      maxVal = maxVal > subVals[i] ? maxVal : subVals[i];
      sum += subVals[i];
      sum2 += subVals[i] * subVals[i];
      n_good++;
    }
  }

  if (n_good < 1) {
    return {
      d_mean: null,
      stde_betsy: null,
      sd: null,
      n_good: n_good,
      lag1: null,
      min: null,
      max: null,
      sum: null
    };
  } // recalculate if we threw anything away.


  d_mean = sum / n_good;
  sd2 = sum2 / n_good - d_mean * d_mean;
  sd = 0;

  if (sd2 > 0) {
    sd = Math.sqrt(sd2);
  } //console.log("new mean after throwing away outliers is " + sd + " n_good is " + n_good + " sum is " + sum  + " sum2 is " + sum2 + " d_mean is " + d_mean);
  // look for gaps


  var lastSecond = -1 * Number.MAX_VALUE;
  var lastPressure = -1 * Number.MAX_VALUE;
  var n_pressures;

  if (hasLevels) {
    n_pressures = arrayUnique(subLevs).length;
  } else {
    n_pressures = 1;
  } // set lag1_t to the first time the time changes from its initial value + 1 (data zero based)
  // set lag1_p to the first time the pressure changes from its initial value + 1 (data zero based)


  var lag1_t = 0;
  var lag1_p = 0;
  var r1_t = 0; // autocorrelation for time

  var r1_p = 0; // autocorrelation for pressure

  var j = 0; // i is loop index without gaps; j is loop index with gaps

  var n_deltas = 0;

  for (i = 0; i < subSecs.length; i++) {
    var sec = subSecs[i];
    var lev;

    if (hasLevels) {
      lev = subLevs[i]; // find first time the pressure changes

      if (lag1_p === 0 && lastPressure > 0) {
        if (lev !== lastPressure) {
          lag1_p = j;
        }
      }
    }

    if (lastSecond >= 0) {
      if (lag1_t === 0 && sec !== lastSecond) {
        lag1_t = j;
      }

      if (Math.abs(sec - lastSecond) > minDelta) {
        n_deltas = (Math.abs(sec - lastSecond) / minDelta - 1) * n_pressures; // for the Autocorrelation at lag 1, it doesn't matter how many missing
        // data we put in within gaps! (But for the other AC's it does.)
        // since we're using only the AC at lag 1 for calculating std err, let's
        // save cpu time and only put in one missing datum per gap, no matter
        // how long. WRM 2/22/2019
        // but if we're using a different lag, which could happen, we'll need
        // to insert all the missing data in each gap. WRM 2/22/2019
        // $n_deltas=1;

        for (var count = 0; count < n_deltas; count++) {
          data_wg.push(null);
          n_gaps++;
          j++;
        }
      }
    }

    lastSecond = sec;

    if (hasLevels) {
      lastPressure = lev;
    }

    data_wg.push(subVals[i]);
    j++;
  } //from http://www.itl.nist.gov/div898/handbook/eda/section3/eda35c.htm


  var r = [];
  var lag_by_r = {};
  var lag1_max = lag1_p > lag1_t ? lag1_p : lag1_t;
  var r_sum = 0;
  var n_r = 0;
  var n_in_lag;
  var lag;
  var t;

  for (lag = 0; lag <= lag1_max; lag++) {
    r[lag] = 0;
    n_in_lag = 0;

    for (t = 0; t < n + n_gaps - lag; t++) {
      if (data_wg[t] != null && data_wg[t + lag] != null) {
        r[lag] += +(data_wg[t] - d_mean) * (data_wg[t + lag] - d_mean);
        n_in_lag++;
      }
    }

    if (n_in_lag > 0 && sd > 0) {
      r[lag] /= n_in_lag * sd * sd;
      r_sum += r[lag];
      n_r++;
    } else {
      r[lag] = null;
    }

    if (lag >= 1 && lag < (n + n_gaps) / 2) {
      lag_by_r[r[lag]] = lag;
    }
  }

  if (lag1_t > 0) {
    r1_t = r[lag1_t] !== undefined ? r[lag1_t] : 0;
  }

  if (lag1_p > 0) {
    r1_p = r[lag1_p] !== undefined ? r[lag1_p] : 0;
  } // Betsy Weatherhead's correction, based on lag 1, augmented by the highest
  // lag > 1 and < n/2


  if (r1_p >= autocorr_limit) {
    r1_p = autocorr_limit;
  }

  if (r1_t >= autocorr_limit) {
    r1_t = autocorr_limit;
  }

  var betsy = Math.sqrt((n_good - 1) * (1. - r1_p) * (1. - r1_t));
  var stde_betsy;

  if (betsy !== 0) {
    stde_betsy = sd / betsy;
  } else {
    stde_betsy = null;
  }

  var stats = {
    d_mean: d_mean,
    stde_betsy: stde_betsy,
    sd: sd,
    n_good: n_good,
    lag1: r[1],
    min: minSecs,
    max: max_secs,
    minVal: minVal,
    maxVal: maxVal,
    sum: sum_d,
    qaCorrected: qaCorrected
  }; //console.log("stats are " + JSON.stringify(stats));
  // stde_betsy is standard error with auto correlation
  //console.log("---------\n\n");

  return stats;
}; // utility to process the user-input histogram customization controls


var setHistogramParameters = function (plotParams) {
  var yAxisFormat = plotParams['histogram-yaxis-controls'];
  var binType = plotParams['histogram-bin-controls'];
  var binNum = 12; // default bin number

  var binStart = undefined; // default is no mandated bin start

  var binStride = undefined; // default is no mandated stride

  var pivotVal = undefined; // default is not to shift the bins over to a pivot

  var binBounds = []; // default is no specified bin bounds -- our algorithm will figure them out if this array stays empty

  switch (binType) {
    case "Set number of bins":
      // get the user's chosen number of bins
      binNum = Number(plotParams['bin-number']);

      if (isNaN(binNum)) {
        throw new Error("Error parsing bin number: please enter the desired number of bins.");
      }

      break;

    case "Make zero a bin bound":
      // let the histogram routine know that we want the bins shifted over to zero
      pivotVal = 0;
      break;

    case "Choose a bin bound":
      // let the histogram routine know that we want the bins shifted over to whatever was input
      pivotVal = Number(plotParams['bin-pivot']);

      if (isNaN(pivotVal)) {
        throw new Error("Error parsing bin pivot: please enter the desired bin pivot.");
      }

      break;

    case "Set number of bins and make zero a bin bound":
      // get the user's chosen number of bins and let the histogram routine know that we want the bins shifted over to zero
      binNum = Number(plotParams['bin-number']);

      if (isNaN(binNum)) {
        throw new Error("Error parsing bin number: please enter the desired number of bins.");
      }

      pivotVal = 0;
      break;

    case "Set number of bins and choose a bin bound":
      // get the user's chosen number of bins and let the histogram routine know that we want the bins shifted over to whatever was input
      binNum = Number(plotParams['bin-number']);

      if (isNaN(binNum)) {
        throw new Error("Error parsing bin number: please enter the desired number of bins.");
      }

      pivotVal = Number(plotParams['bin-pivot']);

      if (isNaN(pivotVal)) {
        throw new Error("Error parsing bin pivot: please enter the desired bin pivot.");
      }

      break;

    case "Manual bins":
      // try to parse whatever we've been given for bin bounds. Throw an error if they didn't follow directions to enter a comma-separated list of numbers.
      try {
        binBounds = plotParams['bin-bounds'].split(",").map(function (item) {
          item.trim();
          item = Number(item);

          if (!isNaN(item)) {
            return item;
          } else {
            throw new Error("Error parsing bin bounds: please enter  at least two numbers delimited by commas.");
          }
        });
        binNum = binBounds.length + 1; // add 1 because these are inner bin bounds
      } catch (e) {
        throw new Error("Error parsing bin bounds: please enter  at least two numbers delimited by commas.");
      } // make sure that we've been given at least two good bin bounds (enough to make one bin).


      if (binNum < 3) {
        throw new Error("Error parsing bin bounds: please enter at least two numbers delimited by commas.");
      }

      break;

    case "Manual bin start, number, and stride":
      // get the bin start, number, and stride.
      binNum = Number(plotParams['bin-number']);

      if (isNaN(binNum)) {
        throw new Error("Error parsing bin number: please enter the desired number of bins.");
      }

      binStart = Number(plotParams['bin-start']);

      if (isNaN(binStart)) {
        throw new Error("Error parsing bin start: please enter the desired bin start.");
      }

      binStride = Number(plotParams['bin-stride']);

      if (isNaN(binStride)) {
        throw new Error("Error parsing bin stride: please enter the desired bin stride.");
      }

      break;

    case "Default bins":
    default:
      break;
  }

  return {
    yAxisFormat: yAxisFormat,
    binNum: binNum,
    binStart: binStart,
    binStride: binStride,
    pivotVal: pivotVal,
    binBounds: binBounds
  };
}; // utility that takes arrays of seconds and values and produces a data structure containing bin information for histogram plotting


var calculateHistogramBins = function (curveSubStats, curveSubSecs, binParams) {
  // binStart and binStride will only be defined if the user wants to specify the bin spacing.
  // otherwise, we'll use the mean and standard deviation of the data to space the bins.
  // pivotVal will only be defined if the user wants to shift the bin limits to align with a certain value.
  // otherwise, we'll keep everything aligned with the data mean.
  var binStats = {};
  var binUpBounds = [];
  var binLowBounds = [];
  var binMeans = []; // calculate the global stats across all of the data

  var globalStats = get_err(curveSubStats, curveSubSecs, []); // we don't need levels for the mean or sd calculations, so just pass in an empty array

  var glob_mean = globalStats.d_mean;
  var glob_sd = globalStats.sd;
  var fullLowBound;
  var fullUpBound;
  var fullRange;
  var binInterval;

  if (binParams.binStart === undefined || binParams.binStride === undefined) {
    // use the global stats to determine the bin bounds -- should be based on dividing up +/- 3*sd from the mean into requested number of bins
    fullLowBound = glob_mean - 3 * glob_sd;
    fullUpBound = glob_mean + 3 * glob_sd;
    fullRange = 6 * glob_sd;
    binInterval = fullRange / (binParams.binNum - 2); // take off two bins from the total number of requested bins to represent values either less than - 3*sd from the mean or greater than 3*sd from the mean
  } else {
    // use the user-defined start, number, and stride to determine the bin bounds
    fullLowBound = binParams.binStart;
    fullUpBound = binParams.binStart + (binParams.binNum - 2) * binParams.binStride; // take off two bins from the total number of requested bins to represent values that fall outside of the prescribed range

    fullRange = (binParams.binNum - 2) * binParams.binStride;
    binInterval = binParams.binStride;
  } // store an array of the upper and lower bounding values for each bin.


  binUpBounds[0] = fullLowBound; // the first upper bound should be exactly - 3*sd from the mean, or the previously calculated fullLowBound

  binLowBounds[0] = -1 * Number.MAX_VALUE;
  binMeans[0] = fullLowBound - binInterval / 2;

  for (var b_idx = 1; b_idx < binParams.binNum - 1; b_idx++) {
    binUpBounds[b_idx] = binUpBounds[b_idx - 1] + binInterval; // increment from fullLowBound to get the rest of the bin upper limits

    binLowBounds[b_idx] = binUpBounds[b_idx - 1];
    binMeans[b_idx] = binUpBounds[b_idx - 1] + binInterval / 2;
  }

  binUpBounds[binParams.binNum - 1] = Number.MAX_VALUE; // the last bin should have everything too large to fit into the previous bins, so make its upper bound the max number value

  binLowBounds[binParams.binNum - 1] = fullUpBound;
  binMeans[binParams.binNum - 1] = fullUpBound + binInterval / 2;

  if (binParams.pivotVal !== undefined && !isNaN(binParams.pivotVal)) {
    // need to shift the bounds and means over so that one of the bounds is on the chosen pivot
    var closestBoundToPivot = binLowBounds.reduce(function (prev, curr) {
      return Math.abs(curr - binParams.pivotVal) < Math.abs(prev - binParams.pivotVal) ? curr : prev;
    });
    binUpBounds = binUpBounds.map(function (val) {
      return val - (closestBoundToPivot - binParams.pivotVal);
    });
    binLowBounds = binLowBounds.map(function (val) {
      return val - (closestBoundToPivot - binParams.pivotVal);
    });
    binMeans = binMeans.map(function (val) {
      return val - (closestBoundToPivot - binParams.pivotVal);
    });
  } // calculate the labels for each bin, based on the data bounding range, for the graph x-axis later


  var binLabels = [];
  var lowSdFromMean;
  var upSdFromMean;

  for (b_idx = 0; b_idx < binParams.binNum; b_idx++) {
    lowSdFromMean = binLowBounds[b_idx].toFixed(2);
    upSdFromMean = binUpBounds[b_idx].toFixed(2);

    if (b_idx === 0) {
      binLabels[b_idx] = "< " + upSdFromMean;
    } else if (b_idx === binParams.binNum - 1) {
      binLabels[b_idx] = "> " + lowSdFromMean;
    } else {
      binLabels[b_idx] = lowSdFromMean + "-" + upSdFromMean;
    }
  }

  binStats['glob_mean'] = glob_mean;
  binStats['glob_sd'] = glob_sd;
  binStats['binUpBounds'] = binUpBounds;
  binStats['binLowBounds'] = binLowBounds;
  binStats['binMeans'] = binMeans;
  binStats['binLabels'] = binLabels;
  return {
    'binStats': binStats
  };
}; // utility that takes an array of user-defined bin bounds and produces a data structure containing bin information for histogram plotting


var prescribeHistogramBins = function (curveSubStats, curveSubSecs, binParams) {
  var binStats = {}; // calculate the global stats across all of the data

  var globalStats = get_err(curveSubStats, curveSubSecs, []); // we don't need levels for the mean or sd calculations, so just pass in an empty array

  var glob_mean = globalStats.d_mean;
  var glob_sd = globalStats.sd; // make sure the user-defined bins are in order from least to greatest

  binParams.binBounds = binParams.binBounds.sort(function (a, b) {
    return Number(a) - Number(b);
  }); // store an array of the upper and lower bounding values for each bin.

  var binUpBounds = [];
  var binLowBounds = [];
  var binMeans = [];
  var binIntervalSum = 0;

  for (var b_idx = 1; b_idx < binParams.binNum - 1; b_idx++) {
    binUpBounds[b_idx] = binParams.binBounds[b_idx];
    binLowBounds[b_idx] = binParams.binBounds[b_idx - 1];
    binMeans[b_idx] = (binUpBounds[b_idx] + binLowBounds[b_idx]) / 2;
    binIntervalSum = binIntervalSum + (binUpBounds[b_idx] - binLowBounds[b_idx]);
  }

  var binIntervalAverage = binIntervalSum / (binParams.binNum - 2);
  binUpBounds[0] = binLowBounds[1];
  binLowBounds[0] = -1 * Number.MAX_VALUE; // the first bin should have everything too small to fit into the other bins, so make its lower bound -1 * the max number value

  binMeans[0] = binLowBounds[1] - binIntervalAverage / 2; // the bin means for the edge bins is a little arbitrary, so base it on the average bin width

  binUpBounds[binParams.binNum - 1] = Number.MAX_VALUE; // the last bin should have everything too large to fit into the previous bins, so make its upper bound the max number value

  binLowBounds[binParams.binNum - 1] = binUpBounds[binParams.binNum - 2];
  binMeans[binParams.binNum - 1] = binUpBounds[binParams.binNum - 2] + binIntervalAverage / 2; // the bin means for the edge bins is a little arbitrary, so base it on the average bin width
  // calculate the labels for each bin, based on the data bounding range, for the graph x-axis later

  var binLabels = [];
  var lowSdFromMean;
  var upSdFromMean;

  for (b_idx = 0; b_idx < binParams.binNum; b_idx++) {
    lowSdFromMean = binLowBounds[b_idx].toFixed(2);
    upSdFromMean = binUpBounds[b_idx].toFixed(2);

    if (b_idx === 0) {
      binLabels[b_idx] = "< " + upSdFromMean;
    } else if (b_idx === binParams.binNum - 1) {
      binLabels[b_idx] = "> " + lowSdFromMean;
    } else {
      binLabels[b_idx] = lowSdFromMean + "-" + upSdFromMean;
    }
  }

  binStats['glob_mean'] = glob_mean;
  binStats['glob_sd'] = glob_sd;
  binStats['binUpBounds'] = binUpBounds;
  binStats['binLowBounds'] = binLowBounds;
  binStats['binMeans'] = binMeans;
  binStats['binLabels'] = binLabels;
  return {
    'binStats': binStats
  };
}; // utility that takes arrays of seconds, values, and optionally levels, and produces a data structure for histogram data
// processing. Used in the initial histogram DB query and in matching.


var sortHistogramBins = function (curveSubStats, curveSubSecs, curveSubLevs, binNum, masterBinStats, hasLevels, d) {
  // need maps to hold the sub values and seconds (and levels) for each bin, after the bin bounds are calculated.
  var binSubStats = {};
  var binSubSecs = {};
  var binSubLevs = {};

  for (var b_idx = 0; b_idx < binNum; b_idx++) {
    binSubStats[b_idx] = [];
    binSubSecs[b_idx] = [];
    binSubLevs[b_idx] = [];
  } // calculate the global stats across all of the data


  var globalStats;

  if (hasLevels) {
    globalStats = get_err(curveSubStats, curveSubSecs, curveSubLevs);
  } else {
    globalStats = get_err(curveSubStats, curveSubSecs, []);
  }

  var glob_mean = globalStats.d_mean;
  var glob_sd = globalStats.sd;
  var glob_n = globalStats.n_good;
  var glob_max = globalStats.maxVal;
  var glob_min = globalStats.minVal; // sort data into bins

  var binUpBounds = masterBinStats.binUpBounds;
  var binLowBounds = masterBinStats.binLowBounds;
  var binMeans = masterBinStats.binMeans;
  var binLabels = masterBinStats.binLabels;

  for (var d_idx = 0; d_idx < curveSubStats.length; d_idx++) {
    // iterate through all of the bins until we find one where the upper limit is greater than our datum.
    for (b_idx = 0; b_idx < binNum; b_idx++) {
      if (curveSubStats[d_idx] <= binUpBounds[b_idx]) {
        binSubStats[b_idx].push(curveSubStats[d_idx]);
        binSubSecs[b_idx].push(curveSubSecs[d_idx]);

        if (hasLevels) {
          binSubLevs[b_idx].push(curveSubLevs[d_idx]);
        }

        break;
      }
    }
  } // calculate the statistics for each bin
  // we are especially interested in the number of values in each bin, as that is the plotted stat in a histogram


  var binStats;
  var bin_mean;
  var bin_sd;
  var bin_n;
  var bin_rf;
  var sum = 0;
  var count = 0;

  for (b_idx = 0; b_idx < binNum; b_idx++) {
    if (hasLevels) {
      binStats = get_err(binSubStats[b_idx], binSubSecs[b_idx], binSubLevs[b_idx]);
    } else {
      binStats = get_err(binSubStats[b_idx], binSubSecs[b_idx], []);
    }

    bin_mean = binStats.d_mean;
    bin_sd = binStats.sd;
    bin_n = binStats.n_good;
    bin_rf = bin_n / glob_n;
    /*
    var d = {// d will contain the curve data
        x: [], //placeholder
        y: [], //placeholder
        error_x: [], // unused
        error_y: [], // unused
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {}, // placeholder
        bin_stats: [], // placeholder
        text: [], //placeholder
        xmax: Number.MIN_VALUE,
        xmin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE
    };
    */

    d.x.push(binMeans[b_idx]);
    d.y.push(bin_n);
    d.subVals.push(binSubStats[b_idx]);
    d.subSecs.push(binSubSecs[b_idx]);
    d.bin_stats.push({
      'bin_mean': bin_mean,
      'bin_sd': bin_sd,
      'bin_n': bin_n,
      'bin_rf': bin_rf,
      'binLowBound': binLowBounds[b_idx],
      'binUpBound': binUpBounds[b_idx],
      'binLabel': binLabels[b_idx]
    });
    d.text.push(null);

    if (hasLevels) {
      d.subLevs.push(binSubLevs[b_idx]);
    } // set axis limits based on returned data


    if (d.y[b_idx] !== null) {
      sum = sum + d.y[b_idx];
      count++;
      d.ymin = d.ymin < d.y[b_idx] ? d.ymin : d.y[b_idx];
      d.ymax = d.ymax > d.y[b_idx] ? d.ymax : d.y[b_idx];
    }
  }

  d.glob_stats = {
    'glob_mean': glob_mean,
    'glob_sd': glob_sd,
    'glob_n': glob_n,
    'glob_max': glob_max,
    'glob_min': glob_min
  };
  d.xmin = d.x[0];
  d.xmax = d.x[binNum - 1];
  return {
    d: d
  };
}; // utility that takes the curve params for two contour plots and collapses them into the curve params for one diff contour.


var getDiffContourCurveParams = function (curves) {
  var newCurve = {};
  var curveKeys = Object.keys(curves[0]);
  var currKey;

  for (var ckidx = 0; ckidx < curveKeys.length; ckidx++) {
    currKey = curveKeys[ckidx];

    if (currKey === 'color') {
      newCurve['color'] = "rgb(255,165,0)";
    } else if (curves[0][currKey] === curves[1][currKey]) {
      newCurve[currKey] = curves[0][currKey];
    } else {
      newCurve[currKey] = curves[1][currKey] + "-" + curves[0][currKey];
    }
  }

  return [newCurve];
}; //used for sorting arrays


var sortFunction = function (a, b) {
  if (a[0] === b[0]) {
    return 0;
  } else {
    return a[0] < b[0] ? -1 : 1;
  }
};

module.exportDefault(matsDataUtils = {
  areObjectsEqual: areObjectsEqual,
  arrayContainsArray: arrayContainsArray,
  arrayContainsSubArray: arrayContainsSubArray,
  arraysEqual: arraysEqual,
  arrayUnique: arrayUnique,
  findArrayInSubArray: findArrayInSubArray,
  objectContainsObject: objectContainsObject,
  average: average,
  stdev: stdev,
  dateConvert: dateConvert,
  getDateRange: getDateRange,
  secsConvert: secsConvert,
  doAuthorization: doAuthorization,
  doColorScheme: doColorScheme,
  doCredentials: doCredentials,
  doRoles: doRoles,
  doSettings: doSettings,
  getPlotParamsFromStack: getPlotParamsFromStack,
  get_err: get_err,
  setHistogramParameters: setHistogramParameters,
  calculateHistogramBins: calculateHistogramBins,
  prescribeHistogramBins: prescribeHistogramBins,
  sortHistogramBins: sortHistogramBins,
  getDiffContourCurveParams: getDiffContourCurveParams,
  sortFunction: sortFunction
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_query_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_query_util.js                                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var matsDataUtils, matsTypes, matsCollections;
module.link("meteor/randyp:mats-common", {
  matsDataUtils: function (v) {
    matsDataUtils = v;
  },
  matsTypes: function (v) {
    matsTypes = v;
  },
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 0);
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 1);

//const Future = require('fibers/future');
//utility to get the cadence for a particular model, so that the query function
//knows where to include null points for missing data.
var getModelCadence = function (pool, dataSource, startDate, endDate) {
  var rows = [];
  var cycles;

  try {
    //this query should only return data if the model cadence is irregular.
    //otherwise, the cadence will be calculated later by the query function.
    rows = simplePoolQueryWrapSynchronous(pool, "select cycle_seconds " + "from mats_common.primary_model_orders " + "where model = " + "(select new_model as display_text from mats_common.standardized_model_list where old_model = '" + dataSource + "');");
    var cycles_raw = JSON.parse(rows[0].cycle_seconds);
    var cycles_keys = Object.keys(cycles_raw).sort(); //there can be difference cadences for different time periods (each time period is a key in cycles_keys,
    //with the cadences for that period represented as values in cycles_raw), so this section identifies all
    //time periods relevant to the requested date range, and returns the union of their cadences.

    if (cycles_keys.length !== 0) {
      var newTime;
      var chosenStartTime;
      var chosenEndTime;
      var chosenStartIdx;
      var chosenEndIdx;
      var foundStart = false;
      var foundEnd = false;

      for (var ti = cycles_keys.length - 1; ti >= 0; ti--) {
        newTime = cycles_keys[ti];

        if (startDate >= Number(newTime) && !foundStart) {
          chosenStartTime = newTime;
          chosenStartIdx = ti;
          foundStart = true;
        }

        if (endDate >= Number(newTime) && !foundEnd) {
          chosenEndTime = newTime;
          chosenEndIdx = ti;
          foundEnd = true;
        }

        if (foundStart && foundEnd) {
          break;
        }
      }

      if (chosenStartTime !== undefined && chosenEndTime !== undefined) {
        if (Number(chosenStartTime) === Number(chosenEndTime)) {
          cycles = cycles_raw[chosenStartTime];
        } else if (chosenEndIdx - chosenStartIdx === 1) {
          var startCycles = cycles_raw[chosenStartTime];
          var endCycles = cycles_raw[chosenEndTime];
          cycles = _.union(startCycles, endCycles);
        } else {
          var middleCycles = [];
          var currCycles;

          for (ti = chosenStartIdx + 1; ti < chosenEndIdx; ti++) {
            currCycles = cycles_raw[cycles_keys[ti]];
            middleCycles = _.union(middleCycles, currCycles);
          }

          var _startCycles = cycles_raw[chosenStartTime];
          var _endCycles = cycles_raw[chosenEndTime];
          cycles = _.union(_startCycles, _endCycles, middleCycles);
        }
      }
    }
  } catch (e) {//ignore - just a safety check, don't want to exit if there isn't a cycles_per_model entry
    //if there isn't a cycles_per_model entry, it just means that the model has a regular cadence
  }

  if (cycles !== null && cycles !== undefined && cycles.length > 0) {
    for (var c = 0; c < cycles.length; c++) {
      cycles[c] = cycles[c] * 1000; // convert to milliseconds
    }
  } else {
    cycles = []; //regular cadence model--cycles will be calculated later by the query function
  }

  return cycles;
}; //this function calculates the interval between the current time and the next time for irregular cadence models.


var getTimeInterval = function (avTime, time_interval, foreCastOffset, cycles) {
  //have to calculate the time_interval
  var ti;
  var dayInMilliSeconds = 24 * 3600 * 1000;
  var minCycleTime = Math.min.apply(Math, (0, _toConsumableArray2.default)(cycles));
  var thisCadence = avTime % dayInMilliSeconds; //current hour of day (valid time)

  if (Number(thisCadence) - Number(foreCastOffset) * 3600 * 1000 < 0) {
    //check to see if cycle time was on previous day -- if so, need to wrap around 00Z to get current hour of day (cycle time)
    thisCadence = Number(thisCadence) - Number(foreCastOffset) * 3600 * 1000 + dayInMilliSeconds; //current hour of day (cycle time)
  } else {
    thisCadence = Number(thisCadence) - Number(foreCastOffset) * 3600 * 1000; //current hour of day (cycle time)
  }

  var thisCadenceIdx = cycles.indexOf(thisCadence); //fnd our where the current hour of day is in the cycles array

  if (thisCadenceIdx !== -1) {
    var nextCadenceIdx = thisCadenceIdx + 1; //choose the next hour of the day

    if (nextCadenceIdx >= cycles.length) {
      ti = dayInMilliSeconds - thisCadence + minCycleTime; //if we were at the last cycle cadence, wrap back around to the first cycle cadence
    } else {
      ti = cycles[nextCadenceIdx] - cycles[thisCadenceIdx]; //otherwise take the difference between the current and next hours of the day.
    }
  } else {
    ti = time_interval; //if for some reason the current hour of the day isn't in the cycles array, default to the regular cadence interval
  }

  return ti;
}; //utility for querying the DB


var simplePoolQueryWrapSynchronous = function (pool, statement) {
  /*
   simple synchronous query of statement to the specified pool.
   params :
   pool - a predefined db pool (usually defined in main.js). i.e. wfip2Pool = mysql.createPool(wfip2Settings);
   statement - String - a valid sql statement
   actions - queries database and will wait until query returns.
   return: rowset - an array of rows
   throws: error
   */
  if (Meteor.isServer) {
    var Future = require('fibers/future');

    var queryWrap = Future.wrap(function (pool, statement, callback) {
      pool.query(statement, function (err, rows) {
        return callback(err, rows);
      });
    });
    return queryWrap(pool, statement).wait();
  }
}; //this method queries the database for timeseries plots


var queryDBTimeSeries = function (pool, statement, dataSource, forecastOffset, startDate, endDate, averageStr, validTimes, hasLevels, forceRegularCadence) {
  //upper air is only verified at 00Z and 12Z, so you need to force irregular models to verify at that regular cadence
  var Future = require('fibers/future');

  if (Meteor.isServer) {
    var plotParams = matsDataUtils.getPlotParamsFromStack();
    var completenessQCParam = Number(plotParams["completeness"]) / 100;
    var cycles = getModelCadence(pool, dataSource, startDate, endDate); // if irregular model cadence, get cycle times. If regular, get empty array.

    if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {
      var vtCycles = validTimes.map(function (x) {
        return (Number(x) - forecastOffset) * 3600 * 1000;
      }); // selecting validTimes makes the cadence irregular

      vtCycles = vtCycles.map(function (x) {
        return x < 0 ? x + 24 * 3600 * 1000 : x;
      }); // make sure no cycles are negative

      vtCycles = vtCycles.sort(function (a, b) {
        return Number(a) - Number(b);
      }); //sort 'em

      cycles = cycles.length > 0 ? _.intersection(cycles, vtCycles) : vtCycles; // if we already had cycles get the ones that correspond to valid times
    }

    var regular = forceRegularCadence || averageStr !== "None" || !(cycles !== null && cycles.length > 0); // If curves have averaging, the cadence is always regular, i.e. it's the cadence of the average

    var dFuture = new Future();
    var d = {
      // d will contain the curve data
      x: [],
      y: [],
      error_x: [],
      error_y: [],
      subVals: [],
      subSecs: [],
      subLevs: [],
      stats: [],
      text: [],
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE,
      sum: 0
    };
    var error = "";
    var N0 = [];
    var N_times = [];
    pool.query(statement, function (err, rows) {
      // query callback - build the curve data from the results - or set an error
      if (err !== undefined && err !== null) {
        error = err.message;
      } else if (rows === undefined || rows === null || rows.length === 0) {
        error = matsTypes.Messages.NO_DATA_FOUND;
      } else {
        var parsedData = parseQueryDataTimeSeries(pool, rows, d, completenessQCParam, hasLevels, averageStr, forecastOffset, cycles, regular);
        d = parsedData.d;
        N0 = parsedData.N0;
        N_times = parsedData.N_times;
        cycles = parsedData.cycles;
      } // done waiting - have results


      dFuture['return']();
    }); // wait for future to finish

    dFuture.wait();
    return {
      data: d,
      error: error,
      N0: N0,
      N_times: N_times,
      averageStr: averageStr,
      cycles: cycles
    };
  }
}; //this method queries the database for specialty curves such as profiles, dieoffs, threshold plots, valid time plots, and histograms


var queryDBSpecialtyCurve = function (pool, statement, plotType, hasLevels) {
  if (Meteor.isServer) {
    var Future = require('fibers/future');

    var plotParams = matsDataUtils.getPlotParamsFromStack();
    var completenessQCParam = Number(plotParams["completeness"]) / 100;
    var appType = matsCollections.Settings.findOne({}).appType;
    var dFuture = new Future();
    var d = {
      // d will contain the curve data
      x: [],
      y: [],
      error_x: [],
      error_y: [],
      subVals: [],
      subSecs: [],
      subLevs: [],
      stats: [],
      text: [],
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE,
      sum: 0
    };
    var error = "";
    var N0 = [];
    var N_times = [];
    pool.query(statement, function (err, rows) {
      // query callback - build the curve data from the results - or set an error
      if (err !== undefined && err !== null) {
        error = err.message;
      } else if (rows === undefined || rows === null || rows.length === 0) {
        error = matsTypes.Messages.NO_DATA_FOUND;
      } else {
        var parsedData;

        if (plotType !== matsTypes.PlotTypes.histogram) {
          parsedData = parseQueryDataSpecialtyCurve(rows, d, completenessQCParam, plotType, appType, hasLevels);
        } else {
          parsedData = parseQueryDataHistogram(d, rows, hasLevels);
        }

        d = parsedData.d;
        N0 = parsedData.N0;
        N_times = parsedData.N_times;
      }

      dFuture['return']();
    }); // wait for future to finish

    dFuture.wait();
    return {
      data: d,
      error: error,
      N0: N0,
      N_times: N_times
    };
  }
}; //this method queries the database for map plots


var queryMapDB = function (pool, statement, dataSource, variable, varUnits, siteMap) {
  if (Meteor.isServer) {
    // d will contain the curve data
    var d = {
      siteName: [],
      queryVal: [],
      lat: [],
      lon: [],
      color: [],
      stats: [],
      text: []
    }; // for biases <= -1

    var dBlue = {
      siteName: [],
      queryVal: [],
      lat: [],
      lon: [],
      stats: [],
      text: [],
      color: "rgb(0,0,255)"
    }; // for biases > -1 and < 1

    var dBlack = {
      siteName: [],
      queryVal: [],
      lat: [],
      lon: [],
      stats: [],
      text: [],
      color: "rgb(0,0,0)"
    }; // for biases >= 1

    var dRed = {
      siteName: [],
      queryVal: [],
      lat: [],
      lon: [],
      stats: [],
      text: [],
      color: "rgb(255,0,0)"
    };
    var error = "";

    var Future = require('fibers/future');

    var pFuture = new Future();
    pool.query(statement, function (err, rows) {
      // query callback - build the curve data from the results - or set an error
      if (err !== undefined && err !== null) {
        error = err.message;
      } else if (rows === undefined || rows === null || rows.length === 0) {
        error = matsTypes.Messages.NO_DATA_FOUND;
      } else {
        var queryVal;

        var _loop = function () {
          var site = rows[rowIndex].sta_name;
          queryVal = rows[rowIndex].model_ob_diff;
          d.siteName.push(site);
          d.queryVal.push(queryVal);
          d.stats.push({
            N_times: rows[rowIndex].N_times,
            min_time: rows[rowIndex].min_time,
            max_time: rows[rowIndex].max_time
          });
          tooltips = site + "<br>" + "variable: " + variable + "<br>" + "model: " + dataSource + "<br>" + "model-obs: " + queryVal + " " + varUnits + "<br>" + "n: " + rows[rowIndex].N_times;
          d.text.push(tooltips);
          thisSite = siteMap.find(function (obj) {
            return obj.name === site;
          });
          d.lat.push(thisSite.point[0]);
          d.lon.push(thisSite.point[1]);
          textMarker = queryVal === null ? "" : queryVal.toFixed(0);

          if (queryVal <= -1) {
            d.color.push("rgb(0,0,255)");
            dBlue.siteName.push(site);
            dBlue.queryVal.push(queryVal);
            dBlue.text.push(textMarker);
            dBlue.lat.push(thisSite.point[0]);
            dBlue.lon.push(thisSite.point[1]);
          } else if (queryVal >= 1) {
            d.color.push("rgb(255,0,0)");
            dRed.siteName.push(site);
            dRed.queryVal.push(queryVal);
            dRed.text.push(textMarker);
            dRed.lat.push(thisSite.point[0]);
            dRed.lon.push(thisSite.point[1]);
          } else {
            d.color.push("rgb(0,0,0)");
            dBlack.siteName.push(site);
            dBlack.queryVal.push(queryVal);
            dBlack.text.push(textMarker);
            dBlack.lat.push(thisSite.point[0]);
            dBlack.lon.push(thisSite.point[1]);
          }
        };

        for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
          var tooltips;
          var thisSite;
          var textMarker;

          _loop();
        } // end of loop row

      } // done waiting - have results


      pFuture['return']();
    }); // wait for future to finish

    pFuture.wait();
    return {
      data: d,
      // [sub_values,sub_secs] as arrays
      dataBlue: dBlue,
      // [sub_values,sub_secs] as arrays
      dataBlack: dBlack,
      // [sub_values,sub_secs] as arrays
      dataRed: dRed,
      // [sub_values,sub_secs] as arrays
      error: error
    };
  }
}; //this method queries the database for contour plots


var queryDBContour = function (pool, statement) {
  if (Meteor.isServer) {
    var Future = require('fibers/future');

    var dFuture = new Future();
    var d = {
      // d will contain the curve data
      x: [],
      y: [],
      z: [],
      n: [],
      text: [],
      xTextOutput: [],
      yTextOutput: [],
      zTextOutput: [],
      nTextOutput: [],
      minDateTextOutput: [],
      maxDateTextOutput: [],
      stats: [],
      glob_stats: {},
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE,
      zmin: Number.MAX_VALUE,
      zmax: Number.MIN_VALUE,
      sum: 0
    };
    var error = "";
    pool.query(statement, function (err, rows) {
      // query callback - build the curve data from the results - or set an error
      if (err !== undefined && err !== null) {
        error = err.message;
      } else if (rows === undefined || rows === null || rows.length === 0) {
        error = matsTypes.Messages.NO_DATA_FOUND;
      } else {
        var parsedData = parseQueryDataContour(rows, d);
        d = parsedData.d;
      }

      dFuture['return']();
    }); // wait for future to finish

    dFuture.wait();
    return {
      data: d,
      error: error
    };
  }
}; //this method parses the returned query data for timeseries plots


var parseQueryDataTimeSeries = function (pool, rows, d, completenessQCParam, hasLevels, averageStr, foreCastOffset, cycles, regular) {
  /*
      var d = {// d will contain the curve data
          x: [],
          y: [],
          error_x: [],   // curveTime
          error_y: [],   // values
          subVals: [],   //subVals
          subSecs: [],   //subSecs
          subLevs: [],   //subLevs
          stats: [],     //pointStats
          text: [],
          glob_stats: {},     //curveStats
          xmin: Number.MAX_VALUE,
          xmax: Number.MIN_VALUE,
          ymin: Number.MAX_VALUE,
          ymax: Number.MIN_VALUE,
          sum: 0
      };
  */
  d.error_x = null; // time series doesn't use x errorbars

  var N0 = [];
  var N_times = [];
  var xmax = Number.MIN_VALUE;
  var xmin = Number.MAX_VALUE;
  var curveTime = [];
  var curveStats = [];
  var subVals = [];
  var subSecs = [];
  var subLevs = [];
  var time_interval = rows.length > 1 ? Number(rows[1].avtime) - Number(rows[0].avtime) : undefined; //calculate a base time interval -- will be used if data is regular

  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var avSeconds = Number(rows[rowIndex].avtime);
    var avTime = avSeconds * 1000;
    xmin = avTime < xmin ? avTime : xmin;
    xmax = avTime > xmax ? avTime : xmax;
    var stat = rows[rowIndex].stat;
    N0.push(rows[rowIndex].N0); // number of values that go into a time series point

    N_times.push(rows[rowIndex].N_times); // number of times that go into a time series point
    // find the minimum time_interval. For regular models, this will differ from the previous time_interval
    // if the interval was artificially large due to missing values. For irregular models, we need the minimum
    // interval to be sure we don't accidentally go past the next data point.

    if (rowIndex < rows.length - 1) {
      var time_diff = Number(rows[rowIndex + 1].avtime) - Number(rows[rowIndex].avtime);

      if (time_diff < time_interval) {
        time_interval = time_diff;
      }
    } // store sub values that will later be used for calculating error bar statistics.


    var sub_values = [];
    var sub_secs = [];
    var sub_levs = [];

    if (stat !== null && stat !== "NULL" && rows[rowIndex].sub_data !== undefined) {
      try {
        var sub_data = rows[rowIndex].sub_data.toString().split(',');
        var curr_sub_data;

        for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {
          curr_sub_data = sub_data[sd_idx].split(';');
          sub_values.push(Number(curr_sub_data[0]));
          sub_secs.push(Number(curr_sub_data[1]));

          if (hasLevels) {
            if (!isNaN(Number(curr_sub_data[2]))) {
              sub_levs.push(Number(curr_sub_data[2]));
            } else {
              sub_levs.push(curr_sub_data[2]);
            }
          }
        }
      } catch (e) {
        // this is an error produced by a bug in the query function, not an error returned by the mysql database
        e.message = "Error in parseQueryDataTimeSeries. The expected fields don't seem to be present in the results cache: " + e.message;
        throw new Error(e.message);
      }
    } else {
      sub_values = NaN;
      sub_secs = NaN;

      if (hasLevels) {
        sub_levs = NaN;
      }
    }

    curveTime.push(avTime);
    curveStats.push(stat);
    subVals.push(sub_values);
    subSecs.push(sub_secs);

    if (hasLevels) {
      subLevs.push(sub_levs);
    }
  }

  var N0_max = Math.max.apply(Math, N0);
  var N_times_max = Math.max.apply(Math, N_times);

  if (xmin < Number(rows[0].avtime) * 1000 || averageStr !== "None") {
    xmin = Number(rows[0].avtime) * 1000;
  }

  time_interval = time_interval * 1000;
  var loopTime = xmin;
  var sum = 0;

  while (loopTime <= xmax) {
    var d_idx = curveTime.indexOf(loopTime);

    if (d_idx < 0) {
      if (hasLevels) {
        //d.push([loopTime, null, -1, NaN, NaN, NaN]);// add a null for missing data
        d.x.push(loopTime);
        d.y.push(null); //d.error_x not used

        d.error_y.push(null); //placeholder

        d.subVals.push(NaN);
        d.subSecs.push(NaN);
        d.subLevs.push(NaN);
      } else {
        //d.push([loopTime, null, -1, NaN, NaN]);     // add a null for missing data
        d.x.push(loopTime);
        d.y.push(null); //d.error_x not used

        d.error_y.push(null); //placeholder

        d.subVals.push(NaN);
        d.subSecs.push(NaN);
      }
    } else {
      var this_N0 = N0[d_idx];
      var this_N_times = N_times[d_idx]; // Make sure that we don't have any points with far less data than the rest of the graph, and that
      // we don't have any points with a smaller completeness value than specified by the user.

      if (this_N0 < 0.1 * N0_max || this_N_times < completenessQCParam * N_times_max) {
        if (hasLevels) {
          //                    d.push([loopTime, null, -1, NaN, NaN, NaN]);     // add a null if this time doesn't pass QC
          d.x.push(loopTime);
          d.y.push(null); //d.error_x not used

          d.error_y.push(null); //placeholder

          d.subVals.push(NaN);
          d.subSecs.push(NaN);
          d.subLevs.push(NaN);
        } else {
          //                    d.push([loopTime, null, -1, NaN, NaN]);     // add a null if this time doesn't pass QC
          d.x.push(loopTime);
          d.y.push(null); //d.error_x not used

          d.error_y.push(null); //placeholder

          d.subVals.push(NaN);
          d.subSecs.push(NaN);
        }
      } else {
        sum += curveStats[d_idx];

        if (hasLevels) {
          //d.push([loopTime, curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);   // else add the real data
          d.x.push(loopTime);
          d.y.push(curveStats[d_idx]); //d.error_x not used

          d.error_y.push(null);
          d.subVals.push(subVals[d_idx]);
          d.subSecs.push(subSecs[d_idx]);
          d.subLevs.push(subLevs[d_idx]);
        } else {
          //d.push([loopTime, curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx]]);   // else add the real data
          d.x.push(loopTime);
          d.y.push(curveStats[d_idx]); //d.error_x not used

          d.error_y.push(null);
          d.subVals.push(subVals[d_idx]);
          d.subSecs.push(subSecs[d_idx]);
        }
      }
    }

    if (!regular) {
      // it is a model that has an irregular set of intervals, i.e. an irregular cadence
      time_interval = getTimeInterval(loopTime, time_interval, foreCastOffset, cycles); // the time interval most likely will not be the one calculated above
    }

    loopTime = loopTime + time_interval; // advance to the next time.
  }

  if (regular) {
    cycles = [time_interval]; // regular models will return one cycle cadence
  }

  var filteredx = d.x.filter(function (x) {
    return x;
  });
  var filteredy = d.y.filter(function (y) {
    return y;
  });
  d.xmin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  d.xmax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  d.ymin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  d.ymax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  d.sum = sum;

  if (d.xmin == "-Infinity" || d.x.indexOf(0) !== -1 && 0 < d.xmin) {
    d.xmin = 0;
  }

  if (d.ymin == "-Infinity" || d.y.indexOf(0) !== -1 && 0 < d.ymin) {
    d.ymin = 0;
  }

  if (d.xmax == "-Infinity") {
    d.xmax = 0;
  }

  if (d.ymax == "-Infinity") {
    d.ymax = 0;
  }

  return {
    d: d,
    N0: N0,
    N_times: N_times,
    cycles: cycles
  };
}; //this method parses the returned query data for specialty curves such as profiles, dieoffs, threshold plots, and valid time plots


var parseQueryDataSpecialtyCurve = function (rows, d, completenessQCParam, plotType, appType, hasLevels) {
  /*
      var d = {// d will contain the curve data
          x: [],
          y: [],
          error_x: [],   // curveTime
          error_y: [],   // values
          subVals: [],   //subVals
          subSecs: [],   //subSecs
          subLevs: [],   //subLevs
          stats: [],     //pointStats
          text: [],
          glob_stats: {},     //curveStats
          xmin:num,
          ymin:num,
          xmax:num,
          ymax:num,
          sum:num;
      };
  */
  var N0 = [];
  var N_times = [];
  var curveIndependentVars = [];
  var curveStats = [];
  var subVals = [];
  var subSecs = [];
  var subLevs = [];

  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var independentVar;

    if (plotType === matsTypes.PlotTypes.validtime) {
      independentVar = Number(rows[rowIndex].hr_of_day);
    } else if (plotType === matsTypes.PlotTypes.profile) {
      independentVar = Number(rows[rowIndex].avVal.toString().replace('P', ''));
    } else if (plotType === matsTypes.PlotTypes.dailyModelCycle) {
      independentVar = Number(rows[rowIndex].avtime) * 1000;
    } else {
      independentVar = Number(rows[rowIndex].avtime);
    }

    var stat = rows[rowIndex].stat;
    N0.push(rows[rowIndex].N0); // number of values that go into a point on the graph

    N_times.push(rows[rowIndex].N_times); // number of times that go into a point on the graph

    var sub_stats = [];
    var sub_secs = [];
    var sub_levs = [];

    if (stat !== null && stat !== "NULL" && rows[rowIndex].sub_data !== undefined) {
      try {
        var sub_data = rows[rowIndex].sub_data.toString().split(',');
        var curr_sub_data;

        for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {
          curr_sub_data = sub_data[sd_idx].split(';');
          sub_stats.push(Number(curr_sub_data[0]));
          sub_secs.push(Number(curr_sub_data[1]));

          if (hasLevels) {
            if (!isNaN(Number(curr_sub_data[2]))) {
              sub_levs.push(Number(curr_sub_data[2]));
            } else {
              sub_levs.push(curr_sub_data[2]);
            }
          }
        }
      } catch (e) {
        // this is an error produced by a bug in the query function, not an error returned by the mysql database
        e.message = "Error in parseQueryDataSpecialtyCurve. The expected fields don't seem to be present in the results cache: " + e.message;
        throw new Error(e.message);
      }
    } else {
      sub_stats = NaN;
      sub_secs = NaN;

      if (hasLevels) {
        sub_levs = NaN;
      }
    } // deal with missing forecast cycles for dailyModelCycle plot type


    if (plotType === matsTypes.PlotTypes.dailyModelCycle && rowIndex > 0 && Number(independentVar) - Number(rows[rowIndex - 1].avtime * 1000) > 3600 * 24 * 1000) {
      var cycles_missing = Math.floor((Number(independentVar) - Number(rows[rowIndex - 1].avtime * 1000)) / (3600 * 24 * 1000));

      for (var missingIdx = cycles_missing; missingIdx > 0; missingIdx--) {
        curveIndependentVars.push(independentVar - 3600 * 24 * 1000 * missingIdx);
        curveStats.push(null);
        subVals.push(NaN);
        subSecs.push(NaN);

        if (hasLevels) {
          subLevs.push(NaN);
        }
      }
    }

    curveIndependentVars.push(independentVar);
    curveStats.push(stat);
    subVals.push(sub_stats);
    subSecs.push(sub_secs);

    if (hasLevels) {
      subLevs.push(sub_levs);
    }
  }

  var N0_max = Math.max.apply(Math, N0);
  var N_times_max = Math.max.apply(Math, N_times);
  var sum = 0;

  for (var d_idx = 0; d_idx < curveIndependentVars.length; d_idx++) {
    var this_N0 = N0[d_idx];
    var this_N_times = N_times[d_idx]; // Make sure that we don't have any points with far less data than the rest of the graph, and that
    // we don't have any points with a smaller completeness value than specified by the user.

    if (this_N0 < 0.05 * N0_max || this_N_times < completenessQCParam * N_times_max) {
      if (plotType === matsTypes.PlotTypes.profile) {
        // profile has the stat first, and then the independent var. The others have independent var and then stat.
        // this is in the pattern of x-plotted-variable, y-plotted-variable.
        //d.push([null, curveIndependentVars[d_idx], -1, NaN, NaN, NaN]);
        d.x.push(null);
        d.y.push(curveIndependentVars[d_idx]);
        d.error_x.push(null); // placeholder
        //d.error_y not used for profile

        d.subVals.push(NaN);
        d.subSecs.push(NaN);
        d.subLevs.push(NaN);
      } else if (plotType !== matsTypes.PlotTypes.dieoff) {
        // for dieoffs, we don't want to add a null for missing data. Just don't have a point for that FHR.
        if (hasLevels) {
          //d.push([curveIndependentVars[d_idx], null, -1, NaN, NaN, NaN]);
          d.x.push(curveIndependentVars[d_idx]);
          d.y.push(null); //d.error_x not used for curves other than profile

          d.error_y.push(null); // placeholder

          d.subVals.push(NaN);
          d.subSecs.push(NaN);
          d.subLevs.push(NaN);
        } else {
          //d.push([curveIndependentVars[d_idx], null, -1, NaN, NaN]);
          d.x.push(curveIndependentVars[d_idx]);
          d.y.push(null); //d.error_x not used for curves other than profile

          d.error_y.push(null); // placeholder

          d.subVals.push(NaN);
          d.subSecs.push(NaN);
        }
      }
    } else {
      // else add the real data
      sum += curveStats[d_idx];

      if (plotType === matsTypes.PlotTypes.profile) {
        // profile has the stat first, and then the independent var. The others have independent var and then stat.
        // this is in the pattern of x-plotted-variable, y-plotted-variable.
        //                d.push([curveStats[d_idx], curveIndependentVars[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);
        d.x.push(curveStats[d_idx]);
        d.y.push(curveIndependentVars[d_idx]);
        d.error_x.push(null); // placeholder
        //d.error_y not used for curves other than profile

        d.subVals.push(subVals[d_idx]);
        d.subSecs.push(subSecs[d_idx]);
        d.subLevs.push(subLevs[d_idx]);
      } else if (hasLevels) {
        //                d.push([curveIndependentVars[d_idx], curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);
        d.x.push(curveIndependentVars[d_idx]);
        d.y.push(curveStats[d_idx]); //d.error_x not used for curves other than profile

        d.error_y.push(null); // placeholder

        d.subVals.push(subVals[d_idx]);
        d.subSecs.push(subSecs[d_idx]);
        d.subLevs.push(subLevs[d_idx]);
      } else {
        //                d.push([curveIndependentVars[d_idx], curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx]]);
        d.x.push(curveIndependentVars[d_idx]);
        d.y.push(curveStats[d_idx]); //d.error_x not used for curves other than profile

        d.error_y.push(null); // placeholder

        d.subVals.push(subVals[d_idx]);
        d.subSecs.push(subSecs[d_idx]);
      }
    }
  } // the met levels are ordered as strings, so we need to re-sort them


  if (plotType === matsTypes.PlotTypes.profile && appType === matsTypes.AppTypes.metexpress) {
    var dSorted = [];

    for (var didx = 0; didx < d.y.length; didx++) {
      dSorted.push({
        y: d.y[didx],
        x: d.x[didx],
        error_x: d.error_x[didx],
        subVals: d.subVals[didx],
        subSecs: d.subSecs[didx],
        subLevs: d.subLevs[didx]
      });
    }

    d.y = [];
    d.x = [];
    d.error_x = [];
    d.subVals = [];
    d.subSecs = [];
    d.subLevs = [];
    dSorted.sort(function (a, b) {
      return a.y - b.y;
    });
    dSorted.map(function (elem) {
      d.y.push(elem.y);
      d.x.push(elem.x);
      d.error_x.push(elem.error_x);
      d.subVals.push(elem.subVals);
      d.subSecs.push(elem.subSecs);
      d.subLevs.push(elem.subLevs);
    });
  }

  var filteredx = d.x.filter(function (x) {
    return x;
  });
  var filteredy = d.y.filter(function (y) {
    return y;
  });
  d.xmin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  d.xmax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  d.ymin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  d.ymax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  d.sum = sum;

  if (d.xmin == "-Infinity" || d.x.indexOf(0) !== -1 && 0 < d.xmin) {
    d.xmin = 0;
  }

  if (d.ymin == "-Infinity" || d.y.indexOf(0) !== -1 && 0 < d.ymin) {
    d.ymin = 0;
  }

  if (d.xmax == "-Infinity") {
    d.xmax = 0;
  }

  if (d.ymax == "-Infinity") {
    d.ymax = 0;
  }

  return {
    d: d,
    N0: N0,
    N_times: N_times
  };
}; // this method parses the returned query data for histograms


var parseQueryDataHistogram = function (d, rows, hasLevels) {
  /*
      var d = {// d will contain the curve data
          x: [], //placeholder
          y: [], //placeholder
          error_x: [], // unused
          error_y: [], // unused
          subVals: [],
          subSecs: [],
          subLevs: [],
          glob_stats: [], // placeholder
          bin_stats: [], // placeholder
          text: [] //placeholder
          xmin:num,
          xmax:num,
          ymin:num,
          ymax:num
      };
  */
  // these arrays hold all the sub values and seconds (and levels) until they are sorted into bins
  var curveSubStatsRaw = [];
  var curveSubSecsRaw = [];
  var curveSubLevsRaw = []; // parse the data returned from the query

  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var stat = rows[rowIndex].stat;
    var sub_stats = [];
    var sub_secs = [];
    var sub_levs = [];

    if (stat !== null && stat !== "NULL" && rows[rowIndex].sub_data !== undefined) {
      try {
        var sub_data = rows[rowIndex].sub_data.toString().split(',');
        var curr_sub_data;

        for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {
          curr_sub_data = sub_data[sd_idx].split(';');
          sub_stats.push(Number(curr_sub_data[0]));
          sub_secs.push(Number(curr_sub_data[1]));

          if (hasLevels) {
            if (!isNaN(Number(curr_sub_data[2]))) {
              sub_levs.push(Number(curr_sub_data[2]));
            } else {
              sub_levs.push(curr_sub_data[2]);
            }
          }

          curveSubLevsRaw.push(sub_levs);
        }

        curveSubStatsRaw.push(sub_stats);
        curveSubSecsRaw.push(sub_secs);
      } catch (e) {
        // this is an error produced by a bug in the query function, not an error returned by the mysql database
        e.message = "Error in parseQueryDataHistogram. The expected fields don't seem to be present in the results cache: " + e.message;
        throw new Error(e.message);
      }
    }
  } // we don't have bins yet, so we want all of the data in one array


  var subVals = [].concat.apply([], curveSubStatsRaw);
  var subSecs = [].concat.apply([], curveSubSecsRaw);
  var subLevs;

  if (hasLevels) {
    subLevs = [].concat.apply([], curveSubLevsRaw);
  }

  d.subVals = subVals;
  d.subSecs = subSecs;
  d.subLevs = subLevs;
  return {
    d: d,
    N0: subVals.length,
    N_times: subSecs.length
  };
}; //this method parses the returned query data for contour plots


var parseQueryDataContour = function (rows, d) {
  /*
      var d = {// d will contain the curve data
          x: [],
          y: [],
          z: [],
          n: [],
          text: [],
          xTextOutput: [],
          yTextOutput: [],
          zTextOutput: [],
          nTextOutput: [],
          minDateTextOutput: [],
          maxDateTextOutput: [],
          stats: []],
          glob_stats: {},
          xmin:num,
          ymin:num,
          zmin:num,
          xmax:num,
          ymax:num,
          zmax:num,
          sum:num
      };
  */
  var curveStatLookup = {};
  var curveNLookup = {}; // get all the data out of the query array

  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var rowXVal = rows[rowIndex].xVal;
    var rowYVal = rows[rowIndex].yVal;
    var statKey = rowXVal.toString() + '_' + rowYVal.toString();
    var stat = rows[rowIndex].stat;
    var n = rows[rowIndex].sub_data !== null ? rows[rowIndex].sub_data.toString().split(',').length : 0;
    var minDate = rows[rowIndex].min_secs;
    var maxDate = rows[rowIndex].max_secs;

    if (stat === undefined || stat === null || stat === 'NULL') {
      stat = null;
      n = 0;
      minDate = null;
      maxDate = null;
    } // store flat arrays of all the parsed data, used by the text output and for some calculations later


    d.xTextOutput.push(Number(rowXVal));
    d.yTextOutput.push(Number(rowYVal));
    d.zTextOutput.push(stat);
    d.nTextOutput.push(n);
    d.minDateTextOutput.push(minDate);
    d.maxDateTextOutput.push(maxDate);
    curveStatLookup[statKey] = stat;
    curveNLookup[statKey] = n;
  } // get the unique x and y values and sort the stats into the 2D z array accordingly


  d.x = matsDataUtils.arrayUnique(d.xTextOutput).sort(function (a, b) {
    return a - b;
  });
  d.y = matsDataUtils.arrayUnique(d.yTextOutput).sort(function (a, b) {
    return a - b;
  });
  var i;
  var j;
  var currX;
  var currY;
  var currStat;
  var currN;
  var currStatKey;
  var currYStatArray;
  var currYNArray;
  var sum = 0;
  var nPoints = 0;

  for (j = 0; j < d.y.length; j++) {
    currY = d.y[j];
    currYStatArray = [];
    currYNArray = [];

    for (i = 0; i < d.x.length; i++) {
      currX = d.x[i];
      currStatKey = currX.toString() + '_' + currY.toString();
      currStat = curveStatLookup[currStatKey];
      currN = curveNLookup[currStatKey];

      if (currStat === undefined) {
        currYStatArray.push(null);
        currYNArray.push(0);
      } else {
        sum += currStat;
        nPoints = nPoints + 1;
        currYStatArray.push(currStat);
        currYNArray.push(currN);
      }
    }

    d.z.push(currYStatArray);
    d.n.push(currYNArray);
  } // calculate statistics


  var filteredx = d.x.filter(function (x) {
    return x;
  });
  var filteredy = d.y.filter(function (y) {
    return y;
  });
  var filteredz = d.zTextOutput.filter(function (z) {
    return z;
  });
  d.xmin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  d.xmax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  d.ymin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  d.ymax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  d.zmin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredz));
  d.zmax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredz));
  d.sum = sum;

  if (d.xmin == "-Infinity" || d.x.indexOf(0) !== -1 && 0 < d.xmin) {
    d.xmin = 0;
  }

  if (d.ymin == "-Infinity" || d.y.indexOf(0) !== -1 && 0 < d.ymin) {
    d.ymin = 0;
  }

  if (d.zmin == "-Infinity" || d.zTextOutput.indexOf(0) !== -1 && 0 < d.zmin) {
    d.zmin = 0;
  }

  if (d.xmax == "-Infinity") {
    d.xmax = 0;
  }

  if (d.ymax == "-Infinity") {
    d.ymax = 0;
  }

  if (d.zmax == "-Infinity") {
    d.zmax = 0;
  }

  var filteredMinDate = d.minDateTextOutput.filter(function (t) {
    return t;
  });
  var filteredMaxDate = d.maxDateTextOutput.filter(function (t) {
    return t;
  });
  d.glob_stats['mean'] = sum / nPoints;
  d.glob_stats['minDate'] = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredMinDate));
  d.glob_stats['maxDate'] = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredMaxDate));
  d.glob_stats['n'] = nPoints;
  return {
    d: d
  };
};

module.exportDefault(matsDataQueryUtils = {
  simplePoolQueryWrapSynchronous: simplePoolQueryWrapSynchronous,
  queryDBTimeSeries: queryDBTimeSeries,
  queryDBSpecialtyCurve: queryDBSpecialtyCurve,
  queryMapDB: queryMapDB,
  queryDBContour: queryDBContour
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_diff_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_diff_util.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 2);

// returns the data for whichever curve has the larger interval in its independent variable
var getLargeIntervalCurveData = function (dataset, diffFrom, independentVarName) {
  var dataMaxInterval = Number.MIN_VALUE;
  var largeIntervalCurveData = dataset[diffFrom[0]]; // set up the indexes and determine the minimum independentVarName value for the dataset

  for (var ci = 0; ci < dataset.length; ci++) {
    if (dataset[ci][independentVarName] === undefined || dataset[ci][independentVarName].length === 0) {
      // one of the curves has no data. No match possible. Just use interval from first curve
      break;
    }

    if (dataset[ci][independentVarName].length > 1) {
      var diff;

      for (var di = 0; di < dataset[ci][independentVarName].length - 1; di++) {
        // don't go all the way to the end - one shy
        diff = dataset[ci][independentVarName][di + 1] - dataset[ci][independentVarName][di];

        if (diff > dataMaxInterval) {
          dataMaxInterval = diff;
          largeIntervalCurveData = dataset[ci];
        }
      }
    }
  }

  return largeIntervalCurveData;
}; // generates diff curves for all plot types that have diff curves.


var getDataForDiffCurve = function (dataset, diffFrom, plotType, hasLevels) {
  /*
   DATASET ELEMENTS:
      series: [data,data,data ...... ]   each data is itself an object
      d = {
          x: [],
          y: [],
          error_x: [],   // curveTime
          error_y: [],   // values
          subVals: [],   //subVals
          subSecs: [],   //subSecs
          subLevs: [],   //subLevs
          stats: [],     //pointStats
          text: [],
          glob_stats: {},     //curveStats
          xmin: Number.MAX_VALUE,
          xmax: Number.MIN_VALUE,
          ymin: Number.MAX_VALUE,
          ymax: Number.MIN_VALUE,
          sum: 0
      };
    NOTE -- for profiles, x is the statVarName and y is the independentVarName, because profiles plot the statVarName
      on the x axis and the independentVarName on the y axis.
   For histograms:
  DATASET ELEMENTS:
      series: [data,data,data ...... ]   each data is itself an array
      d = {
          x: [], //placeholder
          y: [], //placeholder
          error_x: [], // unused
          error_y: [], // unused
          subVals: [],
          subSecs: [],
          subLevs: [],
          glob_stats: [], // placeholder
          bin_stats: [], // placeholder
          text: [] //placeholder
      };
    */
  // determine whether data[0] or data[1] is the independent variable, and which is the stat value
  var independentVarName;
  var statVarName;

  if (plotType !== matsTypes.PlotTypes.profile) {
    independentVarName = 'x';
    statVarName = 'y';
  } else {
    independentVarName = 'y';
    statVarName = 'x';
  } // initialize variables


  var minuendData = dataset[diffFrom[0]];
  var subtrahendData = dataset[diffFrom[1]];
  var subtrahendIndex = 0;
  var minuendIndex = 0;
  var d;

  if (plotType !== matsTypes.PlotTypes.histogram) {
    d = {
      x: [],
      y: [],
      error_x: [],
      // curveTime
      error_y: [],
      // values
      subVals: [],
      //subVals
      subSecs: [],
      //subSecs
      subLevs: [],
      //subLevs
      glob_stats: [],
      stats: [],
      //curveStats
      text: [],
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE,
      sum: 0
    };
  } else {
    d = {
      x: [],
      y: [],
      error_x: [],
      error_y: [],
      subVals: [],
      subSecs: [],
      subLevs: [],
      glob_stats: {
        'glob_mean': null,
        'glob_sd': null,
        'glob_n': null,
        'glob_max': null,
        'glob_min': null
      },
      bin_stats: [],
      text: [],
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE
    };
  } // make sure neither curve is empty


  if (minuendData.x.length === 0 || subtrahendData.x.length === 0) {
    return {
      'dataset': d
    };
  } // this is a difference curve - we are differencing diffFrom[0] - diffFrom[1] based on the
  // independentVarName values of whichever has the largest interval
  // find the largest interval between diffFrom[0] curve and diffFrom[1] curve


  var largeIntervalCurveData = getLargeIntervalCurveData(dataset, diffFrom, independentVarName); // calculate the differences

  for (var largeIntervalCurveIndex = 0; largeIntervalCurveIndex < largeIntervalCurveData[independentVarName].length; largeIntervalCurveIndex++) {
    // make sure that we are actually on the same independentVarName value for each curve
    var subtrahendIndependentVar = subtrahendData[independentVarName][subtrahendIndex];
    var minuendIndependentVar = minuendData[independentVarName][minuendIndex];
    var largeIntervalIndependentVar = largeIntervalCurveData[independentVarName][largeIntervalCurveIndex]; // increment the minuendIndex until it reaches this iteration's largeIntervalIndependentVar

    var minuendChanged = false;

    while (largeIntervalIndependentVar > minuendIndependentVar && minuendIndex < minuendData[independentVarName].length - 1) {
      minuendIndependentVar = minuendData[independentVarName][++minuendIndex];
      minuendChanged = true;
    } // if the end of the curve was reached without finding the largeIntervalIndependentVar, increase the minuendIndex to trigger the end conditions.


    if (!minuendChanged && minuendIndex >= minuendData[independentVarName].length - 1) {
      ++minuendIndex;
    } // increment the subtrahendIndex until it reaches this iteration's largeIntervalIndependentVar


    var subtrahendChanged = false;

    while (largeIntervalIndependentVar > subtrahendIndependentVar && subtrahendIndex < subtrahendData[independentVarName].length - 1) {
      subtrahendIndependentVar = subtrahendData[independentVarName][++subtrahendIndex];
      subtrahendChanged = true;
    } // if the end of the curve was reached without finding the largeIntervalIndependentVar, increase the subtrahendIndex to trigger the end conditions.


    if (!subtrahendChanged && subtrahendIndex >= subtrahendData[independentVarName].length - 1) {
      ++subtrahendIndex;
    }

    var diffValue = null;
    var tempSubValsArray;
    var tempSubSecsArray;
    var tempSubLevsArray;

    if (minuendData[independentVarName][minuendIndex] !== undefined && subtrahendData[independentVarName][subtrahendIndex] !== undefined) {
      // make sure both curves actually have data at this index
      if (minuendData[statVarName][minuendIndex] !== null && subtrahendData[statVarName][subtrahendIndex] !== null && minuendData[independentVarName][minuendIndex] === subtrahendData[independentVarName][subtrahendIndex]) {
        // make sure data is not null at this point and the independentVars actually match
        diffValue = minuendData[statVarName][minuendIndex] - subtrahendData[statVarName][subtrahendIndex];
        d[independentVarName].push(largeIntervalIndependentVar);
        d[statVarName].push(diffValue);
        d.error_x.push(null);
        d.error_y.push(null);
        tempSubValsArray = [];
        tempSubSecsArray = [];

        if (hasLevels) {
          tempSubLevsArray = [];
        }

        if (plotType !== matsTypes.PlotTypes.histogram) {
          var minuendDataSubValues = minuendData.subVals[minuendIndex];
          var minuendDataSubSeconds = minuendData.subSecs[minuendIndex];

          if (hasLevels) {
            var minuendDataSubLevels = minuendData.subLevs[minuendIndex];
          }

          var subtrahendDataSubValues = subtrahendData.subVals[subtrahendIndex];
          var subtrahendDataSubSeconds = subtrahendData.subSecs[subtrahendIndex];

          if (hasLevels) {
            var subtrahendDataSubLevels = subtrahendData.subLevs[subtrahendIndex];
          } // find matching sub values and diff those


          for (var mvalIdx = 0; mvalIdx < minuendDataSubValues.length; mvalIdx++) {
            for (var svalIdx = 0; svalIdx < subtrahendDataSubValues.length; svalIdx++) {
              if (hasLevels && minuendDataSubSeconds[mvalIdx] === subtrahendDataSubSeconds[svalIdx] && minuendDataSubLevels[mvalIdx] === subtrahendDataSubLevels[svalIdx]) {
                tempSubValsArray.push(minuendDataSubValues[mvalIdx] - subtrahendDataSubValues[svalIdx]);
                tempSubSecsArray.push(minuendDataSubSeconds[mvalIdx]);
                tempSubLevsArray.push(minuendDataSubLevels[mvalIdx]);
              } else if (!hasLevels && minuendDataSubSeconds[mvalIdx] === subtrahendDataSubSeconds[svalIdx]) {
                tempSubValsArray.push(minuendDataSubValues[mvalIdx] - subtrahendDataSubValues[svalIdx]);
                tempSubSecsArray.push(minuendDataSubSeconds[mvalIdx]);
              }
            }
          }

          d.subVals.push(tempSubValsArray);
          d.subSecs.push(tempSubSecsArray);

          if (hasLevels) {
            d.subLevs.push(tempSubLevsArray);
          }

          d.sum = d.sum + d[independentVarName][largeIntervalCurveIndex];
        } else {
          d.bin_stats.push({
            'bin_mean': null,
            'bin_sd': null,
            'bin_n': diffValue,
            'bin_rf': minuendData.bin_stats[minuendIndex].bin_rf - subtrahendData.bin_stats[subtrahendIndex].bin_rf,
            'binLowBound': minuendData.bin_stats[minuendIndex].binLowBound,
            'binUpBound': minuendData.bin_stats[minuendIndex].binUpBound,
            'binLabel': minuendData.bin_stats[minuendIndex].binLabel
          });
        }
      } else {
        // no match for this independentVarName
        d[independentVarName].push(largeIntervalIndependentVar);
        d[statVarName].push(null);
        d.error_x.push(null);
        d.error_y.push(null);
        d.subVals.push([]);
        d.subSecs.push([]);

        if (hasLevels) {
          d.subLevs.push([]);
        }

        if (plotType === matsTypes.PlotTypes.histogram) {
          d.bin_stats.push({
            'bin_mean': null,
            'bin_sd': null,
            'bin_n': null,
            'bin_rf': null,
            'binLowBound': minuendData.bin_stats[minuendIndex].binLowBound,
            'binUpBound': minuendData.bin_stats[minuendIndex].binUpBound,
            'binLabel': minuendData.bin_stats[minuendIndex].binLabel
          });
        }
      }
    } else if (!subtrahendChanged && subtrahendIndex >= subtrahendData[independentVarName].length - 1 || !minuendChanged && minuendIndex >= minuendData[independentVarName].length - 1) {
      // we've reached the end of at least one curve, so end the diffing.
      break;
    }
  }

  var filteredx = d.x.filter(function (x) {
    return x;
  });
  var filteredy = d.y.filter(function (y) {
    return y;
  });
  d.xmin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  d.xmax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  d.ymin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  d.ymax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  return {
    'dataset': d
  };
}; // generates diff of two contours.


var getDataForDiffContour = function (dataset) {
  /*
   DATASET ELEMENTS:
      d[i] = {
          label: string,
          curveId: string,
          name: string,
          annotateColor: string,
          annotation: string,             -----
          x: [],                          *****
          y: [],                          *****
          z: [[]],                        *****
          n: [[]],                        *****
          text: [],
          stats: [],
          glob_stats: object,             -----
          type: string,
          autocontour: boolean,
          ncontours: number,
          colorbar: object,
          colorscale: string,
          reversescale: boolean,
          contours: object,
          marker: object,
          xAxisKey: [],
          yAxisKey: [],
          visible: boolean,
          xTextOutput: [],                *****
          yTextOutput: [],                *****
          zTextOutput: [],                *****
          nTextOutput: [],                *****
          maxDateTextOutput: [],          *****
          minDateTextOutput: [],          *****
          xmax: number,                   -----
          xmin: number,                   -----
          ymax: number,                   -----
          ymin: number,                   -----
          zmax: number,                   -----
          zmin: number,                   -----
          sum: number                     *****
      };
       ***** indicates calculation in loops
      ----- indicates calculation after loops
   */
  // initialize output object
  var diffDataset = {};
  diffDataset['label'] = dataset[1].label + '-' + dataset[0].label;
  diffDataset['curveId'] = dataset[1].curveId + '-' + dataset[0].curveId;
  diffDataset['name'] = dataset[1].name + '-' + dataset[0].name;
  diffDataset['annotateColor'] = "rgb(255,165,0)";
  diffDataset['annotation'] = "";
  diffDataset['text'] = [];
  diffDataset['type'] = dataset[0].type;
  diffDataset['marker'] = dataset[0].marker;
  diffDataset['xAxisKey'] = dataset[0].xAxisKey;
  diffDataset['yAxisKey'] = dataset[0].yAxisKey;
  diffDataset['visible'] = dataset[0].visible;
  diffDataset['x'] = [];
  diffDataset['y'] = [];
  diffDataset['z'] = [];
  diffDataset['n'] = [];
  diffDataset['xTextOutput'] = [];
  diffDataset['yTextOutput'] = [];
  diffDataset['zTextOutput'] = [];
  diffDataset['nTextOutput'] = [];
  diffDataset['maxDateTextOutput'] = [];
  diffDataset['minDateTextOutput'] = [];
  diffDataset['stats'] = [];
  diffDataset['glob_stats'] = {};
  diffDataset['xmax'] = -1 * Number.MAX_VALUE;
  diffDataset['xmin'] = Number.MAX_VALUE;
  diffDataset['ymax'] = -1 * Number.MAX_VALUE;
  diffDataset['ymin'] = Number.MAX_VALUE;
  diffDataset['zmax'] = -1 * Number.MAX_VALUE;
  diffDataset['zmin'] = Number.MAX_VALUE;
  diffDataset['sum'] = 0; // initialize local variables

  var minuendData = dataset[1];
  var subtrahendData = dataset[0]; // get common x and y

  diffDataset.x = _.intersection(minuendData.x, subtrahendData.x).sort(function (a, b) {
    return a - b;
  });
  diffDataset.y = _.intersection(minuendData.y, subtrahendData.y).sort(function (a, b) {
    return a - b;
  }); // make we actually have matches

  if (diffDataset.x.length === 0 || diffDataset.y.length === 0) {
    diffDataset.x = [];
    diffDataset.y = [];
    return [diffDataset];
  } // make sure neither dataset is empty


  if (minuendData.x.length === 0 || subtrahendData.x.length === 0 || minuendData.y.length === 0 || subtrahendData.y.length === 0) {
    return [diffDataset];
  }

  var minuendYIndex = 0;
  var subtrahendYIndex = 0;
  var nPoints = 0; // loop through common Ys

  for (var diffDataYIndex = 0; diffDataYIndex < diffDataset.y.length; diffDataYIndex++) {
    //make sure that we are actually on the same y value for each curve
    var diffDataY = diffDataset.y[diffDataYIndex];
    var minuendY = minuendData.y[minuendYIndex];
    var subtrahendY = subtrahendData.y[subtrahendYIndex]; //increment the minuendYIndex until it reaches this iteration's diffDataY

    while (diffDataY > minuendY && minuendYIndex < minuendData.y.length - 1) {
      minuendY = minuendData.y[++minuendYIndex];
    } //increment the subtrahendYIndex until it reaches this iteration's diffDataY


    while (diffDataY > subtrahendY && subtrahendYIndex < subtrahendData.y.length - 1) {
      subtrahendY = subtrahendData.y[++subtrahendYIndex];
    } // initialize n and z arrays for this Y


    diffDataset.z[diffDataYIndex] = [];
    diffDataset.n[diffDataYIndex] = [];
    var minuendXIndex = 0;
    var subtrahendXIndex = 0;

    for (var diffDataXIndex = 0; diffDataXIndex < diffDataset.x.length; diffDataXIndex++) {
      //make sure that we are actually on the same x value for each curve
      var diffDataX = diffDataset.x[diffDataXIndex];
      var minuendX = minuendData.x[minuendXIndex];
      var subtrahendX = subtrahendData.x[subtrahendXIndex]; //increment the minuendXIndex until it reaches this iteration's diffDataX

      while (diffDataX > minuendX && minuendXIndex < minuendData.x.length - 1) {
        minuendX = minuendData.x[++minuendXIndex];
      } //increment the subtrahendXIndex until it reaches this iteration's diffDataX


      while (diffDataX > subtrahendX && subtrahendXIndex < subtrahendData.x.length - 1) {
        subtrahendX = subtrahendData.x[++subtrahendXIndex];
      }

      var diffValue = null;
      var diffNumber = 0;
      var diffMinDate = null;
      var diffMaxDate = null;

      if (minuendData.z[minuendYIndex][minuendXIndex] !== undefined && subtrahendData.z[subtrahendYIndex][subtrahendXIndex] !== undefined && minuendData.z[minuendYIndex][minuendXIndex] !== null && subtrahendData.z[subtrahendYIndex][subtrahendXIndex] !== null && minuendX === subtrahendX && minuendY === subtrahendY) {
        // make sure both contours actually have data at these indices, data is not null at this point, and the x and y actually match
        // calculate the difference values
        diffValue = minuendData.z[minuendYIndex][minuendXIndex] - subtrahendData.z[subtrahendYIndex][subtrahendXIndex];
        diffNumber = minuendData.n[minuendYIndex][minuendXIndex] <= subtrahendData.n[subtrahendYIndex][subtrahendXIndex] ? minuendData.n[minuendYIndex][minuendXIndex] : subtrahendData.n[subtrahendYIndex][subtrahendXIndex];
        diffMinDate = minuendData.minDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] <= subtrahendData.minDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex] ? minuendData.minDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] : subtrahendData.minDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex];
        diffMaxDate = minuendData.maxDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] >= subtrahendData.maxDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex] ? minuendData.maxDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] : subtrahendData.maxDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex];
        diffDataset['sum'] += diffValue;
        nPoints = nPoints + 1;
      }

      diffDataset.z[diffDataYIndex].push(diffValue);
      diffDataset.n[diffDataYIndex].push(diffNumber);
      diffDataset.xTextOutput.push(diffDataX);
      diffDataset.yTextOutput.push(diffDataY);
      diffDataset.zTextOutput.push(diffValue);
      diffDataset.nTextOutput.push(diffNumber);
      diffDataset.minDateTextOutput.push(diffMinDate);
      diffDataset.maxDateTextOutput.push(diffMaxDate);
    }
  } // calculate statistics


  var filteredx = diffDataset.x.filter(function (x) {
    return x;
  });
  var filteredy = diffDataset.y.filter(function (y) {
    return y;
  });
  var filteredz = diffDataset.zTextOutput.filter(function (z) {
    return z;
  });
  diffDataset.xmin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  diffDataset.xmax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredx));
  diffDataset.ymin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  diffDataset.ymax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredy));
  diffDataset.zmin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredz));
  diffDataset.zmax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredz));

  if (diffDataset.xmin == "-Infinity" || diffDataset.x.indexOf(0) !== -1 && 0 < diffDataset.xmin) {
    diffDataset.xmin = 0;
  }

  if (diffDataset.ymin == "-Infinity" || diffDataset.y.indexOf(0) !== -1 && 0 < diffDataset.ymin) {
    diffDataset.ymin = 0;
  }

  if (diffDataset.zmin == "-Infinity" || diffDataset.zTextOutput.indexOf(0) !== -1 && 0 < diffDataset.zmin) {
    diffDataset.zmin = 0;
  }

  if (diffDataset.xmax == "-Infinity") {
    diffDataset.xmax = 0;
  }

  if (diffDataset.ymax == "-Infinity") {
    diffDataset.ymax = 0;
  }

  if (diffDataset.zmax == "-Infinity") {
    diffDataset.zmax = 0;
  }

  var filteredMinDate = diffDataset.minDateTextOutput.filter(function (t) {
    return t;
  });
  var filteredMaxDate = diffDataset.maxDateTextOutput.filter(function (t) {
    return t;
  });
  diffDataset.glob_stats['mean'] = diffDataset.sum / nPoints;
  diffDataset.glob_stats['minDate'] = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredMinDate));
  diffDataset.glob_stats['maxDate'] = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredMaxDate));
  diffDataset.glob_stats['n'] = nPoints;
  diffDataset['annotation'] = diffDataset.glob_stats.mean === undefined ? diffDataset.label + "- mean = NaN" : diffDataset.label + "- mean = " + diffDataset.glob_stats.mean.toPrecision(4); // make contours symmetrical around 0

  diffDataset['autocontour'] = false;
  diffDataset['ncontours'] = 15;
  diffDataset['colorbar'] = dataset[0].colorbar;
  diffDataset['colorbar']['title'] = dataset[0].colorbar.title === dataset[1].colorbar.title ? dataset[0].colorbar.title : dataset[1].colorbar.title + " - " + dataset[0].colorbar.title;
  diffDataset['colorscale'] = [[0, "rgb(5,10,172)"], [0.35, "rgb(106,137,247)"], [0.45, "rgb(255,255,255)"], [0.55, "rgb(255,255,255)"], [0.6, "rgb(220,170,132)"], [0.7, "rgb(230,145,90)"], [1, "rgb(178,10,28)"]];
  diffDataset['reversescale'] = dataset[0].reversescale;
  diffDataset['contours'] = dataset[0].contours;
  var maxZ = Math.abs(diffDataset.zmax) > Math.abs(diffDataset.zmin) ? Math.abs(diffDataset.zmax) : Math.abs(diffDataset.zmin);
  diffDataset['contours']['start'] = -1 * maxZ + 2 * maxZ / 16;
  diffDataset['contours']['end'] = maxZ - 2 * maxZ / 16;
  diffDataset['contours']['size'] = 2 * maxZ / 16;
  return [diffDataset];
};

module.exportDefault(matsDataDiffUtils = {
  getDataForDiffCurve: getDataForDiffCurve,
  getDataForDiffContour: getDataForDiffContour
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_match_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_match_util.js                                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsDataUtils;
module.link("meteor/randyp:mats-common", {
  matsDataUtils: function (v) {
    matsDataUtils = v;
  }
}, 0);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 1);

// function for removing unmatched data from a dataset containing multiple curves *without* levels
var getMatchedDataSet = function (dataset, curvesLength) {
  var subSecs = [];
  var subValues = [];
  var newSubSecs = [];
  var newSubValues = [];
  var independentVarGroups = [];
  var independentVarHasPoint = [];
  var currIndependentVar;
  var curveIndex;
  var data;
  var di;
  var fi;
  var si; // matching in this function is based on a curve's independent variable. For a timeseries, the independentVar is epoch,
  // for a profile, it's level, for a dieoff, it's forecast hour, for a threshold plot, it's threshold, and for a
  // valid time plot, it's hour of day. This function identifies the the independentVar values common across all of
  // the curves, and then the common sub times/levels/values for those independentVar values.
  // find the matching independentVars shared across all curves

  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // every curve
    independentVarGroups[curveIndex] = []; // store the independentVars for each curve that are not null

    independentVarHasPoint[curveIndex] = []; // store the *all* of the independentVars for each curve

    subSecs[curveIndex] = {}; // store the individual record times (subSecs) going into each independentVar for each curve

    data = dataset[curveIndex];

    for (di = 0; di < data.x.length; di++) {
      // loop over every independentVar value in this curve
      currIndependentVar = data.x[di];

      if (data.y[di] !== null) {
        subSecs[curveIndex][currIndependentVar] = data.subSecs[di]; // store raw secs for this independentVar value, since it's not a null point

        independentVarGroups[curveIndex].push(currIndependentVar); // store this independentVar value, since it's not a null point
      }

      independentVarHasPoint[curveIndex].push(currIndependentVar); // store all the independentVar values, regardless of whether they're null
    }
  }

  var matchingIndependentVars = _.intersection.apply(_, independentVarGroups); // find all of the non-null independentVar values common across all the curves


  var matchingIndependentHasPoint = _.intersection.apply(_, independentVarHasPoint); // find all of the independentVar values common across all the curves, regardless of whether or not they're null


  var subSecIntersection = {}; // eventually find the intersecting subSecs for each common non-null independentVar value

  for (fi = 0; fi < matchingIndependentVars.length; fi++) {
    // loop over each common non-null independentVar value
    currIndependentVar = matchingIndependentVars[fi];
    var currSubSecIntersection = subSecs[0][currIndependentVar]; // fill current subSecs intersection array with subSecs from the first curve

    for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {
      // loop over every curve
      currSubSecIntersection = _.intersection(currSubSecIntersection, subSecs[curveIndex][currIndependentVar]); // keep taking the intersection of the current subSecs intersection array with each curve's subSecs array for this independentVar value
    }

    subSecIntersection[currIndependentVar] = currSubSecIntersection; // store the final intersecting subSecs array for this common non-null independentVar value
  } // remove non-matching independentVars and subSecs


  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    data = dataset[curveIndex]; // need to loop backwards through the data array so that we can splice non-matching indices
    // while still having the remaining indices in the correct order

    var dataLength = data.x.length;

    for (di = dataLength - 1; di >= 0; di--) {
      if (matchingIndependentVars.indexOf(data.x[di]) === -1) {
        // if this is not a common non-null independentVar value, we'll have to remove some data
        if (matchingIndependentHasPoint.indexOf(data.x[di]) === -1) {
          // if at least one curve doesn't even have a null here, much less a matching value (beacause of the cadence), just drop this independentVar
          data.x.splice(di, 1);
          data.y.splice(di, 1);
          data.error_y.array.splice(di, 1);
          data.subVals.splice(di, 1);
          data.subSecs.splice(di, 1);
          data.stats.splice(di, 1);
          data.text.splice(di, 1);
        } else {
          // if all of the curves have either data or nulls at this independentVar, and there is at least one null, ensure all of the curves are null
          data.y[di] = null;
          data.subVals[di] = NaN;
          data.subSecs[di] = NaN;
        }

        continue; // then move on to the next independentVar. There's no need to mess with the subSecs
      }

      subSecs = data.subSecs[di];
      subValues = data.subVals[di];

      if (subSecs.length > 0) {
        currIndependentVar = data.x[di];
        newSubValues = [];
        newSubSecs = [];

        for (si = 0; si < subSecs.length; si++) {
          // loop over all subSecs for this independentVar
          if (subSecIntersection[currIndependentVar].indexOf(subSecs[si]) !== -1) {
            // keep the subValue only if its associated subSec is common to all curves for this independentVar
            var newVal = subValues[si];
            var newSec = subSecs[si];

            if (newVal !== undefined) {
              newSubValues.push(newVal);
              newSubSecs.push(newSec);
            }
          }
        } // store the filtered data


        data.subVals[di] = newSubValues;
        data.subSecs[di] = newSubSecs;
      }
    }

    dataset[curveIndex] = data;
  }

  return dataset;
}; // function for removing unmatched data from a dataset containing multiple curves *with* levels


var getMatchedDataSetWithLevels = function (dataset, curvesLength, plotType) {
  var subSecs = [];
  var subLevs = [];
  var subValues = [];
  var newSubSecs = [];
  var newSubLevs = [];
  var newSubValues = [];
  var independentVarGroups = [];
  var independentVarHasPoint = [];
  var currIndependentVar;
  var curveIndex;
  var data;
  var di;
  var fi;
  var si; // matching in this function is based on a curve's independent variable. For a timeseries, the independentVar is epoch,
  // for a profile, it's level, for a dieoff, it's forecast hour, for a threshold plot, it's threshold, and for a
  // valid time plot, it's hour of day. This function identifies the the independentVar values common across all of
  // the curves, and then the common sub times/levels/values for those independentVar values.
  //determine whether data.x or data.y is the independent variable, and which is the stat value

  var independentVarName;
  var statVarName;

  if (plotType !== matsTypes.PlotTypes.profile) {
    independentVarName = 'x';
    statVarName = 'y';
  } else {
    independentVarName = 'y';
    statVarName = 'x';
  }

  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // every curve
    independentVarGroups[curveIndex] = []; // store the independentVars for each curve that are not null

    independentVarHasPoint[curveIndex] = []; // store the *all* of the independentVars for each curve

    subSecs[curveIndex] = {}; // store the individual record times (subSecs) going into each independentVar for each curve

    subLevs[curveIndex] = {}; // store the individual record levels (subLevs) going into each independentVar for each curve

    data = dataset[curveIndex];

    for (di = 0; di < data[independentVarName].length; di++) {
      // loop over every independentVar value in this curve
      currIndependentVar = data[independentVarName][di];

      if (data[statVarName][di] !== null) {
        subSecs[curveIndex][currIndependentVar] = data.subSecs[di]; // store raw secs for this independentVar value, since it's not a null point

        subLevs[curveIndex][currIndependentVar] = data.subLevs[di]; // store raw levs for this independentVar value, since it's not a null point

        independentVarGroups[curveIndex].push(currIndependentVar); // store this independentVar value, since it's not a null point
      }

      independentVarHasPoint[curveIndex].push(currIndependentVar); // store all the independentVar values, regardless of whether they're null
    }
  }

  var matchingIndependentVars = _.intersection.apply(_, independentVarGroups); // find all of the non-null independentVar values common across all the curves


  var matchingIndependentHasPoint = _.intersection.apply(_, independentVarHasPoint); // find all of the independentVar values common across all the curves, regardless of whether or not they're null


  var subIntersections = []; // eventually find the intersecting subSecs and subLevs for each common non-null independentVar value

  for (fi = 0; fi < matchingIndependentVars.length; fi++) {
    // loop over each common non-null independentVar value
    currIndependentVar = matchingIndependentVars[fi];
    subIntersections[currIndependentVar] = [];
    var currSubIntersections = [];

    for (si = 0; si < subSecs[0][currIndependentVar].length; si++) {
      // fill current intersection array with sec-lev pairs from the first curve
      currSubIntersections.push([subSecs[0][currIndependentVar][si], subLevs[0][currIndependentVar][si]]);
    }

    for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {
      // loop over every curve after the first
      var tempSubIntersections = [];
      var tempPair;

      for (si = 0; si < subSecs[curveIndex][currIndependentVar].length; si++) {
        // loop over every subSecs value
        tempPair = [subSecs[curveIndex][currIndependentVar][si], subLevs[curveIndex][currIndependentVar][si]]; // create an individual sec-lev pair for each index in the subSecs and subLevs arrays

        if (matsDataUtils.arrayContainsSubArray(currSubIntersections, tempPair)) {
          // see if the individual sec-lev pair matches a pair from the current intersection array
          tempSubIntersections.push(tempPair); // store matching pairs
        }
      }

      currSubIntersections = tempSubIntersections; //replace current intersection array with array of only pairs that matched from this loop through.
    }

    subIntersections[currIndependentVar] = currSubIntersections; // store the final intersecting subSecs array for this common non-null independentVar value
  } // remove non-matching independentVars and subSecs


  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    data = dataset[curveIndex]; // need to loop backwards through the data array so that we can splice non-matching indices
    // while still having the remaining indices in the correct order

    var dataLength = data[independentVarName].length;

    for (di = dataLength - 1; di >= 0; di--) {
      if (matchingIndependentVars.indexOf(data[independentVarName][di]) === -1) {
        // if this is not a common non-null independentVar value, we'll have to remove some data
        if (matchingIndependentHasPoint.indexOf(data[independentVarName][di]) === -1) {
          // if at least one curve doesn't even have a null here, much less a matching value (beacause of the cadence), just drop this independentVar
          data.x.splice(di, 1);
          data.y.splice(di, 1);
          data['error_' + statVarName].array.splice(di, 1);
          data.subVals.splice(di, 1);
          data.subSecs.splice(di, 1);
          data.subLevs.splice(di, 1);
          data.stats.splice(di, 1);
          data.text.splice(di, 1);
        } else {
          // if all of the curves have either data or nulls at this independentVar, and there is at least one null, ensure all of the curves are null
          data[statVarName][di] = null;
          data.subVals[di] = NaN;
          data.subSecs[di] = NaN;
          data.subLevs[di] = NaN;
        }

        continue; // then move on to the next independentVar. There's no need to mess with the subSecs or subLevs
      }

      subSecs = data.subSecs[di];
      subLevs = data.subLevs[di];
      subValues = data.subVals[di];

      if (subSecs.length > 0 && subLevs.length > 0) {
        currIndependentVar = data[independentVarName][di];
        newSubValues = [];
        newSubSecs = [];
        newSubLevs = [];

        for (si = 0; si < subSecs.length; si++) {
          // loop over all subSecs for this independentVar
          tempPair = [subSecs[si], subLevs[si]]; //create sec-lev pair for each sub value

          if (matsDataUtils.arrayContainsSubArray(subIntersections[currIndependentVar], tempPair)) {
            // keep the subValue only if its sec-lev pair is common to all curves for this independentVar
            var newVal = subValues[si];
            var newSec = subSecs[si];
            var newLev = subLevs[si];

            if (newVal !== undefined) {
              newSubValues.push(newVal);
              newSubSecs.push(newSec);
              newSubLevs.push(newLev);
            }
          }
        } // store the filtered data


        data.subVals[di] = newSubValues;
        data.subSecs[di] = newSubSecs;
        data.subLevs[di] = newSubLevs;
      }
    }

    dataset[curveIndex] = data;
  }

  return dataset;
}; // function for removing unmatched data from a dataset containing multiple curves for a histogram *without* levels.
// separate matching functions are needed for histograms because you have to take all of the data out of the bins, then
// match it, then recalculate the bins. For other plot types, you can just leave the data in its already-sorted fhr, level, etc.


var getMatchedDataSetHistogram = function (dataset, curvesLength, binStats) {
  var subStatsRaw = {};
  var subSecsRaw = {};
  var subStats = {};
  var subSecs = {};
  var newSubStats = {};
  var newSubSecs = {};
  var newCurveData;
  var curveIndex;
  var di;
  var si; // pull all subSecs and subStats out of their bins, and back into one master array

  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    data = dataset[curveIndex];
    subStatsRaw[curveIndex] = [];
    subSecsRaw[curveIndex] = [];
    subStats[curveIndex] = [];
    subSecs[curveIndex] = [];

    for (di = 0; di < data.x.length; di++) {
      subStatsRaw[curveIndex].push(data.subVals[di]);
      subSecsRaw[curveIndex].push(data.subSecs[di]);
    }

    subStats[curveIndex] = [].concat.apply([], subStatsRaw[curveIndex]);
    subSecs[curveIndex] = [].concat.apply([], subSecsRaw[curveIndex]);
  } // determine which seconds are present in all curves


  var subSecIntersection = subSecs[0]; // fill current subSecs intersection array with subSecs from the first curve

  for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    subSecIntersection = _.intersection(subSecIntersection, subSecs[curveIndex]); // keep taking the intersection of the current subSecs intersection array with each curve's subSecs array
  } // remove non-matching subSecs and subStats


  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    data = dataset[curveIndex];

    if (subSecIntersection.length > 0) {
      newSubStats[curveIndex] = [];
      newSubSecs[curveIndex] = [];

      for (si = 0; si < subSecs[curveIndex].length; si++) {
        // loop over all subSecs for this curve
        if (subSecIntersection.indexOf(subSecs[curveIndex][si]) !== -1) {
          // keep the subStat only if its associated subSec is common to all curves
          var newStat = subStats[curveIndex][si];
          var newSec = subSecs[curveIndex][si];

          if (newStat !== undefined) {
            newSubStats[curveIndex].push(newStat);
            newSubSecs[curveIndex].push(newSec);
          }
        }
      } // re-sort all of the data into histogram bins


      var d = {
        // d will contain the curve data
        x: [],
        //placeholder
        y: [],
        //placeholder
        error_x: [],
        // unused
        error_y: [],
        // unused
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {},
        // placeholder
        bin_stats: [],
        // placeholder
        text: [],
        //placeholder
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE
      };
      newCurveData = matsDataUtils.sortHistogramBins(newSubStats[curveIndex], newSubSecs[curveIndex], [], data.x.length, binStats, false, d);
      var newCurveDataKeys = Object.keys(newCurveData.d);

      for (var didx = 0; didx < newCurveDataKeys.length; didx++) {
        dataset[curveIndex][newCurveDataKeys[didx]] = newCurveData.d[newCurveDataKeys[didx]];
      }
    } else {
      // if there are no matching values, set data to an empty array
      dataset[curveIndex] = {
        x: [],
        y: [],
        error_x: [],
        error_y: [],
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {},
        bin_stats: [],
        text: [],
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE
      };
    }
  }

  return dataset;
}; // function for removing unmatched data from a dataset containing multiple curves for a histogram *with* levels.
// separate matching functions are needed for histograms because you have to take all of the data out of the bins, then
// match it, then recalculate the bins. For other plot types, you can just leave the data in its already-sorted fhr, level, etc.


var getMatchedDataSetHistogramWithLevels = function (dataset, curvesLength, binStats) {
  var subStatsRaw = {};
  var subSecsRaw = {};
  var subLevsRaw = {};
  var subStats = {};
  var subSecs = {};
  var subLevs = {};
  var newSubStats = {};
  var newSubSecs = {};
  var newSubLevs = {};
  var newCurveData;
  var curveIndex;
  var di;
  var si; // pull all subSecs and subStats out of their bins, and back into one master array

  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    data = dataset[curveIndex];
    subStatsRaw[curveIndex] = [];
    subSecsRaw[curveIndex] = [];
    subLevsRaw[curveIndex] = [];
    subStats[curveIndex] = [];
    subSecs[curveIndex] = [];
    subLevs[curveIndex] = [];

    for (di = 0; di < data.x.length; di++) {
      subStatsRaw[curveIndex].push(data.subVals[di]);
      subSecsRaw[curveIndex].push(data.subSecs[di]);
      subLevsRaw[curveIndex].push(data.subLevs[di]);
    }

    subStats[curveIndex] = [].concat.apply([], subStatsRaw[curveIndex]);
    subSecs[curveIndex] = [].concat.apply([], subSecsRaw[curveIndex]);
    subLevs[curveIndex] = [].concat.apply([], subLevsRaw[curveIndex]);
  } // determine which seconds and levels are present in all curves


  var subIntersections = []; // eventually find the intersecting subSecs and subLevs across all curves

  for (si = 0; si < subSecs[0].length; si++) {
    // fill current intersection array with sec-lev pairs from the first curve
    subIntersections.push([subSecs[0][si], subLevs[0][si]]);
  }

  for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve after the first
    var tempSubIntersections = [];
    var tempPair;

    for (si = 0; si < subSecs[curveIndex].length; si++) {
      // loop over every subSecs value
      tempPair = [subSecs[curveIndex][si], subLevs[curveIndex][si]]; // create an individual sec-lev pair for each index in the subSecs and subLevs arrays

      if (matsDataUtils.arrayContainsSubArray(subIntersections, tempPair)) {
        // see if the individual sec-lev pair matches a pair from the current intersection array
        tempSubIntersections.push(tempPair); // store matching pairs
      }
    }

    subIntersections = tempSubIntersections; //replace current intersection array with array of only pairs that matched from this loop through.
  } // remove non-matching subSecs, subLevs, and subStats


  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {
    // loop over every curve
    data = dataset[curveIndex];

    if (subIntersections.length > 0) {
      newSubStats[curveIndex] = [];
      newSubSecs[curveIndex] = [];
      newSubLevs[curveIndex] = [];

      for (si = 0; si < subSecs[curveIndex].length; si++) {
        // loop over all subSecs for this curve
        tempPair = [subSecs[curveIndex][si], subLevs[curveIndex][si]]; //create sec-lev pair for each subStat

        if (matsDataUtils.arrayContainsSubArray(subIntersections, tempPair)) {
          // keep the subStat only if its sec-lev pair is common to all curves
          var newStat = subStats[curveIndex][si];
          var newSec = subSecs[curveIndex][si];
          var newLev = subLevs[curveIndex][si];

          if (newStat !== undefined) {
            newSubStats[curveIndex].push(newStat);
            newSubSecs[curveIndex].push(newSec);
            newSubLevs[curveIndex].push(newLev);
          }
        }
      } // re-sort all of the data into histogram bins


      var d = {
        // d will contain the curve data
        x: [],
        //placeholder
        y: [],
        //placeholder
        error_x: [],
        // unused
        error_y: [],
        // unused
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {},
        // placeholder
        bin_stats: [],
        // placeholder
        text: [],
        //placeholder
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE
      };
      newCurveData = matsDataUtils.sortHistogramBins(newSubStats[curveIndex], newSubSecs[curveIndex], newSubLevs[curveIndex], data.x.length, binStats, true, d);
      var newCurveDataKeys = Object.keys(newCurveData.d);

      for (var didx = 0; didx < newCurveDataKeys.length; didx++) {
        dataset[curveIndex][newCurveDataKeys[didx]] = newCurveData.d[newCurveDataKeys[didx]];
      }
    } else {
      // if there are no matching values, set data to an empty dataset
      dataset[curveIndex] = {
        x: [],
        y: [],
        error_x: [],
        error_y: [],
        subVals: [],
        subSecs: [],
        subLevs: [],
        glob_stats: {},
        bin_stats: [],
        text: [],
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE
      };
    }
  }

  return dataset;
};

module.exportDefault(matsDataMatchUtils = {
  getMatchedDataSet: getMatchedDataSet,
  getMatchedDataSetWithLevels: getMatchedDataSetWithLevels,
  getMatchedDataSetHistogram: getMatchedDataSetHistogram,
  getMatchedDataSetHistogramWithLevels: getMatchedDataSetHistogramWithLevels
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_curve_ops_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_curve_ops_util.js                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */
// adds a horizontal black line along a specific y value
var getHorizontalValueLine = function (xmax, xmin, yValue, cLabel) {
  var valueLine = {
    "label": cLabel,
    "curveId": cLabel,
    "annotation": "",
    "name": "y = " + yValue.toString(),
    "mode": "lines",
    "x": [xmin, xmax],
    "x_epoch": [xmin, xmax],
    "y": [yValue, yValue],
    "error_x": [null, null],
    "error_y": [null, null],
    "subVals": [],
    "subSecs": [],
    "subLevs": [],
    "stats": [{
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }, {
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }],
    "tooltip": ["y = " + yValue.toString(), "y = " + yValue.toString()],
    "xmin": xmin,
    "xmax": xmax,
    "ymin": yValue,
    "ymax": yValue,
    "line": {
      "color": "rgb(0,0,0)"
    }
  };
  return valueLine;
}; // adds a vertical black line along a specific x value


var getVerticalValueLine = function (ymax, ymin, xValue, cLabel) {
  var valueLine = {
    "label": cLabel,
    "curveId": cLabel,
    "annotation": "",
    "name": "x = " + xValue.toString(),
    "mode": "lines",
    "x": [xValue, xValue],
    "y": [ymin, ymax],
    "error_x": [null, null],
    "error_y": [null, null],
    "subVals": [],
    "subSecs": [],
    "subLevs": [],
    "stats": [{
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }, {
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }],
    "tooltip": ["x = " + xValue.toString(), "x = " + xValue.toString()],
    "xmin": xValue,
    "xmax": xValue,
    "ymin": ymin,
    "ymax": ymax,
    "line": {
      "color": "rgb(0,0,0)"
    }
  };
  return valueLine;
}; // adds a linear line


var getLinearValueLine = function (xmax, xmin, ymax, ymin, cLabel) {
  var valueLine = {
    "label": cLabel,
    "curveId": cLabel,
    "annotation": "",
    "name": cLabel,
    "mode": "lines",
    "x": [xmin, xmax],
    "x_epoch": [xmin, xmax],
    "y": [ymin, ymax],
    "error_x": [null, null],
    "error_y": [null, null],
    "subVals": [],
    "subSecs": [],
    "subLevs": [],
    "stats": [{
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }, {
      "d_mean": 0,
      "sd": 0,
      "n_good": 0,
      "lag1": 0,
      "stde": 0
    }],
    "tooltip": "",
    "xmin": xmin,
    "xmax": xmax,
    "ymin": ymin,
    "ymax": ymax,
    "line": {
      "color": "rgb(0,0,0)"
    }
  };
  return valueLine;
}; // provides curve options for all plot types with an independent x axis and a dependent y axis


var generateSeriesCurveOptions = function (curve, curveIndex, axisMap, dataSeries) {
  var label = curve['label'];
  var annotation = curve['annotation']; // adjust axes for later setting of the plot options

  var ymin = curve['ymin'];
  var ymax = curve['ymax'];
  var xmin = curve['xmin'];
  var xmax = curve['xmax'];
  var axisKey = curve['axisKey'];

  if (axisKey in axisMap) {
    axisMap[axisKey].axisLabel = axisKey;
    axisMap[axisKey].ymin = ymin < axisMap[axisKey].ymin ? ymin : axisMap[axisKey].ymin;
    axisMap[axisKey].ymax = ymax > axisMap[axisKey].ymax ? ymax : axisMap[axisKey].ymax;
    axisMap[axisKey].xmin = xmin < axisMap[axisKey].xmin ? xmin : axisMap[axisKey].xmin;
    axisMap[axisKey].xmax = xmax > axisMap[axisKey].xmax ? xmax : axisMap[axisKey].xmax;
  } else {
    axisMap[axisKey] = {
      index: Object.keys(axisMap).length + 1,
      xmin: xmin,
      xmax: xmax,
      ymin: ymin,
      ymax: ymax,
      axisLabel: axisKey
    };
  }

  var axisNumber = Object.keys(axisMap).indexOf(axisKey);
  var error_y_temp = {
    error_y: {
      array: dataSeries.error_y,
      thickness: 1,
      // set the thickness of the error bars
      color: curve['color'],
      visible: false // changed later if matching
      // width: 0

    }
  };
  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    xaxis: "x1",
    yaxis: "y" + (axisNumber + 1),
    annotation: annotation,
    annotateColor: curve['color'],
    mode: "lines+markers",
    marker: {
      symbol: "circle",
      color: curve['color'],
      size: 8
    },
    line: {
      dash: 'solid',
      color: curve['color'],
      width: 2
    },
    visible: true
  }, dataSeries);
  delete curveOptions.error_y;
  curveOptions['error_y'] = error_y_temp.error_y;
  return curveOptions;
}; // provides curve options for all plot types with an independent y axis and a dependent x axis


var generateProfileCurveOptions = function (curve, curveIndex, axisMap, dataProfile) {
  var label = curve['label'];
  var annotation = curve['annotation']; // adjust axes for later setting of the plot options

  var ymin = curve['ymin'];
  var ymax = curve['ymax'];
  var xmin = curve['xmin'];
  var xmax = curve['xmax'];
  var axisKey = curve['axisKey'];

  if (axisKey in axisMap) {
    axisMap[axisKey].axisLabel = axisKey;
    axisMap[axisKey].ymin = ymin < axisMap[axisKey].ymin ? ymin : axisMap[axisKey].ymin;
    axisMap[axisKey].ymax = ymax > axisMap[axisKey].ymax ? ymax : axisMap[axisKey].ymax;
    axisMap[axisKey].xmin = xmin < axisMap[axisKey].xmin ? xmin : axisMap[axisKey].xmin;
    axisMap[axisKey].xmax = xmax > axisMap[axisKey].xmax ? xmax : axisMap[axisKey].xmax;
  } else {
    axisMap[axisKey] = {
      index: Object.keys(axisMap).length + 1,
      xmin: xmin,
      xmax: xmax,
      ymin: ymin,
      ymax: ymax,
      axisLabel: axisKey
    };
  }

  var axisNumber = Object.keys(axisMap).indexOf(axisKey);
  var error_x_temp = {
    error_x: {
      array: dataProfile.error_x,
      thickness: 1,
      // set the thickness of the error bars
      color: curve['color'],
      visible: false // changed later if matching
      // width: 0

    }
  };
  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    xaxis: "x" + (axisNumber + 1),
    yaxis: "y1",
    annotation: annotation,
    annotateColor: curve['color'],
    mode: "lines+markers",
    marker: {
      symbol: "circle",
      color: curve['color'],
      size: 8
    },
    line: {
      dash: 'solid',
      color: curve['color'],
      width: 2
    },
    visible: true
  }, dataProfile);
  delete curveOptions.error_x;
  curveOptions['error_x'] = error_x_temp.error_x;
  return curveOptions;
}; // provides curve options for reliability diagrams


var generateReliabilityCurveOptions = function (curve, curveIndex, axisMap, dataSeries) {
  var label = curve['label'];
  var annotation = curve['annotation']; // adjust axes for later setting of the plot options

  var ymin = curve['ymin'];
  var ymax = curve['ymax'];
  var xmin = curve['xmin'];
  var xmax = curve['xmax'];
  var axisKey = curve['axisKey'];

  if (axisKey in axisMap) {
    axisMap[axisKey].axisLabel = axisKey;
    axisMap[axisKey].ymin = ymin < axisMap[axisKey].ymin ? ymin : axisMap[axisKey].ymin;
    axisMap[axisKey].ymax = ymax > axisMap[axisKey].ymax ? ymax : axisMap[axisKey].ymax;
    axisMap[axisKey].xmin = xmin < axisMap[axisKey].xmin ? xmin : axisMap[axisKey].xmin;
    axisMap[axisKey].xmax = xmax > axisMap[axisKey].xmax ? xmax : axisMap[axisKey].xmax;
  } else {
    axisMap[axisKey] = {
      index: Object.keys(axisMap).length + 1,
      xmin: xmin,
      xmax: xmax,
      ymin: ymin,
      ymax: ymax,
      axisLabel: axisKey
    };
  }

  var axisNumber = Object.keys(axisMap).indexOf(axisKey);
  var error_y_temp = {
    error_y: {
      array: dataSeries.error_y,
      thickness: 1,
      // set the thickness of the error bars
      color: curve['color'],
      visible: false // changed later if matching
      // width: 0

    }
  };
  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    xaxis: "x1",
    yaxis: "y" + (axisNumber + 1),
    annotation: annotation,
    annotateColor: curve['color'],
    mode: "lines+markers",
    marker: {
      symbol: "circle",
      color: curve['color'],
      size: 8
    },
    line: {
      dash: 'solid',
      color: curve['color'],
      width: 2
    },
    visible: true
  }, dataSeries);
  delete curveOptions.error_y;
  curveOptions['error_y'] = error_y_temp.error_y;
  return curveOptions;
}; // provides curve options for all plot types with an independent x axis and a dependent y axis


var generateBarChartCurveOptions = function (curve, curveIndex, axisMap, dataBars) {
  var label = curve['label'];
  var annotation = curve['annotation']; // adjust axes for later setting of the plot options

  var ymin = curve['ymin'];
  var ymax = curve['ymax'];
  var xmin = curve['xmin'];
  var xmax = curve['xmax'];
  var axisKey = curve['axisKey'];

  if (axisKey in axisMap) {
    axisMap[axisKey].axisLabel = axisKey;
    axisMap[axisKey].ymin = ymin < axisMap[axisKey].ymin ? ymin : axisMap[axisKey].ymin;
    axisMap[axisKey].ymax = ymax > axisMap[axisKey].ymax ? ymax : axisMap[axisKey].ymax;
    axisMap[axisKey].xmin = xmin < axisMap[axisKey].xmin ? xmin : axisMap[axisKey].xmin;
    axisMap[axisKey].xmax = xmax > axisMap[axisKey].xmax ? xmax : axisMap[axisKey].xmax;
  } else {
    axisMap[axisKey] = {
      index: Object.keys(axisMap).length + 1,
      xmin: xmin,
      xmax: xmax,
      ymin: ymin,
      ymax: ymax,
      axisLabel: axisKey
    };
  }

  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    annotation: annotation,
    annotateColor: curve['color'],
    marker: {
      color: curve['color'],
      line: {
        color: "rgb(0,0,0)"
      }
    },
    type: 'bar',
    visible: true
  }, dataBars);
  return curveOptions;
};

var generateMapCurveOptions = function (curve, dataSeries) {
  var markerSizes = dataSeries.queryVal.map(function (val) {
    return Math.ceil(Math.abs(val * 4)) + 2;
  });
  var label = curve['label'];
  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    type: 'scattermapbox',
    mode: 'markers',
    marker: {
      color: dataSeries.color,
      size: markerSizes,
      opacity: 0
    }
  }, dataSeries);
  delete curveOptions.color;
  return curveOptions;
};

var generateMapColorTextOptions = function (label, dataSeries) {
  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    type: 'scattermapbox',
    mode: 'markers+text',
    marker: {
      opacity: 0
    },
    textfont: {
      family: 'sans serif',
      // size: 18,
      color: dataSeries.color
    },
    hoverinfo: 'skip',
    visible: true
  }, dataSeries);
  delete curveOptions.color;
  return curveOptions;
};

var generateContourCurveOptions = function (curve, axisMap, dataset) {
  var label = curve['label'];
  var annotation = curve['annotation'];
  var unitKey = curve['unitKey'];
  var curveOptions = (0, _objectSpread2.default)({}, {
    label: label,
    curveId: label,
    name: label,
    annotation: annotation,
    annotateColor: curve['color'],
    xAxisKey: curve['xAxisKey'],
    yAxisKey: curve['yAxisKey'],
    marker: {
      color: curve['color']
    },
    type: 'contour',
    autocontour: false,
    ncontours: 15,
    // apparently plotly regards this as a "less than or equal to" field
    contours: {
      // these are only used if autocontour is set to false and ncontour is disregarded
      start: dataset.zmin + (dataset.zmax - dataset.zmin) / 16,
      end: dataset.zmax - (dataset.zmax - dataset.zmin) / 16,
      size: (dataset.zmax - dataset.zmin) / 16,
      showlabels: false
    },
    colorscale: 'RdBu',
    reversescale: false,
    colorbar: {
      title: unitKey,
      titleside: 'right',
      titlefont: {
        size: 20,
        family: 'Arial, sans-serif'
      }
    },
    // connectgaps: true,   // this option will interpolate to fill in nulls
    visible: true
  }, dataset);
  return curveOptions;
};

module.exportDefault(matsDataCurveOpsUtils = {
  getHorizontalValueLine: getHorizontalValueLine,
  getVerticalValueLine: getVerticalValueLine,
  getLinearValueLine: getLinearValueLine,
  generateSeriesCurveOptions: generateSeriesCurveOptions,
  generateReliabilityCurveOptions: generateReliabilityCurveOptions,
  generateProfileCurveOptions: generateProfileCurveOptions,
  generateBarChartCurveOptions: generateBarChartCurveOptions,
  generateMapCurveOptions: generateMapCurveOptions,
  generateMapColorTextOptions: generateMapColorTextOptions,
  generateContourCurveOptions: generateContourCurveOptions
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_plot_ops_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_plot_ops_util.js                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 0);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 1);
var moment;
module.link("meteor/momentjs:moment", {
  moment: function (v) {
    moment = v;
  }
}, 2);

// sets plot options for timeseries graphs
var generateSeriesPlotOptions = function (dataset, curves, axisMap, errorMax) {
  var xmin = axisMap[Object.keys(axisMap)[0]].xmin;
  var xmax = axisMap[Object.keys(axisMap)[0]].xmax;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Time',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 12
    }
  };
  var axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  var axisSide = {
    0: 'left',
    1: 'right',
    2: 'left',
    3: 'right',
    4: 'left',
    5: 'right',
    6: 'left',
    7: 'right'
  };
  var axisPosition = {
    0: 0,
    1: 1,
    2: 0.1,
    3: 0.9,
    4: 0.2,
    5: 0.8,
    6: 0.3,
    7: 0.7
  };
  var yAxisNumber = Object.keys(axisMap).length;
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < yAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var ymin = axisMap[axisKey].ymin;
    var ymax = axisMap[axisKey].ymax;
    ymax = ymax + errorMax;
    ymin = ymin - errorMax;
    var yPad = (ymax - ymin) * 0.05 !== 0 ? (ymax - ymin) * 0.05 : 0.05;
    xmin = axisMap[axisKey].xmin < xmin ? axisMap[axisKey].xmin : xmin;
    xmax = axisMap[axisKey].xmax > xmax ? axisMap[axisKey].xmax : xmax;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'yaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'y',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'y',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  var xPad = (xmax - xmin) * 0.075 !== 0 ? (xmax - xmin) * 0.075 : 0.075;
  xmax = moment.utc(xmax + xPad * Math.ceil(yAxisNumber / 2)).format("YYYY-MM-DD HH:mm");
  xmin = moment.utc(xmin - xPad * Math.ceil(yAxisNumber / 2)).format("YYYY-MM-DD HH:mm");
  layout['xaxis']['range'] = [xmin, xmax];
  return layout;
}; // sets plot options for profile graphs


var generateProfilePlotOptions = function (dataset, curves, axisMap, errorMax) {
  var ymin = 10;
  var ymax = 1075;
  var xAxisNumber = Object.keys(axisMap).length;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: xAxisNumber > 1 ? 80 : 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  var tickVals;
  var tickText;

  if (matsCollections.Settings.findOne({}).appType === matsTypes.AppTypes.metexpress) {
    tickVals = [1000, 850, 700, 600, 500, 400, 300, 250, 200, 150, 100, 50, 10];
    tickText = ['1000', '850', '700', '600', '500', '400', '300', '250', '200', '150', '100', '50', '10'];
  } else {
    tickVals = [1000, 900, 800, 700, 600, 500, 400, 300, 200, 100];
    tickText = ['1000', '900', '800', '700', '600', '500', '400', '300', '200', '100'];
  }

  layout['yaxis'] = {
    title: 'Pressure Level',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: tickVals,
    ticktext: tickText,
    type: 'linear',
    autorange: 'reversed'
  };
  var axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  var axisSide = {
    0: 'bottom',
    1: 'top',
    2: 'bottom',
    3: 'top',
    4: 'bottom',
    5: 'top',
    6: 'bottom',
    7: 'top'
  };
  var axisPosition = {
    0: 0,
    1: 1,
    2: 0.15,
    3: 0.85,
    4: 0.3,
    5: 0.7,
    6: 0.45,
    7: 0.55
  };
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < xAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var xmin = axisMap[axisKey].xmin;
    var xmax = axisMap[axisKey].xmax;
    xmax = xmax + errorMax;
    xmin = xmin - errorMax;
    axisLabel = axisMap[axisKey].axisLabel;
    var xPad = (xmax - xmin) * 0.05 !== 0 ? (xmax - xmin) * 0.05 : 0.05;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'xaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [xmin - xPad, xmax + xPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'xaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [xmin - xPad, xmax + xPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'x',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'xaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [xmin - xPad, xmax + xPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'x',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  var yPad = (ymax - ymin) * 0.25 !== 0 ? (ymax - ymin) * 0.25 : 0.25;
  ymax = ymax + yPad * Math.ceil(xAxisNumber / 2);
  ymin = ymin - yPad * Math.ceil(xAxisNumber / 2);
  layout['yaxis']['range'] = [ymin, ymax];
  return layout;
}; // sets plot options for dieoff graphs


var generateDieoffPlotOptions = function (dataset, curves, axisMap, errorMax) {
  var xmin = axisMap[Object.keys(axisMap)[0]].xmin;
  var xmax = axisMap[Object.keys(axisMap)[0]].xmax;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Forecast Hour',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    }
  };
  var axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  var axisSide = {
    0: 'left',
    1: 'right',
    2: 'left',
    3: 'right',
    4: 'left',
    5: 'right',
    6: 'left',
    7: 'right'
  };
  var axisPosition = {
    0: 0,
    1: 1,
    2: 0.1,
    3: 0.9,
    4: 0.2,
    5: 0.8,
    6: 0.3,
    7: 0.7
  };
  var yAxisNumber = Object.keys(axisMap).length;
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < yAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var ymin = axisMap[axisKey].ymin;
    var ymax = axisMap[axisKey].ymax;
    ymax = ymax + errorMax;
    ymin = ymin - errorMax;
    var yPad = (ymax - ymin) * 0.05 !== 0 ? (ymax - ymin) * 0.05 : 0.05;
    xmin = axisMap[axisKey].xmin < xmin ? axisMap[axisKey].xmin : xmin;
    xmax = axisMap[axisKey].xmax > xmax ? axisMap[axisKey].xmax : xmax;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'yaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'y',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'y',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  var xPad = (xmax - xmin) * 0.075 !== 0 ? (xmax - xmin) * 0.075 : 0.075;
  xmax = xmax + xPad * Math.ceil(yAxisNumber / 2);
  xmin = xmin - xPad * Math.ceil(yAxisNumber / 2);
  layout['xaxis']['range'] = [xmin, xmax];
  return layout;
}; // sets plot options for threshold graphs


var generateThresholdPlotOptions = function (dataset, curves, axisMap, errorMax) {
  var xmin = 0;
  var xmax = 3;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Threshold',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: [0.01, 0.1, 0.25, 0.5, 1.0, 1.5, 2.0, 3.0],
    ticktext: ["0.01", "0.10", "0.25", "0.50", "1.00", "1.50", "2.00", "3.00"]
  };
  var axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  var axisSide = {
    0: 'left',
    1: 'right',
    2: 'left',
    3: 'right',
    4: 'left',
    5: 'right',
    6: 'left',
    7: 'right'
  };
  var axisPosition = {
    0: 0,
    1: 1,
    2: 0.1,
    3: 0.9,
    4: 0.2,
    5: 0.8,
    6: 0.3,
    7: 0.7
  };
  var yAxisNumber = Object.keys(axisMap).length;
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < yAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var ymin = axisMap[axisKey].ymin;
    var ymax = axisMap[axisKey].ymax;
    ymax = ymax + errorMax;
    ymin = ymin - errorMax;
    var yPad = (ymax - ymin) * 0.05 !== 0 ? (ymax - ymin) * 0.05 : 0.05;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'yaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'y',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'y',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  var xPad = (xmax - xmin) * 0.075 !== 0 ? (xmax - xmin) * 0.075 : 0.075;
  xmax = xmax + xPad * Math.ceil(yAxisNumber / 2);
  xmin = xmin - xPad * Math.ceil(yAxisNumber / 2);
  layout['xaxis']['range'] = [xmin, xmax];
  return layout;
}; // sets plot options for valid time graphs


var generateValidTimePlotOptions = function (dataset, curves, axisMap, errorMax) {
  var xmin = 0;
  var xmax = 23;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Hour of Day',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],
    ticktext: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"]
  };
  var axisAnchor = {
    0: 'x',
    1: 'x',
    2: 'free',
    3: 'free',
    4: 'free',
    5: 'free',
    6: 'free',
    7: 'free'
  };
  var axisSide = {
    0: 'left',
    1: 'right',
    2: 'left',
    3: 'right',
    4: 'left',
    5: 'right',
    6: 'left',
    7: 'right'
  };
  var axisPosition = {
    0: 0,
    1: 1,
    2: 0.1,
    3: 0.9,
    4: 0.2,
    5: 0.8,
    6: 0.3,
    7: 0.7
  };
  var yAxisNumber = Object.keys(axisMap).length;
  var axisKey;
  var axisIdx;
  var axisLabel;

  for (axisIdx = 0; axisIdx < yAxisNumber; axisIdx++) {
    axisKey = Object.keys(axisMap)[axisIdx];
    var ymin = axisMap[axisKey].ymin;
    var ymax = axisMap[axisKey].ymax;
    ymax = ymax + errorMax;
    ymin = ymin - errorMax;
    var yPad = (ymax - ymin) * 0.05 !== 0 ? (ymax - ymin) * 0.05 : 0.05;
    axisLabel = axisMap[axisKey].axisLabel;
    var axisObjectKey;

    if (axisIdx === 0) {
      axisObjectKey = 'yaxis';
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        zeroline: false
      };
    } else if (axisIdx < Object.keys(axisPosition).length) {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[axisIdx],
        overlaying: 'y',
        side: axisSide[axisIdx],
        position: axisPosition[axisIdx],
        zeroline: false
      };
    } else {
      axisObjectKey = 'yaxis' + (axisIdx + 1);
      layout[axisObjectKey] = {
        title: axisLabel,
        titlefont: {
          color: '#000000',
          size: 22
        },
        tickfont: {
          color: '#000000',
          size: 14
        },
        range: [ymin - yPad, ymax + yPad],
        anchor: axisAnchor[Object.keys(axisPosition).length - 1],
        overlaying: 'y',
        side: axisSide[Object.keys(axisPosition).length - 1],
        position: axisPosition[Object.keys(axisPosition).length - 1],
        zeroline: false
      };
    }
  }

  var xPad = (xmax - xmin) * 0.075 !== 0 ? (xmax - xmin) * 0.075 : 0.075;
  xmax = xmax + xPad * Math.ceil(yAxisNumber / 2);
  xmin = xmin - xPad * Math.ceil(yAxisNumber / 2);
  layout['xaxis']['range'] = [xmin, xmax];
  return layout;
}; // sets plot options for reliability graphs


var generateReliabilityPlotOptions = function (dataset) {
  var xmin = 0;
  var xmax = 1;
  var ymin = 0;
  var ymax = 1;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: true,
    perfectLine: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Forecast Probability',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
    ticktext: ["0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0"],
    range: [xmin, xmax]
  };
  layout['yaxis'] = {
    title: 'Observed Relative Frequency',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    },
    tickvals: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
    ticktext: ["0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0"],
    range: [ymin, ymax]
  };
  return layout;
}; // sets plot options for map graphs


var generateMapPlotOptions = function () {
  var options = {
    autosize: true,
    hovermode: 'closest',
    mapbox: {
      bearing: 0,
      center: {
        lat: 39.834,
        lon: -98.604
      },
      pitch: 0,
      zoom: 3.25,
      accesstoken: 'pk.eyJ1IjoibWF0cy1nc2QiLCJhIjoiY2pvN2l1N2MyMG9xdTN3bWR3ODV5a2E2ZiJ9.PtgcGhxaoD43N0OwJSNVMg',
      style: 'light'
    },
    margin: {
      l: 30,
      r: 30,
      b: 40,
      t: 10,
      pad: 4
    },
    showlegend: false
  };
  return options;
}; // sets plot options for valid time graphs


var generateHistogramPlotOptions = function (dataset, curves, axisMap, plotBins) {
  var axisKey = curves[0].axisKey;
  var axisLabel = axisMap[axisKey].axisLabel;
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    bargap: 0.25,
    barmode: 'group',
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    },
    showlegend: false
  };
  layout['xaxis'] = {
    title: 'Bin',
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 12
    },
    tickvals: plotBins.binMeans,
    ticktext: plotBins.binLabels
  };
  layout['yaxis'] = {
    title: axisLabel,
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 14
    }
  };
  return layout;
}; // sets plot options for valid time graphs


var generateContourPlotOptions = function (dataset, axisMap) {
  var xAxisKey = dataset[0]['xAxisKey'];
  var yAxisKey = dataset[0]['yAxisKey'];
  var layout = {
    margin: {
      l: 80,
      r: 80,
      b: 80,
      t: 20,
      pad: 4
    },
    zeroline: false,
    hovermode: 'closest',
    hoverlabel: {
      'font': {
        'size': 14,
        'family': 'Arial',
        'color': '#FFFFFF'
      }
    }
  };
  layout['xaxis'] = {
    title: xAxisKey,
    titlefont: {
      color: '#000000',
      size: 22
    },
    tickfont: {
      color: '#000000',
      size: 12
    }
  };

  if (yAxisKey === "Pressure level") {
    layout['yaxis'] = {
      title: yAxisKey,
      titlefont: {
        color: '#000000',
        size: 22
      },
      tickfont: {
        color: '#000000',
        size: 14
      },
      tickvals: [1000, 900, 800, 700, 600, 500, 400, 300, 200, 100],
      ticktext: ['1000', '900', '800', '700', '600', '500', '400', '300', '200', '100'],
      range: [1100, 0],
      type: 'linear',
      autorange: 'reversed'
    };
  } else {
    layout['yaxis'] = {
      title: yAxisKey,
      titlefont: {
        color: '#000000',
        size: 22
      },
      tickfont: {
        color: '#000000',
        size: 14
      }
    };
  }

  return layout;
};

module.exportDefault(matsDataPlotOpsUtils = {
  generateSeriesPlotOptions: generateSeriesPlotOptions,
  generateProfilePlotOptions: generateProfilePlotOptions,
  generateDieoffPlotOptions: generateDieoffPlotOptions,
  generateThresholdPlotOptions: generateThresholdPlotOptions,
  generateValidTimePlotOptions: generateValidTimePlotOptions,
  generateReliabilityPlotOptions: generateReliabilityPlotOptions,
  generateMapPlotOptions: generateMapPlotOptions,
  generateHistogramPlotOptions: generateHistogramPlotOptions,
  generateContourPlotOptions: generateContourPlotOptions
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"data_process_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/data_process_util.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsDataUtils;
module.link("meteor/randyp:mats-common", {
  matsDataUtils: function (v) {
    matsDataUtils = v;
  }
}, 2);
var matsDataMatchUtils;
module.link("meteor/randyp:mats-common", {
  matsDataMatchUtils: function (v) {
    matsDataMatchUtils = v;
  }
}, 3);
var matsDataDiffUtils;
module.link("meteor/randyp:mats-common", {
  matsDataDiffUtils: function (v) {
    matsDataDiffUtils = v;
  }
}, 4);
var matsDataCurveOpsUtils;
module.link("meteor/randyp:mats-common", {
  matsDataCurveOpsUtils: function (v) {
    matsDataCurveOpsUtils = v;
  }
}, 5);
var matsDataPlotOpsUtils;
module.link("meteor/randyp:mats-common", {
  matsDataPlotOpsUtils: function (v) {
    matsDataPlotOpsUtils = v;
  }
}, 6);
var moment;
module.link("meteor/momentjs:moment", {
  moment: function (v) {
    moment = v;
  }
}, 7);

var processDataXYCurve = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {
  // variable to store maximum error bar length
  var errorMax = Number.MIN_VALUE;
  var error = "";
  var appName = matsCollections.appName.findOne({}).app; // if matching, pare down dataset to only matching data

  if (curveInfoParams.curvesLength > 1 && appParams.matching) {
    if (appParams.hasLevels) {
      dataset = matsDataMatchUtils.getMatchedDataSetWithLevels(dataset, curveInfoParams.curvesLength, appParams.plotType);
    } else {
      dataset = matsDataMatchUtils.getMatchedDataSet(dataset, curveInfoParams.curvesLength);
    }
  } // we may need to recalculate the axis limits after unmatched data and outliers are removed


  var axisLimitReprocessed = {}; // calculate data statistics (including error bars) for each curve

  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    if (appName !== "surfrad") {
      axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] = axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] !== undefined;
    }

    var diffFrom = curveInfoParams.curves[curveIndex].diffFrom;
    var statisticSelect = appName.indexOf("anomalycor") !== -1 ? "ACC" : curveInfoParams.curves[curveIndex]['statistic'];
    var data = dataset[curveIndex];
    var _label = dataset[curveIndex].label;
    var di = 0;
    var values = [];
    var indVars = [];
    var means = [];
    var rawStat;
    /*
    dataset[curveIndex] is the dataset.
    it looks like:
     d = {
        x: [],
        y: [],
        error_x: [],   // curveTime
        error_y: [],   // values
        subVals: [],   //subVals
        subSecs: [],   //subSecs
        subLevs: [],   //subLevs
        stats: [],     //pointStats
        text: [],
        glob_stats: {},     //curveStats
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE,
        sum: 0
    };
    */

    while (di < data.x.length) {
      // errorResult holds all the calculated curve stats like mean, sd, etc.
      var errorResult;

      if (appParams.hasLevels) {
        errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], data.subLevs[di]);
      } else {
        errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], []);
      } // store raw statistic from query before recalculating that statistic to account for data removed due to matching, QC, etc.


      rawStat = data.y[di]; // this ungainly if statement is because the surfrad3 database doesn't support recalculating some stats.

      if (appName !== "surfrad" || !(appName === "surfrad" && (statisticSelect === 'Std deviation (do not plot matched)' || statisticSelect === 'RMS (do not plot matched)') && !appParams.matching)) {
        if (diffFrom === null || diffFrom === undefined || !appParams.matching) {
          // assign recalculated statistic to data[di][1], which is the value to be plotted
          data.y[di] = errorResult.d_mean;
        } else {
          if (dataset[diffFrom[0]].y[di] !== null && dataset[diffFrom[1]].y[di] !== null) {
            // make sure that the diff curve actually shows the difference when matching. Otherwise outlier filtering etc. can make it slightly off.
            data.y[di] = dataset[diffFrom[0]].y[di] - dataset[diffFrom[1]].y[di];
          } else {
            // keep the null for no data at this point
            data.y[di] = null;
          }
        }
      }

      values.push(data.y[di]);
      indVars.push(data.x[di]);
      means.push(errorResult.d_mean); // store error bars if matching

      var errorBar = errorResult.stde_betsy * 1.96;

      if (appParams.matching) {
        errorMax = errorMax > errorBar ? errorMax : errorBar;
        data.error_y.array[di] = errorBar;
      } else {
        data.error_y.array[di] = null;
      } // remove sub values and times to save space


      data.subVals[di] = [];
      data.subSecs[di] = [];
      data.subLevs[di] = []; // store statistics for this di datapoint

      data.stats[di] = {
        raw_stat: rawStat,
        d_mean: errorResult.d_mean,
        sd: errorResult.sd,
        n_good: errorResult.n_good,
        lag1: errorResult.lag1,
        stde_betsy: errorResult.stde_betsy
      }; // this is the tooltip, it is the last element of each dataseries element.
      // also change the x array from epoch to date for timeseries and DMC, as we are now done with it for calculations.

      data.text[di] = _label;

      switch (appParams.plotType) {
        case matsTypes.PlotTypes.timeSeries:
          data.text[di] = data.text[di] + "<br>time: " + moment.utc(data.x[di]).format("YYYY-MM-DD HH:mm");
          break;

        case matsTypes.PlotTypes.dailyModelCycle:
          var fhr = data.x[di] / 1000 % (24 * 3600) / 3600 - curveInfoParams.utcCycleStarts[curveIndex];
          fhr = fhr < 0 ? fhr + 24 : fhr;
          data.text[di] = data.text[di] + "<br>time: " + moment.utc(data.x[di]).format("YYYY-MM-DD HH:mm");
          data.text[di] = data.text[di] + "<br>forecast hour: " + fhr;
          break;

        case matsTypes.PlotTypes.dieoff:
          data.text[di] = data.text[di] + "<br>fhr: " + data.x[di];
          break;

        case matsTypes.PlotTypes.threshold:
          data.text[di] = data.text[di] + "<br>threshold: " + data.x[di];
          break;

        case matsTypes.PlotTypes.validtime:
          data.text[di] = data.text[di] + "<br>hour of day: " + data.x[di];
          break;

        default:
          data.text[di] = data.text[di] + "<br>" + data.x[di];
          break;
      }

      data.text[di] = data.text[di] + "<br>" + statisticSelect + ": " + (data.y[di] === null ? null : data.y[di].toPrecision(4)) + "<br>sd: " + (errorResult.sd === null ? null : errorResult.sd.toPrecision(4)) + "<br>mean: " + (errorResult.d_mean === null ? null : errorResult.d_mean.toPrecision(4)) + "<br>n: " + errorResult.n_good + // "<br>lag1: " + (errorResult.lag1 === null ? null : errorResult.lag1.toPrecision(4)) +
      // "<br>stde: " + errorResult.stde_betsy +
      "<br>errorbars: " + Number(data.y[di] - errorResult.stde_betsy * 1.96).toPrecision(4) + " to " + Number(data.y[di] + errorResult.stde_betsy * 1.96).toPrecision(4);
      di++;
    } // enable error bars if matching and they aren't null


    if (appParams.matching && data.error_y.array.filter(function (x) {
      return x;
    }).length > 0) {
      data.error_y.visible = true;
    } // get the overall stats for the text output - this uses the means not the stats.


    var stats = matsDataUtils.get_err(values, indVars, []);
    var filteredMeans = means.filter(function (x) {
      return x;
    });
    var miny = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredMeans));
    var maxy = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredMeans));

    if (means.indexOf(0) !== -1 && 0 < miny) {
      miny = 0;
    }

    if (means.indexOf(0) !== -1 && 0 > maxy) {
      maxy = 0;
    }

    stats.miny = miny;
    stats.maxy = maxy;
    dataset[curveIndex]['glob_stats'] = stats; // recalculate axis options after QC and matching

    if (appName !== "surfrad") {
      var minx = Math.min.apply(Math, indVars);
      var maxx = Math.max.apply(Math, indVars);
      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'] < maxy || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? maxy : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'];
      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'] > miny || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? miny : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'];
      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] < maxx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? maxx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'];
      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] > minx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? minx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'];
    } // recalculate curve annotation after QC and matching


    if (stats.d_mean !== undefined && stats.d_mean !== null) {
      dataset[curveIndex]['annotation'] = _label + "- mean = " + stats.d_mean.toPrecision(4);
    }

    if (appParams.plotType === matsTypes.PlotTypes.timeSeries || appParams.plotType === matsTypes.PlotTypes.dailyModelCycle) {
      data['x_epoch'] = data.x;
      data.x = data.x.map(function (val) {
        return moment.utc(val).format("YYYY-MM-DD HH:mm");
      });
    }
  } // add black 0 line curve
  // need to define the minimum and maximum x value for making the zero curve


  var zeroLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, 0, matsTypes.ReservedWords.zero);
  dataset.push(zeroLine); //add ideal value lines, if any

  var idealValueLine;
  var idealLabel;

  for (var ivIdx = 0; ivIdx < curveInfoParams.idealValues.length; ivIdx++) {
    idealLabel = "ideal" + ivIdx.toString();
    idealValueLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, curveInfoParams.idealValues[ivIdx], matsTypes.ReservedWords[idealLabel]);
    dataset.push(idealValueLine);
  } // generate plot options


  var resultOptions;

  switch (appParams.plotType) {
    case matsTypes.PlotTypes.timeSeries:
    case matsTypes.PlotTypes.dailyModelCycle:
      resultOptions = matsDataPlotOpsUtils.generateSeriesPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
      break;

    case matsTypes.PlotTypes.dieoff:
      resultOptions = matsDataPlotOpsUtils.generateDieoffPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
      break;

    case matsTypes.PlotTypes.validtime:
      resultOptions = matsDataPlotOpsUtils.generateValidTimePlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
      break;

    case matsTypes.PlotTypes.threshold:
      resultOptions = matsDataPlotOpsUtils.generateThresholdPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
      break;

    default:
      break;
  }

  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

var processDataProfile = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {
  // variable to store maximum error bar length
  var errorMax = Number.MIN_VALUE;
  var error = "";
  var appName = matsCollections.appName.findOne({}).app; // if matching, pare down dataset to only matching data

  if (curveInfoParams.curvesLength > 1 && appParams.matching) {
    dataset = matsDataMatchUtils.getMatchedDataSetWithLevels(dataset, curveInfoParams.curvesLength, appParams.plotType);
  } // we may need to recalculate the axis limits after unmatched data and outliers are removed


  var axisLimitReprocessed = {}; // calculate data statistics (including error bars) for each curve

  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] = axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] !== undefined;
    var diffFrom = curveInfoParams.curves[curveIndex].diffFrom;
    var statisticSelect = appName.indexOf("anomalycor") !== -1 ? "ACC" : curveInfoParams.curves[curveIndex]['statistic'];
    var data = dataset[curveIndex];
    var _label2 = dataset[curveIndex].label;
    var di = 0;
    var values = [];
    var levels = [];
    var means = [];
    var rawStat;
    /*
    dataset[curveIndex] is the dataset.
    it looks like:
     d = {
        x: [],
        y: [],
        error_x: [],   // curveTime
        error_y: [],   // values
        subVals: [],   //subVals
        subSecs: [],   //subSecs
        subLevs: [],   //subLevs
        stats: [],     //pointStats
        text: [],
        glob_stats: {},     //curveStats
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE,
        sum: 0
    };
    */

    while (di < data.y.length) {
      // errorResult holds all the calculated curve stats like mean, sd, etc.
      var errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], data.subLevs[di]); // store raw statistic from query before recalculating that statistic to account for data removed due to matching, QC, etc.

      rawStat = data.x[di];

      if (diffFrom === null || diffFrom === undefined || !appParams.matching) {
        // assign recalculated statistic to data[di][1], which is the value to be plotted
        data.x[di] = errorResult.d_mean;
      } else {
        if (dataset[diffFrom[0]].x[di] !== null && dataset[diffFrom[1]].x[di] !== null) {
          // make sure that the diff curve actually shows the difference when matching. Otherwise outlier filtering etc. can make it slightly off.
          data.x[di] = dataset[diffFrom[0]].x[di] - dataset[diffFrom[1]].x[di];
        } else {
          // keep the null for no data at this point
          data.x[di] = null;
        }
      }

      values.push(data.x[di]);
      levels.push(data.y[di]);
      means.push(errorResult.d_mean); // store error bars if matching

      var errorBar = errorResult.stde_betsy * 1.96;

      if (appParams.matching) {
        errorMax = errorMax > errorBar ? errorMax : errorBar;
        data.error_x.array[di] = errorBar;
      } else {
        data.error_x.array[di] = null;
      } // remove sub values and times to save space


      data.subVals[di] = [];
      data.subSecs[di] = [];
      data.subLevs[di] = []; // store statistics

      data.stats[di] = {
        raw_stat: rawStat,
        d_mean: errorResult.d_mean,
        sd: errorResult.sd,
        n_good: errorResult.n_good,
        lag1: errorResult.lag1,
        stde_betsy: errorResult.stde_betsy
      }; // this is the tooltip, it is the last element of each dataseries element

      data.text[di] = _label2 + "<br>" + data.y[di] + "mb" + "<br>" + statisticSelect + ": " + (data.x[di] === null ? null : data.x[di].toPrecision(4)) + "<br>sd: " + (errorResult.sd === null ? null : errorResult.sd.toPrecision(4)) + "<br>mean: " + (errorResult.d_mean === null ? null : errorResult.d_mean.toPrecision(4)) + "<br>n: " + errorResult.n_good + // "<br>lag1: " + (errorResult.lag1 === null ? null : errorResult.lag1.toPrecision(4)) +
      // "<br>stde: " + errorResult.stde_betsy +
      "<br>errorbars: " + Number(data.x[di] - errorResult.stde_betsy * 1.96).toPrecision(4) + " to " + Number(data.x[di] + errorResult.stde_betsy * 1.96).toPrecision(4);
      di++;
    } // enable error bars if matching and they aren't null


    if (appParams.matching && data.error_x.array.filter(function (x) {
      return x;
    }).length > 0) {
      data.error_x.visible = true;
    } // get the overall stats for the text output - this uses the means not the stats.


    var stats = matsDataUtils.get_err(values.reverse(), levels.reverse(), []); // have to reverse because of data inversion

    var filteredMeans = means.filter(function (x) {
      return x;
    });
    var minx = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredMeans));
    var maxx = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredMeans));

    if (means.indexOf(0) !== -1 && 0 < minx) {
      minx = 0;
    }

    if (means.indexOf(0) !== -1 && 0 > maxx) {
      maxx = 0;
    }

    stats.minx = minx;
    stats.maxx = maxx;
    dataset[curveIndex]['glob_stats'] = stats; // recalculate axis options after QC and matching

    curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] < maxx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? maxx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'];
    curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] > minx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? minx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin']; // recalculate curve annotation after QC and matching

    if (stats.d_mean !== undefined && stats.d_mean !== null) {
      dataset[curveIndex]['annotation'] = _label2 + "- mean = " + stats.d_mean.toPrecision(4);
    }
  } // add black 0 line curve
  // need to define the minimum and maximum x value for making the zero curve


  var zeroLine = matsDataCurveOpsUtils.getVerticalValueLine(1100, 0, 0, matsTypes.ReservedWords.zero);
  dataset.push(zeroLine); //add ideal value lines, if any

  var idealValueLine;
  var idealLabel;

  for (var ivIdx = 0; ivIdx < curveInfoParams.idealValues.length; ivIdx++) {
    idealLabel = "ideal" + ivIdx.toString();
    idealValueLine = matsDataCurveOpsUtils.getVerticalValueLine(1100, 0, curveInfoParams.idealValues[ivIdx], matsTypes.ReservedWords[idealLabel]);
    dataset.push(idealValueLine);
  } // generate plot options


  var resultOptions = matsDataPlotOpsUtils.generateProfilePlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);
  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

var processDataReliability = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {
  var error = ""; // calculate data statistics (including error bars) for each curve

  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    var data = dataset[curveIndex];
    var _label3 = dataset[curveIndex].label;
    var sample_climo = data.subVals;
    var di = 0;
    /*
    dataset[curveIndex] is the dataset.
    it looks like:
     d = {
        x: [],
        y: [],
        error_x: [],   // curveTime
        error_y: [],   // values
        subVals: [],   //subVals
        subSecs: [],   //subSecs
        subLevs: [],   //subLevs
        stats: [],     //pointStats
        text: [],
        glob_stats: {},     //curveStats
        xmin: Number.MAX_VALUE,
        xmax: Number.MIN_VALUE,
        ymin: Number.MAX_VALUE,
        ymax: Number.MIN_VALUE,
        sum: 0
    };
    */

    while (di < data.x.length) {
      // store statistics for this di datapoint
      data.stats[di] = {
        prob_bin: data.x[di],
        hit_rate: data.y[di],
        obs_y: data.error_x[di],
        obs_n: data.subLevs[di]
      }; // this is the tooltip, it is the last element of each dataseries element.
      // also change the x array from epoch to date for timeseries and DMC, as we are now done with it for calculations.

      data.text[di] = _label3;
      data.text[di] = data.text[di] + "<br>probability bin: " + data.x[di];
      data.text[di] = data.text[di] + "<br>hit rate: " + data.y[di];
      data.text[di] = data.text[di] + "<br>oy: " + data.error_x[di];
      data.text[di] = data.text[di] + "<br>on: " + data.subLevs[di]; // remove sub values and times to save space

      data.subVals[di] = [];
      data.subSecs[di] = [];
      data.subLevs[di] = [];
      di++;
    }

    dataset[curveIndex]['glob_stats'] = {
      sample_climo: sample_climo
    };
  } // add black perfect reliability line curve


  var perfectLine = matsDataCurveOpsUtils.getLinearValueLine(curveInfoParams.xmax, curveInfoParams.xmin, data.ymax, data.ymin, matsTypes.ReservedWords.perfectReliability);
  dataset.push(perfectLine);

  if (sample_climo >= data.ymin) {
    var skillmin = sample_climo - (sample_climo - data.xmin) / 2;
  } else {
    var skillmin = data.xmin - (data.xmin - sample_climo) / 2;
  }

  if (sample_climo >= data.ymax) {
    var skillmax = sample_climo - (sample_climo - data.xmax) / 2;
  } else {
    var skillmax = data.xmax - (data.xmax - sample_climo) / 2;
  } // add black no skill line curve


  var noSkillLine = matsDataCurveOpsUtils.getLinearValueLine(curveInfoParams.xmax, curveInfoParams.xmin, skillmax, skillmin, matsTypes.ReservedWords.noSkill);
  dataset.push(noSkillLine); // add sample climo lines
  // need to define the minimum and maximum x value for making the curves

  var xClimoLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, sample_climo, matsTypes.ReservedWords.zero);
  dataset.push(xClimoLine);
  var yClimoLine = matsDataCurveOpsUtils.getVerticalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, sample_climo, matsTypes.ReservedWords.zero);
  dataset.push(yClimoLine); // generate plot options

  var resultOptions = matsDataPlotOpsUtils.generateReliabilityPlotOptions();
  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

var processDataHistogram = function (allReturnedSubStats, allReturnedSubSecs, allReturnedSubLevs, dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams) {
  var error = "";
  var curvesLengthSoFar = 0; // flatten all the returned data into one stats array and one secs array in order to calculate histogram bins over the whole range.

  var curveSubStats = [].concat.apply([], allReturnedSubStats);
  var curveSubSecs = [].concat.apply([], allReturnedSubSecs);
  var binStats;

  if (binParams.binBounds.length === 0) {
    binStats = matsDataUtils.calculateHistogramBins(curveSubStats, curveSubSecs, binParams).binStats;
  } else {
    binStats = matsDataUtils.prescribeHistogramBins(curveSubStats, curveSubSecs, binParams).binStats;
  } // store bin labels and x-axis positions of those labels for later when we set up the plot options


  var plotBins = {};
  plotBins['binMeans'] = [];
  plotBins['binLabels'] = [];

  for (var b_idx = 0; b_idx < binStats.binMeans.length; b_idx++) {
    plotBins['binMeans'].push(binStats.binMeans[b_idx]);
    plotBins['binLabels'].push(binStats.binLabels[b_idx]);
  } // post process curves


  var sortedData;
  var curve;
  var diffFrom;
  var label;

  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    curve = curveInfoParams.curves[curveIndex];
    diffFrom = curve.diffFrom;
    label = curve.label;
    var d = {
      // d will contain the curve data
      x: [],
      //placeholder
      y: [],
      //placeholder
      error_x: [],
      // unused
      error_y: [],
      // unused
      subVals: [],
      subSecs: [],
      subLevs: [],
      glob_stats: {},
      // placeholder
      bin_stats: [],
      // placeholder
      text: [],
      //placeholder
      xmin: Number.MAX_VALUE,
      xmax: Number.MIN_VALUE,
      ymin: Number.MAX_VALUE,
      ymax: Number.MIN_VALUE
    };

    if (diffFrom == null) {
      var postQueryStartMoment = moment();

      if (curveInfoParams.dataFoundForCurve[curveIndex]) {
        // sort queried data into the full set of histogram bins
        sortedData = matsDataUtils.sortHistogramBins(allReturnedSubStats[curveIndex], allReturnedSubSecs[curveIndex], allReturnedSubLevs[curveIndex], binParams.binNum, binStats, appParams.hasLevels, d);
        d = sortedData.d;
      }
    } else {
      // this is a difference curve, so we're done with regular curves.
      // do any matching that needs to be done.
      if (appParams.matching && !bookkeepingParams.alreadyMatched) {
        if (appParams.hasLevels) {
          dataset = matsDataMatchUtils.getMatchedDataSetHistogramWithLevels(dataset, curvesLengthSoFar, binStats);
        } else {
          dataset = matsDataMatchUtils.getMatchedDataSetHistogram(dataset, curvesLengthSoFar, binStats);
        }

        bookkeepingParams.alreadyMatched = true;
      } // then take diffs


      var diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, matsTypes.PlotTypes.histogram, appParams.hasLevels); // adjust axis stats based on new data from diff curve

      d = diffResult.dataset;
    } // set curve annotation to be the curve mean -- may be recalculated later
    // also pass previously calculated axis stats to curve options


    curve['annotation'] = "";
    curve['axisKey'] = curveInfoParams.curves[curveIndex].axisKey;
    var cOptions = matsDataCurveOpsUtils.generateBarChartCurveOptions(curve, curveIndex, curveInfoParams.axisMap, d); // generate plot with data, curve annotation, axis labels, etc.

    dataset.push(cOptions);
    curvesLengthSoFar++;
    var postQueryFinishMoment = moment();
    bookkeepingParams.dataRequests["post data retrieval (query) process time - " + curve.label] = {
      begin: postQueryStartMoment.format(),
      finish: postQueryFinishMoment.format(),
      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'
    };
  } // end for curves
  // if matching, pare down dataset to only matching data. Only do this if we didn't already do it while calculating diffs.


  if (curveInfoParams.curvesLength > 1 && appParams.matching && !bookkeepingParams.alreadyMatched) {
    if (appParams.hasLevels) {
      dataset = matsDataMatchUtils.getMatchedDataSetHistogramWithLevels(dataset, curveInfoParams.curvesLength, binStats);
    } else {
      dataset = matsDataMatchUtils.getMatchedDataSetHistogram(dataset, curveInfoParams.curvesLength, binStats);
    }
  } // calculate data statistics (including error bars) for each curve


  for (curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {
    var statisticSelect = curveInfoParams.curves[curveIndex]['statistic'];
    diffFrom = curveInfoParams.curves[curveIndex].diffFrom;
    var data = dataset[curveIndex];
    label = dataset[curveIndex].label;
    var di = 0;

    while (di < data.x.length) {
      if (curveInfoParams.yAxisFormat === 'Relative frequency') {
        // replace the bin number with the bin relative frequency for the plotted statistic
        data.y[di] = data.bin_stats[di].bin_rf * 100;
      } // remove sub values and times to save space


      data.subVals[di] = [];
      data.subSecs[di] = [];
      data.subLevs[di] = []; // this is the tooltip, it is the last element of each dataseries element

      data.text[di] = label + "<br>" + "bin: " + di + " (" + statisticSelect + " values between " + (data.bin_stats[di].binLowBound === null ? null : data.bin_stats[di].binLowBound.toPrecision(4)) + " and " + (data.bin_stats[di].binUpBound === null ? null : data.bin_stats[di].binUpBound.toPrecision(4)) + ")" + "<br>" + "number in bin for this curve: " + (data.y[di] === null ? null : data.y[di]) + "<br>bin mean for this curve: " + statisticSelect + " = " + (data.bin_stats[di].bin_mean === null ? null : data.bin_stats[di].bin_mean.toPrecision(4)) + "<br>bin sd  for this curve: " + statisticSelect + " = " + (data.bin_stats[di].bin_sd === null ? null : data.bin_stats[di].bin_sd.toPrecision(4));
      di++;
    }
  } // end curves
  // generate plot options


  var resultOptions = matsDataPlotOpsUtils.generateHistogramPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, plotBins);
  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

var processDataContour = function (dataset, curveInfoParams, plotParams, bookkeepingParams) {
  var error = "";
  var appName = matsCollections.appName.findOne({}).app;
  var statisticSelect = appName.indexOf("anomalycor") !== -1 ? "ACC" : curveInfoParams.curve[0]['statistic'];
  var data = dataset[0];
  var label = dataset[0].label;

  if (data.xAxisKey.indexOf("Date") !== -1) {
    data.x = data.x.map(function (val) {
      return moment.utc(val * 1000).format("YYYY-MM-DD HH:mm");
    });
  } else if (data.yAxisKey.indexOf("Date") !== -1) {
    data.y = data.y.map(function (val) {
      return moment.utc(val * 1000).format("YYYY-MM-DD HH:mm");
    });
  }

  var i;
  var j;
  var currX;
  var currY;
  var currText;
  var currYTextArray;

  for (j = 0; j < data.y.length; j++) {
    currY = data.y[j];
    currYTextArray = [];

    for (i = 0; i < data.x.length; i++) {
      currX = data.x[i];
      currText = label + "<br>" + data['xAxisKey'] + ": " + data.x[i] + "<br>" + data['yAxisKey'] + ": " + data.y[j] + "<br>" + statisticSelect + ": " + (data.z[j][i] === undefined || data.z[j][i] === null || data.z[j][i] === 'null' ? null : data.z[j][i].toPrecision(4)) + "<br>n: " + data['n'][j][i];
      currYTextArray.push(currText);
    }

    data.text.push(currYTextArray);
  } // generate plot options


  var resultOptions = matsDataPlotOpsUtils.generateContourPlotOptions(dataset, curveInfoParams.axisMap);
  var totalProcessingFinish = moment();
  bookkeepingParams.dataRequests["total retrieval and processing time for curve set"] = {
    begin: bookkeepingParams.totalProcessingStart.format(),
    finish: totalProcessingFinish.format(),
    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'
  }; // pass result to client-side plotting functions

  return {
    error: error,
    data: dataset,
    options: resultOptions,
    basis: {
      plotParams: plotParams,
      queries: bookkeepingParams.dataRequests
    }
  };
};

module.exportDefault(matsDataProcessUtils = {
  processDataXYCurve: processDataXYCurve,
  processDataProfile: processDataProfile,
  processDataReliability: processDataReliability,
  processDataHistogram: processDataHistogram,
  processDataContour: processDataContour
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"plot_spec_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/plot_spec_util.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var matsCollections, matsDataCurveOpsUtils, matsDataDiffUtils, matsDataProcessUtils, matsDataQueryUtils, matsDataUtils, matsMethods, matsParamUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  },
  matsDataCurveOpsUtils: function (v) {
    matsDataCurveOpsUtils = v;
  },
  matsDataDiffUtils: function (v) {
    matsDataDiffUtils = v;
  },
  matsDataProcessUtils: function (v) {
    matsDataProcessUtils = v;
  },
  matsDataQueryUtils: function (v) {
    matsDataQueryUtils = v;
  },
  matsDataUtils: function (v) {
    matsDataUtils = v;
  },
  matsMethods: function (v) {
    matsMethods = v;
  },
  matsParamUtils: function (v) {
    matsParamUtils = v;
  },
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 1);
var mysql;
module.link("meteor/pcel:mysql", {
  mysql: function (v) {
    mysql = v;
  }
}, 2);
var moment;
module.link("meteor/momentjs:moment", {
  moment: function (v) {
    moment = v;
  }
}, 3);
var statMvTranslation = {
  'ACC': "ANOM_CORR",
  'RMS': 'RMSE',
  'Bias (Model - Obs)': 'ME',
  'Model average': "FBAR",
  'Obs average': "OBAR"
};

var xmlBuilder = require('xmlbuilder');

var _pad = function (num, size) {
  var s = num + "";

  while (s.length < size) {
    s = "0" + s;
  }

  return s;
};

var _title = function () {
  try {
    if (matsCollections.Settings === undefined || matsCollections.Settings.findOne({}, {
      fields: {
        Title: 1
      }
    }) === undefined) {
      return "";
    } else {
      return matsCollections.Settings.findOne({}, {
        fields: {
          Title: 1
        }
      }).Title;
    }
  } catch (someError) {
    return "";
  }
};

var _plotText = function (plotParams) {
  var format = plotParams.plotFormat;

  if (matsCollections.PlotParams.findOne({
    name: 'plotFormat'
  }) && matsCollections.PlotParams.findOne({
    name: 'plotFormat'
  }).optionsMap && matsCollections.PlotParams.findOne({
    name: 'plotFormat'
  }).optionsMap[plotParams.plotFormat] !== undefined) {
    format = matsCollections.PlotParams.findOne({
      name: 'plotFormat'
    }).optionsMap[plotParams.plotFormat];
  }

  if (format === undefined) {
    format = "Unmatched";
  }

  var plotType = _.invert(plotParams.plotTypes)[true];

  switch (plotType) {
    case matsTypes.PlotTypes.timeSeries:
      return "TimeSeries " + plotParams.dates + " : " + format;
      break;

    case matsTypes.PlotTypes.profile:
      return "Profile: " + format;
      break;

    case matsTypes.PlotTypes.dieoff:
      return "DieOff: " + format;
      break;

    case matsTypes.PlotTypes.threshold:
      return "Threshold: " + format;
      break;

    case matsTypes.PlotTypes.validtime:
      return "ValidTime: " + format;
      break;

    case matsTypes.PlotTypes.dailyModelCycle:
      return "DailyModelCycle " + plotParams.dates + " : " + format;
      break;

    case matsTypes.PlotTypes.reliability:
      return "Reliability: " + format;
      break;

    case matsTypes.PlotTypes.map:
      return "Map " + plotParams.dates + " ";
      break;

    case matsTypes.PlotTypes.histogram:
      return "Histogram: " + format;
      break;

    default:
      return "Scatter: " + plotParams.dates + " : " + format;
  }
};

var _componentToHex = function (c) {
  var hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
};

var _rgbToHex = function (color) {
  var cParts = color.replace('rgb(', '').replace(')', '').split(',');
  var r = Number(cParts[0]);
  var g = Number(cParts[1]);
  var b = Number(cParts[2]);
  return "#" + _componentToHex(r) + _componentToHex(g) + _componentToHex(b);
};

var _getUniqDates = function (dates, database, model, dataSource, region, variable, forecastLength, fromSecs, toSecs, validTimes) {
  var regionsClause = "";

  if (region != null) {
    region = Array.isArray(region) ? region : [region];

    if (region.length > 0) {
      var regions = region.map(function (r) {
        return "'" + r + "'";
      }).join(',');
      regionsClause = "and h.vx_mask IN(" + regions + ")";
    }
  } // the forecast lengths appear to have sometimes been inconsistent (by format) in the varias databases
  // so they have been sanitized for display purposes in the forecastValueMap.
  // now we have to go get the damn ole unsanitary ones for the database.


  var forecastLengthsClause = "";

  if (forecastLength != null) {
    forecastLength = Array.isArray(forecastLength) ? forecastLength : [forecastLength];

    if (forecastLength.length > 0) {
      var forecastValueMap = matsCollections.CurveParams.findOne({
        name: 'forecast-length'
      }, {
        valuesMap: 1
      })['valuesMap'][database][dataSource];
      var forecastLengths = forecastLength.map(function (fl) {
        return forecastValueMap[fl];
      }).join(',');
      forecastLengthsClause = "and ld.fcst_lead IN (" + forecastLengths + ")";
    }
  }

  var statement = "select ld.fcst_valid_beg as avtime " + "from " + database + ".stat_header h, " + database + ".line_data_sl1l2 ld " + "where 1=1 and h.model = '" + model + "' " + regionsClause + "and unix_timestamp(ld.fcst_valid_beg) >= '" + fromSecs + "' " + "and unix_timestamp(ld.fcst_valid_beg) <= '" + toSecs + "' " + forecastLengthsClause + "and h.fcst_var = '" + variable + "' " + "and ld.stat_header_id = h.stat_header_id " + "group by avtime order by avtime;";
  var rows = matsDataQueryUtils.simplePoolQueryWrapSynchronous(metadataPool, statement);

  if (rows === undefined || rows === null || rows.length === 0) {
    console.log(matsTypes.Messages.NO_DATA_FOUND);
  } else {
    for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      var dstrMoment = moment(rows[rowIndex].avtime);
      var dstr = dstrMoment.format('YYYY-MM-DD HH:mm:ss').trim(); // apply the valid-time filter here.....

      var valid = true;

      if (validTimes != null && validTimes.length > 0) {
        valid = false;
        var momentSdiHour = Number(dstrMoment.format("HH"));

        for (var vti = 0; vti < validTimes.length; vti++) {
          var thisvt = Number(validTimes[vti]);

          if (momentSdiHour === thisvt) {
            // it is valid
            valid = true;
            break;
          }
        }
      }

      if (valid === true && dates.indexOf(dstr) === -1) {
        dates.push(dstr);
      }
    }
  }

  return dates;
}; // adds date elements to an element of the current xml between a start and an end date, incremented by specific seconds
// series variables can be grouped or ungrouped.
// e.g. grouped ...    <val>2018-11-01 00:00:00,2018-11-01 06:00:00,2018-11-01 12:00:00,2018-11-01</val>
// e.g. ungrouped ...    <val>2018-11-01 00:00:00</val>
//                       <val>2018-11-01 06:00:00</val>
//                       <val>2018-11-01 12:00:00</val>
//                       <val>2018-11-01</val>
// for time series valid_beg is always ungrouped.


var _getSortedDatesForIndepRange = function (plotParams) {
  var dateRange = matsDataUtils.getDateRange(plotParams.dates);
  var fromSecs = dateRange.fromSeconds;
  var toSecs = dateRange.toSeconds;
  var curves = plotParams.curves; // have to get all the valid dates for each curve then union them
  // to get a complete date list

  var dates = [];

  for (var ci = 0; ci < curves.length; ci++) {
    if (curves[ci]['diffFrom']) {
      // currrently we do not do mv differencing
      continue;
    }

    var curve = curves[ci];
    var validTimes = curve['valid-time'];
    var region = curve['region'];
    var forecastLength = curve['forecast-length'];
    var variable = curve['variable']; //example 2018-11-06 00:00:00

    var database = curve['database'];
    var dataSource = curve['data-source'];
    var model = matsCollections.CurveParams.findOne({
      name: 'data-source'
    }).optionsMap[database][dataSource][0];
    dates = _getUniqDates(dates, database, model, dataSource, region, variable, forecastLength, fromSecs, toSecs, validTimes);
  } // sort the dates


  var sortedDates = dates.sort(function (a, b) {
    return new moment(a) - new moment(b);
  });
  return sortedDates;
};

var _getSortedHoursForIndepRange = function (plotParams) {
  var sortedDates = _getSortedDatesForIndepRange(plotParams);

  var hours = new Set();

  for (var di = 0; di < sortedDates.length; di++) {
    var hour = moment(sortedDates[di]).format("HH");
    hours.add(hour);
  }

  return Array.from(hours).sort();
};

var _getSortedDatesForDepRange = function (curve) {
  var dates = [];
  var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);
  var fromSecs = dateRange.fromSeconds;
  var toSecs = dateRange.toSeconds;
  var validTimes = curve['valid-time'];
  var region = curve['region'];
  var forecastLength = curve['forecast-length'];
  var variable = curve['variable']; //example 2018-11-06 00:00:00

  var database = curve['database'];
  var dataSource = curve['data-source'];
  var model = matsCollections.CurveParams.findOne({
    name: 'data-source'
  }).optionsMap[database][dataSource][0];
  dates = _getUniqDates(dates, database, model, dataSource, region, variable, forecastLength, fromSecs, toSecs, validTimes); // sort the dates

  var sortedDates = dates.sort(function (a, b) {
    return new moment(a) - new moment(b);
  });
  return sortedDates;
}; // for profiles valid_beg is always grouped.


var addIndepUngroupedDateElementsBetween = function (element, plotParams) {
  var sortedDates = _getSortedDatesForIndepRange(plotParams); //these must be ungrouped


  for (var sdi = 0; sdi < sortedDates.length; sdi++) {
    element.ele('val', {
      'label': sortedDates[sdi],
      'plot_val': ""
    }, sortedDates[sdi]);
  }
}; // parse the databases from the curves and add a database string


var addDatabaseElement = function (element, curves) {
  try {
    databases = [];

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      if (!databases.includes(curves[ci].database)) {
        databases.push(curves[ci].database);
      }
    }

    databasesStr = databases.join("'");
    element.ele('database', databasesStr);
    return element;
  } catch (someError) {
    return "";
  }
}; // add the required metviewer folders


var addFolders = function (element) {
  try {
    element.ele('rscript', Meteor.settings.private.MV_RSCRIPT);
    var folders = element.ele('folders');
    folders.ele('r_tmpl', matsMethods.MV_DIRS.HOME + "/R_tmpl");
    folders.ele('r_work', matsMethods.MV_DIRS.HOME + "/R_work");
    folders.ele('plots', matsMethods.MV_DIRS.PLOTSDIR);
    folders.ele('data', matsMethods.MV_DIRS.DATADIR);
    folders.ele('scripts', matsMethods.MV_DIRS.SCRIPTSDIR);
    return element;
  } catch (e) {}
}; // start the plotspec


var startPlotSpec = function (pool, plotParams) {
  try {
    var xml = xmlBuilder.create('plot_spec', {
      version: "1.0",
      encoding: "UTF-8",
      standalone: false
    });
    var connection = xml.ele('connection');
    connection.ele('host', sumPool.config.connectionConfig.host + ":" + sumPool.config.connectionConfig.port);
    addDatabaseElement(connection, plotParams.curves);
    connection.ele('user', sumPool.config.connectionConfig.user);
    connection.ele('password', sumPool.config.connectionConfig.password);
    var management_system = Meteor.settings.private.MV_DB_MANAGEMENT_SYSTEM != null ? Meteor.settings.private.MV_DB_MANAGEMENT_SYSTEM : "mysql";
    connection.ele('management_system', management_system);
    addFolders(xml);
    var plot = xml.ele('plot');
    return {
      xml: xml,
      plot: plot
    };
  } catch (e) {}
};

var addPlotCi = function (element, plotParams) {
  try {
    //example c("none","none")
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('"none"');
    }

    cListStr += cList.join(',') + ')';
    element.ele('plot_ci', cListStr);
  } catch (e) {}
};

var addShowSignif = function (element, plotParams) {
  try {
    //example c(FALSE,FALSE)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('FALSE');
    }

    cListStr += cList.join(',') + ')';
    element.ele('show_signif', cListStr);
  } catch (e) {}
};

var addPlotDisp = function (element, plotParams) {
  try {
    //example c(TRUE,TRUE)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      cList.push('TRUE');
    }

    cListStr += cList.join(',') + ')';
    element.ele('plot_disp', cListStr);
  } catch (e) {}
};

var addColors = function (element, plotParams) {
  try {
    //  example  'c("#ff0000FF","#8000ffFF")'
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      var ch = _rgbToHex(curves[ci].color) + "FF";
      cList.push('"' + ch + '"');
    }

    cListStr += cList.join(',') + ')';
    element.ele('colors', cListStr);
  } catch (e) {}
};

var addPch = function (element, plotParams) {
  try {
    //example c(20,20)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('20');
    }

    cListStr += cList.join(',') + ')';
    element.ele('pch', cListStr);
  } catch (e) {}
};

var addType = function (element, plotParams) {
  try {
    //example c("b","b")
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('"b"');
    }

    cListStr += cList.join(',') + ')';
    element.ele('type', cListStr);
  } catch (e) {}
};

var addLty = function (element, plotParams) {
  try {
    // example c(1,1)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push(1);
    }

    cListStr += cList.join(',') + ')';
    element.ele('lty', cListStr);
  } catch (e) {}
};

var addLwd = function (element, plotParams) {
  try {
    // example c(1,1)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push(1);
    }

    cListStr += cList.join(',') + ')';
    element.ele('lwd', cListStr);
  } catch (e) {}
};

var addConSeries = function (element, plotParams) {
  try {
    // example c(1,1)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push(1);
    }

    cListStr += cList.join(',') + ')';
    element.ele('con_series', cListStr);
  } catch (e) {}
};

var addOrderSeries = function (element, plotParams) {
  try {
    // example c(1,2)
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push(ci + 1);
    }

    cListStr += cList.join(',') + ')';
    element.ele('order_series', cListStr);
  } catch (e) {}
};

var addLegend = function (element, plotParams) {
  try {
    // example c("","")
    var curves = plotParams.curves;
    var cList = [];
    var cListStr = 'c(';

    for (var ci = 0; ci < curves.length; ci++) {
      if (curves[ci]['diffFrom']) {
        // currrently we do not do mv differencing
        continue;
      }

      cList.push('""');
    }

    cListStr += cList.join(',') + ')';
    element.ele('legend', cListStr);
  } catch (e) {}
};

var addSeries = function (plot, dependentAxes, plotParams) {
  /***
   data-source(models), region(vx_mask),forecast_length (fcst_lead), and pres-level(fcst_lev)
   are series variables. Multiple selections for a given curve are MV grouped (join'd)
   Multiple selections associated with different curves are seperate <val> tags.
    All of the non grouped combinations are added which results in possibly too many curves. The redundant ones are later hidden.
    They can also go on the axis that is associated with the curve that the region parameter is on.
   In other words force a new series.
   i.e. Y1 Series variables or Y2 Series variables
    series variables can be grouped or ungrouped.
   e.g. grouped ...    <val>2018-11-01 00:00:00,2018-11-01 06:00:00,2018-11-01 12:00:00,2018-11-01</val>
   e.g. ungrouped ...    <val>2018-11-01 00:00:00</val>
   <val>2018-11-01 06:00:00</val>
   <val>2018-11-01 12:00:00</val>
   <val>2018-11-01</val>
   For MATS curves they are grouped for each curve and added ase series variables. This results in redundant curves in MV and so the
   redundant curves will be hidden.
   Curves that were assigned to different axis were figured out and assigned in getDependents and are assigned in the dependentAxes structure.
   ***/
  var hiddenCurves = [];
  var sVars = {
    'data-source': 'model',
    'region': 'vx_mask',
    'forecast-length': 'fcst_lead',
    'pres-level': 'fcst_lev'
  };

  var type = _.invert(plotParams.plotTypes)[true];

  var seriesAxisMap = {
    'series1': 'y1',
    'series2': 'y2'
  };
  Object.keys(seriesAxisMap).forEach(function (series) {
    var models = [];
    var vx_masks = [];
    var fcst_leads = [];
    var fcst_levls = [];
    var seriesElem = plot.ele(series);
    var axis = seriesAxisMap[series];
    var initHours = new Set();

    switch (type) {
      case matsTypes.PlotTypes.timeSeries:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev'
        };
        break;

      case matsTypes.PlotTypes.dailyModelCycle:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev'
        };
        break;

      case matsTypes.PlotTypes.profile:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      case matsTypes.PlotTypes.dieoff:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };

        for (var ci = 0; ci < plotParams.curves.length; ci++) {
          if (curves[ci]['diffFrom']) {
            // currrently we do not do mv differencing
            continue;
          }

          var c = plotParams.curves[ci];

          if (c['dieoff-type'] === 'Dieoff for a specified UTC cycle init hour') {
            initHours.add(c['utc-cycle-start']);
          } else if (c.dieoff - type === matsTypes.ForecastTypes.singleCycle) {// placeholder for if issue 60313 gets resolved
          }
        }

        if (initHours.size > 0) {
          sVars['utc-cycle-start'] = 'init_hour';
        }

        break;

      case matsTypes.PlotTypes.threshold:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      case matsTypes.PlotTypes.validtime:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      case matsTypes.PlotTypes.reliability:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      case matsTypes.PlotTypes.histogram:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev',
          'curve-dates': 'fcst_valid_beg'
        };
        break;

      default:
        sVars = {
          'data-source': 'model',
          'region': 'vx_mask',
          'forecast-length': 'fcst_lead',
          'pres-level': 'fcst_lev'
        };
    }

    if (type === matsTypes.PlotTypes.profile) {
      delete sVars['pres-level'];
    } else {
      // we only consider pressure levels when it isn't a profile
      sVars['pres-level'] = 'fcst_lev';
    }

    var seriesElements = {};
    var seriesElementValues = {};

    var _loop = function () {
      var curve = dependentAxes[axis][daci];
      var database = curve['database'];
      var dataSource = curve['data-source'];
      Object.keys(sVars).forEach(function (sVar) {
        try {
          // models - not multiple - ungrouped
          var sValues = [];

          switch (sVar) {
            case 'data-source':
              // convert data-source to single element array
              sValues = [matsParamUtils.getParameterForName(sVar).optionsMap[database][dataSource][0]];
              break;

            case 'curve-dates':
              sValues = _getSortedDatesForDepRange(curve);
              break;

            case 'utc-cycle-start':
              var _v = curve['utc-cycle-start'];

              var paddedV = _pad(_v, 2);

              sValues = [paddedV]; // turn single selection padded value into array

              break;

            case 'forecast-length':
              sValues = curve[sVar];

              if (sValues == null || sValues.length === 0) {
                sValues = matsParamUtils.getParameterForName(sVar).optionsMap[database][dataSource]; // have to assign all the fcst leads
              }

              var forecastValueMap = matsParamUtils.getParameterForName(sVar).valuesMap[database][dataSource];
              sValues = sValues.map(function (fl) {
                return forecastValueMap[fl];
              }).join(',');
              break;

            default:
              sValues = curve[sVar];

              if (sValues == null || sValues.length === 0) {
                sValues = matsParamUtils.getParameterForName(sVar).optionsMap[database][dataSource]; // have to assign all the regions
              }

          } // check to see if this element was already added.
          // if not added then add the element.
          // if element was already added see if we need to add this value.
          // multiples are always grouped.


          if (sValues !== undefined) {
            sValues = Array.isArray(sValues) ? sValues : [sValues];

            if (sValues.length > 0) {
              var sValuesStr = sValues.join(',');

              if (sValuesStr !== undefined) {
                var thisVar = sVars[sVar];

                if (seriesElements[thisVar] == null) {
                  seriesElements[thisVar] = seriesElem.ele('field', {
                    'name': sVars[sVar]
                  });
                  seriesElementValues[thisVar] = new Set();
                  seriesElementValues[thisVar].add(sValuesStr);
                } else {
                  // already exists
                  if (seriesElementValues[thisVar].has(sValuesStr) === false) {
                    seriesElementValues[thisVar].add(sValuesStr);
                  }
                }
              }
            }
          }
        } catch (error) {
          console.log(error);
          throw new Meteor.Error(error);
        }
      });
    };

    for (var daci = 0; daci < dependentAxes[axis].length; daci++) {
      _loop();
    }

    var sElementKeys = Object.keys(seriesElements);

    for (var sei = 0; sei < sElementKeys.length; sei++) {
      var seVar = sElementKeys[sei];
      var svars = Array.from(seriesElementValues[seVar]).sort();

      for (var svi = 0; svi < svars.length; svi++) {
        var v = svars[svi];

        if (v !== "undefined") {
          seriesElements[seVar].ele('val', v);
        }
      }

      ;
    }
  });
};

var getDependentAxis = function (plotParams) {
  // there are two possible axis for metviewer. We want to collect all the variables
  // into groups. We will take the two largest groups.
  // variables and statistics go together. They are dependent variabales in MV.
  // The variable/stat pairs always are associated with different curves, and will always be on different axis,
  // if possible, but might be assigned an axis via an axes parameter.
  var yaxesDefault = "auto-by-variable";
  var curves = plotParams['curves'];
  var dependentAxes = {
    'y1': [],
    'y2': []
  };
  dependentAxes['y1'].push(curves[0]);
  var dependentAxesVariables = {
    'y1': [curves[0]['variable']],
    'y2': []
  };

  for (var ci = 1; ci < curves.length; ci++) {
    if (curves[ci]['diffFrom']) {
      // currrently we do not do mv differencing
      continue;
    }

    if (curves[ci].yaxes != yaxesDefault) {
      // it was assigned an axis by the axis param so sort it into its selectedYaxes
      dependentAxes[curves[ci].yaxes].push(curves[ci]);
    } else {
      // sort it into an axis by its variable/stat combination
      //     variables:
      //     variables that share an axis are different dependent variables. Put them in dep1.
      // unless it is a variable with multiple stats.
      // different variable with different stats that have differing axis must go in different Y axis vars (and you can only have two of those)
      var variable = curves[ci].variable;

      if (dependentAxesVariables['y1'].includes(variable)) {
        dependentAxes['y1'].push(curves[ci]);
      } else {
        dependentAxes['y2'].push(curves[ci]);
      }
    }
  }

  return dependentAxes;
};

function addDeps(plot, dependentAxes) {
  var dep = plot.ele('dep');
  var deps = {
    "dep1": "y1",
    "dep2": "y2"
  };

  for (var di = 0; di < Object.keys(deps).length; di++) {
    // [dep1, dep2]
    var depKey = Object.keys(deps)[di]; // dep1 or dep2

    var depAxis = deps[depKey];
    var subDep = dep.ele(depKey); //<dep><dep1/><dep2/>

    var variableStatisticPairs = {};

    for (var daci = 0; daci < dependentAxes[depAxis].length; daci++) {
      //[y1,y2]
      // record the variable-statistic pair
      var variable = dependentAxes[depAxis][daci]['variable'];
      var stat = statMvTranslation[dependentAxes[depAxis][daci]['statistic']];

      if (variableStatisticPairs[variable] == null) {
        variableStatisticPairs[variable] = [stat];
      } else {
        variableStatisticPairs[variable].push(stat);
      }
    }

    var vars = Object.keys(variableStatisticPairs); //['T','HGT','WIND'...]

    for (var v = 0; v < vars.length; v++) {
      var stats = Array.from(new Set(variableStatisticPairs[vars[v]]));
      var depElem = subDep.ele('fcst_var', {
        'name': vars[v]
      }); //<dep><dep1><fcst_var name='T'><stat>RMS</stat></fcst_var> </dep1><dep2/>

      for (var si = 0; si < stats.length; si++) {
        depElem.ele('stat', stats[si]);
      }
    }
  }
}

function addAnomalycorrDeps(plot, dependentAxes) {
  var dep = plot.ele('dep');
  var deps = {
    "dep1": "y1",
    "dep2": "y2"
  };

  for (var di = 0; di < Object.keys(deps).length; di++) {
    // [dep1, dep2]
    var depKey = Object.keys(deps)[di]; // dep1 or dep2

    var depAxis = deps[depKey];
    var subDep = dep.ele(depKey); //<dep><dep1/><dep2/>

    var variables = new Set();

    for (var daci = 0; daci < dependentAxes[depAxis].length; daci++) {
      //[y1,y2]
      var variable = dependentAxes[depAxis][daci]['variable'];
      variables.add(variable);
    }

    var vars = Array.from(variables);

    for (var v = 0; v < vars.length; v++) {
      subDep.ele('fcst_var', {
        'name': vars[v]
      }).ele('stat', 'ANOM_CORR');
    }
  }
}

var _addSeriesLabels = function (element, dependentAxes, plotParams) {
  var plotType = _.invert(plotParams.plotTypes)[true];

  var label;

  switch (plotType) {
    case matsTypes.PlotTypes.timeSeries:
      label = "Time";
      break;

    case matsTypes.PlotTypes.dieoff:
      label = "Forecast Hour";
      break;

    case matsTypes.PlotTypes.dailyModelCycle:
      label = "Time";
      break;

    case matsTypes.PlotTypes.histogram:
      label = "Bin";
      break;

    case matsTypes.PlotTypes.validtime:
      label = "Hour of Day";
      break;

    case matsTypes.PlotTypes.reliability:
      label = "Reliability";
      break;

    case matsTypes.PlotTypes.threshold:
      label = "Threshold";
      break;

    case matsTypes.PlotTypes.profile:
      var vars = new Set();
      plotParams.curves.forEach(function (c) {
        vars.add(c.variable);
      });
      label = Array.from(vars).join(' - ');
      break;

    default:
      label = "Time";
  }

  element.ele('x_label', label);
  var y1vars = [];

  for (var y1i = 0; y1i < dependentAxes['y1'].length; y1i++) {
    if (!y1vars.includes(dependentAxes['y1'][y1i]['variable'])) {
      y1vars.push(dependentAxes['y1'][y1i]['variable']);
    }
  }

  element.ele('y1_label', y1vars.join(','));
  var y2vars = [];

  for (var y2i = 0; y2i < dependentAxes['y2'].length; y2i++) {
    if (!y2vars.includes(dependentAxes['y2'][y2i]['variable'])) {
      y2vars.push(dependentAxes['y2'][y2i]['variable']);
    }
  }

  element.ele('y2_label', y2vars.join(','));
};

var addTemplate = function (plot, templateStr) {
  plot.ele('template', templateStr);
};

var addIndepDates = function (plot, plotParams) {
  var indep = plot.ele('indep', {
    'equalize': 'false',
    'name': 'fcst_valid_beg'
  });
  addIndepUngroupedDateElementsBetween(indep, plotParams);
};

var addIndepLevels = function (plot, plotParams) {
  // for profiles we use a union of all the levels available for all the data-sources
  var indep = plot.ele('indep', {
    'equalize': 'false',
    'name': 'fcst_lev'
  });
  var curves = plotParams.curves;
  var lvlSet = new Set(); // use a set to accumulate all the levels

  for (var ci = 0; ci < curves.length; ci++) {
    if (curves[ci]['diffFrom']) {
      // currrently we do not do mv differencing
      continue;
    }

    var curve = curves[ci];
    var database = curve['database'];
    var dataSource = curve['data-source'];
    var levelVals = matsCollections.CurveParams.findOne({
      name: 'data-source'
    })['levelsMap'][database][dataSource];
    lvlSet.add(levelVals);
  } // only add the fcst_lev tag if there are pres-levels requested - leaving it out will get them all


  var lvls = Array.from(lvlSet)[0];

  for (var li = 0; li < lvls.length; li++) {
    var val = indep.ele('val', lvls[li]);
    val.att('label', lvls[li]);
    val.att('plot_val', "");
  }
};

var addIndepValidHours = function (plot, plotParams) {
  // for validTimes we use a union of all the vts available for all the data-sources
  var indep = plot.ele('indep', {
    'equalize': 'false',
    'name': 'valid_hour'
  });

  var hours = _getSortedHoursForIndepRange(plotParams);

  for (var hi = 0; hi < hours.length; hi++) {
    var val = indep.ele('val', hours[hi]);
    val.att('label', hours[hi]);
    val.att('plot_val', "");
  }
};

var addIndepForecastHours = function (plot, plotParams) {
  // for dieoffs we use a union of all the fhrs available for all the data-sources
  var indep = plot.ele('indep', {
    'equalize': 'false',
    'name': 'fcst_lead'
  });
  var curves = plotParams.curves;
  var leadSet = new Set(); // use a set to accumulate all the levels

  for (var ci = 0; ci < curves.length; ci++) {
    if (curves[ci]['diffFrom']) {
      // currrently we do not do mv differencing
      continue;
    }

    var curve = curves[ci];
    var database = curve['database'];
    var dataSource = curve['data-source'];
    var forecastLengths = matsCollections.CurveParams.findOne({
      name: 'forecast-length'
    })['optionsMap'][database][dataSource];
    leadSet.add(forecastLengths);
  }

  var leads = Array.from(leadSet)[0];

  for (var li = 0; li < leads.length; li++) {
    var val = indep.ele('val', leads[li]);
    val.att('label', leads[li]);
    val.att('plot_val', "");
  }
};

var addTmpl = function (plot, key, plotParams, dependentAxes) {
  var tmpl = plot.ele('tmpl');
  tmpl.ele('data_file', key + '.data');
  tmpl.ele('plot_file', key + '.png');
  tmpl.ele('r_file', key + '.R');
  tmpl.ele('title', _title() + " : " + _plotText(plotParams) + " " + plotParams.plotAction);

  _addSeriesLabels(tmpl, dependentAxes, plotParams);

  tmpl.ele('caption');
  tmpl.ele('job_title');
  tmpl.ele('keep_revisions', 'false');
  tmpl.ele('listdiffseries1', 'list()');
  tmpl.ele('listdiffseries2', 'list()');
};

var addPlotFix = function (plot) {
  plot.ele('plot_fix');
};

var addPlotCond = function (plot, plotParams) {
  plot.ele('plot_cond');
};

var addCalcStat = function (plot, statType) {
  plot.ele('calc_stat').ele(statType, true);
}; // unused for time series


var addPlotStat = function (plot, stat) {
  //Statistics --- We always do Summary with Mean - so there
  plot.ele('plot_stat', stat);
};

var addPlotCmd = function (plot) {
  plot.ele('plot_cmd');
};

var addY1Lim = function (plot) {
  plot.ele('y1_lim', 'c()');
};

var addY1Bufr = function (plot) {
  plot.ele('y1_bufr', '0.04');
};

var addY2Lim = function (plot) {
  plot.ele('y2_lim', 'c()');
};

var addMiscellaneous = function (plot, plotParams) {
  plot.ele('event_equal', 'false');

  var plotType = _.invert(plotParams.plotTypes)[true];

  switch (plotType) {
    case matsTypes.PlotTypes.timeSeries:
    case matsTypes.PlotTypes.dieoff:
    case matsTypes.PlotTypes.dailyModelCycle:
    case matsTypes.PlotTypes.histogram:
    case matsTypes.PlotTypes.validtime:
    case matsTypes.PlotTypes.reliability:
    case matsTypes.PlotTypes.threshold:
      plot.ele('vert_plot', 'false');
      plot.ele('x_reverse', 'false');
      break;

    case matsTypes.PlotTypes.profile:
      plot.ele('vert_plot', 'true');
      plot.ele('x_reverse', 'true');
      break;

    default:
      plot.ele('vert_plot', 'false');
      plot.ele('x_reverse', 'false');
  }

  plot.ele('num_stats', 'false');
  plot.ele('indy1_stag', 'false');
  plot.ele('indy2_stag', 'false');
  plot.ele('grid_on', 'true');
  plot.ele('sync_axes', 'false');
  plot.ele('dump_points1', 'true');
  plot.ele('dump_points2', 'true');
  plot.ele('log_y1', 'false');
  plot.ele('log_y2', 'false');
  plot.ele('varianceinflationfactor', 'false');
  plot.ele('plot_type', 'png16m');
  plot.ele('plot_height', '8.5');
  plot.ele('plot_width', '11');
  plot.ele('plot_res', '72');
  plot.ele('plot_units', 'in');
  plot.ele('mar', 'c(8,4,5,4)');
  plot.ele('mgp', 'c(1,1,0)');
  plot.ele('cex', '1');
  plot.ele('title_weight', '2');
  plot.ele('title_size', '1.4');
  plot.ele('title_offset', '-2');
  plot.ele('title_align', '0.5');
  plot.ele('xtlab_orient', '1');
  plot.ele('xtlab_perp', '-0.75');
  plot.ele('xtlab_horiz', '0.5');
  plot.ele('xtlab_freq', '0');
  plot.ele('xtlab_size', '1');
  plot.ele('xlab_weight', '1');
  plot.ele('xlab_size', '1');
  plot.ele('xlab_offset', '2');
  plot.ele('xlab_align', '0.5');
  plot.ele('ytlab_orient', '1');
  plot.ele('ytlab_perp', '0.5');
  plot.ele('ytlab_horiz', '0.5');
  plot.ele('ytlab_size', '1');
  plot.ele('ylab_weight', '1');
  plot.ele('ylab_size', '1');
  plot.ele('ylab_offset', '-2');
  plot.ele('ylab_align', '0.5');
  plot.ele('grid_lty', '3');
  plot.ele('grid_col', '#cccccc');
  plot.ele('grid_lwd', '1');
  plot.ele('grid_x', 'listX');
  plot.ele('x2tlab_orient', '1');
  plot.ele('x2tlab_perp', '1');
  plot.ele('x2tlab_horiz', '0.5');
  plot.ele('x2tlab_size', '0.8');
  plot.ele('x2lab_size', '0.8');
  plot.ele('x2lab_offset', '-0.5');
  plot.ele('x2lab_align', '0.5');
  plot.ele('y2tlab_orient', '1');
  plot.ele('y2tlab_perp', '0.5');
  plot.ele('y2tlab_horiz', '0.5');
  plot.ele('y2tlab_size', '1');
  plot.ele('y2lab_size', '1');
  plot.ele('y2lab_offset', '1');
  plot.ele('y2lab_align', '0.5');
  plot.ele('legend_box', 'o');
  plot.ele('legend_inset', 'c(0, -.25)');
  plot.ele('legend_ncol', '3');
  plot.ele('legend_size', '0.8');
  plot.ele('caption_weight', '1');
  plot.ele('caption_col', '#333333');
  plot.ele('caption_size', '0.8');
  plot.ele('caption_offset', '3');
  plot.ele('caption_align', '0');
  plot.ele('ci_alpha', '0.05');
};

var endPlotSpec = function (xml) {
  xml.end({
    pretty: true
  });
};

module.exportDefault(matsPlotSpecUtils = {
  startPlotSpec: startPlotSpec,
  addDeps: addDeps,
  addAnomalycorrDeps: addAnomalycorrDeps,
  getDependentAxis: getDependentAxis,
  addDatabaseElement: addDatabaseElement,
  addFolders: addFolders,
  addPlotCi: addPlotCi,
  addShowSignif: addShowSignif,
  addPlotDisp: addPlotDisp,
  addColors: addColors,
  addPch: addPch,
  addType: addType,
  addLty: addLty,
  addLwd: addLwd,
  addConSeries: addConSeries,
  addOrderSeries: addOrderSeries,
  addLegend: addLegend,
  addSeries: addSeries,
  addTemplate: addTemplate,
  addIndepDates: addIndepDates,
  addTmpl: addTmpl,
  addPlotFix: addPlotFix,
  addPlotCond: addPlotCond,
  addCalcStat: addCalcStat,
  addPlotStat: addPlotStat,
  addPlotCmd: addPlotCmd,
  addY1Lim: addY1Lim,
  addY1Bufr: addY1Bufr,
  addY2Lim: addY2Lim,
  addMiscellaneous: addMiscellaneous,
  endPlotSpec: endPlotSpec,
  addIndepLevels: addIndepLevels,
  addIndepForecastHours: addIndepForecastHours,
  addIndepValidHours: addIndepValidHours
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/index.js                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("./publications.js");
module.link("./data_util.js");
module.link("./data_query_util.js");
module.link("./data_diff_util.js");
module.link("./data_match_util.js");
module.link("./data_curve_ops_util.js");
module.link("./data_plot_ops_util.js");
module.link("./data_process_util.js");
module.link("./plot_spec_util.js");
module.link("./cache.js");
module.link("../both");
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"publications.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/publications.js                                                  //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);

if (Meteor.isServer) {
  Meteor.publish("CurveParams", function () {
    var data = matsCollections.CurveParams.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("CurveTextPatterns", function () {
    var data = matsCollections.CurveTextPatterns.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("ScatterAxisTextPattern", function () {
    var data = matsCollections.ScatterAxisTextPattern.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("SavedCurveParams", function () {
    var data = matsCollections.SavedCurveParams.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("PlotParams", function () {
    var data = matsCollections.PlotParams.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("Scatter2dParams", function () {
    var data = matsCollections.Scatter2dParams.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("PlotGraphFunctions", function () {
    var data = matsCollections.PlotGraphFunctions.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("RegionsPerModel", function () {
    var data = matsCollections.RegionsPerModel.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("SitesPerModel", function () {
    var data = matsCollections.SitesPerModel.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("RegionDescriptions", function () {
    var data = matsCollections.RegionDescriptions.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("Models", function () {
    var data = matsCollections.Models.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("FcstLensPerModel", function () {
    var data = matsCollections.FcstLensPerModel.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("ColorScheme", function () {
    var data = matsCollections.ColorScheme.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("Settings", function () {
    var data = matsCollections.Settings.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("CurveSettings", function () {
    var data = matsCollections.CurveSettings.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("SentAddresses", function () {
    var data = matsCollections.SentAddresses.find({
      userId: this.userId
    });

    if (data) {
      return data;
    }

    return this.ready();
  }); // do not publish roles
  // Meteor.publish("Roles", function () {
  //     var data = matsCollections.Roles.find({});
  //     if (data) {
  //         return data;
  //     }
  //     return this.ready();
  // });
  // do not publish Authorization
  // Meteor.publish("Authorization", function () {
  //     var data = matsCollections.Authorization.find({});
  //     if (data) {
  //         return data;
  //     }
  //     return this.ready();
  // });
  // do not publish credentials
  // Meteor.publish("Credentials", function () {
  //     var data = matsCollections.Credentials.find({});
  //     if (data) {
  //         return data;
  //     }
  //     return this.ready();
  // });
  //do not publish databases
  // Meteor.publish("Databases", function () {
  //     var data = matsCollections.Databases.find({});
  //     if (data) {
  //         return data;
  //     }
  //     return this.ready();
  // });

  Meteor.publish("SiteMap", function () {
    var data = matsCollections.SiteMap.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("StationMap", function () {
    var data = matsCollections.StationMap.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
  Meteor.publish("appName", function () {
    var data = matsCollections.appName.find({});

    if (data) {
      return data;
    }

    return this.ready();
  });
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"cache.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/imports/startup/server/cache.js                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);

if (Meteor.isServer) {
  var Results = require('node-file-cache').create({
    file: 'fileCache',
    life: 8 * 3600
  });

  var getResult = function (key) {
    //console.log('asked to get result from cache for key:', key);
    var result = Results.get(key);
    return result === null ? undefined : result;
  };

  var storeResult = function (key, result) {
    //console.log('asked to set result in cache for app: ',process.env.PWD, ' key:', key);
    Results.set(key, result); //console.log('set result in cache for app: ', process.env.PWD, 'key:', key);
  };

  var clear = function () {
    //console.log('asked to clear result cache');
    Results.clear();
  };

  var expireKey = function (key) {
    //console.log('asked to clear result cache for key ', key);
    Results.expire(key);
  };
}

module.exportDefault(matsCache = {
  getResult: getResult,
  storeResult: storeResult,
  clear: clear,
  expireKey: expireKey
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}}},"template.footer.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/template.footer.js                                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("footer");
Template["footer"] = new Template("Template.footer", (function() {
  var view = this;
  return HTML.NAV({
    id: "footnav",
    class: "navbar navbar-default",
    style: "display: block;"
  }, "\n    ", HTML.DIV({
    class: "container-fluid",
    style: "background-color: #dddddd;height:100%;margin-bottom:0;margin-top:0;padding-bottom:1em;padding-top:0;"
  }, "\n        ", HTML.Raw('<div class="navbar-header">\n            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-3" aria-expanded="false">\n                <span class="sr-only">Toggle navigation</span>\n                <span class="icon-bar"></span>\n                <span class="icon-bar"></span>\n                <span class="icon-bar"></span>\n            </button>\n        </div>'), "\n        ", HTML.Raw("<!-- Collect the nav links, forms, and other content for toggling -->"), "\n        ", HTML.DIV({
    class: "collapse navbar-collapse",
    id: "navbar-collapse-3",
    style: "background-color: #dddddd;height:100%;margin-bottom:0;margin-top:0;padding-bottom:1em;padding-top:0;"
  }, "\n            ", HTML.UL({
    class: "nav navbar-nav",
    style: "background-color: #dddddd;height:100%;margin-bottom:0;margin-top:0;padding-bottom:0;padding-top:0;"
  }, "\n                ", HTML.LI(Spacebars.include(view.lookupTemplate("version"))), "\n                ", HTML.Raw('<li style="height:1em"><a href="http://www.noaa.gov/privacy.html" class="navbar-link">NOAA Privacy Statement</a></li>'), "\n                ", HTML.Raw('<li style="height:1em"><a href="http://esrl.noaa.gov/gsd/accessibility.html" class="navbar-link">Web Accessibility Statement</a></li>'), "\n                ", HTML.Raw('<li style="height:1em"><a href="http://www.noaa.gov/disclaimer.html" class="navbar-link">Disclaimer for External Links</a></li>'), "\n                ", HTML.Raw('<li style="height:1em"><a href="http://www.noaa.gov/" class="navbar-link">NOAA</a></li>'), "\n                ", HTML.Raw('<li style="height:1em"><a href="http://www.commerce.gov/" class="navbar-link">U.S. Department of Commerce</a></li>'), "\n                ", HTML.Raw('<li style="height:1em"><a href="http://research.noaa.gov/" class="navbar-link">NOAA Research</a></li>'), "\n                ", HTML.Raw('<li style="height:1em"><a href="http://esrl.noaa.gov/" class="navbar-link">Earth System Research Laboratory</a></li>'), "\n                ", HTML.Raw('<li style="height:1em"><a href="http://esrl.noaa.gov/gsd/" class="navbar-link">Global Systems Division</a></li>'), "\n                ", HTML.Raw('<li style="height:1em"><a href="mailto:webmaster.hiwpp@noaa.gov" class="navbar-link">Contact the Webmaster</a></li>'), "\n            "), "\n        "), HTML.Raw("<!-- /.navbar-collapse -->"), "\n    "), HTML.Raw("<!-- /.container-fluid -->\n"));
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"lib":{"regression.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/lib/regression.js                                                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */
var gaussianElimination = function (a, o) {
  var i = 0,
      j = 0,
      k = 0,
      maxrow = 0,
      tmp = 0,
      n = a.length - 1,
      x = new Array(o);

  for (i = 0; i < n; i++) {
    maxrow = i;

    for (j = i + 1; j < n; j++) {
      if (Math.abs(a[i][j]) > Math.abs(a[i][maxrow])) maxrow = j;
    }

    for (k = i; k < n + 1; k++) {
      tmp = a[k][i];
      a[k][i] = a[k][maxrow];
      a[k][maxrow] = tmp;
    }

    for (j = i + 1; j < n; j++) {
      for (k = n; k >= i; k--) {
        a[k][j] -= a[k][i] * a[i][j] / a[i][i];
      }
    }
  }

  for (j = n - 1; j >= 0; j--) {
    tmp = 0;

    for (k = j + 1; k < n; k++) {
      tmp += a[k][j] * x[k];
    }

    x[j] = (a[n][j] - tmp) / a[j][j];
  }

  return x;
};

var methods = {
  linear: function (data) {
    var sum = [0, 0, 0, 0, 0],
        n = 0,
        results = [];

    for (; n < data.length; n++) {
      if (data[n][1] != null) {
        sum[0] += data[n][0];
        sum[1] += data[n][1];
        sum[2] += data[n][0] * data[n][0];
        sum[3] += data[n][0] * data[n][1];
        sum[4] += data[n][1] * data[n][1];
      }
    }

    var gradient = (n * sum[3] - sum[0] * sum[1]) / (n * sum[2] - sum[0] * sum[0]);
    var intercept = sum[1] / n - gradient * sum[0] / n; //  var correlation = (n * sum[3] - sum[0] * sum[1]) / Math.sqrt((n * sum[2] - sum[0] * sum[0]) * (n * sum[4] - sum[1] * sum[1]));

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], data[i][0] * gradient + intercept];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(gradient * 100) / 100 + 'x + ' + Math.round(intercept * 100) / 100;
    return {
      equation: [gradient, intercept],
      points: results,
      string: string
    };
  },
  linearThroughOrigin: function (data) {
    var sum = [0, 0],
        n = 0,
        results = [];

    for (; n < data.length; n++) {
      if (data[n][1] != null) {
        sum[0] += data[n][0] * data[n][0]; //sumSqX

        sum[1] += data[n][0] * data[n][1]; //sumXY
      }
    }

    var gradient = sum[1] / sum[0];

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], data[i][0] * gradient];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(gradient * 100) / 100 + 'x';
    return {
      equation: [gradient],
      points: results,
      string: string
    };
  },
  exponential: function (data) {
    var sum = [0, 0, 0, 0, 0, 0],
        n = 0,
        results = [];

    for (len = data.length; n < len; n++) {
      if (data[n][1] != null) {
        sum[0] += data[n][0];
        sum[1] += data[n][1];
        sum[2] += data[n][0] * data[n][0] * data[n][1];
        sum[3] += data[n][1] * Math.log(data[n][1]);
        sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
        sum[5] += data[n][0] * data[n][1];
      }
    }

    var denominator = sum[1] * sum[2] - sum[5] * sum[5];
    var A = Math.pow(Math.E, (sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
    var B = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], A * Math.pow(Math.E, B * data[i][0])];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(A * 100) / 100 + 'e^(' + Math.round(B * 100) / 100 + 'x)';
    return {
      equation: [A, B],
      points: results,
      string: string
    };
  },
  logarithmic: function (data) {
    var sum = [0, 0, 0, 0],
        n = 0,
        results = [];

    for (len = data.length; n < len; n++) {
      if (data[n][1] != null) {
        sum[0] += Math.log(data[n][0]);
        sum[1] += data[n][1] * Math.log(data[n][0]);
        sum[2] += data[n][1];
        sum[3] += Math.pow(Math.log(data[n][0]), 2);
      }
    }

    var B = (n * sum[1] - sum[2] * sum[0]) / (n * sum[3] - sum[0] * sum[0]);
    var A = (sum[2] - B * sum[0]) / n;

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], A + B * Math.log(data[i][0])];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(A * 100) / 100 + ' + ' + Math.round(B * 100) / 100 + ' ln(x)';
    return {
      equation: [A, B],
      points: results,
      string: string
    };
  },
  power: function (data) {
    var sum = [0, 0, 0, 0],
        n = 0,
        results = [];

    for (len = data.length; n < len; n++) {
      if (data[n][1] != null) {
        sum[0] += Math.log(data[n][0]);
        sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
        sum[2] += Math.log(data[n][1]);
        sum[3] += Math.pow(Math.log(data[n][0]), 2);
      }
    }

    var B = (n * sum[1] - sum[2] * sum[0]) / (n * sum[3] - sum[0] * sum[0]);
    var A = Math.pow(Math.E, (sum[2] - B * sum[0]) / n);

    for (var i = 0, len = data.length; i < len; i++) {
      var coordinate = [data[i][0], A * Math.pow(data[i][0], B)];
      results.push(coordinate);
    }

    var string = 'y = ' + Math.round(A * 100) / 100 + 'x^' + Math.round(B * 100) / 100;
    return {
      equation: [A, B],
      points: results,
      string: string
    };
  },
  polynomial: function (data, order) {
    if (typeof order == 'undefined') {
      order = 2;
    }

    var lhs = [],
        rhs = [],
        results = [],
        a = 0,
        b = 0,
        i = 0,
        k = order + 1;

    for (; i < k; i++) {
      for (var l = 0, len = data.length; l < len; l++) {
        if (data[l][1] != null) {
          a += Math.pow(data[l][0], i) * data[l][1];
        }
      }

      lhs.push(a), a = 0;
      var c = [];

      for (var j = 0; j < k; j++) {
        for (var l = 0, len = data.length; l < len; l++) {
          if (data[l][1] != null) {
            b += Math.pow(data[l][0], i + j);
          }
        }

        c.push(b), b = 0;
      }

      rhs.push(c);
    }

    rhs.push(lhs);
    var equation = gaussianElimination(rhs, k);

    for (var i = 0, len = data.length; i < len; i++) {
      var answer = 0;

      for (var w = 0; w < equation.length; w++) {
        answer += equation[w] * Math.pow(data[i][0], w);
      }

      results.push([data[i][0], answer]);
    }

    var string = 'y = ';

    for (var i = equation.length - 1; i >= 0; i--) {
      if (i > 1) string += Math.round(equation[i] * Math.pow(10, i)) / Math.pow(10, i) + 'x^' + i + ' + ';else if (i == 1) string += Math.round(equation[i] * 100) / 100 + 'x' + ' + ';else string += Math.round(equation[i] * 100) / 100;
    }

    return {
      equation: equation,
      points: results,
      string: string
    };
  },
  lastvalue: function (data) {
    var results = [];
    var lastvalue = null;

    for (var i = 0; i < data.length; i++) {
      if (data[i][1]) {
        lastvalue = data[i][1];
        results.push([data[i][0], data[i][1]]);
      } else {
        results.push([data[i][0], lastvalue]);
      }
    }

    return {
      equation: [lastvalue],
      points: results,
      string: "" + lastvalue
    };
  }
};
module.exportDefault(regression = function (method, data, order) {
  if (typeof method == 'string') {
    return methods[method](data, order);
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"param_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/lib/param_util.js                                                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 2);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 3);
var moment;
module.link("meteor/momentjs:moment", {
  moment: function (v) {
    moment = v;
  }
}, 4);

// get the document id for the control button element that corresponds to the param name
var getControlButtonIdForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  var pname = paramName.replace(/^.axis-/, '');
  var param = matsCollections.CurveParams.findOne({
    name: pname
  });

  if (param !== undefined) {
    var id = "controlButton-" + param.name;
    return id;
  }
}; // get the control Button Element that corresponds to the param name


var getControlElementForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  var pname = paramName.replace(/^.axis-/, '');
  return document.getElementById(getControlButtonIdForParamName(pname));
}; // get the document element that corresponds to the param name


var getValueElementForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  var pname = paramName.replace(/^.axis-/, '');
  var val = getValueIdForParamName(pname);
  return document.getElementById(val);
}; // get the current selected value in the document element that corresponds to the param name
// Note that the value should be reflected in the adjoining control button value textContent.


var getValueForParamName = function (paramName) {
  try {
    var elem = getValueElementForParamName(paramName);
    return getValueElementForParamName(paramName).textContent.trim();
  } catch (error) {
    return undefined;
  }
}; // get the VALUE BOX id for the element that corresponds to the param name


var getValueIdForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  var pname = paramName.replace(/^.axis-/, '');
  return "controlButton-" + pname + "-value";
}; // set the VALUE BOX text for the element that corresponds to the param name


var setValueTextForParamName = function (paramName, text) {
  try {
    var text = text;
    var param = matsCollections.CurveParams.findOne({
      name: paramName
    });

    if (param === undefined) {
      param = matsCollections.PlotParams.findOne({
        name: paramName
      });
    }

    if (param === undefined) {
      return;
    }

    if (text === undefined) {
      if (param.multiple) {
        // .... if multi selected  get the first .. last
        var selection = getInputElementForParamName(paramName).selectedOptions;

        if (selection.length == 0) {
          text = "";
        } else if (selection.length == 1) {
          text = selection[0].textContent;
        } else {
          text = selection[0].textContent + " .. " + selection[selection.length - 1].textContent;
        }
      }
    }

    var elem = getValueElementForParamName(paramName);

    if (elem.textContent !== text) {
      elem.textContent = text;
    }
  } catch (error) {
    console.log("Error: could not find param: " + paramName);
  }
}; // get the document id for the element that corresponds to the param name


var getInputIdForParamName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  var pname = paramName.replace(/^.axis-/, '');
  var param = matsCollections.CurveParams.findOne({
    name: pname
  });

  if (param === undefined) {
    param = matsCollections.PlotParams.findOne({
      name: pname
    });
  }

  if (param === undefined) {
    param = matsCollections.Scatter2dParams.findOne({
      name: pname
    });

    if (param === undefined) {
      return undefined;
    }
  }

  if (param.type === matsTypes.InputTypes.dateRange) {
    return ("element-" + param.name).replace(/ /g, '-');
  } else {
    return (param.name + "-" + param.type).replace(/ /g, '-');
  }
}; // get the parameter for the element that corresponds to the param name


var getParameterForName = function (paramName) {
  // scatter axis don't really exist in matsCollections.CurveParams but they are elements
  var pname = paramName.replace(/^.axis-/, '');
  var param = matsCollections.CurveParams.findOne({
    name: pname
  });

  if (param === undefined) {
    param = matsCollections.PlotParams.findOne({
      name: pname
    });
  }

  if (param === undefined) {
    param = matsCollections.Scatter2dParams.findOne({
      name: pname
    });

    if (param === undefined) {
      return undefined;
    }
  }

  return param;
}; // get the document element that corresponds to the param name


var getInputElementForParamName = function (paramName) {
  var name = paramName.replace(/^.axis-/, '');
  var id = getInputIdForParamName(name);

  if (id === undefined) {
    return undefined;
  }

  return document.getElementById(id);
}; // get a param disabledOptions list - if any.


var getDisabledOptionsForParamName = function (paramName) {
  var name = paramName.replace(/^.axis-/, '');
  var id = getInputIdForParamName(name);

  if (id === undefined) {
    return undefined;
  }

  var param = getParameterForName(name);

  if (!param) {
    return undefined;
  }

  return param.disabledOptions;
}; // set the input for the element that corresponds to the param name
// also sets a data-mats-currentValue attribute


var setInputForParamName = function (paramName, value) {
  var param = getParameterForName(paramName);
  var id = getInputIdForParamName(paramName);
  var idSelectorStr = "#" + id;
  var idSelector = $(idSelectorStr); // SHOULD DEAL WITH CHECKBOXES HERE

  if (param.type === matsTypes.InputTypes.radioGroup) {
    $("#" + id + "-" + value).prop("checked", true);
  } else {
    idSelector.val(value);
    setValueTextForParamName(paramName, value);
  }
};

var getElementValues = function () {
  var data = {
    curveParams: {},
    plotParams: {},
    scatterParams: {}
  };
  var axis = ['xaxis-', 'yaxis-'];
  var params = matsCollections.CurveParams.find({}).fetch();
  params.forEach(function (param) {
    var val = "";

    if (param.type === matsTypes.InputTypes.radioGroup) {
      var selector = "input:radio[name='" + param.name + "']:checked";
      val = $(selector).val();
    } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
      var selector = "input[name='" + param.name + "']:checked";
      val = $(selector).map(function (_, el) {
        return $(el).val();
      }).get();
    } else if (param.type === matsTypes.InputTypes.dateRange) {
      val = getValueForParamName(param.name);
    } else {
      var idSelect = '#' + getInputIdForParamName(param.name);
      val = $(idSelect).val();
    }

    data.curveParams[param.name] = val;

    if (matsPlotUtils.getPlotType() == matsTypes.PlotTypes.scatter2d) {
      for (var a = 0; a < axis.length; a++) {
        var axisStr = axis[a];
        var name = axisStr + param.name;
        var val = "";

        if (param.type === matsTypes.InputTypes.radioGroup) {
          var selector = "input:radio[name='" + name + "']:checked";
          val = $(selector).val();
        } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
          var selector = "input[name='" + name + "']:checked";
          val = $(selector).map(function (_, el) {
            return $(el).val();
          }).get();
        } else {
          var idSelect = '#' + getInputIdForParamName(name);
          val = $(idSelect).val();
        }

        data.curveParams[name] = val;
      }
    }
  });
  params = matsCollections.PlotParams.find({}).fetch();
  params.forEach(function (param) {
    var val = "";

    if (param.type === matsTypes.InputTypes.radioGroup) {
      var selector = "input:radio[name='" + param.name + "']:checked";
      val = $(selector).val();
    } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
      var selector = "input[name='" + param.name + "']:checked";
      val = $(selector).map(function (_, el) {
        return $(el).val();
      }).get();
    } else {
      var idSelect = '#' + getInputIdForParamName(param.name);
      val = $(idSelect).val();
    }

    data.plotParams[param.name] = val;
  });
  params = matsCollections.Scatter2dParams.find({}).fetch();
  params.forEach(function (param) {
    var val = "";

    if (param.type === matsTypes.InputTypes.radioGroup) {
      var selector = "input:radio[name='" + param.name + "']:checked";
      val = $(selector).val();
    } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
      var selector = "input[name='" + param.name + "']:checked";
      val = $(selector).map(function (_, el) {
        return $(el).val();
      }).get();
    } else {
      var idSelect = '#' + getInputIdForParamName(param.name);
      val = $(idSelect).val();
    }

    data.scatterParams[param.name] = val;

    if (matsPlotUtils.getPlotType() == matsTypes.PlotTypes.scatter2d) {
      for (var a = 0; a < axis.length; a++) {
        var axisStr = axis[a];
        var name = axisStr + param.name;
        var val = "";

        if (param.type === matsTypes.InputTypes.radioGroup) {
          var selector = "input:radio[name='" + name + "']:checked";
          val = $(selector).val();
        } else if (param.type === matsTypes.InputTypes.checkBoxGroup) {
          var selector = "input[name='" + name + "']:checked";
          val = $(selector).map(function (_, el) {
            return $(el).val();
          }).get();
        } else {
          var idSelect = '#' + getInputIdForParamName(name);
          val = $(idSelect).val();
        }

        data.scatterParams[name] = val;
      }
    }
  });
  return data;
};

var expandParams = function () {
  var params = matsCollections.CurveParams.find({}).fetch();
  params.forEach(function (param) {
    if (param.type !== matsTypes.InputTypes.selectMap) {
      var selector = "element" + "-" + param.name;
      var elem = document.getElementById(selector);

      if (elem) {
        elem.style.display = "block";
        var dataElem = document.getElementById(param.name + "-" + param.type);

        if (dataElem && dataElem.options && dataElem.selectedIndex >= 0) {
          dataElem.options[dataElem.selectedIndex].scrollIntoView();
        }
      }
    }
  });
};

var collapseParams = function () {
  var params = matsCollections.CurveParams.find({}).fetch();
  params.forEach(function (param) {
    if (param.type !== matsTypes.InputTypes.selectMap) {
      var selector = "element" + "-" + param.name;

      if (document.getElementById(selector)) {
        document.getElementById(selector).style.display = "none";
      }
    }
  });
};

var collapseParam = function (paramName) {
  var param = matsCollections.CurveParams.findOne({
    name: paramName
  });

  if (param === undefined || param === null) {
    return;
  }

  if (param.type !== matsTypes.InputTypes.selectMap) {
    var selector = "element" + "-" + param.name;

    if (document.getElementById(selector)) {
      document.getElementById(selector).style.display = "none";
    }
  }
};

var typeSort = function (arr) {
  if (arr === undefined) {
    return undefined;
  }

  return arr.sort(function (a, b) {
    if (isNaN(Number(a) && isNaN(Number(b)))) {
      // string compare
      var A = a.toLowerCase();
      var B = b.toLowerCase();

      if (A < B) {
        return -1;
      } else if (A > B) {
        return 1;
      } else {
        return 0;
      }
    } else if (isNaN(Number(a) || isNaN(Number(b)))) {
      // number always precedes
      if (isNaN(Number(a))) {
        return 1;
      } else {
        return -1;
      }
    } else {
      return a - b; // numerical compare
    }
  });
};

var setDefaultForParamName = function (param) {
  var paramName = param.name;
  var type = param.type;
  var defaultValue = param.default;

  if (paramName == 'label') {
    setInputForParamName(paramName, Session.get('NextCurveLabel'));
  } else {
    if (defaultValue != "undefined") {
      if (type === matsTypes.InputTypes.select && (defaultValue === -1 || defaultValue === undefined || defaultValue === matsTypes.InputTypes.unused)) {
        setInputForParamName(paramName, matsTypes.InputTypes.unused);
      } else {
        setInputForParamName(paramName, defaultValue);
      }
    }
  }
};

var getDefaultDateRange = function (name) {
  var dateParam = matsCollections.CurveParams.findOne({
    name: name
  });

  if (dateParam === undefined) {
    dateParam = matsCollections.PlotParams.findOne({
      name: name
    });
  }

  var startInit = dateParam.startDate;
  var stopInit = dateParam.stopDate;
  var dstr = dateParam.default;
  return {
    startDate: startInit,
    stopDate: stopInit,
    dstr: dstr
  };
};

var getMinMaxDates = function (minDate, maxDate) {
  var minMoment = moment(minDate, "MM/DD/YYYY HH:mm");
  var maxMoment = moment(maxDate, "MM/DD/YYYY HH:mm");

  if (maxMoment.diff(minMoment, 'days') > 30) {
    minDate = moment(maxMoment.subtract(30, 'days')).format("MM/DD/YYYY HH:mm");
  }

  return {
    minDate: minDate,
    maxDate: maxDate
  };
};

var setAllParamsToDefault = function () {
  // default the superiors and refresh them so that they cause the dependent options to refresh
  var params = matsCollections.CurveParams.find({}).fetch();
  var superiors = matsCollections.CurveParams.find({
    "dependentNames": {
      "$exists": true
    }
  }).fetch();
  superiors.forEach(function (param) {
    setDefaultForParamName(param); // actually call the refresh directly - don't use an event, because we want this all to be synchronous

    matsSelectUtils.refresh(null, param.name); // remove from params list - actually rewrite params list NOT with this param

    params = params.filter(function (obj) {
      return obj.name !== param.name;
    });
  }); // refresh all the non superiors to their default values

  var nonDependents = matsCollections.CurveParams.find({
    "superiorNames": {
      "$exists": true
    }
  }).fetch();
  nonDependents.forEach(function (param) {
    setDefaultForParamName(param);

    if (param.type === matsTypes.InputTypes.dateRange) {
      var dstr = getDefaultDateRange(param.name).dstr;
      setValueTextForParamName(param.name, dstr);
    } else {
      matsSelectUtils.refresh(null, param.name); // remove from params list - actually rewrite params list NOT with this param

      params = params.filter(function (obj) {
        return obj.name !== param.name;
      });
    }
  }); // reset everything else

  params.forEach(function (param) {
    if (param.type === matsTypes.InputTypes.dateRange) {
      var dstr = getDefaultDateRange(param.name).dstr;
      setValueTextForParamName(param.name, dstr);
    } else if (param.type === matsTypes.InputTypes.selectMap) {
      var targetId = param.name + '-' + param.type;
      var targetElem = document.getElementById(targetId);
      var resetMapEvent = new CustomEvent("reset", {
        detail: {
          refElement: null
        }
      });
      targetElem.dispatchEvent(resetMapEvent);
    } else {
      setDefaultForParamName(param);
    }
  });
  matsCollections.PlotParams.find({}).fetch().forEach(function (param) {
    if (param.type === matsTypes.InputTypes.dateRange) {
      var dstr = getDefaultDateRange(param.name).dstr;
      setValueTextForParamName(param.name, dstr);
    } else {
      setDefaultForParamName(param);
    }
  });
}; // is the input element displaying? used by curve_param_item_group


var isInputElementVisible = function (paramName) {
  var name = paramName.replace(/^.axis-/, ''); // need to acount for scatter plots params

  var inputElement = getInputElementForParamName(name);
  return $(inputElement).is(':visible');
}; // is the input element displaying? used by curve_param_item_group


var isParamVisible = function (paramName) {
  var name = paramName.replace(/^.axis-/, ''); // need to acount for scatter plots params

  var paramRef = "#" + name + "-item";
  return $(paramRef).is(':visible');
}; // is the input element displaying? used by curve_param_item_group


var isControlButtonVisible = function (paramName) {
  var name = paramName.replace(/^.axis-/, ''); // need to acount for scatter plots params

  var paramRef = "#controlButton-" + name;
  return $(paramRef).is(':visible');
};

var setInputValueForParamAndtriggerChange = function (paramName, value) {
  var elem = getInputElementForParamName(paramName);
  elem.value = value;
  setValueTextForParamName(paramName, elem.value);
  $(elem).trigger('change');
};

var getOptionsMapForParam = function (paramName) {
  var param = matsCollections.CurveParams.findOne({
    name: paramName
  });
  return param.optionsMap;
};

var getOptionsForParam = function (paramName) {
  var param = matsCollections.CurveParams.findOne({
    name: paramName
  });
  return param.options;
};

var getAppName = function () {
  var app = matsCollections.appName.findOne({}).app;
  return app;
};

var getCurveItemValueForParamName = function (curveNumber, paramName) {//MODEL-curve-0-Item
  //    const id = paramName.toString().toUpperCase() + "-curve-" + curveNumber + "-Item"; // the id of the text span for a curveItem
  //    return text = document.getElementById(id).innerText;
  // const elem = $("#" + id);
  // var text = undefined;
  // if (elem) {
  //     text = elem.text();
  // }
};

var visibilityControllerForParam = function (paramName) {
  /*
  Need to iterate all the params looking for one that has this paramName as a key in its
  hideOtherFor map.
  If it exists, that param is returned. Otherwise return undefined.
   */
  var params = matsCollections.CurveParams.find({}).fetch();
  var found = undefined;
  params.some(function (param) {
    if (param.hideOtherFor) {
      var pKeys = Object.keys(param.hideOtherFor);

      if (pKeys.indexOf(paramName) !== -1) {
        found = param;
        return;
      }
    }
  });
  return found;
};

module.exportDefault(matsParamUtils = {
  getDisabledOptionsForParamName: getDisabledOptionsForParamName,
  getControlButtonIdForParamName: getControlButtonIdForParamName,
  getControlElementForParamName: getControlElementForParamName,
  getValueElementForParamName: getValueElementForParamName,
  getValueForParamName: getValueForParamName,
  setValueTextForParamName: setValueTextForParamName,
  getValueIdForParamName: getValueIdForParamName,
  getInputIdForParamName: getInputIdForParamName,
  getInputElementForParamName: getInputElementForParamName,
  getElementValues: getElementValues,
  setInputForParamName: setInputForParamName,
  expandParams: expandParams,
  collapseParams: collapseParams,
  collapseParam: collapseParam,
  getParameterForName: getParameterForName,
  setDefaultForParamName: setDefaultForParamName,
  setAllParamsToDefault: setAllParamsToDefault,
  typeSort: typeSort,
  isInputElementVisible: isInputElementVisible,
  isParamVisible: isParamVisible,
  isControlButtonVisible: isControlButtonVisible,
  setInputValueForParamAndtriggerChange: setInputValueForParamAndtriggerChange,
  getOptionsForParam: getOptionsForParam,
  getOptionsMapForParam: getOptionsMapForParam,
  getCurveItemValueForParamName: getCurveItemValueForParamName,
  visibilityControllerForParam: visibilityControllerForParam,
  getAppName: getAppName,
  getDefaultDateRange: getDefaultDateRange,
  getMinMaxDates: getMinMaxDates
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"plot_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/lib/plot_util.js                                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 0);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 1);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 2);

// determine the axisText (used in scatter_axis.js for example)
// according to the Scatter Axis Text Patterns Pattern defined in
// ScatterAxisTextPatterns according to plotType - and derived from
// currently selected inputs in the document.
var getAxisText = function (plotType) {
  var scatterAxisTextPattern = matsCollections.ScatterAxisTextPattern.findOne({
    plotType: getPlotType()
  });
  var textPattern = scatterAxisTextPattern ? matsCollections.ScatterAxisTextPattern.findOne({
    plotType: getPlotType()
  }).textPattern : undefined;

  if (scatterAxisTextPattern === undefined) {
    return "";
  }

  var text = "";

  for (var i = 0; i < scatterAxisTextPattern.length; i++) {
    var pName = scatterAxisTextPattern[i][0];
    var delimiter = scatterAxisTextPattern[i][1];
    var value = matsParamUtils.getValueForParamName(pName);
    text += value += delimiter;
  }

  return text;
}; // determine the curveText (used in curveItem for example) for a given curve (from Session.get('curves'))
// that has already been added


var getCurveText = function (plotType, curve) {
  var curveTextPattern = matsCollections.CurveTextPatterns.findOne({
    plotType: plotType
  }).textPattern;
  var text = "";

  for (var i = 0; i < curveTextPattern.length; i++) {
    var a = curveTextPattern[i];

    if (a === undefined || a === null || curve[a[1]] === undefined) {
      continue;
    }

    text += a[0];

    if (curve[a[1]] instanceof Array && curve[a[1]].length > 2) {
      text += curve[a[1]][0] + ".." + curve[a[1]][curve[a[1]].length - 1];
    } else {
      text += curve[a[1]];
    }

    text += a[2];
  }

  return text;
}; // determine which plotType radio button is checked


var getPlotType = function () {
  var buttons = document.getElementsByName('plot-type');

  for (var i = 0, len = buttons.length; i < len; i++) {
    if (buttons[i].checked) {
      return buttons[i].value;
    }
  }

  return ""; // error condition actually - shouldn't ever happen
}; // determine which plotFormat radio button is checked


var getPlotFormat = function () {
  var buttons = document.getElementsByName('plotFormat');

  if (buttons === undefined) {
    return ""; // app may not have plotFormat?
  }

  var plotFormatParam = matsCollections.PlotParams.findOne({
    name: 'plotFormat'
  });

  if (plotFormatParam === undefined) {
    return ""; // app may not have plotFormat?
  }

  var optionsMap = plotFormatParam.optionsMap;

  for (var i = 0, len = buttons.length; i < len; i++) {
    if (buttons[i].checked) {
      return buttons[i].value;
    }
  }

  return ""; // error condition actually - shouldn't ever happen
}; // Determine which BestFit radio button is checked


var getBestFit = function () {
  var buttons = document.getElementsByName('Fit Type');
  var optionsMap = matsCollections.PlotParams.findOne({
    name: 'bestFit'
  }).optionsMap;

  for (var i = 0, len = buttons.length; i < len; i++) {
    if (buttons[i].checked) {
      return buttons[i].value;
    }
  }

  return ""; // error condition actually - shouldn't ever happen
};

var containsPoint = function (pointArray, point) {
  var lat = point[0];
  var lon = point[1];

  for (var i = 0; i < pointArray.length; i++) {
    var pLat = pointArray[i][0];
    var pLon = pointArray[i][1];

    if (lat === pLat && lon === pLon) {
      return true;
    }
  }

  return false;
}; // disable the action buttons while the query and plot routines are processing, then re-enable them afterwards


var disableActionButtons = function () {
  document.getElementById('plotMatched').disabled = true;
  document.getElementById('plotUnmatched').disabled = true;
  document.getElementById('add').disabled = true;
  document.getElementById('remove-all').disabled = true;
};

var enableActionButtons = function () {
  document.getElementById('plotMatched').disabled = false;
  document.getElementById('plotUnmatched').disabled = false;
  document.getElementById('add').disabled = false;
  document.getElementById('remove-all').disabled = false;
};

module.exportDefault(matsPlotUtils = {
  getAxisText: getAxisText,
  getCurveText: getCurveText,
  getPlotType: getPlotType,
  getPlotFormat: getPlotFormat,
  getBestFit: getBestFit,
  containsPoint: containsPoint,
  disableActionButtons: disableActionButtons,
  enableActionButtons: enableActionButtons
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"math_util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/lib/math_util.js                                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */

/*
generic Math Functions
 */
var isNum = function (args) {
  if (args == null || args == undefined) {
    return false;
  }

  args = args.toString();
  if (args.length == 0) return false;

  for (var i = 0; i < args.length; i++) {
    if ((args.substring(i, i + 1) < "0" || args.substring(i, i + 1) > "9") && args.substring(i, i + 1) != "." && args.substring(i, i + 1) != "-") {
      return false;
    }
  }

  return true;
};

var mean = function (arr) {
  var len = 0;
  var sum = 0;

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] == "") {} else if (!isNum(arr[i])) {
      //alert(arr[i] + " is not number!");
      console.log("Error: value at position: " + i + " is not number! Mean Calculation failed!");
      return 0;
    } else {
      len = len + 1;
      sum = sum + parseFloat(arr[i]);
    }
  }

  return sum / len;
};

var variance = function (arr) {
  var len = 0;
  var sum = 0;

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] == "") {} else if (!isNum(arr[i])) {
      //alert(arr[i] + " is not number, Variance Calculation failed!");
      console.log("value at position " + i + " is not number, Variance Calculation failed!");
      return 0;
    } else {
      len = len + 1;
      sum = sum + parseFloat(arr[i]);
    }
  }

  var v = 0;

  if (len > 1) {
    var mean = sum / len;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] == "") {} else {
        v = v + (arr[i] - mean) * (arr[i] - mean);
      }
    }

    return v / len;
  } else {
    return 0;
  }
};

var median = function (arr) {
  arr.sort(function (a, b) {
    return a - b;
  });
  var median = 0;

  if (arr.length % 2 == 1) {
    median = arr[(arr.length + 1) / 2 - 1];
  } else {
    median = (1 * arr[arr.length / 2 - 1] + 1 * arr[arr.length / 2]) / 2;
  }

  return median;
};

module.exportDefault(matsMathUtils = {
  isNum: isNum,
  mean: mean,
  variance: variance,
  median: median
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"templates":{"topnav":{"template.top_nav.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/topnav/template.top_nav.js                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("topNav");
Template["topNav"] = new Template("Template.topNav", (function() {
  var view = this;
  return HTML.DIV({
    id: "navbar",
    style: "display:block;height:100%;margin-bottom:0;margin-top:0;padding-top:0;padding-bottom:0;"
  }, "\n        ", HTML.NAV({
    id: "topnav",
    class: "navbar navbar-default",
    style: "color:white; background: #006699;height:100%;margin-bottom:0;margin-top:0;padding-top:0;padding-bottom:0;"
  }, "\n            ", HTML.DIV({
    class: "container-fluid"
  }, "\n                ", HTML.Raw('<div class="navbar-header">\n                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1" aria-expanded="false">\n                        <span class="sr-only">Toggle navigation</span>\n                        <span class="icon-bar"></span>\n                        <span class="icon-bar"></span>\n                        <span class="icon-bar"></span>\n                    </button>\n                    <a href=""> <i style="color:cyan" class="matshome fa fa-home fa-3x" aria-hidden="true"></i></a>\n                </div>'), "\n                ", HTML.Raw("<!-- Collect the nav links, forms, and other content for toggling -->"), "\n                ", HTML.DIV({
    class: "collapse navbar-collapse",
    id: "navbar-collapse-1"
  }, "\n                    ", HTML.Raw('<ul class="nav navbar-nav">\n                        <li><a href="http://www.doc.gov/"><span style="color:white">U.S. Department of Commerce</span></a></li>\n                        <li><a href="http://www.noaa.gov/"><span style="color:white">National Oceanic and Atmospheric Administration</span></a>\n                        </li>\n                        <li><a href="http://www.research.noaa.gov/"><span style="color:white">NOAA Research</span></a>\n                        </li>\n                    </ul>'), "\n                    ", HTML.SPAN({
    class: "navbar-right",
    style: "font-size: small"
  }, Spacebars.include(view.lookupTemplate("loginButtons"))), "\n\n                "), HTML.Raw("<!-- /.navbar-collapse -->"), "\n            "), HTML.Raw("<!-- /.container-fluid -->"), "\n        "), HTML.Raw('\n        <nav id="topnav1" class="navbar navbar-default" style="color:white; background: #000066;height:100%;margin-bottom:0;margin-top:0;padding-top:0;padding-bottom:1.5%;">\n            <div class="container-fluid">\n                <!-- Brand and toggle get grouped for better mobile display -->\n                <div class="navbar-header">\n                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-2" aria-expanded="false">\n                        <span class="sr-only">Toggle navigation</span>\n                        <span class="icon-bar"></span>\n                        <span class="icon-bar"></span>\n                        <span class="icon-bar"></span>\n                    </button>\n                    <a style="margin-bottom:0;margin-top:0;padding: 0;" class="navbar-brand" href="#"><img style="height:100%;margin-bottom:0;margin-top:0;padding-left:1em;padding-right:1em;padding-bottom:0;padding-top:0;" src="img/noaa_transparent.gif" alt="NOAA"></a>\n                </div>\n\n                <!-- Collect the nav links, forms, and other content for toggling -->\n                <div class="collapse navbar-collapse" id="navbar-collapse-2">\n                    <ul class="nav navbar-nav">\n                        <li>\n                            <div>\n                                <a href="http://esrl.noaa.gov/gsd/mdb"><span style="color:white;font-size: large;">Earth System Research Laboratory</span></a><br>\n                                <a href=""><span class="matshome" style="color:white;font-size: small;">Model Analysis Tool Suite</span></a><br>\n                            </div>\n                        </li>\n                    </ul>\n                    <ul class="nav navbar-nav navbar-right">\n                        <li><a href="https://vlab.ncep.noaa.gov/redmine/projects/mats-users/issues" target="_blank"><span style="color:white">bugs/issues</span></a></li>\n                        <li><a href=""> <span class="matshome" style="color:white">Home</span></a></li>\n                        <li><a href="" class="about"><span style="color:white">About</span></a></li>\n                    </ul>\n                </div><!-- /.navbar-collapse -->\n            </div><!-- /.container-fluid -->\n        </nav>\n        <div style="background-color: #dddddd;height:100%;margin-bottom:0;margin-top:0;padding-left:1em;padding-right: 0" class="container-fluid">\n            <a style="font-size:large;font-weight: bold" href="http://esrl.noaa.gov/gsd/">GSD Modeling</a>\n        </div>\n    '));
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"top_nav.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/topnav/top_nav.js                                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */
Template.topNav.events({
  'click .matshome': function (event) {
    event.preventDefault();
    var homeref = document.referrer;

    if (homeref === "" || homeref === undefined) {
      var r = document.location.href;
      var rparts = r.split(":");

      if (rparts.length >= 2) {
        // has a port - remove the port part
        rparts.pop;
        homeref = rparts.join(":");
      } else {
        // doesn't have a port - strip the appreference
        var appref = Session.get("app").appref;
        homeref = appref.substring(0, appref.lastIndexOf("/")); //                homeref = r.split("://")[0] + "://" + r.split("://")[1].split(".").splice(1, 10).join(".")
      }
    }

    window.location.replace(homeref);
    return false;
  },
  'click .about': function () {
    $("#modal-display-about").modal();
    return false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"spinner":{"template.spinner.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/spinner/template.spinner.js                                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("spinner");
Template["spinner"] = new Template("Template.spinner", (function() {
  var view = this;
  return HTML.DIV({
    id: "spinner",
    name: "spinner",
    style: "display:none"
  }, "\n        ", HTML.IMG({
    src: function() {
      return [ "img/", Spacebars.mustache(view.lookup("image")) ];
    },
    alt: "Loading...",
    height: "5%",
    width: "5%"
  }), HTML.Raw(' <span style="color:red">Loading ...</span>\n        <button type="button" class="cancel btn btn-info">&nbsp;&nbsp;Cancel</button>\n    '));
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"spinner.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/spinner/spinner.js                                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCurveUtils, matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  },
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 0);
Template.spinner.helpers({
  image: function () {
    var img = Session.get("spinner_img");

    if (img == undefined) {
      img = "spinner.gif";
      Session.set("spinner_img", "spinner.gif");
    }

    return img;
  }
});
Template.spinner.events({
  'click .cancel': function () {
    matsCurveUtils.hideSpinner();
    matsPlotUtils.enableActionButtons();
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"template.Home.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/template.Home.js                                                              //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("Home");
Template["Home"] = new Template("Template.Home", (function() {
  var view = this;
  return [ HTML.Raw('<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">\n    <meta http-equiv="Pragma" content="no-cache">\n    <meta http-equiv="Expires" content="0">\n    '), HTML.DIV({
    id: "main",
    class: " main row"
  }, "\n        ", Spacebars.include(view.lookupTemplate("topNav")), "\n        ", Spacebars.include(view.lookupTemplate("administration")), "\n        ", Spacebars.include(view.lookupTemplate("spinner")), "\n        ", Spacebars.include(view.lookupTemplate("help")), "\n        ", HTML.DIV({
    class: "container row pull-left col-lg-8",
    style: "width:100%;"
  }, "\n            ", Spacebars.include(view.lookupTemplate("error")), "\n            ", HTML.DIV({
    class: " row pull-left col-lg-8",
    id: "plotTypeContainer"
  }, "\n                ", Spacebars.include(view.lookupTemplate("plotType")), "\n            "), "\n            ", Spacebars.include(view.lookupTemplate("About")), "\n            ", Blaze.If(function() {
    return Spacebars.call(view.templateInstance().subscriptionsReady());
  }, function() {
    return [ "\n                ", Blaze.If(function() {
      return Spacebars.call(view.lookup("isUnderConstruction"));
    }, function() {
      return [ "\n                    ", HTML.DIV({
        class: "row pull-left col-lg-12"
      }, "\n                        ", Spacebars.include(view.lookupTemplate("underConstruction")), "\n                    "), "\n                " ];
    }, function() {
      return [ "\n                    ", HTML.DIV({
        class: " row"
      }, "\n                        ", Spacebars.include(view.lookupTemplate("changePlotType")), "\n                    "), "\n                    ", HTML.DIV({
        class: "row pull-left col-lg-12"
      }, "\n                        ", Spacebars.include(view.lookupTemplate("curveList")), "\n                    "), "\n                    ", HTML.DIV({
        class: " row pull-left"
      }, "\n                        ", Spacebars.include(view.lookupTemplate("error")), "\n                        ", Spacebars.include(view.lookupTemplate("info")), "\n                    "), "\n                    ", HTML.DIV({
        id: "scatterView",
        class: " row pull-left col-lg-10"
      }, "\n                        ", Spacebars.include(view.lookupTemplate("scatter2d")), "\n                    "), "\n                    ", HTML.DIV({
        id: "paramView",
        class: " row pull-left col-lg-12"
      }, "\n                        ", Spacebars.include(view.lookupTemplate("paramList")), "\n                    "), "\n                    ", HTML.DIV({
        id: "plotView",
        class: " row  pull-left col-lg-12",
        style: "width:100%;"
      }, "\n                        ", Spacebars.include(view.lookupTemplate("plotList")), "\n                    "), "\n                    ", Blaze.View("lookup:resetDefaults", function() {
        return Spacebars.mustache(view.lookup("resetDefaults"));
      }), "\n                " ];
    }), "\n            " ];
  }, function() {
    return "\n                Loading...\n            ";
  }), "\n        "), "\n        ", HTML.DIV("\n            ", Spacebars.include(view.lookupTemplate("graph")), "\n        "), "\n    "), "\n\n    ", Spacebars.include(view.lookupTemplate("footer")) ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"Home.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/Home.js                                                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 0);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 1);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 2);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 3);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 4);
Template.Home.onCreated(function () {
  this.subscribe("matsPlotUtils").ready();
  this.subscribe("matsTypes").ready();
  this.subscribe("matsCollections").ready();
  this.subscribe("matsCurveUtils").ready();
  this.subscribe("matsParamUtils").ready();
  this.subscribe("plotType").ready();
});
Template.Home.helpers({
  isUnderConstruction: function () {
    return matsCollections.CurveParams.findOne({
      name: 'underConstruction'
    }) !== undefined;
  },
  resetDefaults: function () {
    matsMethods.refreshMetaData.call({}, function (error, result) {
      if (error !== undefined) {
        setError(new Error(error.message));
      }

      matsParamUtils.setAllParamsToDefault();
    });
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"underConstruction":{"template.underConstruction.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/underConstruction/template.underConstruction.js                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("underConstruction");
Template["underConstruction"] = new Template("Template.underConstruction", (function() {
  var view = this;
  return HTML.DIV({
    id: "underConstruction",
    name: "underConstruction"
  }, "\n        ", HTML.DIV("\n            ", HTML.Raw("<p>......</p>"), "\n            ", HTML.DIV("\n                ", HTML.IMG({
    src: function() {
      return [ "img/", Spacebars.mustache(view.lookup("image")) ];
    },
    alt: "Building...",
    height: "50%",
    width: "50%"
  }), "\n            "), "\n        "), HTML.Raw("\n        <p>......</p>\n    "));
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"underConstruction.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/underConstruction/underConstruction.js                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */
Template.underConstruction.helpers({
  image: function () {
    var img = "underConstruction.jpg";
    return img;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"template.about.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/template.about.js                                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("About");
Template["About"] = new Template("Template.About", (function() {
  var view = this;
  return HTML.DIV({
    class: "modal fade",
    id: "modal-display-about",
    role: "dialog",
    "aria-labelledby": "displayAboutDialog",
    "aria-hidden": "true"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog",
    style: "background-color: cornflowerblue; overflow-y: initial"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, HTML.Raw('<i class="fa fa-2x fa-question" style="color:cornflowerblue"></i>'), "\n                ", HTML.DIV({
    class: "modal-header"
  }, "\n                    ", HTML.Raw('<div>\n                        <h2 class="modal-title" style="text-align: center; color: red;">About</h2>\n                    </div>'), "\n                    ", HTML.DIV("\n                        ", HTML.Raw('<h3 style="text-align:center">Model Analysis Tool Suite</h3>'), "\n                        ", Blaze.View("lookup:version", function() {
    return Spacebars.makeRaw(Spacebars.mustache(view.lookup("version")));
  }), "\n                    "), "\n                "), "\n                ", HTML.DIV({
    class: "modal-body",
    style: "height:30%"
  }, "\n                    ", HTML.DIV({
    id: "releaseNotes",
    style: "display:none; overflow-y: auto"
  }, "\n                        ", HTML.Raw("<h3>RELEASE NOTES</h3>"), "\n                        ", Blaze.View("lookup:releaseNotes", function() {
    return Spacebars.makeRaw(Spacebars.mustache(view.lookup("releaseNotes")));
  }), "\n                    "), "\n                "), "\n                ", HTML.Raw('<div class="modal-footer btn-group">\n                    <button class="clear-info btn btn-success btn-xs show-release-notes">\n                        <i class="fa fa-file-alt"></i>&nbsp;&nbsp;Show Release Notes\n                    </button>\n                    <button class="clear-info btn btn-success btn-xs hide-release-notes">\n                        <i class="fa fa-file-excel"></i>&nbsp;&nbsp;Hide Release Notes\n                    </button>\n                    <button data-dismiss="modal" class="clear-info btn btn-success btn-xs"><i class="fa fa-eraser">\n                        </i>&nbsp;&nbsp;Close\n                    </button>\n                </div>'), "\n            "), "\n        "), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"about.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/about.js                                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 0);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 1);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 2);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 3);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 4);
var jqueryui;
module.link("jquery-ui", {
  jqueryui: function (v) {
    jqueryui = v;
  }
}, 5);
var matsMethods;
module.link("../imports/startup/api/matsMethods", {
  "default": function (v) {
    matsMethods = v;
  }
}, 6);
var notes;
Template.About.helpers({
  version: function () {
    var settings = matsCollections.Settings.findOne({});
    var version = "unknown";
    var buildDate = "unkown";

    if (settings) {
      version = settings.appVersion;
      buildDate = settings.buildDate;
    }

    versionStr = "<div class='row' style='text-align:center'>Version: " + version + "</div>";
    return versionStr + "<div class='row' style='text-align:center'> Last Build Date: " + buildDate + "</div>";
  },
  releaseNotes: function () {
    Session.get('notesUpdated');
    return notes;
  }
});
Template.About.events({
  'click .show-release-notes': function () {
    matsMethods.getReleaseNotes.call({}, function (error, result) {
      if (error !== undefined) {
        setError(error);
        return "<p>" + error + "</p>";
      }

      notes = result;
      Session.set('notesUpdated', Date.now());
    });
    document.getElementById('releaseNotes').style.display = "block";
  },
  'click .hide-release-notes': function () {
    document.getElementById('releaseNotes').style.display = "none";
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"version":{"template.version.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/version/template.version.js                                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("version");
Template["version"] = new Template("Template.version", (function() {
  var view = this;
  return HTML.P("version ", Blaze.View("lookup:version", function() {
    return Spacebars.mustache(view.lookup("version"));
  }));
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"version.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/version/version.js                                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 0);
Template.version.helpers({
  version: function () {
    if (matsCollections.Settings.findOne()) {
      var settings = matsCollections.Settings.findOne({});
      var version = settings.appVersion;
      return version;
    } else {
      return "unknown";
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"plot":{"template.plot_list.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/plot/template.plot_list.js                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("plotList");
Template["plotList"] = new Template("Template.plotList", (function() {
  var view = this;
  return HTML.DIV({
    id: "plotList",
    class: "clearfix well span12"
  }, "\n        ", HTML.FORM({
    id: "plotForm",
    name: "plotForm",
    novalidate: ""
  }, "\n            ", HTML.DIV({
    style: "display:inline-block;width:100%;"
  }, "\n                ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("PlotParamGroups"));
  }, function() {
    return [ "\n                    ", Spacebars.include(view.lookupTemplate("plotParamGroup")), "\n                " ];
  }), "\n            "), "\n            ", HTML.DIV({
    id: "saveModal",
    class: "modal",
    role: "dialog"
  }, "\n                ", HTML.DIV({
    class: "modal-dialog"
  }, "\n                    ", HTML.DIV({
    class: "modal-content"
  }, "\n                        ", HTML.Raw('<div class="modal-header">\n                            <h4>Save Settings</h4>\n                        </div>'), "\n                        ", HTML.DIV({
    class: "modal-body"
  }, "\n                            ", HTML.DIV("\n                                ", HTML.Raw("<label>Save Settings to new entry ...</label>"), "\n                                ", HTML.Raw('<input id="save_as" class="data-input textInput" type="text" name="save_as">'), "\n                                ", HTML.INPUT(HTML.Attrs({
    id: "save-private",
    type: "radio",
    name: "save-public-private",
    value: "private"
  }, function() {
    return Spacebars.attrMustache(view.lookup("privateDisabled"));
  })), "Private\n                                ", HTML.Raw('<input id="save-public" type="radio" name="save-public-private" value="public" checked="">'), "Public\n                            "), "\n                            ", HTML.DIV("\n                                ", HTML.Raw("<label>Overwrite Settings to entry...</label>"), "\n                                ", HTML.SELECT({
    class: "data-input save-to",
    size: "5",
    name: "save_selector",
    id: "save_to"
  }, "\n                                    ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("privateRestoreNames"));
  }, function() {
    return [ "\n                                        ", HTML.OPTION(Blaze.View("lookup:.", function() {
      return Spacebars.mustache(view.lookup("."));
    })), "\n                                    " ];
  }), "\n                                "), "\n                            "), "\n                        "), "\n                        ", HTML.Raw('<div class="modal-footer btn-group">\n                            <button type="button" class="cancel-save btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                            <button name="delete" type="button" class="delete-selected btn btn-primary">&nbsp;&nbsp;Delete Selected</button>\n                            <button name="save" type="submit" class="submit-params btn btn-primary">&nbsp;&nbsp;Save Settings</button>\n                        </div>'), "\n                    "), "\n                    ", HTML.Raw("<!-- /.modal-content -->"), "\n                "), "\n                ", HTML.Raw("<!-- /.modal-dialog -->"), "\n            "), "\n            ", HTML.Raw("<!-- /.modal -->"), "\n            ", HTML.DIV({
    id: "restoreModal",
    class: "modal",
    role: "dialog"
  }, "\n                ", HTML.DIV({
    class: "modal-dialog"
  }, "\n                    ", HTML.DIV({
    class: "modal-content"
  }, "\n                        ", HTML.Raw('<div class="modal-header">\n                            <h4>Restore Settings</h4>\n                        </div>'), "\n                        ", HTML.DIV({
    class: "modal-body"
  }, "\n                            ", HTML.Raw("<label>Restore Settings from private...</label>"), "\n                            ", HTML.SELECT({
    class: "data-input restore-from-private",
    size: "5",
    name: "restore_from_private",
    id: "restore_from_private"
  }, "\n                                ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("privateRestoreNames"));
  }, function() {
    return [ "\n                                    ", HTML.OPTION(Blaze.View("lookup:.", function() {
      return Spacebars.mustache(view.lookup("."));
    })), "\n                                " ];
  }), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "modal-body"
  }, "\n                            ", HTML.Raw("<label>Restore Settings from public...</label>"), "\n                            ", HTML.SELECT({
    class: "data-input restore-from-public",
    size: "5",
    name: "restore_from_public",
    id: "restore_from_public"
  }, "\n                                ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("publicRestoreNames"));
  }, function() {
    return [ "\n                                    ", HTML.OPTION(Blaze.View("lookup:.", function() {
      return Spacebars.mustache(view.lookup("."));
    })), "\n                                " ];
  }), "\n                            "), "\n                        "), "\n                        ", HTML.Raw('<div class="modal-footer btn-group">\n                            <button type="button" class="cancel-restore btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                            <button name="restore" type="submit" class="submit-params btn btn-primary">&nbsp;&nbsp;Restore Settings</button>\n                        </div>'), "\n                    "), "\n                    ", HTML.Raw("<!-- /.modal-content -->"), "\n                "), "\n                ", HTML.Raw("<!-- /.modal-dialog -->"), "\n            "), "\n            ", HTML.Raw("<!-- /.modal -->"), "\n            ", HTML.Raw('<div id="plot-buttons" class="btn-group">\n                <button type="submit" name="plot" id="plot-curves" class="submit-params btn btn-success btn-xs fa fa-area-chart" style="display:none"></button>\n                <button type="submit" name="save" id="save-settings" class="submit-params btn btn-success  btn-xs fa fa-cloud-upload" style="display:none"></button>\n                <button type="submit" name="restore" id="restore-settings" class="submit-params btn btn-success  btn-xs fa fa-cloud-download" style="display:none"></button>\n            </div>'), "\n            ", HTML.DIV("\n                ", Spacebars.include(view.lookupTemplate("QCParamGroup")), "\n            "), "\n        "), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"plot_list.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/plot/plot_list.js                                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 2);
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 3);
var matsGraphUtils;
module.link("meteor/randyp:mats-common", {
  matsGraphUtils: function (v) {
    matsGraphUtils = v;
  }
}, 4);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 5);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 6);
var matsSelectUtils;
module.link("meteor/randyp:mats-common", {
  matsSelectUtils: function (v) {
    matsSelectUtils = v;
  }
}, 7);
Template.plotList.helpers({
  Title: function () {
    return matsCollections.Settings.findOne({}, {
      fields: {
        Title: 1
      }
    }).Title;
  },
  PlotParamGroups: function () {
    var groupNums = [];
    var params = matsCollections.PlotParams.find({}, {
      fields: {
        displayGroup: 1
      }
    }).fetch();

    for (var i = 0; i < params.length; i++) {
      groupNums.push(params[i].displayGroup);
    }

    var res = _.uniq(groupNums).sort();

    return res;
  },
  curves: function () {
    return Session.get('Curves');
  },
  privateDisabled: function () {
    if (!Meteor.user()) {
      return "disabled";
    } else {
      return "";
    }
  },
  privateRestoreNames: function () {
    var names = [];
    var l = matsCollections.CurveSettings.find({}, {
      fields: {
        name: 1,
        owner: 1,
        permission: 1
      }
    }).fetch();

    for (var i = 0; i < l.length; i++) {
      if (l[i].owner === Meteor.userId() && l[i].permission === "private") {
        names.push(l[i].name);
      }
    }

    return names;
  },
  publicRestoreNames: function () {
    var names = [];
    var savedSettings = matsCollections.CurveSettings.find({}, {
      fields: {
        name: 1,
        owner: 1,
        permission: 1
      }
    }).fetch();

    for (var i = 0; i < savedSettings.length; i++) {
      if (savedSettings[i].permission === "public") {
        names.push(savedSettings[i].name);
      }
    }

    return names;
  },
  isOwner: function () {
    return this.owner === Meteor.userId();
  }
});
Template.plotList.events({
  'click .cancel-restore': function () {
    document.getElementById('restore_from_public').value = "";
    document.getElementById('restore_from_private').value = "";
  },
  'click .cancel-save': function () {
    document.getElementById('save_as').value = "";
    document.getElementById('save_to').value = "";
  },
  'click .delete-selected': function () {
    var deleteThis = document.getElementById('save_to').value;

    if (deleteThis !== undefined && deleteThis !== "") {
      matsMethods.deleteSettings.call({
        name: deleteThis
      }, function (error) {
        if (error) {
          setError(new Error(error.message));
        }
      });
    }
  },
  // catch a click on a diff plotFormat radio button.
  'click .data-input': function () {
    var formats = Object.keys(matsTypes.PlotFormats);

    if ($.inArray(this.toString(), formats) !== -1) {
      matsCurveUtils.checkDiffs();
    }
  },
  'click .restore-from-private': function () {
    document.getElementById('restore_from_public').value = "";
  },
  'click .restore-from-public': function () {
    document.getElementById('restore_from_private').value = "";
  },
  'click .submit-params': function (event, template) {
    var plotAction = Session.get('plotParameter');
    Session.set("spinner_img", "spinner.gif");
    document.getElementById("spinner").style.display = "block";
    event.preventDefault();
    var action = event.currentTarget.name;
    var p = {}; // get the plot-type elements checked state

    var plotTypeElems = $('input[name=plot-type]');
    p.plotTypes = {};

    for (ptei = 0; ptei < plotTypeElems.length; ptei++) {
      var _ptElem = plotTypeElems[ptei];
      p.plotTypes[_ptElem.value] = _ptElem.checked;
    }

    var curves = Session.get('Curves');

    if (curves == 0 && action !== "restore") {
      //alert ("No Curves To plot");
      setError(new Error("There are no curves to plot!"));
      Session.set("spinner_img", "spinner.gif");
      document.getElementById("spinner").style.display = "none";
      return false;
    }

    p.curves = [];
    p.plotAction = plotAction;
    curves.forEach(function (curve) {
      p.curves.push(curve);
    });
    matsCollections.PlotParams.find({}).fetch().forEach(function (plotParam) {
      var name = plotParam.name;
      var type = plotParam.type;
      var options = plotParam.options;

      if (type == matsTypes.InputTypes.radioGroup) {
        for (var i = 0; i < options.length; i++) {
          if (document.getElementById(name + "-" + type + "-" + options[i]).checked == true) {
            p[name] = options[i];
            break;
          }
        }
      } else if (type == matsTypes.InputTypes.checkBoxGroup) {
        p[name] = [];

        for (var i = 0; i < options.length; i++) {
          if (document.getElementById(name + "-" + type + "-" + options[i]).checked) {
            p[name].push(options[i]);
          }
        }
      } else if (type == matsTypes.InputTypes.dateRange) {
        p[name] = matsParamUtils.getValueForParamName(name);
      } else if (type == matsTypes.InputTypes.numberSpinner) {
        p[name] = document.getElementById(name + '-' + type).value;
      } else if (type == matsTypes.InputTypes.select) {
        p[name] = document.getElementById(name + '-' + type).value;
      } else if (type == matsTypes.InputTypes.textInput) {
        p[name] = document.getElementById(name + '-' + type).value;
      }
    });
    p['completeness'] = document.getElementById("completeness").value;
    p['outliers'] = document.getElementById("outliers").value;
    Session.set("PlotParams", p);

    switch (action) {
      case "save":
        if ((document.getElementById('save_as').value === "" || document.getElementById('save_as').value === undefined) && (document.getElementById('save_to').value === "" || document.getElementById('save_to').value === undefined)) {
          $("#saveModal").modal('show');
          Session.set("spinner_img", "spinner.gif");
          document.getElementById("spinner").style.display = "none";
          return false;
        }

        var saveAs = "";

        if (document.getElementById('save_as').value !== "" && document.getElementById('save_as').value !== undefined) {
          saveAs = document.getElementById('save_as').value;
        } else {
          saveAs = document.getElementById('save_to').value;
        }

        var permission = document.getElementById("save-public").checked == true ? "public" : "private"; //console.log("saving settings to " + saveAs);

        Session.set('plotName', saveAs); // get the settings to save out of the session

        p = Session.get("PlotParams");
        var paramData = matsParamUtils.getElementValues();
        p['paramData'] = paramData;
        matsMethods.saveSettings.call({
          saveAs: saveAs,
          p: p,
          permission: permission
        }, function (error) {
          if (error) {
            setError(new Error("matsMethods.saveSettings from plot_list.js " + error.message));
          }
        });
        document.getElementById('save_as').value = "";
        document.getElementById('save_to').value = "";
        $("#saveModal").modal('hide');
        Session.set("spinner_img", "spinner.gif");
        document.getElementById("spinner").style.display = "none";
        return false;
        break;

      case "restore":
        matsCurveUtils.clearAllUsed();

        if ((document.getElementById('restore_from_private').value === "" || document.getElementById('restore_from_private').value === undefined) && (document.getElementById('restore_from_public').value === "" || document.getElementById('restore_from_public').value === undefined)) {
          $("#restoreModal").modal('show');
          Session.set("spinner_img", "spinner.gif");
          document.getElementById("spinner").style.display = "none";
          return false;
        }

        var restoreFrom = document.getElementById('restore_from_private').value;

        if (restoreFrom === "" || restoreFrom === undefined) {
          restoreFrom = document.getElementById('restore_from_public').value;
        } //console.log("restore settings from " + restoreFrom);


        Session.set('plotName', restoreFrom);
        p = matsCollections.CurveSettings.findOne({
          name: restoreFrom
        }); // now set all the curves.... This will refresh the curves list

        Session.set('Curves', p.data.curves); // reset the plotType - have to do this first because the event will remove all the possibly existing curves
        // get the plot-type elements checked state

        var plotTypeSaved = false;

        var _plotTypeElems = $('input[name=plot-type]');

        for (var ptei = 0; ptei < _plotTypeElems.length; ptei++) {
          var ptElem = _plotTypeElems[ptei];

          if (p.data.plotTypes && p.data.plotTypes[ptElem.value] === true) {
            plotTypeSaved = true;
            ptElem.checked = true; // We have to set up the display without using click events because that would cause
            // the restored curves to be removed

            switch (ptElem.value) {
              case matsTypes.PlotTypes.timeSeries:
                matsCurveUtils.showTimeseriesFace();
                break;

              case matsTypes.PlotTypes.profile:
                matsCurveUtils.showProfileFace();
                break;

              case matsTypes.PlotTypes.dieoff:
                matsCurveUtils.showDieOffFace();
                break;

              case matsTypes.PlotTypes.threshold:
                matsCurveUtils.showThresholdFace();
                break;

              case matsTypes.PlotTypes.validtime:
                matsCurveUtils.showValidTimeFace();
                break;

              case matsTypes.PlotTypes.dailyModelCycle:
                matsCurveUtils.showDailyModelCycleFace();
                break;

              case matsTypes.PlotTypes.reliability:
                matsCurveUtils.showReliabilityFace();
                break;

              case matsTypes.PlotTypes.map:
                matsCurveUtils.showMapFace();
                break;

              case matsTypes.PlotTypes.histogram:
                matsCurveUtils.showHistogramFace();
                break;

              case matsTypes.PlotTypes.contour:
              case matsTypes.PlotTypes.contourDiff:
                matsCurveUtils.showContourFace();
                break;

              case matsTypes.PlotTypes.scatter2d:
                matsCurveUtils.showScatterFace();
                break;
            }
          } else {
            ptElem.checked = false;
          }
        }

        if (plotTypeSaved !== true) {
          // set the default - in the case none was set in an old saved settings
          document.getElementById("plot-type-" + matsCollections.PlotGraphFunctions.findOne({
            checked: true
          }).plotType).checked = true;
        } // now set the PlotParams


        var params = matsCollections.PlotParams.find({}).fetch();
        params.forEach(function (plotParam) {
          var val = p.data.paramData.plotParams[plotParam.name] === null || p.data.paramData.plotParams[plotParam.name] === undefined ? matsTypes.InputTypes.unused : p.data.paramData.plotParams[plotParam.name];
          matsParamUtils.setInputForParamName(plotParam.name, val);
        }); // reset the form parameters for the superiors first

        params = matsCollections.CurveParams.find({
          "dependentNames": {
            "$exists": true
          }
        }).fetch();
        params.forEach(function (plotParam) {
          if (plotParam.type === matsTypes.InputTypes.dateRange) {
            if (p.data.paramData.curveParams[plotParam.name] === undefined) {
              return; // just like continue
            }

            var dateArr = p.data.paramData.curveParams[plotParam.name].split(' - ');
            var from = dateArr[0];
            var to = dateArr[1];
            var idref = "#" + plotParam.name + "-item";
            $(idref).data('daterangepicker').setStartDate(moment.utc(from, 'MM-DD-YYYY HH:mm'));
            $(idref).data('daterangepicker').setEndDate(moment.utc(to, 'MM-DD-YYYY HH:mm'));
            matsParamUtils.setValueTextForParamName(plotParam.name, p.data.paramData.curveParams[plotParam.name]);
          } else {
            var val = p.data.paramData.curveParams[plotParam.name] === null || p.data.paramData.curveParams[plotParam.name] === undefined ? matsTypes.InputTypes.unused : p.data.paramData.curveParams[plotParam.name];
            matsParamUtils.setInputForParamName(plotParam.name, val);
          }
        }); // now reset the form parameters for the dependents

        params = matsCollections.CurveParams.find({
          "dependentNames": {
            "$exists": false
          }
        }).fetch();
        params.forEach(function (plotParam) {
          if (plotParam.type === matsTypes.InputTypes.dateRange) {
            if (p.data.paramData.curveParams[plotParam.name] === undefined) {
              return; // just like continue
            }

            var dateArr = p.data.paramData.curveParams[plotParam.name].split(' - ');
            var from = dateArr[0];
            var to = dateArr[1];
            var idref = "#" + plotParam.name + "-item";
            $(idref).data('daterangepicker').setStartDate(moment.utc(from, 'MM-DD-YYYY HH:mm'));
            $(idref).data('daterangepicker').setEndDate(moment.utc(to, 'MM-DD-YYYY HH:mm'));
            matsParamUtils.setValueTextForParamName(plotParam.name, p.data.paramData.curveParams[plotParam.name]);
          } else {
            var val = p.data.paramData.curveParams[plotParam.name] === null || p.data.paramData.curveParams[plotParam.name] === undefined ? matsTypes.InputTypes.unused : p.data.paramData.curveParams[plotParam.name];
            matsParamUtils.setInputForParamName(plotParam.name, val);
          }
        }); // reset the scatter parameters

        params = matsCollections.Scatter2dParams.find({}).fetch();
        params.forEach(function (plotParam) {
          var val = p.data.paramData.scatterParams[plotParam.name] === null || p.data.paramData.scatterParams[plotParam.name] === undefined ? matsTypes.InputTypes.unused : p.data.paramData.scatterParams[plotParam.name];
          matsParamUtils.setInputForParamName(plotParam.name, val);
        }); // reset the dates

        if (p.data.dates !== undefined) {
          var dateArr = p.data.dates.split(' - ');
          var from = dateArr[0];
          var to = dateArr[1];
          $('#dates-item').data('daterangepicker').setStartDate(moment.utc(from, 'MM-DD-YYYY HH:mm'));
          $('#dates-item').data('daterangepicker').setEndDate(moment.utc(to, 'MM-DD-YYYY HH:mm'));
          matsParamUtils.setValueTextForParamName('dates', p.data.dates);
        } // reset the plotFormat
        // reset the plotParams


        Session.set("PlotParams", p); //set the used defaults so that subsequent adds get a core default

        matsCurveUtils.setUsedColorsAndLabels();
        document.getElementById('restore_from_public').value = "";
        document.getElementById('restore_from_private').value = "";
        $("#restoreModal").modal('hide');
        Session.set("spinner_img", "spinner.gif");
        document.getElementById("spinner").style.display = "none";
        matsParamUtils.collapseParams();
        return false;
        break;

      case "plot":
        var pt = matsPlotUtils.getPlotType();
        console.log("resizing graph type is ", pt);
        matsGraphUtils.resizeGraph(pt);
        var pgf = matsCollections.PlotGraphFunctions.findOne({
          plotType: pt
        });

        if (pgf === undefined) {
          setError(new Error("plot_list.js - plot -do not have a plotGraphFunction for this plotType: " + pt));
          Session.set("spinner_img", "spinner.gif");
          document.getElementById("spinner").style.display = "none";
          return false;
        }

        Session.set('graphViewMode', matsTypes.PlotView.graph);
        Session.set('mvResultKey', null); // disable the mv links on the graph page

        var graphFunction = pgf.graphFunction;
        console.log("prior to getGraphData call time:", new Date()); // the following line converts a null expireKey to false.

        var expireKey = Session.get('expireKey') === true ? true : false;
        matsMethods.getGraphData.call({
          plotParams: p,
          plotType: pt,
          expireKey: expireKey
        }, function (error, ret) {
          if (error !== undefined) {
            //setError(new Error("matsMethods.getGraphData from plot_list.js : error: " + error ));
            setError(error);
            matsCurveUtils.resetGraphResult(); //Session.set ('PlotResultsUpDated', new Date());

            Session.set("spinner_img", "spinner.gif");
            matsCurveUtils.hideSpinner();
            Session.set('expireKey', false);
            return false;
          }

          Session.set('expireKey', false);
          matsCurveUtils.setGraphResult(ret.result);
          var plotType = Session.get('plotType');

          if (plotType === matsTypes.PlotTypes.contourDiff) {
            var oldCurves = Session.get('Curves');
            Session.set('oldCurves', oldCurves);
            Session.set('Curves', ret.result.basis.plotParams.curves);
          }

          Session.set("plotResultKey", ret.key);
          delete ret;
          Session.set('graphFunction', graphFunction);
          Session.set('PlotResultsUpDated', new Date());
          console.log("after successful getGraphData call time:", new Date(), ":Session key: ", ret.key, " graphFunction:", graphFunction);
          matsGraphUtils.setGraphView(pt);
        });

        if (matsCollections.Settings.findOne({}).appType === matsTypes.AppTypes.metexpress && p['metexpress-mode'] === "matsmv") {
          p['mvPlot'] = true; // mark this as a metviewer plot so that the key is uniq wrt the mats plot

          Session.set('mvs', null);
          Session.set("mvResultKey", null);
          matsMethods.mvBatch.call({
            plotParams: p,
            plotType: pt
          }, function (error, ret) {
            if (error !== undefined) {
              setError("matsMethods.mvBatch from plot_list.js : error: " + error);
              return false;
            }

            var mvs = [];
            var key = ret.key;
            var artifacts = ret.artifacts;

            for (var i = 0; i < Object.keys(artifacts).length; i++) {
              var name = Object.keys(artifacts)[i];
              var url = location.href + artifacts[name];
              mvs.push({
                name: name,
                url: url
              });
            }

            Session.set('mvs', mvs);
            Session.set("mvResultKey", key);
            Session.set('MvResultsUpDated', new Date());
          });
        }

        break;

      default:
        break;
    }

    return false;
  }
});
Template.plotList.onRendered(function () {
  // last bit of stuff that needs to be done when the page finally renders
  // hide selectors that don't belong to timeseries
  var elem;

  for (var sidx = 0; sidx < matsTypes.selectorsToHide.length; sidx++) {
    elem = document.getElementById(matsTypes.selectorsToHide[sidx] + '-item');

    if (elem && elem.style) {
      elem.style.display = 'none';
    }
  } // need to display correct selectors on page load if default plot type is not timeseries


  var plotType = matsPlotUtils.getPlotType();

  switch (plotType) {
    case matsTypes.PlotTypes.profile:
      matsCurveUtils.showProfileFace();
      break;

    case matsTypes.PlotTypes.dieoff:
      matsCurveUtils.showDieOffFace();
      break;

    case matsTypes.PlotTypes.threshold:
      matsCurveUtils.showThresholdFace();
      break;

    case matsTypes.PlotTypes.validtime:
      matsCurveUtils.showValidTimeFace();
      break;

    case matsTypes.PlotTypes.dailyModelCycle:
      matsCurveUtils.showDailyModelCycleFace();
      break;

    case matsTypes.PlotTypes.reliability:
      matsCurveUtils.showReliabilityFace();
      break;

    case matsTypes.PlotTypes.map:
      matsCurveUtils.showMapFace();
      break;

    case matsTypes.PlotTypes.histogram:
      matsCurveUtils.showHistogramFace();
      break;

    case matsTypes.PlotTypes.contour:
    case matsTypes.PlotTypes.contourDiff:
      matsCurveUtils.showContourFace();
      break;

    case matsTypes.PlotTypes.scatter2d:
      matsCurveUtils.showScatterFace();
      break;

    case matsTypes.PlotTypes.timeSeries:
    default:
      break;
  } // make sure everything is at default


  matsParamUtils.setAllParamsToDefault();
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.plot_param_group.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/plot/template.plot_param_group.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("plotParamGroup");
Template["plotParamGroup"] = new Template("Template.plotParamGroup", (function() {
  var view = this;
  return HTML.DIV({
    id: "plotParamGroup",
    class: "clearfix",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("displayGroup")), ";" ];
    }
  }, "\n        ", Blaze.Each(function() {
    return Spacebars.dataMustache(view.lookup("PlotParams"), view.lookup("."));
  }, function() {
    return [ "\n            ", Spacebars.include(view.lookupTemplate("item")), "\n        " ];
  }), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"plot_param_group.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/plot/plot_param_group.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 0);
var plotParamHandler;
module.link("meteor/randyp:mats-common", {
  plotParamHandler: function (v) {
    plotParamHandler = v;
  }
}, 1);
Template.plotParamGroup.helpers({
  PlotParams: function (num) {
    var params = matsCollections.PlotParams.find({
      displayGroup: num
    }, {
      sort: ["displayOrder", "asc"]
    }).fetch();
    return params;
  },
  displayGroup: function () {
    return "block";
  },
  log: function () {
    console.log(this);
  }
});
Template.plotParamGroup.events({
  'click': function (event) {
    if (plotParamHandler !== undefined) {
      plotParamHandler(event); // call app specific handler with event.
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.QC_param_group.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/plot/template.QC_param_group.js                                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("QCParamGroup");
Template["QCParamGroup"] = new Template("Template.QCParamGroup", (function() {
  var view = this;
  return HTML.DIV({
    id: "QCParamGroup",
    style: "background-color:lightcyan;margin-top: 1.5em;float:left;"
  }, HTML.Raw('\n        <label style="padding-left:1em;font-size:large;font-weight: normal;">QC parameters: </label>\n        '), HTML.SPAN({
    style: "font-size:large;font-weight: normal;"
  }, "\n            ", HTML.Raw('<label style="padding-left:1em;font-size:large;font-weight: normal;">Data completeness percentage: </label>'), "\n            ", HTML.INPUT({
    type: "number",
    name: "quantity",
    id: "completeness",
    min: "0",
    max: "100",
    value: function() {
      return Spacebars.mustache(view.lookup("completenessNumber"));
    }
  }), "\n        "), "\n        ", HTML.SPAN({
    style: "font-size:large;font-weight: normal;"
  }, "\n            ", HTML.Raw('<label style="padding-left:1em;font-size:large;font-weight: normal;">Stdev filter level: </label>'), "\n            ", Blaze.If(function() {
    return Spacebars.call(view.lookup("noQC"));
  }, function() {
    return [ "\n                ", HTML.SELECT({
      id: "outliers"
    }, "\n                    ", HTML.OPTION({
      value: "all",
      selected: "selected"
    }, "All Data"), "\n                    ", HTML.OPTION({
      value: "3"
    }, "3 sd"), "\n                    ", HTML.OPTION({
      value: "2"
    }, "2 sd"), "\n                    ", HTML.OPTION({
      value: "1"
    }, "1 sd"), "\n                "), "\n            " ];
  }, function() {
    return [ "\n                ", HTML.SELECT({
      id: "outliers"
    }, "\n                    ", HTML.OPTION({
      value: "all"
    }, "All Data"), "\n                    ", HTML.OPTION({
      value: "3",
      selected: "selected"
    }, "3 sd"), "\n                    ", HTML.OPTION({
      value: "2"
    }, "2 sd"), "\n                    ", HTML.OPTION({
      value: "1"
    }, "1 sd"), "\n                "), "\n            " ];
  }), "\n        "), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"QC_param_group.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/plot/QC_param_group.js                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 0);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 1);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 2);
var plotParamHandler;
module.link("meteor/randyp:mats-common", {
  plotParamHandler: function (v) {
    plotParamHandler = v;
  }
}, 3);
Template.QCParamGroup.helpers({
  completenessNumber: function () {
    var appType = matsCollections.Settings.findOne({}).appType;

    if (appType === 'anomalycor' || appType === matsTypes.AppTypes.metexpress) {
      return '0';
    } else {
      return '75';
    }
  },
  noQC: function () {
    var appType = matsCollections.Settings.findOne({}).appType;
    return appType === 'anomalycor' || appType === matsTypes.AppTypes.metexpress;
  }
});
Template.QCParamGroup.events({});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"help":{"template.help.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/help/template.help.js                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("help");
Template["help"] = new Template("Template.help", (function() {
  var view = this;
  return HTML.Raw('<div id="helpModal" class="modal" role="dialog">\n    <div class="modal-dialog modal-lg">\n        <div class="modal-content">\n            <div class="modal-header">\n                <h4 class="modal-title">Help</h4>\n            </div>\n            <div class="modal-body">\n                <div id="matshelp">\n                </div>\n                <div class="modal-footer btn-group">\n                    <button type="button" class="close-help btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Close</button>\n                </div>\n            </div>\n        </div>\n        <!-- /.modal-content -->\n    </div>\n    <!-- /.modal-dialog -->\n</div>');
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"error":{"template.error.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/error/template.error.js                                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("error");
Template["error"] = new Template("Template.error", (function() {
  var view = this;
  return HTML.DIV({
    id: "error",
    name: "errorModal",
    class: "modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog  modal-lg"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title"><i class="fa fa-frown-o"></i> Error:</h4>\n                </div>'), "\n                ", HTML.DIV({
    class: "modal-body"
  }, "\n                    ", HTML.DIV("\n                        ", HTML.P({
    style: "color:red"
  }, Blaze.View("lookup:errorMessage", function() {
    return Spacebars.makeRaw(Spacebars.mustache(view.lookup("errorMessage")));
  })), "\n                    "), "\n                    ", HTML.DIV({
    id: "stack",
    style: "display:none"
  }, "\n                        ", HTML.P(Blaze.View("lookup:stackTrace", function() {
    return Spacebars.makeRaw(Spacebars.mustache(view.lookup("stackTrace")));
  })), "\n                        ", HTML.Raw('<button class="hide-stack btn btn-success btn-xs"><i class="fa fa-eraser"></i>&nbsp;&nbsp;Hide Stack</button>'), "\n                    "), "\n                    ", HTML.Raw('<div class="modal-footer btn-group">\n                        <button class="show-stack btn btn-success btn-xs"><i class="fa fa-stack-exchange"></i>&nbsp;&nbsp;Stack?</button>\n                        <button class="clear-error btn btn-success btn-xs"><i class="fa fa-eraser"></i>&nbsp;&nbsp;Clear</button>\n                    </div>'), "\n                "), "\n            "), "\n        "), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"error.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/error/error.js                                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 0);
Template.error.helpers({
  errorMessage: function () {
    return getError();
  },
  stackTrace: function () {
    return getStack();
  }
});
Template.error.events({
  'click .clear-error': function () {
    clearError();
    document.getElementById('stack').style.display = "none";
    matsPlotUtils.enableActionButtons();
    return false;
  },
  'click .show-stack': function () {
    document.getElementById('stack').style.display = "block";
  },
  'click .hide-stack': function () {
    document.getElementById('stack').style.display = "none";
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"info":{"template.info.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/info/template.info.js                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("info");
Template["info"] = new Template("Template.info", (function() {
  var view = this;
  return HTML.DIV({
    id: "info",
    name: "infoModal",
    class: "modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog  modal-lg"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title"><i class="fa fa-smile-o"></i> Info:</h4>\n                </div>'), "\n                ", HTML.DIV({
    class: "modal-body"
  }, "\n                    ", HTML.DIV("\n                        ", HTML.P({
    style: "color:cornflowerblue"
  }, Blaze.View("lookup:infoMessage", function() {
    return Spacebars.makeRaw(Spacebars.mustache(view.lookup("infoMessage")));
  })), "\n                    "), "\n                    ", HTML.Raw('<div class="modal-footer btn-group">\n                        <button id="clear-info" class="clear-info btn btn-success btn-xs"><i class="fa fa-eraser"></i>&nbsp;&nbsp;Clear</button>\n                    </div>'), "\n                "), "\n            "), "\n        "), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"info.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/info/info.js                                                                  //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 0);
Template.info.helpers({
  infoMessage: function () {
    return getInfo();
  }
});
Template.info.events({
  'click .clear-info': function () {
    clearInfo();
    matsPlotUtils.enableActionButtons();
    return false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"changePlotType":{"template.changePlotType.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/changePlotType/template.changePlotType.js                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("changePlotType");
Template["changePlotType"] = new Template("Template.changePlotType", (function() {
  var view = this;
  return HTML.Raw('<div class="modal modal-dialog fade" id="modal-change-plot-type" tabindex="-1" role="dialog" aria-labelledby="confirmChangePlotType" aria-hidden="true" style="background-color: cornflowerblue;">\n        <div class="modal-dialog">\n            <div class="modal-content"><i class="fa fa-4x fa-question" style="color:cornflowerblue"></i>\n                <h2 class="modal-title" style="text-align: center; color: red;">Change Plot Type?</h2>\n                <div class="modal-body">\n                    <h4 style="color:cornflowerblue">\n                        <p>If you change plot types and have already added curves, it is possible that the parameters for the new plot type may be incomplete.\n                        </p>\n                        <p>For Example time series curves have a common date whereas profile plots each have their own date. The program will\n                            attempt to pick reasonable defaults but you should review.</p>\n                        Do you want to proceed and remove all existing curves, or proceed and retain existing curves with possibly incomplete parameters?\n                    </h4>\n                </div>\n                <div class="modal-footer">\n                    <button id="confirm-remove-all" class="btn btn-danger confirm-remove-all" data-dismiss="modal">Proceed and remove all the existing curves</button>\n                    <button id="confirm-keep-all" class="btn btn-warning confirm-keep-all" data-dismiss="modal">Proceed and keep all the existing curves</button>\n                </div>\n            </div>\n        </div>\n    </div>');
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"changePlotType.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/changePlotType/changePlotType.js                                              //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsParamUtils, matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  },
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 0);
// moved here from plotType.html and plotType.js
Template.changePlotType.events({
  'click .confirm-remove-all': function (event) {
    event.preventDefault();
    matsCurveUtils.clearAllUsed();
    matsParamUtils.setAllParamsToDefault();
    Session.set("editMode", "");
    Session.set("paramWellColor", "#f5f5f5"); // default grey

    Session.set("lastUpdate", Date.now());
    Session.set("confirmPlotChange", Date.now());
    var plotChangeType = Session.get('plotChangeType');
    var ref = "#plot-type-" + plotChangeType; //NOTE: this assumes that the id of the associated plotType is following a convention defined by matsTypes.PlotTypes

    $(ref).trigger('click'); //return false;
  },
  'click .confirm-keep-all': function (event) {
    event.preventDefault();
    Session.set("confirmPlotChange", Date.now());
    var plotChangeType = Session.get('plotChangeType');
    var ref = "#plot-type-" + plotChangeType; //NOTE: this assumes that the id of the associated plotType is following a convention defined by matsTypes.PlotTypes

    $(ref).trigger('click'); //return false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"graph":{"template.graph.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/graph/template.graph.js                                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("graph");
Template["graph"] = new Template("Template.graph", (function() {
  var view = this;
  return [ "\n    ", HTML.HEAD("\n        ", HTML.SCRIPT({
    src: "https://cdn.plot.ly/plotly-latest.min.js"
  }), "\n    "), "\n    ", HTML.DIV({
    id: "graph-container",
    class: "container-fluid pull-left",
    style: "margin-top: 0.5em; padding-left: 5%; display:none;"
  }, "\n        ", HTML.DIV({
    id: "graph-control",
    class: "row"
  }, "\n            ", HTML.SPAN({
    id: "all-plot-buttons-grp",
    class: "btn-group btn-group-sm"
  }, "\n                ", HTML.Raw('<button id="backButton" type="button" class="back btn btn-primary fa fa-long-arrow-left" style="border-radius: 5px;" data-toggle="tooltip" data-placement="top" title="return to parameters">&nbsp;&nbsp;<strong>Back</strong></button>'), "\n                ", HTML.Raw('<button id="gc-spacer" type="button" class="btn spacebutton"></button>'), "\n                ", HTML.Raw('<button id="previewButton" type="button" class="preview btn btn-primary fa fa-print" style="border-top-left-radius: 5px; border-bottom-left-radius: 5px;" data-toggle="tooltip" data-placement="top" title="preview graph in separate window">&nbsp;&nbsp;<strong>Preview</strong></button>'), "\n                ", HTML.Raw('<button id="basisButton" type="button" class="basis btn btn-primary fa fa-info" data-toggle="tooltip" data-placement="top" title="view data details">&nbsp;&nbsp;<strong>Data Lineage</strong></button>'), "\n                ", HTML.Raw('<span id="text-page-button-group" class="btn-group btn-group-sm" style="display:none;">\n                    <button id="exportButton" type="button" class="export btn btn-primary fa fa-floppy-o" style="border-top-right-radius: 5px; border-bottom-right-radius: 5px;" data-toggle="tooltip" data-placement="top" title="export current text data to csv file">&nbsp;&nbsp;<strong>Export</strong></button>\n                    <button id="gc-spacer" type="button" class="btn spacebutton"></button>\n                    <button id="plotButton" type="button" class="plotButton btn btn-primary fa fa-line-chart" style="border-radius: 5px; display:block;" data-toggle="tooltip" data-placement="top" title="change to plot view">&nbsp;&nbsp;<strong>Plot</strong></button>\n                    <button id="gc-spacer" type="button" class="btn spacebutton"></button>\n                    <button id="firstPageButton" type="button" class="firstPageButton btn btn-info fa fa-fast-backward" style="border-top-left-radius: 5px; border-bottom-left-radius: 5px; display:block;background-color: #003399;" data-toggle="tooltip" data-placement="top" title="first page">&nbsp;&nbsp;<strong>First page</strong></button>\n                    <button id="previousTenPageButton" type="button" class="previousTenPageButton btn btn-info fa fa-step-backward" style="display:block;background-color: #003399;" data-toggle="tooltip" data-placement="top" title="previous 10 pages">&nbsp;&nbsp;<strong>Back 10 pages</strong></button>\n                    <button id="previousPageButton" type="button" class="previousPageButton btn btn-info fa fa-chevron-left" style="display:block;background-color: #003399;" data-toggle="tooltip" data-placement="top" title="previous page">&nbsp;&nbsp;<strong>Prev page</strong></button>\n                    <button id="nextPageButton" type="button" class="nextPageButton btn btn-info fa fa-chevron-right" style="display:block;background-color: #003399;" data-toggle="tooltip" data-placement="top" title="next page">&nbsp;&nbsp;<strong>Next page</strong></button>\n                    <button id="nextTenPageButton" type="button" class="nextTenPageButton btn btn-info fa fa-step-forward" style="display:block;background-color: #003399;" data-toggle="tooltip" data-placement="top" title="next 10 pages">&nbsp;&nbsp;<strong>Forward 10 pages</strong></button>\n                    <button id="lastPageButton" type="button" class="lastPageButton btn btn-info fa fa-fast-forward" style="border-top-right-radius: 5px; border-bottom-right-radius: 5px; display:block;background-color: #003399;" data-toggle="tooltip" data-placement="top" title="last page">&nbsp;&nbsp;<strong>Last page</strong></button>\n                </span>'), "\n                ", HTML.SPAN({
    id: "plot-page-button-group",
    class: "btn-group btn-group-sm",
    style: "display:block;"
  }, "\n                    ", HTML.SPAN({
    id: "plot-control-button-group",
    class: "btn-group btn-group-sm",
    style: "display:block;"
  }, "\n                        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isNotMap"));
  }, function() {
    return [ "\n                            ", HTML.BUTTON({
      id: "axisLimitButton",
      type: "button",
      class: "axisLimitButton btn btn-primary fa fa-arrows",
      style: "display:block;",
      "data-toggle": "tooltip",
      "data-placement": "top",
      title: "modify axis"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.STRONG("Axes")), "\n                        " ];
  }), "\n                        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isLinePlot"));
  }, function() {
    return [ "\n                            ", HTML.BUTTON({
      id: "lineTypeButton",
      type: "button",
      class: "lineTypeButton btn btn-primary fa fa-bars",
      style: "display:block;",
      "data-toggle": "tooltip",
      "data-placement": "top",
      title: "modify axis"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.STRONG("Line Styles")), "\n                        " ];
  }), "\n                        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isProfile"));
  }, function() {
    return [ "\n                            ", HTML.BUTTON({
      id: "axisYScale",
      type: "button",
      class: "axisYScale btn btn-primary fa fa-arrows",
      style: "display:block;",
      "data-toggle": "tooltip",
      "data-placement": "top",
      title: "toggle linear/log Y axis"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.STRONG("Y Linear/Log")), "\n                        " ];
  }), "\n                        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isContour"));
  }, function() {
    return [ "\n                            ", HTML.BUTTON({
      id: "colorbarButton",
      type: "button",
      class: "colorbarButton btn btn-primary fa fa-paint-brush",
      style: "display:block;",
      "data-toggle": "tooltip",
      "data-placement": "top",
      title: "modify colorbar"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.STRONG("Colorbar")), "\n                        " ];
  }), "\n                        ", HTML.BUTTON({
    id: "replotZoomButton",
    type: "button",
    class: "replotZoomButton btn btn-primary fa fa-line-chart",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("displayReplotZoom")), ";" ];
    },
    "data-toggle": "tooltip",
    "data-placement": "top",
    title: "replot graph to current zoom setting"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), HTML.Raw("<strong>Re-sample</strong>")), "\n                        ", HTML.Raw('<button id="reCacheButton" type="button" class="reCacheButton btn btn-primary fa fa-line-chart" style="display:block;" data-toggle="tooltip" data-placement="top" title="replot graph and refresh cache with new data">&nbsp;&nbsp;<strong>Re-cache</strong></button>'), "\n                    "), "\n                    ", HTML.Raw('<button id="textButton" type="button" class="textButton btn btn-primary fa fa-file-text-o" style="border-top-right-radius: 5px; border-bottom-right-radius: 5px; display:block;" data-toggle="tooltip" data-placement="top" title="change to text view">&nbsp;&nbsp;<strong>Text</strong></button>'), "\n                    ", HTML.Raw('<button id="gc-spacer" type="button" class="btn spacebutton"></button>'), "\n                "), "\n                ", HTML.Raw('<span id="graph-touch-controls" class="btn-group btn-group-sm" role="group" aria-label="touchcontrol">\n                    <button id="refresh-plot" type="button" class="btn btn-info fa fa-refresh" style="border-radius: 15px; background-color: #00badb;" data-toggle="tooltip" data-placement="top" title="reset plot to original (or last re-sample)"></button>\n                </span>'), "\n                ", HTML.SPAN("\n                    ", HTML.DIV({
    id: "mv-controls",
    class: "btn-group btn-group-xs",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("metApp")) ];
    },
    role: "group",
    "aria-label": "touchcontrol"
  }, "\n                        ", HTML.BUTTON({
    type: "button",
    id: "mvloading",
    class: "btn btn-xs btn-warning",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("mvLoading")) ];
    }
  }, "mvbatch"), "\n                        ", HTML.SPAN({
    class: "btn btn-xs btn-warning fas fa-spinner fa-pulse",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("mvLoading")) ];
    }
  }), "\n                        ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("mvFiles"));
  }, function() {
    return [ "\n                                ", HTML.BUTTON({
      type: "button",
      id: function() {
        return Spacebars.mustache(Spacebars.dot(view.lookup("."), "name"));
      },
      class: "btn btn-xs btn-info mvCtrlButton",
      style: function() {
        return [ "display:", Spacebars.mustache(view.lookup("mvDisabled")) ];
      }
    }, "mv-", Blaze.View("lookup:..name", function() {
      return Spacebars.mustache(Spacebars.dot(view.lookup("."), "name"));
    })), "\n                        " ];
  }), "\n                    "), "\n                "), "\n            "), "\n        "), "\n        ", HTML.DIV({
    id: "sendModal",
    class: "modal row",
    role: "dialog"
  }, "\n            ", HTML.DIV({
    class: "modal-dialog"
  }, "\n                ", HTML.DIV({
    class: "modal-content"
  }, "\n                    ", HTML.Raw('<div class="modal-header">\n                        <h4>Send To ?</h4>\n                    </div>'), "\n                    ", HTML.DIV({
    class: "modal-body"
  }, "\n                        ", HTML.DIV("\n                            ", HTML.Raw("<label>Send Address ...</label>"), "\n                            ", HTML.Raw('<input id="sendAddress" class="send-address data-input textInput" type="text" name="send address">'), "\n                            ", HTML.SELECT({
    class: "data-input sentAddresses",
    size: "5",
    name: "sentAddresses",
    id: "sentAddresses"
  }, "\n                                ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("sentAddresses"));
  }, function() {
    return [ "\n                                    ", HTML.OPTION(Blaze.View("lookup:.", function() {
      return Spacebars.mustache(view.lookup("."));
    })), "\n                                " ];
  }), "\n                            "), "\n                        "), "\n                    "), "\n                    ", HTML.Raw('<div class="modal-footer btn-group">\n                        <button type="button" class="cancel-send btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                        <button name="send" type="submit" class="send btn btn-primary">&nbsp;&nbsp;Send</button>\n                    </div>'), "\n                "), "\n                ", HTML.Raw("<!-- /.modal-content -->"), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-dialog -->"), "\n        "), "\n        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isNotMap"));
  }, function() {
    return [ "\n            ", HTML.DIV({
      id: "axisLimitModal",
      class: "modal container",
      role: "dialog"
    }, "\n                ", HTML.DIV({
      class: "modal-dialog"
    }, "\n                    ", HTML.DIV({
      class: "modal-content"
    }, "\n                        ", HTML.DIV({
      class: "modal-header"
    }, "\n                            ", HTML.H3("Select axis limits and labels: "), "\n                            ", HTML.H4("* Leave a field blank to preserve its original value. "), "\n                            ", HTML.H4("* Only data from your original time range has been queried and is available to plot. "), "\n                        "), "\n                        ", HTML.DIV({
      class: "modal-body"
    }, "\n                            ", Blaze.Each(function() {
      return {
        _sequence: Spacebars.call(view.lookup("xAxes")),
        _variable: "xAxis"
      };
    }, function() {
      return [ "\n                                ", HTML.DIV(HTML.BR()), "\n                                ", HTML.DIV({
        id: function() {
          return [ "x", Spacebars.mustache(Spacebars.dot(view.lookup("xAxis"), "label")), "AxisCustomControls" ];
        },
        style: "display:block;"
      }, "\n                                    ", HTML.DIV({
        class: "row"
      }, "\n                                        ", HTML.LABEL({
        class: "col-sm-2"
      }, "X", Blaze.View("lookup:xAxis", function() {
        return Spacebars.mustache(view.lookup("xAxis"));
      }), " label: "), "\n                                        ", HTML.INPUT({
        id: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisLabel" ];
        },
        class: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "-axis-label data-input textInput col-sm-3" ];
        },
        type: "text",
        value: "",
        name: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisLabel" ];
        }
      }), "\n                                    "), "\n                                    ", HTML.DIV({
        id: "xAxisControlsNumber",
        style: function() {
          return [ "display:", Spacebars.mustache(view.lookup("xAxisControlsNumberVisibility")), ";" ];
        }
      }, "\n                                        ", HTML.DIV({
        class: "row"
      }, "\n                                            ", HTML.LABEL({
        class: "col-sm-2"
      }, "X", Blaze.View("lookup:xAxis", function() {
        return Spacebars.mustache(view.lookup("xAxis"));
      }), "_min: "), "\n                                            ", HTML.INPUT({
        id: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisMin" ];
        },
        class: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "-axis-min data-input numberInput col-sm-3" ];
        },
        type: "number",
        value: "",
        name: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisMin" ];
        }
      }), "\n                                        "), "\n                                        ", HTML.DIV({
        class: "row"
      }, "\n                                            ", HTML.LABEL({
        class: "col-sm-2"
      }, "X", Blaze.View("lookup:xAxis", function() {
        return Spacebars.mustache(view.lookup("xAxis"));
      }), "_max: "), "\n                                            ", HTML.INPUT({
        id: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisMax" ];
        },
        class: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "-axis-max data-input numberInput col-sm-3" ];
        },
        type: "number",
        value: "",
        name: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisMax" ];
        }
      }), "\n                                        "), "\n                                    "), "\n                                    ", HTML.DIV({
        id: "xAxisControlsText",
        style: function() {
          return [ "display:", Spacebars.mustache(view.lookup("xAxisControlsTextVisibility")), ";" ];
        }
      }, "\n                                        ", HTML.DIV({
        class: "row"
      }, "\n                                            ", HTML.LABEL({
        class: "col-sm-2"
      }, "X", Blaze.View("lookup:xAxis", function() {
        return Spacebars.mustache(view.lookup("xAxis"));
      }), "_min: "), "\n                                            ", HTML.INPUT({
        id: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisMinText" ];
        },
        class: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "-axis-min data-input textInput col-sm-3" ];
        },
        type: "text",
        value: "",
        name: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisMinText" ];
        }
      }), "\n                                            ", HTML.SPAN({
        class: "col-sm-5"
      }, "YYYY-MM-DD HH:MM format"), "\n                                        "), "\n                                        ", HTML.DIV({
        class: "row"
      }, "\n                                            ", HTML.LABEL({
        class: "col-sm-2"
      }, "X", Blaze.View("lookup:xAxis", function() {
        return Spacebars.mustache(view.lookup("xAxis"));
      }), "_max: "), "\n                                            ", HTML.INPUT({
        id: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisMaxText" ];
        },
        class: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "-axis-max data-input textInput col-sm-3" ];
        },
        type: "text",
        value: "",
        name: function() {
          return [ "x", Spacebars.mustache(view.lookup("xAxis")), "AxisMaxText" ];
        }
      }), "\n                                            ", HTML.SPAN({
        class: "col-sm-5"
      }, "YYYY-MM-DD HH:MM format"), "\n                                        "), "\n                                    "), "\n                                "), "\n                            " ];
    }), "\n                            ", Blaze.Each(function() {
      return {
        _sequence: Spacebars.call(view.lookup("yAxes")),
        _variable: "yAxis"
      };
    }, function() {
      return [ "\n                                ", HTML.DIV(HTML.BR()), "\n                                ", HTML.DIV({
        id: function() {
          return [ "y", Spacebars.mustache(Spacebars.dot(view.lookup("yAxis"), "label")), "AxisCustomControls" ];
        },
        style: "display:block;"
      }, "\n                                    ", HTML.DIV({
        class: "row"
      }, "\n                                        ", HTML.LABEL({
        class: "col-sm-2"
      }, "Y", Blaze.View("lookup:yAxis", function() {
        return Spacebars.mustache(view.lookup("yAxis"));
      }), " label: "), "\n                                        ", HTML.INPUT({
        id: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisLabel" ];
        },
        class: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "-axis-label data-input textInput col-sm-3" ];
        },
        type: "text",
        value: "",
        name: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisLabel" ];
        }
      }), "\n                                    "), "\n                                    ", HTML.DIV({
        id: "yAxisControlsNumber",
        style: function() {
          return [ "display:", Spacebars.mustache(view.lookup("yAxisControlsNumberVisibility")), ";" ];
        }
      }, "\n                                        ", HTML.DIV({
        class: "row"
      }, "\n                                            ", HTML.LABEL({
        class: "col-sm-2"
      }, "Y", Blaze.View("lookup:yAxis", function() {
        return Spacebars.mustache(view.lookup("yAxis"));
      }), "_min: "), "\n                                            ", HTML.INPUT({
        id: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisMin" ];
        },
        class: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "-axis-min data-input numberInput col-sm-3" ];
        },
        type: "number",
        value: "",
        name: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisMin" ];
        }
      }), "\n                                        "), "\n                                        ", HTML.DIV({
        class: "row"
      }, "\n                                            ", HTML.LABEL({
        class: "col-sm-2"
      }, "Y", Blaze.View("lookup:yAxis", function() {
        return Spacebars.mustache(view.lookup("yAxis"));
      }), "_max: "), "\n                                            ", HTML.INPUT({
        id: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisMax" ];
        },
        class: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "-axis-max data-input numberInput col-sm-3" ];
        },
        type: "number",
        value: "",
        name: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisMax" ];
        }
      }), "\n                                        "), "\n                                    "), "\n                                    ", HTML.DIV({
        id: "yAxisControlsText",
        style: function() {
          return [ "display:", Spacebars.mustache(view.lookup("yAxisControlsTextVisibility")), ";" ];
        }
      }, "\n                                        ", HTML.DIV({
        class: "row"
      }, "\n                                            ", HTML.LABEL({
        class: "col-sm-2"
      }, "Y", Blaze.View("lookup:yAxis", function() {
        return Spacebars.mustache(view.lookup("yAxis"));
      }), "_min: "), "\n                                            ", HTML.INPUT({
        id: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisMinText" ];
        },
        class: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "-axis-min data-input textInput col-sm-3" ];
        },
        type: "text",
        value: "",
        name: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisMinText" ];
        }
      }), "\n                                            ", HTML.SPAN({
        class: "col-sm-5"
      }, "YYYY-MM-DD HH:MM format"), "\n                                        "), "\n                                        ", HTML.DIV({
        class: "row"
      }, "\n                                            ", HTML.LABEL({
        class: "col-sm-2"
      }, "Y", Blaze.View("lookup:yAxis", function() {
        return Spacebars.mustache(view.lookup("yAxis"));
      }), "_max: "), "\n                                            ", HTML.INPUT({
        id: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisMaxText" ];
        },
        class: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "-axis-max data-input textInput col-sm-3" ];
        },
        type: "text",
        value: "",
        name: function() {
          return [ "y", Spacebars.mustache(view.lookup("yAxis")), "AxisMaxText" ];
        }
      }), "\n                                            ", HTML.SPAN({
        class: "col-sm-5"
      }, "YYYY-MM-DD HH:MM format"), "\n                                        "), "\n                                    "), "\n                                "), "\n                            " ];
    }), "\n                        "), "\n                        ", HTML.DIV({
      class: "modal-footer btn-group"
    }, "\n                            ", HTML.BUTTON({
      type: "button",
      class: "cancel-send btn btn-info",
      "data-dismiss": "modal"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Cancel"), "\n                            ", HTML.BUTTON({
      name: "axisSubmit",
      id: "axisSubmit",
      type: "submit",
      class: "send btn btn-primary"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Submit\n                            "), "\n                        "), "\n                    "), "\n                    ", HTML.Comment(" /.modal-content "), "\n                "), "\n                ", HTML.Comment(" /.modal-dialog "), "\n            "), "\n        " ];
  }), "\n        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isLinePlot"));
  }, function() {
    return [ "\n            ", HTML.DIV({
      id: "lineTypeModal",
      class: "modal container",
      role: "dialog"
    }, "\n                ", HTML.DIV({
      class: "modal-dialog"
    }, "\n                    ", HTML.DIV({
      class: "modal-content"
    }, "\n                        ", HTML.DIV({
      class: "modal-header"
    }, "\n                            ", HTML.H3("Select line styles and markers: "), "\n                            ", HTML.H4("* Leave a field blank to preserve its original value. "), "\n                        "), "\n                        ", HTML.DIV({
      class: "modal-body"
    }, "\n                            ", HTML.DIV(HTML.BR()), "\n                            ", HTML.DIV({
      class: "row"
    }, "\n                                ", HTML.LABEL({
      class: "col-sm-2"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    })), "\n                                ", HTML.LABEL({
      class: "col-sm-3"
    }, "Line style "), "\n                                ", HTML.LABEL({
      class: "col-sm-3"
    }, "Line weight "), "\n                                ", HTML.LABEL({
      class: "col-sm-3"
    }, "Line marker "), "\n                            "), "\n                            ", Blaze.Each(function() {
      return Spacebars.call(view.lookup("curves"));
    }, function() {
      return [ "\n                                ", HTML.DIV({
        class: "row"
      }, "\n                                    ", HTML.LABEL({
        class: "col-sm-2"
      }, Blaze.View("lookup:..label", function() {
        return Spacebars.mustache(Spacebars.dot(view.lookup("."), "label"));
      }), ": "), "\n                                    ", HTML.SELECT({
        id: function() {
          return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "LineStyle" ];
        },
        class: function() {
          return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-line-style col-sm-3" ];
        }
      }, "\n                                        ", HTML.OPTION({
        value: "solid",
        selected: "selected"
      }, "Solid"), "\n                                        ", HTML.OPTION({
        value: "dash"
      }, "Dash"), "\n                                        ", HTML.OPTION({
        value: "dot"
      }, "Dot"), "\n                                        ", HTML.OPTION({
        value: "dashdot"
      }, "Dash-dot"), "\n                                    "), "\n                                    ", HTML.INPUT({
        id: function() {
          return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "LineWeight" ];
        },
        class: function() {
          return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-line-weight data-input numberInput col-sm-3" ];
        },
        type: "number",
        value: "2",
        name: function() {
          return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "Weight" ];
        }
      }), "\n                                    ", HTML.SELECT({
        id: function() {
          return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "LineMarker" ];
        },
        class: function() {
          return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-line-marker col-sm-3" ];
        }
      }, "\n                                        ", HTML.OPTION({
        value: "circle",
        selected: "selected"
      }, "Solid circle"), "\n                                        ", HTML.OPTION({
        value: "circle-open"
      }, "Open circle"), "\n                                        ", HTML.OPTION({
        value: "square"
      }, "Solid Square"), "\n                                        ", HTML.OPTION({
        value: "square-open"
      }, "Open Square"), "\n                                        ", HTML.OPTION({
        value: "star-square"
      }, "Concave Square"), "\n                                        ", HTML.OPTION({
        value: "diamond-tall"
      }, "Solid Diamond"), "\n                                        ", HTML.OPTION({
        value: "diamond-tall-open"
      }, "Open Diamond"), "\n                                        ", HTML.OPTION({
        value: "star-diamond"
      }, "Concave Diamond"), "\n                                        ", HTML.OPTION({
        value: "star"
      }, "Solid star"), "\n                                        ", HTML.OPTION({
        value: "star-open"
      }, "Open star"), "\n                                        ", HTML.OPTION({
        value: "x"
      }, "Solid X"), "\n                                        ", HTML.OPTION({
        value: "x-open"
      }, "Open X"), "\n                                    "), "\n                                "), "\n                            " ];
    }), "\n                        "), "\n                        ", HTML.DIV({
      class: "modal-footer btn-group"
    }, "\n                            ", HTML.BUTTON({
      type: "button",
      class: "cancel-send btn btn-info",
      "data-dismiss": "modal"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Cancel"), "\n                            ", HTML.BUTTON({
      name: "lineTypeSubmit",
      id: "lineTypeSubmit",
      type: "submit",
      class: "send btn btn-primary"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Submit\n                            "), "\n                        "), "\n                    "), "\n                    ", HTML.Comment(" /.modal-content "), "\n                "), "\n                ", HTML.Comment(" /.modal-dialog "), "\n            "), "\n        " ];
  }), "\n        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isContour"));
  }, function() {
    return [ "\n            ", HTML.DIV({
      id: "colorbarModal",
      class: "modal container",
      role: "dialog"
    }, "\n                ", HTML.DIV({
      class: "modal-dialog"
    }, "\n                    ", HTML.DIV({
      class: "modal-content"
    }, "\n                        ", HTML.DIV({
      class: "modal-header"
    }, "\n                            ", HTML.H3("Select colorbar limits and label: "), "\n                            ", HTML.H4("* Leave a field blank to preserve its original value. "), "\n                            ", HTML.H4("* Choose either a contour step OR a number of contours. If both are given, the number of contours will be used."), "\n                        "), "\n                        ", HTML.DIV({
      class: "modal-body"
    }, "\n                            ", HTML.DIV(HTML.BR()), "\n                            ", HTML.DIV({
      id: "colorbarCustomControls",
      style: "display:block;"
    }, "\n                                ", HTML.DIV({
      class: "row"
    }, "\n                                    ", HTML.LABEL({
      class: "col-sm-5"
    }, "Colorbar label: "), "\n                                    ", HTML.INPUT({
      id: "colorbarLabel",
      class: "colorbar-label data-input textInput col-sm-5",
      type: "text",
      value: "",
      name: "colorbarLabel"
    }), "\n                                "), "\n                                ", HTML.DIV(HTML.BR()), "\n                                ", HTML.DIV({
      class: "row"
    }, "\n                                    ", HTML.LABEL({
      class: "col-sm-5"
    }, "Minimum contour value: "), "\n                                    ", HTML.INPUT({
      id: "colorbarMin",
      class: "colorbar-min data-input numberInput col-sm-5",
      type: "number",
      value: "",
      name: "colorbarMin"
    }), "\n                                "), "\n                                ", HTML.DIV({
      class: "row"
    }, "\n                                    ", HTML.LABEL({
      class: "col-sm-5"
    }, "Maximum contour value: "), "\n                                    ", HTML.INPUT({
      id: "colorbarMax",
      class: "colorbar-max data-input numberInput col-sm-5",
      type: "number",
      value: "",
      name: "colorbarMax"
    }), "\n                                "), "\n                                ", HTML.DIV(HTML.BR()), "\n                                ", HTML.DIV({
      class: "row"
    }, "\n                                    ", HTML.LABEL({
      class: "col-sm-5"
    }, "Number of contours: "), "\n                                    ", HTML.INPUT({
      id: "colorbarNumber",
      class: "colorbar-number data-input numberInput col-sm-5",
      type: "number",
      value: "",
      name: "colorbarNumber"
    }), "\n                                "), "\n                                ", HTML.DIV("OR"), "\n                                ", HTML.DIV({
      class: "row"
    }, "\n                                    ", HTML.LABEL({
      class: "col-sm-5"
    }, "Contour value step: "), "\n                                    ", HTML.INPUT({
      id: "colorbarStep",
      class: "colorbar-step data-input numberInput col-sm-5",
      type: "number",
      value: "",
      name: "colorbarStep"
    }), "\n                                "), "\n                                ", HTML.DIV(HTML.BR()), "\n                                ", HTML.DIV({
      class: "row"
    }, "\n                                    ", HTML.LABEL({
      class: "col-sm-5"
    }, "Reverse colormap: "), "\n                                    ", HTML.INPUT({
      id: "colorbarReverse",
      class: "colorbar-reverse data-input checkboxInput col-sm-5",
      type: "checkbox",
      value: "",
      name: "colorbarReverse"
    }), "\n                                "), "\n                                ", HTML.DIV(HTML.BR()), "\n                                ", HTML.DIV({
      class: "row"
    }, "\n                                    ", HTML.LABEL({
      class: "col-sm-5"
    }, "Select colormap: "), "\n                                    ", HTML.SELECT({
      id: "colormapSelect"
    }, "\n                                        ", Blaze.If(function() {
      return Spacebars.call(view.lookup("isContourDiff"));
    }, function() {
      return [ "\n                                            ", HTML.OPTION({
        value: "RdBu"
      }, "RedBlue"), "\n                                            ", HTML.OPTION({
        value: '[[0,"rgb(5,10,172)"],[0.35,"rgb(106,137,247)"],[0.45,"rgb(255,255,255)"],[0.55,"rgb(255,255,255)"],[0.6,"rgb(220,170,132)"],[0.7,"rgb(230,145,90)"],[1,"rgb(178,10,28)"]]',
        selected: "selected"
      }, "RedWhiteBlue"), "\n                                        " ];
    }, function() {
      return [ "\n                                            ", HTML.OPTION({
        value: "RdBu",
        selected: "selected"
      }, "RedBlue"), "\n                                            ", HTML.OPTION({
        value: '[[0,"rgb(5,10,172)"],[0.35,"rgb(106,137,247)"],[0.45,"rgb(255,255,255)"],[0.55,"rgb(255,255,255)"],[0.6,"rgb(220,170,132)"],[0.7,"rgb(230,145,90)"],[1,"rgb(178,10,28)"]]'
      }, "RedWhiteBlue"), "\n                                        " ];
    }), "\n                                        ", HTML.OPTION({
      value: "Jet"
    }, "Jet"), "\n                                        ", HTML.OPTION({
      value: "Portland"
    }, "Portland"), "\n                                        ", HTML.OPTION({
      value: "Rainbow"
    }, "Rainbow"), "\n                                        ", HTML.OPTION({
      value: "Blackbody"
    }, "Blackbody"), "\n                                        ", HTML.OPTION({
      value: "Earth"
    }, "Earth"), "\n                                        ", HTML.OPTION({
      value: "Electric"
    }, "Electric"), "\n                                        ", HTML.OPTION({
      value: "Hot"
    }, "Hot"), "\n                                        ", HTML.OPTION({
      value: "Picnic"
    }, "Picnic"), "\n                                        ", HTML.OPTION({
      value: "Reds"
    }, "Reds"), "\n                                        ", HTML.OPTION({
      value: "Greens"
    }, "Greens"), "\n                                        ", HTML.OPTION({
      value: "Blues"
    }, "Blues"), "\n                                        ", HTML.OPTION({
      value: "Greys"
    }, "Greys"), "\n                                        ", HTML.OPTION({
      value: "Viridis"
    }, "Viridis"), "\n                                        ", HTML.OPTION({
      value: "Cividis"
    }, "Cividis"), "\n                                        ", HTML.OPTION({
      value: "Bluered"
    }, "BlueRed"), "\n                                        ", HTML.OPTION({
      value: "YlGnBu"
    }, "YellowGreenBlue"), "\n                                        ", HTML.OPTION({
      value: "YlOrRd"
    }, "YellowOrangeRed"), "\n                                    "), "\n                                "), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
      class: "modal-footer btn-group"
    }, "\n                            ", HTML.BUTTON({
      type: "button",
      class: "cancel-send btn btn-info",
      "data-dismiss": "modal"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Cancel"), "\n                            ", HTML.BUTTON({
      name: "colorbarSubmit",
      id: "colorbarSubmit",
      type: "submit",
      class: "send btn btn-primary"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Submit\n                            "), "\n                        "), "\n                    "), "\n                    ", HTML.Comment(" /.modal-content "), "\n                "), "\n                ", HTML.Comment(" /.modal-dialog "), "\n            "), "\n        " ];
  }), "\n        ", HTML.DIV({
    id: "header",
    class: "row"
  }, "\n            ", HTML.SPAN("\n                ", HTML.H4({
    class: "col-8"
  }, "\n                    ", HTML.SPAN(Blaze.View("lookup:Title", function() {
    return Spacebars.mustache(view.lookup("Title"));
  }), " : "), HTML.SPAN(Blaze.View("lookup:plotText", function() {
    return Spacebars.mustache(view.lookup("plotText"));
  })), HTML.SPAN(" ", Blaze.View("lookup:plotName", function() {
    return Spacebars.mustache(view.lookup("plotName"));
  })), "\n                    ", HTML.Raw('<button class="btn btn-xs col-2 btn-danger closeapp">Close All Preview Windows</button>'), "\n                    ", HTML.Raw('<span class="col-2 pull-right"> </span>'), "\n                "), "\n            "), "\n            ", HTML.SPAN({
    style: "display: none"
  }, Blaze.View("lookup:graphFunction", function() {
    return Spacebars.mustache(view.lookup("graphFunction"));
  })), "\n        "), "\n        ", HTML.DIV({
    id: "curves",
    class: "row"
  }, "\n            ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("curves"));
  }, function() {
    return [ "\n                ", HTML.SPAN({
      style: function() {
        return [ "color:", Spacebars.mustache(view.lookup("color")), "; font-weight: bolder;" ];
      }
    }, "--- "), HTML.SPAN({
      style: "font-size:small;"
    }, Blaze.View("lookup:curveText", function() {
      return Spacebars.mustache(view.lookup("curveText"));
    })), "\n                ", HTML.DIV({
      id: function() {
        return [ "curve-text-buttons-grp-", Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")) ];
      },
      class: "btn-group btn-group-xs"
    }, "\n                    ", HTML.INPUT({
      type: "button",
      class: "curveVisibility btn btn-primary",
      value: function() {
        return Spacebars.mustache(view.lookup("hideButtonText"));
      },
      id: function() {
        return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-curve-show-hide" ];
      },
      style: function() {
        return [ "border-radius: 5px; display:", Spacebars.mustache(view.lookup("curveShowHideDisplay")), "; background-color: #FFFFFF; border-color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")), "; color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")) ];
      }
    }), "\n                    ", HTML.INPUT({
      type: "button",
      class: "pointsVisibility btn btn-primary",
      value: function() {
        return Spacebars.mustache(view.lookup("pointsButtonText"));
      },
      id: function() {
        return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-curve-show-hide-points" ];
      },
      style: function() {
        return [ "border-radius: 5px; display:", Spacebars.mustache(view.lookup("pointsShowHideDisplay")), "; background-color: #FFFFFF; border-color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")), "; color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")) ];
      }
    }), "\n                    ", HTML.INPUT({
      type: "button",
      class: "errorBarVisibility btn btn-primary",
      value: function() {
        return Spacebars.mustache(view.lookup("errorBarButtonText"));
      },
      id: function() {
        return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-curve-show-hide-errorbars" ];
      },
      style: function() {
        return [ "border-radius: 5px; display:", Spacebars.mustache(view.lookup("errorbarsShowHideDisplay")), "; background-color: #FFFFFF; border-color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")), "; color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")) ];
      }
    }), "\n                    ", HTML.INPUT({
      type: "button",
      class: "barVisibility btn btn-primary",
      value: function() {
        return Spacebars.mustache(view.lookup("barChartButtonText"));
      },
      id: function() {
        return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-curve-show-hide-bars" ];
      },
      style: function() {
        return [ "border-radius: 5px; display:", Spacebars.mustache(view.lookup("barsShowHideDisplay")), "; background-color: #FFFFFF; border-color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")), "; color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")) ];
      }
    }), "\n                    ", HTML.INPUT({
      type: "button",
      class: "annotateVisibility btn btn-primary",
      value: function() {
        return Spacebars.mustache(view.lookup("annotateButtonText"));
      },
      id: function() {
        return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-curve-show-hide-annotate" ];
      },
      style: function() {
        return [ "border-radius: 5px; display:", Spacebars.mustache(view.lookup("annotateShowHideDisplay")), "; background-color: #FFFFFF; border-color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")), "; color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")) ];
      }
    }), "\n                    ", HTML.INPUT({
      type: "button",
      class: "heatMapVisibility btn btn-primary",
      value: function() {
        return Spacebars.mustache(view.lookup("heatMapButtonText"));
      },
      id: function() {
        return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-curve-show-hide-heatmap" ];
      },
      style: function() {
        return [ "border-radius: 5px; display:", Spacebars.mustache(view.lookup("heatMapShowHideDisplay")), "; background-color: #FFFFFF; border-color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")), "; color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")) ];
      }
    }), "\n                "), "\n                ", HTML.BR(), "\n            " ];
  }), "\n            ", HTML.Raw("<hr>"), "\n        "), "\n        ", HTML.DIV({
    id: "textView",
    style: "display:none;"
  }, "\n            ", Spacebars.include(view.lookupTemplate("textOutput")), "\n        "), "\n        ", HTML.DIV({
    id: "graphView",
    style: "height:100%;margin:0;padding:0;",
    class: "row"
  }, "\n            ", HTML.Raw('<div id="legendContainer" name="legendContainer"></div>'), "\n            ", HTML.DIV({
    id: "placeholder",
    class: "row",
    name: "placeholder",
    style: function() {
      return [ "float:left;width:", Spacebars.mustache(view.lookup("width")), "; height:", Spacebars.mustache(view.lookup("height")), ";" ];
    }
  }, "\n                \n            "), "\n        "), "\n        ", HTML.H5({
    class: "row text-center",
    id: "confidenceNote",
    style: function() {
      return [ "font-size:large;display:", Spacebars.mustache(view.lookup("confidenceDisplay")), ";" ];
    }
  }, "Error\n            Bars show 95% confidence"), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"graph.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/graph/graph.js                                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var Hooks;
module.link("meteor/differential:event-hooks", {
  Hooks: function (v) {
    Hooks = v;
  }
}, 1);
var matsCollections, matsCurveUtils, matsGraphUtils, matsMethods, matsParamUtils, matsPlotUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  },
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  },
  matsGraphUtils: function (v) {
    matsGraphUtils = v;
  },
  matsMethods: function (v) {
    matsMethods = v;
  },
  matsParamUtils: function (v) {
    matsParamUtils = v;
  },
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  },
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 2);
var pageIndex = 0;
var annotation = "";
var openWindows = [];
var xAxes = [];
var yAxes = [];
var curveOpsUpdate = [];
Template.graph.onCreated(function () {
  // the window resize event needs to also resize the graph
  $(window).resize(function () {
    matsGraphUtils.resizeGraph(matsPlotUtils.getPlotType());
    var dataset = matsCurveUtils.getGraphResult().data;
    var options = matsCurveUtils.getGraphResult().options;

    if (dataset !== undefined && options !== undefined) {
      Plotly.newPlot($("#placeholder")[0], dataset, options, {
        showLink: true
      });
    }
  });
});
Template.graph.helpers({
  /**
   * @return {string}
   * @return {string}
   */
  graphFunction: function () {
    // causes graph display routine to be processed
    Session.get('PlotResultsUpDated');
    var graphFunction = Session.get('graphFunction');

    if (graphFunction) {
      module.runSetters(eval(graphFunction))(Session.get('plotResultKey'));
      var plotType = Session.get('plotType');
      var dataset = matsCurveUtils.getGraphResult().data;
      var options = matsCurveUtils.getGraphResult().options;
      Session.set('options', options); // need to save some curve options so that the reset button can undo Plotly.restyle

      switch (plotType) {
        case matsTypes.PlotTypes.contour:
        case matsTypes.PlotTypes.contourDiff:
          //saved curve options for contours
          Session.set('colorbarResetOpts', {
            'colorbar.title': dataset[0].colorbar.title,
            'autocontour': dataset[0].autocontour,
            'ncontours': dataset[0].ncontours,
            'contours.start': dataset[0].contours.start,
            'contours.end': dataset[0].contours.end,
            'contours.size': dataset[0].contours.size,
            'reversescale': false,
            'colorscale': JSON.stringify(dataset[0].colorscale)
          });
          break;

        case matsTypes.PlotTypes.timeSeries:
        case matsTypes.PlotTypes.profile:
        case matsTypes.PlotTypes.dieoff:
        case matsTypes.PlotTypes.threshold:
        case matsTypes.PlotTypes.validtime:
        case matsTypes.PlotTypes.dailyModelCycle:
        case matsTypes.PlotTypes.reliability:
          // saved curve options for line graphs
          var lineTypeResetOpts = [];

          for (var lidx = 0; lidx < dataset.length; lidx++) {
            if (Object.values(matsTypes.ReservedWords).indexOf(dataset[lidx].label) === -1) {
              lineTypeResetOpts.push({
                'visible': dataset[lidx].visible,
                'mode': dataset[lidx].mode,
                'error_y': dataset[lidx].error_y,
                'error_x': dataset[lidx].error_x,
                'line.dash': dataset[lidx].line.dash,
                'line.width': dataset[lidx].line.width,
                'marker.symbol': dataset[lidx].marker.symbol
              });
            } else {
              break;
            }
          }

          Session.set('lineTypeResetOpts', lineTypeResetOpts);
          break;

        case matsTypes.PlotTypes.histogram:
          // saved curve options for maps
          var barTypeResetOpts = [];

          for (var bidx = 0; bidx < dataset.length; bidx++) {
            if (Object.values(matsTypes.ReservedWords).indexOf(dataset[bidx].label) === -1) {
              barTypeResetOpts.push({
                'visible': dataset[bidx].visible
              });
            } else {
              break;
            }
          }

          Session.set('barTypeResetOpts', barTypeResetOpts);
          break;

        case matsTypes.PlotTypes.map:
          // saved curve options for maps
          var mapResetOpts = [];
          mapResetOpts[0] = {
            'marker.opacity': dataset[0].marker.opacity
          };

          for (var midx = 1; midx < dataset.length; midx++) {
            mapResetOpts.push({
              'visible': dataset[midx].visible
            });
          }

          Session.set('mapResetOpts', mapResetOpts);
          break;

        case matsTypes.PlotTypes.scatter2d:
        default:
          break;
      } // initial plot


      $("#legendContainer").empty();
      $("#placeholder").empty();

      if (!dataset || !options) {
        return false;
      }

      Plotly.newPlot($("#placeholder")[0], dataset, options, {
        showLink: true
      }); // append annotations

      if (plotType !== matsTypes.PlotTypes.map) {
        annotation = "";

        for (var i = 0; i < dataset.length; i++) {
          if (plotType !== matsTypes.PlotTypes.histogram && dataset[i].curveId !== undefined) {
            annotation = annotation + "<div id='" + dataset[i].curveId + "-annotation' style='color:" + dataset[i].annotateColor + "'>" + dataset[i].annotation + " </div>";
          }
        }

        $("#legendContainer").append("<div id='annotationContainer' style='font-size:smaller'>" + annotation + "</div>"); // store the existing axes.

        Object.keys($("#placeholder")[0].layout).filter(function (k) {
          if (k.startsWith('xaxis')) {
            xAxes.push(k);
          }

          if (k.startsWith('yaxis')) {
            yAxes.push(k);
          }
        });
      }

      matsCurveUtils.hideSpinner();
    }

    return graphFunction;
  },
  Title: function () {
    if (matsCollections.Settings === undefined || matsCollections.Settings.findOne({}, {
      fields: {
        Title: 1
      }
    }) === undefined) {
      return "";
    } else {
      return matsCollections.Settings.findOne({}, {
        fields: {
          Title: 1
        }
      }).Title;
    }
  },
  width: function () {
    return matsGraphUtils.width(matsPlotUtils.getPlotType());
  },
  height: function () {
    return matsGraphUtils.height(matsPlotUtils.getPlotType());
  },
  curves: function () {
    return Session.get('Curves');
  },
  plotName: function () {
    return Session.get('PlotParams') === [] || Session.get('PlotParams').plotAction === undefined || Session.get('plotType') === matsTypes.PlotTypes.map ? "" : Session.get('PlotParams').plotAction.toUpperCase();
  },
  curveText: function () {
    if (this.diffFrom === undefined) {
      var plotType = Session.get('plotType');

      if (plotType === undefined) {
        pfuncs = matsCollections.PlotGraphFunctions.find({}).fetch();

        for (var i = 0; i < pfuncs.length; i++) {
          if (pfuncs[i].checked === true) {
            Session.set('plotType', pfuncs[i].plotType);
          }
        }

        plotType = Session.get('plotType');
      }

      return matsPlotUtils.getCurveText(plotType, this);
    } else {
      return this.label + ":  Difference";
    }
  },
  confidenceDisplay: function () {
    if (Session.get('plotParameter') === "matched") {
      var plotType = Session.get('plotType');

      switch (plotType) {
        case matsTypes.PlotTypes.timeSeries:
        case matsTypes.PlotTypes.profile:
        case matsTypes.PlotTypes.dieoff:
        case matsTypes.PlotTypes.threshold:
        case matsTypes.PlotTypes.validtime:
        case matsTypes.PlotTypes.dailyModelCycle:
          return "block";

        case matsTypes.PlotTypes.reliability:
        case matsTypes.PlotTypes.map:
        case matsTypes.PlotTypes.histogram:
        case matsTypes.PlotTypes.scatter2d:
        case matsTypes.PlotTypes.contour:
        case matsTypes.PlotTypes.contourDiff:
        default:
          return "none";
      }
    } else {
      return "none";
    }
  },
  mvSpanDisplay: function () {
    var updated = Session.get("MvResultsUpDated");

    if (Session.get("mvResultKey") != null || Session.get('plotParams')['metexpress-mode'] == "matsmv") {
      return "block";
    } else {
      return "none";
    }
  },
  plotText: function () {
    var p = Session.get('PlotParams');

    if (p !== undefined) {
      var format = p.plotFormat;

      if (matsCollections.PlotParams.findOne({
        name: 'plotFormat'
      }) && matsCollections.PlotParams.findOne({
        name: 'plotFormat'
      }).optionsMap && matsCollections.PlotParams.findOne({
        name: 'plotFormat'
      }).optionsMap[p.plotFormat] !== undefined) {
        format = matsCollections.PlotParams.findOne({
          name: 'plotFormat'
        }).optionsMap[p.plotFormat];
      }

      if (format === undefined) {
        format = "Unmatched";
      }

      var plotType = Session.get('plotType');

      switch (plotType) {
        case matsTypes.PlotTypes.timeSeries:
          return "TimeSeries " + p.dates + " : " + format;

        case matsTypes.PlotTypes.profile:
          return "Profile: " + format;

        case matsTypes.PlotTypes.dieoff:
          return "DieOff: " + format;

        case matsTypes.PlotTypes.threshold:
          return "Threshold: " + format;

        case matsTypes.PlotTypes.validtime:
          return "ValidTime: " + format;

        case matsTypes.PlotTypes.dailyModelCycle:
          return "DailyModelCycle " + p.dates + " : " + format;

        case matsTypes.PlotTypes.reliability:
          return "Reliability: " + p.dates + " : " + format;

        case matsTypes.PlotTypes.map:
          return "Map " + p.dates + " ";

        case matsTypes.PlotTypes.histogram:
          return "Histogram: " + format;

        case matsTypes.PlotTypes.contour:
          return "Contour " + p.dates + " : " + format;

        case matsTypes.PlotTypes.contourDiff:
          return "ContourDiff " + p.dates + " : " + format;

        case matsTypes.PlotTypes.scatter2d:
          break;

        default:
          return "Scatter: " + p.dates + " : " + format;
      }
    } else {
      return "no plot params";
    }
  },
  color: function () {
    return this.color;
  },
  xAxes: function () {
    Session.get('PlotResultsUpDated');
    var plotType = Session.get('plotType'); // create an array like [0,1,2...] for each unique xaxis
    // by getting the xaxis keys - filtering them to be unique, then using an Array.apply on the resulting array
    // to assign a number to each value

    var xaxis = {};

    if ($("#placeholder")[0] === undefined || $("#placeholder")[0].layout === undefined || plotType === matsTypes.PlotTypes.map) {
      return;
    }

    Object.keys($("#placeholder")[0].layout).filter(function (k) {
      if (k.startsWith('xaxis')) {
        xaxis[k] = $("#placeholder")[0].layout[k];
      }
    });
    return Array.apply(null, {
      length: Object.keys(xaxis).length
    }).map(Number.call, Number);
  },
  yAxes: function () {
    Session.get('PlotResultsUpDated');
    var plotType = Session.get('plotType'); // create an array like [0,1,2...] for each unique yaxis
    // by getting the yaxis keys - filtering them to be unique, then using an Array.apply on the resulting array
    // to assign a number to each value

    var yaxis = {};

    if ($("#placeholder")[0] === undefined || $("#placeholder")[0].layout === undefined || plotType === matsTypes.PlotTypes.map) {
      return;
    }

    Object.keys($("#placeholder")[0].layout).filter(function (k) {
      if (k.startsWith('yaxis')) {
        yaxis[k] = $("#placeholder")[0].layout[k];
      }
    });
    return Array.apply(null, {
      length: Object.keys(yaxis).length
    }).map(Number.call, Number);
  },
  isProfile: function () {
    return Session.get('plotType') === matsTypes.PlotTypes.profile;
  },
  isLinePlot: function () {
    var plotType = Session.get('plotType');

    switch (plotType) {
      case matsTypes.PlotTypes.timeSeries:
      case matsTypes.PlotTypes.profile:
      case matsTypes.PlotTypes.dieoff:
      case matsTypes.PlotTypes.threshold:
      case matsTypes.PlotTypes.validtime:
      case matsTypes.PlotTypes.dailyModelCycle:
      case matsTypes.PlotTypes.reliability:
        return true;

      case matsTypes.PlotTypes.map:
      case matsTypes.PlotTypes.histogram:
      case matsTypes.PlotTypes.scatter2d:
      case matsTypes.PlotTypes.contour:
      case matsTypes.PlotTypes.contourDiff:
      default:
        return false;
    }
  },
  isContour: function () {
    return Session.get('plotType') === matsTypes.PlotTypes.contour || Session.get('plotType') === matsTypes.PlotTypes.contourDiff;
  },
  isContourDiff: function () {
    return Session.get('plotType') === matsTypes.PlotTypes.contourDiff;
  },
  isNotMap: function () {
    return Session.get('plotType') !== matsTypes.PlotTypes.map;
  },
  sentAddresses: function () {
    var addresses = [];
    var a = matsCollections.SentAddresses.find({}, {
      fields: {
        address: 1
      }
    }).fetch();

    for (var i = 0; i < a.length; i++) {
      addresses.push(a[i].address);
    }

    return addresses;
  },
  hideButtonText: function () {
    var sval = this.label + "hideButtonText";

    if (Session.get(sval) === undefined) {
      Session.set(sval, 'hide curve');
    }

    return Session.get(sval);
  },
  pointsButtonText: function () {
    var sval = this.label + "pointsButtonText";

    if (Session.get(sval) === undefined) {
      Session.set(sval, 'hide points');
    }

    return Session.get(sval);
  },
  errorBarButtonText: function () {
    var sval = this.label + "errorBarButtonText";

    if (Session.get(sval) === undefined) {
      Session.set(sval, 'hide error bars');
    }

    return Session.get(sval);
  },
  barChartButtonText: function () {
    var sval = this.label + "barChartButtonText";

    if (Session.get(sval) === undefined) {
      Session.set(sval, 'hide bars');
    }

    return Session.get(sval);
  },
  annotateButtonText: function () {
    var sval = this.label + "annotateButtonText";

    if (Session.get(sval) === undefined) {
      Session.set(sval, 'hide annotation');
    }

    return Session.get(sval);
  },
  heatMapButtonText: function () {
    var sval = this.label + "heatMapButtonText";

    if (Session.get(sval) === undefined) {
      Session.set(sval, 'show heat map');
    }

    return Session.get(sval);
  },
  curveShowHideDisplay: function () {
    var plotType = Session.get('plotType');

    switch (plotType) {
      case matsTypes.PlotTypes.timeSeries:
      case matsTypes.PlotTypes.profile:
      case matsTypes.PlotTypes.dieoff:
      case matsTypes.PlotTypes.threshold:
      case matsTypes.PlotTypes.validtime:
      case matsTypes.PlotTypes.dailyModelCycle:
      case matsTypes.PlotTypes.reliability:
      case matsTypes.PlotTypes.scatter2d:
        return "block";

      case matsTypes.PlotTypes.map:
      case matsTypes.PlotTypes.histogram:
      case matsTypes.PlotTypes.contour:
      case matsTypes.PlotTypes.contourDiff:
      default:
        return "none";
    }
  },
  pointsShowHideDisplay: function () {
    var plotType = Session.get('plotType');

    switch (plotType) {
      case matsTypes.PlotTypes.timeSeries:
      case matsTypes.PlotTypes.profile:
      case matsTypes.PlotTypes.dieoff:
      case matsTypes.PlotTypes.threshold:
      case matsTypes.PlotTypes.validtime:
      case matsTypes.PlotTypes.dailyModelCycle:
      case matsTypes.PlotTypes.reliability:
      case matsTypes.PlotTypes.scatter2d:
        return "block";

      case matsTypes.PlotTypes.map:
      case matsTypes.PlotTypes.histogram:
      case matsTypes.PlotTypes.contour:
      case matsTypes.PlotTypes.contourDiff:
      default:
        return "none";
    }
  },
  errorbarsShowHideDisplay: function () {
    var plotType = Session.get('plotType');
    var isMatched = Session.get('plotParameter') === "matched";

    if (isMatched) {
      switch (plotType) {
        case matsTypes.PlotTypes.timeSeries:
        case matsTypes.PlotTypes.profile:
        case matsTypes.PlotTypes.dieoff:
        case matsTypes.PlotTypes.threshold:
        case matsTypes.PlotTypes.validtime:
        case matsTypes.PlotTypes.dailyModelCycle:
          return "block";

        case matsTypes.PlotTypes.reliability:
        case matsTypes.PlotTypes.map:
        case matsTypes.PlotTypes.histogram:
        case matsTypes.PlotTypes.scatter2d:
        case matsTypes.PlotTypes.contour:
        case matsTypes.PlotTypes.contourDiff:
        default:
          return "none";
      }
    } else {
      return "none";
    }
  },
  barsShowHideDisplay: function () {
    var plotType = Session.get('plotType');

    if (plotType === matsTypes.PlotTypes.histogram) {
      return 'block';
    } else {
      return 'none';
    }
  },
  annotateShowHideDisplay: function () {
    var plotType = Session.get('plotType');

    if (plotType === matsTypes.PlotTypes.map || plotType === matsTypes.PlotTypes.histogram) {
      return 'none';
    } else {
      return 'block';
    }
  },
  heatMapShowHideDisplay: function () {
    var plotType = Session.get('plotType');

    if (plotType !== matsTypes.PlotTypes.map) {
      return 'none';
    } else {
      return 'block';
    }
  },
  xAxisControlsNumberVisibility: function () {
    Session.get('PlotResultsUpDated');
    var plotType = Session.get('plotType');

    if (plotType === matsTypes.PlotTypes.timeSeries || plotType === matsTypes.PlotTypes.dailyModelCycle || (plotType === matsTypes.PlotTypes.contour || plotType === matsTypes.PlotTypes.contourDiff) && $("#placeholder")[0].layout.xaxis.title.text.indexOf("Date") > -1) {
      return "none";
    } else {
      return "block";
    }
  },
  xAxisControlsTextVisibility: function () {
    Session.get('PlotResultsUpDated');
    var plotType = Session.get('plotType');

    if (plotType === matsTypes.PlotTypes.timeSeries || plotType === matsTypes.PlotTypes.dailyModelCycle || (plotType === matsTypes.PlotTypes.contour || plotType === matsTypes.PlotTypes.contourDiff) && $("#placeholder")[0].layout.xaxis.title.text.indexOf("Date") > -1) {
      return "block";
    } else {
      return "none";
    }
  },
  yAxisControlsNumberVisibility: function () {
    Session.get('PlotResultsUpDated');

    if ((plotType === matsTypes.PlotTypes.contour || plotType === matsTypes.PlotTypes.contourDiff) && $("#placeholder")[0].layout.yaxis.title.text.indexOf("Date") > -1) {
      return "none";
    } else {
      return "block";
    }
  },
  yAxisControlsTextVisibility: function () {
    Session.get('PlotResultsUpDated');

    if ((plotType === matsTypes.PlotTypes.contour || plotType === matsTypes.PlotTypes.contourDiff) && $("#placeholder")[0].layout.yaxis.title.text.indexOf("Date") > -1) {
      return "block";
    } else {
      return "none";
    }
  },
  displayReplotZoom: function () {
    // the replot to zoom function is only really appropriate for downsampled graphs which are
    // only possible in timeseries or dailymodelcycle plots
    Session.get("PlotParams");
    Session.get('PlotResultsUpDated');
    var plotType = Session.get('plotType');

    if (plotType === matsTypes.PlotTypes.timeSeries || plotType === matsTypes.PlotTypes.dailyModelCycle) {
      return "block";
    } else {
      return "none";
    }
  },
  metApp: function () {
    Session.get("PlotParams");
    Session.get('PlotResultsUpDated');

    if (matsCollections.Settings.findOne({}).appType && matsCollections.Settings.findOne({}).appType === matsTypes.AppTypes.metexpress && Session.get('PlotParams')['metexpress-mode'] == "matsmv") {
      return "block";
    } else {
      return "none";
    }
  },
  mvFiles: function () {
    var updated = Session.get('MvResultsUpDated');
    var key = Session.get('mvResultKey');
    var mvs = Session.get('mvs');

    if (mvs != null) {
      return mvs;
    } else {
      return [];
    }
  },
  mvDisabled: function () {
    var updated = Session.get('MvResultsUpDated');

    if (Session.get('mvs') == null || Session.get('PlotParams')['metexpress-mode'] == "mats") {
      return "none";
    } else {
      return "block";
    }
  },
  mvLoading: function () {
    var updated = Session.get('MvResultsUpDated');

    if (Session.get('mvs') == null && Session.get('PlotParams')['metexpress-mode'] == "matsmv") {
      return "block";
    } else {
      return "none";
    }
  }
});
Template.graph.events({
  'click .mvCtrlButton': function () {
    var mvWindow = window.open(this.url, "mv", "height=200,width=200");
    setTimeout(function () {
      mvWindow.reload();
    }, 500);
  },
  'click .back': function () {
    var plotType = Session.get('plotType');

    if (plotType === matsTypes.PlotTypes.contourDiff) {
      var oldCurves = Session.get('oldCurves');
      Session.set('Curves', oldCurves);
    }

    matsPlotUtils.enableActionButtons();
    matsGraphUtils.setDefaultView();
    matsCurveUtils.resetPlotResultData();
    return false;
  },
  'click .header': function (event) {
    document.getElementById('graph-control').style.display = 'block'; // document.getElementById('showAdministration').style.display = 'block';

    document.getElementById('navbar').style.display = 'block';
    document.getElementById('footnav').style.display = 'block';
    var ctbgElems = $('*[id^="curve-text-buttons-grp"]');

    for (var i = 0; i < ctbgElems.length; i++) {
      ctbgElems[i].style.display = 'block';
    }
  },
  'click .preview': function () {
    // capture the layout
    var layout = $("#placeholder")[0].layout;
    var key = Session.get('plotResultKey');
    matsMethods.saveLayout.call({
      resultKey: key,
      layout: layout,
      curveOpsUpdate: {
        curveOpsUpdate: curveOpsUpdate
      }
    }, function (error) {
      if (error !== undefined) {
        setError(error);
      }
    }); // open a new window with a standAlone graph of the current graph

    var h = Math.max(document.documentElement.clientHeight, window.innerWidth || 0) * .5;
    var w = h * 1.3;
    var wind = window.open(window.location + "/preview/" + Session.get("graphFunction") + "/" + Session.get("plotResultKey") + "/" + Session.get('plotParameter') + "/" + matsCollections.Settings.findOne({}, {
      fields: {
        Title: 1
      }
    }).Title, "_blank", "status=no,titlebar=no,toolbar=no,scrollbars=no,menubar=no,resizable=yes", "height=" + h + ",width=" + w);
    setTimeout(function () {
      wind.resizeTo(w, h);
    }, 500);
    openWindows.push(wind);
  },
  'click .closeapp': function () {
    for (var widx = 0; widx < openWindows.length; widx++) {
      openWindows[widx].close();
    }

    openWindows = [];
  },
  'click .reload': function () {
    var dataset = matsCurveUtils.getGraphResult().data;
    var options = matsCurveUtils.getGraphResult().options;
    var graphFunction = Session.get('graphFunction');
    window[graphFunction](dataset, options);
  },
  'click .plotButton': function () {
    matsGraphUtils.setGraphView(Session.get('plotType'));
    var graphView = document.getElementById('graphView');
    Session.set('graphViewMode', matsTypes.PlotView.graph);
    matsCurveUtils.hideSpinner();
  },
  'click .textButton': function () {
    matsGraphUtils.setTextView(Session.get('plotType'));
    Session.set('graphViewMode', matsTypes.PlotView.text);
    Session.set("pageIndex", 0);
    Session.set("newPageIndex", 1);
    Session.set('textRefreshNeeded', true);
  },
  'click .export': function () {
    document.getElementById('text_export').click();
  },
  'click .sentAddresses': function (event) {
    var address = event.currentTarget.options[event.currentTarget.selectedIndex].value;
    document.getElementById("sendAddress").value = address;
  },
  'click .share': function () {
    // show address modal
    if (!Meteor.user()) {
      setError(new Error("You must be logged in to use the 'share' feature"));
      return false;
    }

    $("#sendModal").modal('show');
  },
  'click .basis': function () {
    window.open(window.location + "/JSON/" + Session.get("graphFunction") + "/" + Session.get("plotResultKey") + "/" + Session.get('plotParameter') + "/" + matsCollections.Settings.findOne({}, {
      fields: {
        Title: 1
      }
    }).Title, "_blank", "resizable=yes");
  },
  'click .axisLimitButton': function () {
    $("#axisLimitModal").modal('show');
  },
  'click .lineTypeButton': function () {
    $("#lineTypeModal").modal('show');
  },
  'click .colorbarButton': function () {
    $("#colorbarModal").modal('show');
  },
  'click .axisYScale': function () {
    // get all yaxes and change their scales
    var newOpts = {};
    var yAxis;

    for (var k = 0; k < yAxes.length; k++) {
      yAxis = yAxes[k];
      newOpts[yAxis + '.type'] = $("#placeholder")[0].layout[yAxis].type === 'linear' ? 'log' : 'linear';
    }

    Plotly.relayout($("#placeholder")[0], newOpts);
  },
  'click .firstPageButton': function () {
    var pageIndex = Session.get("pageIndex"); // if pageIndex is NaN, it means we only have one page and these buttons shouldn't do anything

    if (!Number.isNaN(pageIndex)) {
      Session.set("pageIndex", 0);
      Session.set("newPageIndex", 1);
      Session.set('textRefreshNeeded', true);
    }
  },
  'click .previousTenPageButton': function () {
    var pageIndex = Session.get("pageIndex"); // if pageIndex is NaN, it means we only have one page and these buttons shouldn't do anything

    if (!Number.isNaN(pageIndex)) {
      var pageTextDirection = Session.get("pageTextDirection"); // if the navigation direction is changing, you have to increment the page index an additional time,
      // or you just move to the other end of the current page, and nothing appears to change.

      if (pageTextDirection !== undefined && pageTextDirection === -1) {
        Session.set("newPageIndex", pageIndex - 10);
      } else {
        Session.set("newPageIndex", pageIndex - 11);
      }

      Session.set('textRefreshNeeded', true);
    }
  },
  'click .previousPageButton': function () {
    var pageIndex = Session.get("pageIndex"); // if pageIndex is NaN, it means we only have one page and these buttons shouldn't do anything

    if (!Number.isNaN(pageIndex)) {
      var pageTextDirection = Session.get("pageTextDirection"); // if the navigation direction is changing, you have to increment the page index an additional time,
      // or you just move to the other end of the current page, and nothing appears to change.

      if (pageTextDirection !== undefined && pageTextDirection === -1) {
        Session.set("newPageIndex", pageIndex - 1);
      } else {
        Session.set("newPageIndex", pageIndex - 2);
      }

      Session.set('textRefreshNeeded', true);
    }
  },
  'click .nextPageButton': function () {
    var pageIndex = Session.get("pageIndex"); // if pageIndex is NaN, it means we only have one page and these buttons shouldn't do anything

    if (!Number.isNaN(pageIndex)) {
      var pageTextDirection = Session.get("pageTextDirection"); // if the navigation direction is changing, you have to increment the page index an additional time,
      // or you just move to the other end of the current page, and nothing appears to change.

      if (pageTextDirection !== undefined && pageTextDirection === 1) {
        Session.set("newPageIndex", pageIndex + 1);
      } else {
        Session.set("newPageIndex", pageIndex + 2);
      }

      Session.set('textRefreshNeeded', true);
    }
  },
  'click .nextTenPageButton': function () {
    var pageIndex = Session.get("pageIndex"); // if pageIndex is NaN, it means we only have one page and these buttons shouldn't do anything

    if (!Number.isNaN(pageIndex)) {
      var pageTextDirection = Session.get("pageTextDirection"); // if the navigation direction is changing, you have to increment the page index an additional time,
      // or you just move to the other end of the current page, and nothing appears to change.

      if (pageTextDirection !== undefined && pageTextDirection === 1) {
        Session.set("newPageIndex", pageIndex + 10);
      } else {
        Session.set("newPageIndex", pageIndex + 11);
      }

      Session.set('textRefreshNeeded', true);
    }
  },
  'click .lastPageButton': function () {
    var pageIndex = Session.get("pageIndex"); // if pageIndex is NaN, it means we only have one page and these buttons shouldn't do anything

    if (!Number.isNaN(pageIndex)) {
      Session.set("newPageIndex", -2000);
      Session.set('textRefreshNeeded', true);
    }
  },
  'click .replotZoomButton': function () {
    var plotType = Session.get('plotType');

    if (plotType === matsTypes.PlotTypes.timeSeries || plotType === matsTypes.PlotTypes.dailyModelCycle) {
      var newDateRange = moment.utc($("#placeholder")[0].layout['xaxis'].range[0]).format('M/DD/YYYY HH:mm') + " - " + moment.utc($("#placeholder")[0].layout['xaxis'].range[1]).format('M/DD/YYYY HH:mm');
      console.log(newDateRange);
      document.getElementById('controlButton-dates-value').innerHTML = newDateRange;
      var params = Session.get('params');
      var actionId = "plotUnmatched";

      if (params.plotAction === "matched") {
        actionId = plotMatched;
      }

      document.getElementById("plot-curves").click();
    }
  },
  'click .reCacheButton': function () {
    var plotType = Session.get('plotType');
    var params = Session.get('params');
    var actionId = "plotUnmatched";

    if (params.plotAction === "matched") {
      actionId = plotMatched;
    }

    Session.set('expireKey', true);
    document.getElementById("plot-curves").click();
  },
  'click .curveVisibility': function (event) {
    event.preventDefault();
    var dataset = matsCurveUtils.getGraphResult().data;
    var id = event.target.id;
    var label = id.replace('-curve-show-hide', '');
    var myDataIdx = dataset.findIndex(function (d) {
      return d.curveId === label;
    });

    if (dataset[myDataIdx].x.length > 0) {
      var update;

      if (dataset[myDataIdx].visible) {
        if (dataset[myDataIdx].mode === "lines") {
          // in line mode, lines are visible, so make nothing visible
          update = {
            visible: !dataset[myDataIdx].visible
          };
          $('#' + label + "-curve-show-hide")[0].value = "show curve";
        } else if (dataset[myDataIdx].mode === "lines+markers") {
          // in line and point mode, lines and points are visible, so make nothing visible
          update = {
            visible: !dataset[myDataIdx].visible
          };
          $('#' + label + "-curve-show-hide")[0].value = "show curve";
          $('#' + label + "-curve-show-hide-points")[0].value = "show points";
        } else if (dataset[myDataIdx].mode === "markers") {
          // in point mode, points are visible, so make lines and points visible
          update = {
            mode: "lines+markers"
          };
          $('#' + label + "-curve-show-hide")[0].value = "hide curve";
        }
      } else {
        if (dataset[myDataIdx].mode === "lines") {
          // in line mode, nothing is visible, so make lines visible
          update = {
            visible: !dataset[myDataIdx].visible
          };
          $('#' + label + "-curve-show-hide")[0].value = "hide curve";
        } else if (dataset[myDataIdx].mode === "lines+markers") {
          // in line and point mode, nothing is visible, so make lines and points visible
          update = {
            visible: !dataset[myDataIdx].visible
          };
          $('#' + label + "-curve-show-hide")[0].value = "hide curve";
          $('#' + label + "-curve-show-hide-points")[0].value = "hide points";
        }
      }
    }

    Plotly.restyle($("#placeholder")[0], update, myDataIdx); // save the updates in case we want to pass them to a pop-out window.

    curveOpsUpdate[myDataIdx] = curveOpsUpdate[myDataIdx] === undefined ? {} : curveOpsUpdate[myDataIdx];
    var updatedKeys = Object.keys(update);

    for (var kidx = 0; kidx < updatedKeys.length; kidx++) {
      var updatedKey = updatedKeys[kidx]; // json doesn't like . to be in keys, so replace it with a placeholder

      var jsonHappyKey = updatedKey.split(".").join("____");
      curveOpsUpdate[myDataIdx][jsonHappyKey] = update[updatedKey];
    }
  },
  'click .pointsVisibility': function (event) {
    event.preventDefault();
    var dataset = matsCurveUtils.getGraphResult().data;
    var id = event.target.id;
    var label = id.replace('-curve-show-hide-points', '');
    var myDataIdx = dataset.findIndex(function (d) {
      return d.curveId === label;
    });

    if (dataset[myDataIdx].x.length > 0) {
      var update;

      if (dataset[myDataIdx].visible) {
        if (dataset[myDataIdx].mode === "lines") {
          // lines are visible, so make lines and points visible
          update = {
            mode: "lines+markers"
          };
          $('#' + label + "-curve-show-hide-points")[0].value = "hide points";
        } else if (dataset[myDataIdx].mode === "lines+markers") {
          // lines and points are visible, so make only lines visible
          update = {
            mode: "lines"
          };
          $('#' + label + "-curve-show-hide-points")[0].value = "show points";
        } else if (dataset[myDataIdx].mode === "markers") {
          // points are visible, so make nothing visible
          update = {
            visible: !dataset[myDataIdx].visible,
            mode: "lines"
          };
          $('#' + label + "-curve-show-hide-points")[0].value = "show points";
        }
      } else {
        // nothing is visible, so make points visible
        update = {
          visible: !dataset[myDataIdx].visible,
          mode: "markers"
        };
        $('#' + label + "-curve-show-hide-points")[0].value = "hide points";
      }
    }

    Plotly.restyle($("#placeholder")[0], update, myDataIdx); // save the updates in case we want to pass them to a pop-out window.

    curveOpsUpdate[myDataIdx] = curveOpsUpdate[myDataIdx] === undefined ? {} : curveOpsUpdate[myDataIdx];
    var updatedKeys = Object.keys(update);

    for (var kidx = 0; kidx < updatedKeys.length; kidx++) {
      var updatedKey = updatedKeys[kidx]; // json doesn't like . to be in keys, so replace it with a placeholder

      var jsonHappyKey = updatedKey.split(".").join("____");
      curveOpsUpdate[myDataIdx][jsonHappyKey] = update[updatedKey];
    }
  },
  'click .errorBarVisibility': function (event) {
    event.preventDefault();
    var plotType = Session.get('plotType');
    var dataset = matsCurveUtils.getGraphResult().data;
    var id = event.target.id;
    var label = id.replace('-curve-show-hide-errorbars', '');
    var myDataIdx = dataset.findIndex(function (d) {
      return d.curveId === label;
    });

    if (dataset[myDataIdx].x.length > 0) {
      var update;

      if (plotType !== matsTypes.PlotTypes.profile) {
        update = {
          error_y: dataset[myDataIdx].error_y
        };
        update.error_y.visible = !update.error_y.visible;

        if (update.error_y.visible) {
          $('#' + label + "-curve-show-hide-errorbars")[0].value = "hide error bars";
        } else {
          $('#' + label + "-curve-show-hide-errorbars")[0].value = "show error bars";
        }
      } else {
        update = {
          error_x: dataset[myDataIdx].error_x
        };
        update.error_x.visible = !update.error_x.visible;

        if (update.error_x.visible) {
          $('#' + label + "-curve-show-hide-errorbars")[0].value = "hide error bars";
        } else {
          $('#' + label + "-curve-show-hide-errorbars")[0].value = "show error bars";
        }
      }
    }

    Plotly.restyle($("#placeholder")[0], update, myDataIdx); // save the updates in case we want to pass them to a pop-out window.

    curveOpsUpdate[myDataIdx] = curveOpsUpdate[myDataIdx] === undefined ? {} : curveOpsUpdate[myDataIdx];
    var updatedKeys = Object.keys(update);

    for (var kidx = 0; kidx < updatedKeys.length; kidx++) {
      var updatedKey = updatedKeys[kidx]; // json doesn't like . to be in keys, so replace it with a placeholder

      var jsonHappyKey = updatedKey.split(".").join("____");
      curveOpsUpdate[myDataIdx][jsonHappyKey] = update[updatedKey];
    }
  },
  'click .barVisibility': function (event) {
    event.preventDefault();
    var dataset = matsCurveUtils.getGraphResult().data;
    var id = event.target.id;
    var label = id.replace('-curve-show-hide-bars', '');
    var myDataIdx = dataset.findIndex(function (d) {
      return d.curveId === label;
    });

    if (dataset[myDataIdx].x.length > 0) {
      var update = {
        visible: !dataset[myDataIdx].visible
      };

      if (update.visible) {
        $('#' + label + "-curve-show-hide-bars")[0].value = "hide bars";
      } else {
        $('#' + label + "-curve-show-hide-bars")[0].value = "show bars";
      }
    }

    Plotly.restyle($("#placeholder")[0], update, myDataIdx); // save the updates in case we want to pass them to a pop-out window.

    curveOpsUpdate[myDataIdx] = curveOpsUpdate[myDataIdx] === undefined ? {} : curveOpsUpdate[myDataIdx];
    var updatedKeys = Object.keys(update);

    for (var kidx = 0; kidx < updatedKeys.length; kidx++) {
      var updatedKey = updatedKeys[kidx]; // json doesn't like . to be in keys, so replace it with a placeholder

      var jsonHappyKey = updatedKey.split(".").join("____");
      curveOpsUpdate[myDataIdx][jsonHappyKey] = update[updatedKey];
    }
  },
  'click .annotateVisibility': function (event) {
    event.preventDefault();
    var id = event.target.id;
    var label = id.replace('-curve-show-hide-annotate', '');

    if ($('#' + label + "-annotation")[0].hidden) {
      $('#' + label + "-annotation")[0].style.display = "block";
      $('#' + label + "-curve-show-hide-annotate")[0].value = "hide annotation";
      $('#' + label + "-annotation")[0].hidden = false;
    } else {
      $('#' + label + "-annotation")[0].style.display = "none";
      $('#' + label + "-curve-show-hide-annotate")[0].value = "show annotation";
      $('#' + label + "-annotation")[0].hidden = true;
    }

    annotation = $('#annotationContainer')[0].innerHTML;
  },
  'click .heatMapVisibility': function (event) {
    event.preventDefault();
    var dataset = matsCurveUtils.getGraphResult().data;

    if (dataset[0].lat.length > 0) {
      var update;
      var didx;

      if (dataset[0].marker.opacity === 0) {
        update = {
          'marker.opacity': 1
        };
        Plotly.restyle($("#placeholder")[0], update, 0); // save the updates in case we want to pass them to a pop-out window.

        curveOpsUpdate[0] = curveOpsUpdate[0] === undefined ? {} : curveOpsUpdate[0];
        curveOpsUpdate[0]['marker____opacity'] = update['marker.opacity'];
        update = {
          'visible': false
        };

        for (didx = 1; didx < dataset.length; didx++) {
          Plotly.restyle($("#placeholder")[0], update, didx); // save the updates in case we want to pass them to a pop-out window.

          curveOpsUpdate[didx] = curveOpsUpdate[didx] === undefined ? {} : curveOpsUpdate[didx];
          curveOpsUpdate[didx]['visible'] = update['visible'];
        }

        $('#' + label + "-curve-show-hide-heatmap")[0].value = "hide heat map";
      } else {
        update = {
          'marker.opacity': 0
        };
        Plotly.restyle($("#placeholder")[0], update, 0); // save the updates in case we want to pass them to a pop-out window.

        curveOpsUpdate[0] = curveOpsUpdate[0] === undefined ? {} : curveOpsUpdate[0];
        curveOpsUpdate[0]['marker____opacity'] = update['marker.opacity'];
        update = {
          'visible': true
        };

        for (didx = 1; didx < dataset.length; didx++) {
          Plotly.restyle($("#placeholder")[0], update, didx); // save the updates in case we want to pass them to a pop-out window.

          curveOpsUpdate[didx] = curveOpsUpdate[didx] === undefined ? {} : curveOpsUpdate[didx];
          curveOpsUpdate[didx]['visible'] = update['visible'];
        }

        $('#' + label + "-curve-show-hide-heatmap")[0].value = "show heat map";
      }
    }
  },
  // add refresh button
  'click #refresh-plot': function (event) {
    event.preventDefault();
    var plotType = Session.get('plotType');
    var dataset = matsCurveUtils.getGraphResult().data;
    var options = Session.get('options');

    if (curveOpsUpdate.length === 0) {
      // we just need a relayout
      Plotly.relayout($("#placeholder")[0], options);
    } else {
      // we need both a relayout and a restyle
      curveOpsUpdate = [];

      switch (plotType) {
        case matsTypes.PlotTypes.contour:
        case matsTypes.PlotTypes.contourDiff:
          // restyle for contour plots
          Plotly.restyle($("#placeholder")[0], Session.get('colorbarResetOpts'), 0);
          break;

        case matsTypes.PlotTypes.timeSeries:
        case matsTypes.PlotTypes.profile:
        case matsTypes.PlotTypes.dieoff:
        case matsTypes.PlotTypes.threshold:
        case matsTypes.PlotTypes.validtime:
        case matsTypes.PlotTypes.dailyModelCycle:
        case matsTypes.PlotTypes.reliability:
          // restyle for line plots
          var lineTypeResetOpts = Session.get('lineTypeResetOpts');

          for (var lidx = 0; lidx < lineTypeResetOpts.length; lidx++) {
            Plotly.restyle($("#placeholder")[0], lineTypeResetOpts[lidx], lidx);
            $('#' + dataset[lidx].label + "-curve-show-hide")[0].value = "hide curve";
            $('#' + dataset[lidx].label + "-curve-show-hide-points")[0].value = "hide points";
            $('#' + dataset[lidx].label + "-curve-show-hide-errorbars")[0].value = "hide error bars";
          }

          break;

        case matsTypes.PlotTypes.histogram:
          // restyle for bar plots
          var barTypeResetOpts = Session.get('barTypeResetOpts');

          for (var bidx = 0; bidx < barTypeResetOpts.length; bidx++) {
            Plotly.restyle($("#placeholder")[0], barTypeResetOpts[bidx], bidx);
            $('#' + dataset[bidx].label + "-curve-show-hide-bars")[0].value = "hide bars";
          }

          break;

        case matsTypes.PlotTypes.map:
          // restyle for maps
          var mapResetOpts = Session.get('mapResetOpts');

          for (var midx = 0; midx < mapResetOpts.length; midx++) {
            Plotly.restyle($("#placeholder")[0], mapResetOpts[midx], midx);
          }

          $('#' + dataset[0].label + "-curve-show-hide-heatmap")[0].value = "show heat map";
          break;

        case matsTypes.PlotTypes.scatter2d:
        default:
          break;
      }

      Plotly.relayout($("#placeholder")[0], options);
    }
  },
  // add axis customization modal submit button
  'click #axisSubmit': function (event) {
    event.preventDefault();
    var plotType = Session.get('plotType');
    var changeYScaleBack = false;
    var newOpts = {}; // get input axis limits and labels

    $("input[id^=x][id$=AxisLabel]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        newOpts['xaxis' + (index === 0 ? "" : index + 1) + '.title'] = elem.value;
      }
    });

    if (plotType === matsTypes.PlotTypes.timeSeries || plotType === matsTypes.PlotTypes.dailyModelCycle || (plotType === matsTypes.PlotTypes.contour || plotType === matsTypes.PlotTypes.contourDiff) && $("#placeholder")[0].layout.xaxis.title.text.indexOf("Date") > -1) {
      $("input[id^=x][id$=AxisMinText]").get().forEach(function (elem, index) {
        if (elem.value !== undefined && elem.value !== "") {
          newOpts['xaxis' + (index === 0 ? "" : index + 1) + '.range[0]'] = elem.value;
        }
      });
      $("input[id^=x][id$=AxisMaxText]").get().forEach(function (elem, index) {
        if (elem.value !== undefined && elem.value !== "") {
          newOpts['xaxis' + (index === 0 ? "" : index + 1) + '.range[1]'] = elem.value;
        }
      });
    } else {
      $("input[id^=x][id$=AxisMin]").get().forEach(function (elem, index) {
        if (elem.value !== undefined && elem.value !== "") {
          newOpts['xaxis' + (index === 0 ? "" : index + 1) + '.range[0]'] = elem.value;
        }
      });
      $("input[id^=x][id$=AxisMax]").get().forEach(function (elem, index) {
        if (elem.value !== undefined && elem.value !== "") {
          newOpts['xaxis' + (index === 0 ? "" : index + 1) + '.range[1]'] = elem.value;
        }
      });
    }

    $("input[id^=y][id$=AxisLabel]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        newOpts['yaxis' + (index === 0 ? "" : index + 1) + '.title'] = elem.value;
      }
    });

    if ((plotType === matsTypes.PlotTypes.contour || plotType === matsTypes.PlotTypes.contourDiff) && $("#placeholder")[0].layout.xaxis.title.text.indexOf("Date") > -1) {
      $("input[id^=y][id$=AxisMinText]").get().forEach(function (elem, index) {
        if (elem.value !== undefined && elem.value !== "") {
          newOpts['yaxis' + (index === 0 ? "" : index + 1) + '.range[0]'] = elem.value;
        }
      });
      $("input[id^=y][id$=AxisMaxText]").get().forEach(function (elem, index) {
        if (elem.value !== undefined && elem.value !== "") {
          newOpts['yaxis' + (index === 0 ? "" : index + 1) + '.range[1]'] = elem.value;
        }
      });
    } else {
      $("input[id^=y][id$=AxisMin]").get().forEach(function (elem, index) {
        if (elem.value !== undefined && elem.value !== "") {
          if (plotType === matsTypes.PlotTypes.profile) {
            newOpts['yaxis' + (index === 0 ? "" : index + 1) + '.range[1]'] = elem.value; // plotly can't seem to set axis limits on a log axis, so this needs to be changed to linear

            if ($("#placeholder")[0].layout['yaxis' + (index === 0 ? "" : index + 1)].type === 'log') {
              $("#axisYScale").click();
              changeYScaleBack = true;
            }
          } else {
            newOpts['yaxis' + (index === 0 ? "" : index + 1) + '.range[0]'] = elem.value;
          }
        }
      });
      $("input[id^=y][id$=AxisMax]").get().forEach(function (elem, index) {
        if (elem.value !== undefined && elem.value !== "") {
          if (plotType === matsTypes.PlotTypes.profile) {
            newOpts['yaxis' + (index === 0 ? "" : index + 1) + '.range[0]'] = elem.value; // plotly can't seem to set axis limits on a log axis, so this needs to be changed to linear

            if ($("#placeholder")[0].layout['yaxis' + (index === 0 ? "" : index + 1)].type === 'log') {
              $("#axisYScale").click();
              changeYScaleBack = true;
            }
          } else {
            newOpts['yaxis' + (index === 0 ? "" : index + 1) + '.range[1]'] = elem.value;
          }
        }
      });
    }

    Plotly.relayout($("#placeholder")[0], newOpts); // if needed, restore the log axis

    if (changeYScaleBack) {
      $("#axisYScale").click();
    }

    $("#axisLimitModal").modal('hide');
  },
  // add line style modal submit button
  'click #lineTypeSubmit': function (event) {
    event.preventDefault();
    var plotType = Session.get('plotType');
    var updates = []; // get input line style change

    $("[id$=LineStyle]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        updates[index] = updates[index] === undefined ? {} : updates[index];
        updates[index]['line.dash'] = elem.value;
      }
    });
    $("input[id$=LineWeight]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        updates[index] = updates[index] === undefined ? {} : updates[index];
        updates[index]['line.width'] = elem.value;
      }
    });
    $("[id$=LineMarker]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        updates[index] = updates[index] === undefined ? {} : updates[index];
        updates[index]['marker.symbol'] = elem.value;
      }
    });

    for (var uidx = 0; uidx < updates.length; uidx++) {
      // apply new settings
      Plotly.restyle($("#placeholder")[0], updates[uidx], uidx);
    }

    $("#lineTypeModal").modal('hide'); // save the updates in case we want to pass them to a pop-out window.

    for (uidx = 0; uidx < updates.length; uidx++) {
      curveOpsUpdate[uidx] = curveOpsUpdate[uidx] === undefined ? {} : curveOpsUpdate[uidx];
      var updatedKeys = Object.keys(updates[uidx]);

      for (var kidx = 0; kidx < updatedKeys.length; kidx++) {
        var updatedKey = updatedKeys[kidx]; // json doesn't like . to be in keys, so replace it with a placeholder

        var jsonHappyKey = updatedKey.split(".").join("____");
        curveOpsUpdate[uidx][jsonHappyKey] = updates[uidx][updatedKey];
      }
    }
  },
  // add colorbar customization modal submit button
  'click #colorbarSubmit': function (event) {
    event.preventDefault();
    var dataset = matsCurveUtils.getGraphResult().data;
    var update = {}; // get new formatting

    $("input[id=colorbarLabel]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        update['colorbar.title'] = elem.value;
        update['colorbar.titleside'] = 'right';
        update['colorbar.titlefont'] = {
          size: 16,
          family: 'Arial, sans-serif'
        };
      }
    });
    $("input[id=colorbarMin]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        update['autocontour'] = false;
        update['contours.start'] = elem.value;
      }
    });
    $("input[id=colorbarMax]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        update['autocontour'] = false;
        update['contours.end'] = elem.value;
      }
    });
    $("input[id=colorbarNumber]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        update['autocontour'] = false;
        update['ncontours'] = elem.value; // sadly plotly regards this as a "less than or equal to" value, so we have to manually set contour size

        var isStartDefined = update['contours.start'] !== undefined;
        var isEndDefined = update['contours.end'] !== undefined;
        var startVal = isStartDefined ? update['contours.start'] : dataset[0].zmin + (dataset[0].zmax - dataset[0].zmin) / 16;
        var endVal = isEndDefined ? update['contours.end'] : dataset[0].zmax - (dataset[0].zmax - dataset[0].zmin) / 16;
        update['contours.size'] = (endVal - startVal) / (Number(update['ncontours']) - 1);
      }
    });
    $("input[id=colorbarStep]").get().forEach(function (elem, index) {
      if (elem.value !== undefined && elem.value !== "") {
        if (update['ncontours'] === undefined) {
          update['autocontour'] = false;
          update['contours.size'] = elem.value;
        }
      }
    });
    $("input[id=colorbarReverse]").get().forEach(function (elem, index) {
      if (elem && elem.checked) {
        update['reversescale'] = true;
      } else {
        update['reversescale'] = false;
      }
    });
    var elem = document.getElementById("colormapSelect");

    if (elem !== undefined && elem.value !== undefined) {
      update['colorscale'] = elem.value;
    } // apply new settings


    Plotly.restyle($("#placeholder")[0], update, 0);
    $("#colorbarModal").modal('hide'); // save the updates in case we want to pass them to a pop-out window.

    curveOpsUpdate[0] = curveOpsUpdate[0] === undefined ? {} : curveOpsUpdate[0];
    var updatedKeys = Object.keys(update);

    for (var uidx = 0; uidx < updatedKeys.length; uidx++) {
      var updatedKey = updatedKeys[uidx]; // json doesn't like . to be in keys, so replace it with a placeholder

      var jsonHappyKey = updatedKey.split(".").join("____");
      curveOpsUpdate[0][jsonHappyKey] = update[updatedKey];
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"displayFunctions":{"graph_plotly.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/graph/displayFunctions/graph_plotly.js                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var moment;
module.link("meteor/momentjs:moment", {
  moment: function (v) {
    moment = v;
  }
}, 0);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 1);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 2);
var matsGraphUtils;
module.link("meteor/randyp:mats-common", {
  matsGraphUtils: function (v) {
    matsGraphUtils = v;
  }
}, 3);

graphPlotly = function (key) {
  // get plot info
  var route = Session.get('route'); // get dataset info and options

  var resultSet = matsCurveUtils.getGraphResult();

  if (resultSet === null || resultSet === undefined || resultSet.data === undefined) {
    return false;
  } //set options


  var options = resultSet.options;

  if (route !== undefined && route !== "") {
    options.selection = [];
  } // initialize show/hide button labels


  var dataset = resultSet.data;

  if (Session.get('plotType') !== matsTypes.PlotTypes.map) {
    matsGraphUtils.setNoDataLabels(dataset);
  } else {
    matsGraphUtils.setNoDataLabelsMap(dataset);
  }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"template.text_output.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/graph/template.text_output.js                                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("textOutput");
Template["textOutput"] = new Template("Template.textOutput", (function() {
  var view = this;
  return HTML.DIV({
    id: "textOutput",
    class: "container"
  }, HTML.Raw('\n        <button id="text_export" type="button" class="export" style="display:none">Export</button>\n        <br>\n        '), Blaze.Each(function() {
    return Spacebars.call(view.lookup("curves"));
  }, function() {
    return [ "\n            ", HTML.H5(Blaze.View("lookup:curveText", function() {
      return Spacebars.mustache(view.lookup("curveText"));
    })), "\n        " ];
  }), "\n        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("notScatter"));
  }, function() {
    return [ "\n            ", HTML.TABLE({
      id: "textStatsTable",
      class: "table table-condensed table-striped table-bordered"
    }, "\n                ", HTML.THEAD("\n                ", HTML.TR("\n                    ", Blaze.View("lookup:statHeaders", function() {
      return Spacebars.makeRaw(Spacebars.mustache(view.lookup("statHeaders")));
    }), "\n                "), "\n                "), "\n                ", HTML.TBODY("\n                ", Blaze.Each(function() {
      return Spacebars.call(view.lookup("curves"));
    }, function() {
      return [ "\n                    ", HTML.TR("\n                        ", Blaze.View("lookup:stats", function() {
        return Spacebars.makeRaw(Spacebars.mustache(view.lookup("stats"), view.lookup(".")));
      }), "\n                    "), "\n                " ];
    }), "\n                "), "\n            "), "\n        " ];
  }), "\n        ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("curves"));
  }, function() {
    return [ "\n            ", HTML.TABLE({
      id: "textElementsTable",
      class: "table table-condensed table-bordered table-striped table-hover table-sm"
    }, "\n                ", HTML.THEAD({
      class: "thead-inverse"
    }, "\n                ", HTML.TR("\n                    ", Blaze.View("lookup:elementHeaders", function() {
      return Spacebars.makeRaw(Spacebars.mustache(view.lookup("elementHeaders"), view.lookup(".")));
    }), "\n                "), "\n                "), "\n                ", HTML.TBODY("\n                ", Blaze.Each(function() {
      return Spacebars.dataMustache(view.lookup("elements"), view.lookup("."));
    }, function() {
      return [ "\n                    ", HTML.TR("\n                        ", Blaze.View("lookup:elementHtml", function() {
        return Spacebars.makeRaw(Spacebars.mustache(view.lookup("elementHtml"), view.lookup(".")));
      }), "\n                    "), "\n                " ];
    }), "\n                "), "\n            "), "\n        " ];
  }), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"text_output.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/graph/text_output.js                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections, matsCurveUtils, matsPlotUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  },
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  },
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  },
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var moment;
module.link("meteor/momentjs:moment", {
  moment: function (v) {
    moment = v;
  }
}, 1);

/*
Referring to the Session variable plotResultKey here causes the html template to get re-rendered with the current graph data
(which is in the Results collection).
 */
var fillStr = "---";
var times = []; // I don't think this is used anymore, but I'm not certain, so I'm leaving it here for now.

var getDataForTime = function (data, time) {
  if (data === undefined) {
    return undefined;
  }

  for (var i = 0; i < data.length; i++) {
    if (data[i][0] == Number(time)) {
      return data[i] === null ? undefined : data[i];
    }
  }

  return undefined;
}; // fetches the data back from where the query routine stored it.


var getDataForCurve = function (curve) {
  if (Session.get("plotResultKey") == undefined || matsCurveUtils.getPlotResultData() === undefined) {
    return undefined;
  }

  if (matsCurveUtils.getPlotResultData() === null) {
    return [];
  }

  if (Session.get("plotType") === matsTypes.PlotTypes.scatter2d) {
    return matsCurveUtils.getPlotResultData()[curve.label];
  } else {
    return matsCurveUtils.getPlotResultData().data[curve.label];
  }
};

Template.textOutput.onRendered(function () {
  var settings = matsCollections.Settings.findOne({}, {
    fields: {
      NullFillString: 1
    }
  });

  if (settings === undefined) {
    fillStr = "---";
  } else {
    fillStr = settings.NullFillString;
  }
});
Template.textOutput.helpers({
  notScatter: function () {
    return Session.get("plotType") !== matsTypes.PlotTypes.scatter2d;
  },
  // get the table header for the summary stats at the top of the text page
  statHeaders: function () {
    var header = "";

    switch (Session.get('plotType')) {
      case matsTypes.PlotTypes.timeSeries:
      case matsTypes.PlotTypes.dailyModelCycle:
      case matsTypes.PlotTypes.profile:
        header += "<th>label</th>\
                    <th>mean</th>\
                    <th>standard deviation</th>\
                    <th>n</th>\
                    <th>standard error</th>\
                    <th>lag1</th>\
                    <th>minimum</th>\
                    <th>maximum</th>";
        break;

      case matsTypes.PlotTypes.dieoff:
      case matsTypes.PlotTypes.threshold:
      case matsTypes.PlotTypes.validtime:
        header += "<th>label</th>\
                    <th>mean</th>\
                    <th>standard deviation</th>\
                    <th>n</th>\
                    <th>minimum</th>\
                    <th>maximum</th>";
        break;

      case matsTypes.PlotTypes.reliability:
        header += "<th>label</th>\
                    <th>sample climatology</th>";
        break;

      case matsTypes.PlotTypes.map:
        header += "<th>label</th>\
                    <th>mean</th>\
                    <th>standard deviation</th>\
                    <th>n</th>\
                    <th>minimum time</th>\
                    <th>maximum time</th>";
        break;

      case matsTypes.PlotTypes.histogram:
        header += "<th>label</th>\
                    <th>mean</th>\
                    <th>standard deviation</th>\
                    <th>n</th>\
                    <th>minimum</th>\
                    <th>maximum</th>";
        break;

      case matsTypes.PlotTypes.contour:
      case matsTypes.PlotTypes.contourDiff:
        header += "<th>label</th>\
                    <th>mean stat</th>\
                    <th>n</th>\
                    <th>minimum time</th>\
                    <th>maximum time</th>";
        break;

      case matsTypes.PlotTypes.scatter2d:
        // no stat for scatter
        break;

      default:
        break;
    }

    return header;
  },
  // get the table header for each curve's data
  elementHeaders: function (curve) {
    var header = "";

    switch (Session.get('plotType')) {
      case matsTypes.PlotTypes.timeSeries:
        header += "<th>" + curve.label + " time</th>\
                        <th>raw stat from query</th>\
                        <th>plotted stat</th>\
                        <th>std dev</th>\
                        <th>std error</th>\
                        <th>lag1</th>\
                        <th>n</th>";
        break;

      case matsTypes.PlotTypes.dailyModelCycle:
        header += "<th>" + curve.label + " time</th>\
                        <th>raw stat from query</th>\
                        <th>plotted stat</th>\
                        <th>std dev</th>\
                        <th>n</th>";
        break;

      case matsTypes.PlotTypes.profile:
        header += "<th>" + curve.label + " level</th>\
                        <th>raw stat from query</th>\
                        <th>plotted stat</th>\
                        <th>std dev</th>\
                        <th>std error</th>\
                        <th>lag1</th>\
                        <th>n</th>";
        break;

      case matsTypes.PlotTypes.dieoff:
        header += "<th>" + curve.label + " forecast lead time</th>\
                        <th>raw stat from query</th>\
                        <th>plotted stat</th>\
                        <th>std dev</th>\
                        <th>n</th>";
        break;

      case matsTypes.PlotTypes.threshold:
        header += "<th>" + curve.label + " threshold (in)</th>\
                        <th>raw stat from query</th>\
                        <th>plotted stat</th>\
                        <th>std dev</th>\
                        <th>n</th>";
        break;

      case matsTypes.PlotTypes.validtime:
        header += "<th>" + curve.label + " hour of day</th>\
                        <th>raw stat from query</th>\
                        <th>plotted stat</th>\
                        <th>std dev</th>\
                        <th>n</th>";
        break;

      case matsTypes.PlotTypes.reliability:
        header += "<th>" + curve.label + " probability bin</th>\
                        <th>hit rate</th>\
                        <th>oy</th>\
                        <th>on</th>";
        break;

      case matsTypes.PlotTypes.map:
        header += "<th>Site Name</th>\
                        <th>Number of Times</th>\
                        <th>Start Date</th>\
                        <th>End Date</th>\
                        <th>Average Difference</th>";
        break;

      case matsTypes.PlotTypes.histogram:
        header += "<th>" + curve.label + "  bin range</th>\
                        <th>bin n</th>\
                        <th>bin rel freq</th>\
                        <th>bin lower bound</th>\
                        <th>bin upper bound</th>\
                        <th>bin mean</th>\
                        <th>bin std dev</th>";
        break;

      case matsTypes.PlotTypes.contour:
      case matsTypes.PlotTypes.contourDiff:
        header += "<th>X Value</th>\
                        <th>Y Value</th>\
                        <th>Stat</th>\
                        <th>Number</th>\
                        <th>Start Date</th>\
                        <th>End Date</th>";
        break;

      case matsTypes.PlotTypes.scatter2d:
        header += "<th>" + curve.label + " x axis</th>\
                        <th>" + curve.label + " y axis</th>\
                        <th>best fit</th>";
        break;

      default:
        break;
    }

    return header;
  },
  elements: function (curve) {
    Session.get('textLoaded'); // monitor for data changres like previous / next

    return getDataForCurve(curve);
  },
  curves: function () {
    Session.get('textLoaded');
    Session.get("plotResultKey"); // make sure we re-render when data changes

    return Session.get('Curves');
  },
  curveLabel: function (curve) {
    switch (Session.get('plotType')) {
      case matsTypes.PlotTypes.timeSeries:
        return curve.label + " time";
        break;

      case matsTypes.PlotTypes.profile:
        return curve.label + " level";
        break;

      case matsTypes.PlotTypes.dieoff:
        return curve.label + " forecast lead time";

      default:
        return curve.label;
        break;
    }
  },
  curveText: function () {
    var text = matsPlotUtils.getCurveText(matsPlotUtils.getPlotType(), this);
    return text;
  },
  // get the table row values for each curve's data
  elementHtml: function (element) {
    var labelKey = Template.parentData().label;
    var elementLabel = "";
    var line = "";

    switch (Session.get('plotType')) {
      case matsTypes.PlotTypes.timeSeries:
        line += "<td>" + element[labelKey += " time"] + "</td>" + "<td>" + (element['raw stat from query'] != undefined && element['raw stat from query'] !== null ? element['raw stat from query'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['plotted stat'] != undefined && element['plotted stat'] !== null ? element['plotted stat'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['std dev'] != undefined && element['std dev'] !== null ? element['std dev'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['std error'] != undefined && element['std error'] !== null ? element['std error'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['lag1'] != undefined && element['lag1'] !== null ? element['lag1'].toPrecision(4) : fillStr) + "</td>" + "<td>" + ('n' in element && element['n'] ? element['n'] : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.profile:
        line += "<td>" + element[labelKey += " level"] + "</td>" + "<td>" + (element['raw stat from query'] != undefined && element['raw stat from query'] !== null ? element['raw stat from query'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['plotted stat'] != undefined && element['plotted stat'] !== null ? element['plotted stat'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['std dev'] != undefined && element['std dev'] !== null ? element['std dev'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['std error'] != undefined && element['std error'] !== null ? element['std error'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['lag1'] != undefined && element['lag1'] !== null ? element['lag1'].toPrecision(4) : fillStr) + "</td>" + "<td>" + ('n' in element ? element['n'] : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.dieoff:
        line += "<td>" + element[labelKey += " forecast lead time"] + "</td>" + "<td>" + (element['raw stat from query'] != undefined && element['raw stat from query'] !== null ? element['raw stat from query'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['plotted stat'] != undefined && element['plotted stat'] !== null ? element['plotted stat'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['std dev'] != undefined && element['std dev'] !== null ? element['std dev'].toPrecision(4) : fillStr) + "</td>" + "<td>" + ('n' in element ? element['n'] : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.threshold:
        line += "<td>" + element[labelKey += " threshold (in)"] + "</td>" + "<td>" + (element['raw stat from query'] != undefined && element['raw stat from query'] !== null ? element['raw stat from query'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['plotted stat'] != undefined && element['plotted stat'] !== null ? element['plotted stat'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['std dev'] != undefined && element['std dev'] !== null ? element['std dev'].toPrecision(4) : fillStr) + "</td>" + "<td>" + ('n' in element ? element['n'] : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.validtime:
        line += "<td>" + element[labelKey += " hour of day"] + "</td>" + "<td>" + (element['raw stat from query'] != undefined && element['raw stat from query'] !== null ? element['raw stat from query'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['plotted stat'] != undefined && element['plotted stat'] !== null ? element['plotted stat'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['std dev'] != undefined && element['std dev'] !== null ? element['std dev'].toPrecision(4) : fillStr) + "</td>" + "<td>" + ('n' in element ? element['n'] : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.dailyModelCycle:
        line += "<td>" + element[labelKey += " time"] + "</td>" + "<td>" + (element['raw stat from query'] != undefined && element['raw stat from query'] !== null ? element['raw stat from query'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['plotted stat'] != undefined && element['plotted stat'] !== null ? element['plotted stat'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['std dev'] != undefined && element['std dev'] !== null ? element['std dev'].toPrecision(4) : fillStr) + "</td>" + "<td>" + ('n' in element ? element['n'] : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.reliability:
        line += "<td>" + element[labelKey += " probability bin"] + "</td>" + "<td>" + (element['hit rate'] != undefined && element['hit rate'] !== null ? element['hit rate'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['oy'] != undefined && element['oy'] !== null ? element['oy'] : fillStr) + "</td>" + "<td>" + (element['on'] != undefined && element['on'] !== null ? element['on'] : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.map:
        line += "<td>" + element["Site Name"] + "</td>" + "<td>" + (element['Number of Times'] != undefined && element['Number of Times'] !== null ? element['Number of Times'] : fillStr) + "</td>" + "<td>" + (element['Start Date'] != undefined && element['Start Date'] !== null ? element['Start Date'] : fillStr) + "</td>" + "<td>" + (element['End Date'] != undefined && element['End Date'] !== null ? element['End Date'] : fillStr) + "</td>" + "<td>" + (element['Average Difference'] != undefined && element['Average Difference'] !== null ? element['Average Difference'] : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.histogram:
        line += "<td>" + element[labelKey += " bin range"] + "</td>" + "<td>" + ('n' in element ? element['n'] : fillStr) + "</td>" + "<td>" + (element['bin rel freq'] != undefined && element['bin rel freq'] !== null ? element['bin rel freq'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['bin lower bound'] != undefined && element['bin lower bound'] !== null ? element['bin lower bound'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['bin upper bound'] != undefined && element['bin upper bound'] !== null ? element['bin upper bound'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['bin mean'] != undefined && element['bin mean'] !== null ? element['bin mean'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['bin std dev'] != undefined && element['bin std dev'] !== null ? element['bin std dev'].toPrecision(4) : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.contour:
      case matsTypes.PlotTypes.contourDiff:
        line += "<td>" + element["xVal"] + "</td>" + "<td>" + element["yVal"] + "</td>" + "<td>" + (element['stat'] != undefined && element['stat'] !== null ? element['stat'] : fillStr) + "</td>" + "<td>" + (element['N'] != undefined && element['N'] !== null ? element['N'] : fillStr) + "</td>" + "<td>" + (element['Start Date'] != undefined && element['Start Date'] !== null ? element['Start Date'] : fillStr) + "</td>" + "<td>" + (element['End Date'] != undefined && element['End Date'] !== null ? element['End Date'] : fillStr) + "</td>";
        break;

      case matsTypes.PlotTypes.scatter2d:
        line += "<td>" + (element['xAxis'] != undefined && element['xAxis'] !== null ? element['xAxis'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['yAxis'] != undefined && element['yAxis'] !== null ? element['yAxis'].toPrecision(4) : fillStr) + "</td>" + "<td>" + (element['best fit'] != undefined && element['best fit'] !== null ? element['best fit'] : fillStr) + "</td>";
        break;

      default:
        break;
    }

    return line;
  },
  // get the table row values for the summary stats at the top of the text page
  stats: function (curve) {
    if (Session.get("plotResultKey") === undefined) {
      return [];
    }

    var curves = Session.get('Curves');

    if (curves === undefined || curves.length == 0) {
      return [];
    }

    var cindex;

    for (cindex = 0; cindex < curves.length; cindex++) {
      if (curves[cindex].label == curve.label) {
        break;
      }
    }

    if (matsCurveUtils.getPlotResultData() === null || matsCurveUtils.getPlotResultData() === undefined || matsCurveUtils.getPlotResultData().stats === undefined || matsCurveUtils.getPlotResultData().stats[curves[cindex].label] === undefined) {
      return "";
    }

    var stats = matsCurveUtils.getPlotResultData().stats[curves[cindex].label];
    var line = "";

    switch (Session.get('plotType')) {
      case matsTypes.PlotTypes.timeSeries:
      case matsTypes.PlotTypes.profile:
      case matsTypes.PlotTypes.dailyModelCycle:
        line += "<td>" + curve['label'] + "</td>" + "<td>" + (stats['mean'] != undefined && stats['mean'] !== null ? stats['mean'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['standard deviation'] != undefined && stats['standard deviation'] !== null ? stats['standard deviation'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + stats['n'].toString() + "</td>" + "<td>" + (stats['standard error'] != undefined && stats['standard error'] != null ? stats['standard error'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['lag1'] != undefined && stats['lag1'] != null ? stats['lag1'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['minimum'] != undefined && stats['minimum'] != null ? stats['minimum'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['maximum'] != undefined && stats['maximum'] != null ? stats['maximum'].toPrecision(4) : "undefined").toString() + "</td>";
        break;

      case matsTypes.PlotTypes.dieoff:
      case matsTypes.PlotTypes.threshold:
      case matsTypes.PlotTypes.validtime:
        line += "<td>" + curve['label'] + "</td>" + "<td>" + (stats['mean'] != undefined && stats['mean'] !== null ? stats['mean'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['standard deviation'] != undefined && stats['standard deviation'] !== null ? stats['standard deviation'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + stats['n'].toString() + "</td>" + "<td>" + (stats['minimum'] != undefined && stats['minimum'] != null ? stats['minimum'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['maximum'] != undefined && stats['maximum'] != null ? stats['maximum'].toPrecision(4) : "undefined").toString() + "</td>";
        break;

      case matsTypes.PlotTypes.reliability:
        line += "<td>" + curve['label'] + "</td>" + "<td>" + (stats['sample climo'] != undefined && stats['sample climo'] !== null ? stats['sample climo'].toPrecision(4) : "undefined").toString() + "</td>";
        break;

      case matsTypes.PlotTypes.map:
        line += "<td>" + curve['label'] + "</td>" + "<td>" + (stats['mean difference'] != undefined && stats['mean difference'] !== null ? stats['mean difference'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['standard deviation'] != undefined && stats['standard deviation'] !== null ? stats['standard deviation'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['total number of obs'] != undefined && stats['total number of obs'] !== null ? stats['total number of obs'] : "undefined").toString() + "</td>" + "<td>" + (stats['minimum time'] != undefined && stats['minimum time'] != null ? stats['minimum time'] : "undefined").toString() + "</td>" + "<td>" + (stats['maximum time'] != undefined && stats['maximum time'] != null ? stats['maximum time'] : "undefined").toString() + "</td>";
        break;

      case matsTypes.PlotTypes.histogram:
        line += "<td>" + curve['label'] + "</td>" + "<td>" + (stats['mean'] != undefined && stats['mean'] !== null ? stats['mean'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['standard deviation'] != undefined && stats['standard deviation'] != null ? stats['standard deviation'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + stats['n'].toString() + "</td>" + "<td>" + (stats['minimum'] != undefined && stats['minimum'] != null ? stats['minimum'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['maximum'] != undefined && stats['maximum'] != null ? stats['maximum'].toPrecision(4) : "undefined").toString() + "</td>";
        break;

      case matsTypes.PlotTypes.contour:
      case matsTypes.PlotTypes.contourDiff:
        line += "<td>" + curve['label'] + "</td>" + "<td>" + (stats['mean stat'] != undefined && stats['mean stat'] !== null ? stats['mean stat'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['total number of points'] != undefined && stats['total number of points'] !== null ? stats['total number of points'] : "undefined").toString() + "</td>" + "<td>" + (stats['minimum time'] != undefined && stats['minimum time'] != null ? stats['minimum time'] : "undefined").toString() + "</td>" + "<td>" + (stats['maximum time'] != undefined && stats['maximum time'] != null ? stats['maximum time'] : "undefined").toString() + "</td>";
        break;

      case matsTypes.PlotTypes.scatter2d:
        line += "<td>" + curve['label'] + "</td>" + "<td>" + (stats['mean'] != undefined && stats['mean'] !== null ? stats['mean'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['standard deviation'] != undefined && stats['standard deviation'] !== null ? stats['standard deviation'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + stats['n'].toString() + "</td>" + "<td>" + (stats['standard error'] != undefined && stats['standard error'] != null ? stats['standard error'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['lag1'] != undefined && stats['lag1'] != null ? stats['lag1'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['minimum'] != undefined && stats['minimum'] != null ? stats['minimum'].toPrecision(4) : "undefined").toString() + "</td>" + "<td>" + (stats['maximum'] != undefined && stats['maximum'] != null ? stats['maximum'].toPrecision(4) : "undefined").toString() + "</td>";
        break;

      default:
        break;
    }

    return line;
  }
});
Template.textOutput.events({
  'click .export': function () {
    var plotType = Session.get('plotType');
    var key = Session.get('plotResultKey'); // open a new window with

    window.open(window.location + "/CSV/" + Session.get("graphFunction") + "/" + Session.get("plotResultKey") + "/" + Session.get('plotParameter') + "/" + matsCollections.Settings.findOne({}, {
      fields: {
        Title: 1
      }
    }).Title);
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"graphStandAlone":{"graphStandAlone.html":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/templates/graphStandAlone/graphStandAlone.html                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.link("./template.graphStandAlone.js", { "*": "*+" });

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.graphStandAlone.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/graphStandAlone/template.graphStandAlone.js                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("GraphStandAlone");
Template["GraphStandAlone"] = new Template("Template.GraphStandAlone", (function() {
  var view = this;
  return [ HTML.HEAD("\n        ", HTML.SCRIPT({
    src: "https://cdn.plot.ly/plotly-latest.min.js"
  }), "\n    "), "\n    ", HTML.DIV({
    id: "graph-container",
    class: "container-fluid pull-left",
    style: function() {
      return [ "padding-left: 5%; display:", Spacebars.mustache(view.lookup("graphFunctionDispay")), ";" ];
    }
  }, "\n        ", HTML.DIV({
    id: "header",
    class: "row"
  }, "\n            ", HTML.H4(HTML.SPAN(Blaze.View("lookup:Title", function() {
    return Spacebars.mustache(view.lookup("Title"));
  }), " : "), HTML.SPAN(Blaze.View("lookup:plotText", function() {
    return Spacebars.mustache(view.lookup("plotText"));
  })), HTML.SPAN(" ", Blaze.View("lookup:plotName", function() {
    return Spacebars.mustache(view.lookup("plotName"));
  }))), "\n        "), "\n        ", HTML.Raw('<div id="gsaSpinner" name="gsaSpinner" style="display:block">\n            <img src="../../../../img/spinner.gif" alt="Loading..." height="5%" width="5%"> <span style="color:red">Loading ...</span>\n        </div>'), "\n        ", HTML.DIV({
    class: "row form-inline previewCurveButtons"
  }, "\n            ", HTML.SPAN("\n                ", HTML.INPUT({
    class: "input-sm col-sm-5",
    id: "exportFileName",
    value: function() {
      return Spacebars.mustache(view.lookup("matsplotFilemname"));
    }
  }), "\n                ", HTML.Raw('<button class="btn btn-xs col-sm-3 pull-right btn-primary exportpdf" id="exportpdf">save pdf</button>'), "\n                ", HTML.Raw('<button class="btn btn-xs col-sm-3 pull-right btn-primary exportpng" id="exportpng">save png</button>'), "\n            "), "\n        "), "\n        ", HTML.DIV({
    id: "curves",
    class: "row"
  }, "\n            ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("curves"));
  }, function() {
    return [ "\n                ", HTML.SPAN({
      style: function() {
        return [ "color:", Spacebars.mustache(view.lookup("color")), "; font-weight: bolder;" ];
      }
    }, "--- "), HTML.SPAN({
      style: "font-size:small;"
    }, Blaze.View("lookup:curveText", function() {
      return Spacebars.mustache(view.lookup("curveText"));
    })), "\n                ", HTML.DIV({
      id: function() {
        return [ "curve-text-buttons-grp-", Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")) ];
      },
      class: "btn-group btn-group-xs previewCurveButtons"
    }, "\n                    ", HTML.INPUT({
      type: "button",
      class: "annotateVisibility btn btn-primary",
      value: function() {
        return Spacebars.mustache(view.lookup("annotateButtonText"));
      },
      id: function() {
        return [ Spacebars.mustache(Spacebars.dot(view.lookup("."), "label")), "-curve-show-hide-annotate" ];
      },
      style: function() {
        return [ "border-radius: 5px; display:", Spacebars.mustache(view.lookup("annotateShowHideDisplay")), "; background-color: #FFFFFF; border-color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")), "; color: ", Spacebars.mustache(Spacebars.dot(view.lookup("."), "color")) ];
      }
    }), "\n                "), "\n                ", HTML.BR(), "\n            " ];
  }), "\n            ", HTML.Raw("<hr>"), "\n        "), "\n        ", HTML.DIV({
    id: "graphView",
    style: "height:100%;margin:0;padding:0;",
    class: "row"
  }, "\n            ", HTML.Raw('<div id="legendContainer" name="legendContainer"></div>'), "\n            ", HTML.DIV({
    id: "placeholder",
    class: "row",
    name: "placeholder",
    style: function() {
      return [ "float:left;width:", Spacebars.mustache(view.lookup("width")), "; height:", Spacebars.mustache(view.lookup("height")), ";" ];
    }
  }, "\n                \n            "), "\n            ", HTML.SPAN({
    style: "display: none"
  }, Blaze.View("lookup:graphFunction", function() {
    return Spacebars.mustache(view.lookup("graphFunction"));
  })), "\n        "), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"graphStandAlone.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/graphStandAlone/graphStandAlone.js                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var jsPDF;
module.link("jspdf", {
  "default": function (v) {
    jsPDF = v;
  }
}, 1);
var html2canvas;
module.link("html2canvas", {
  "default": function (v) {
    html2canvas = v;
  }
}, 2);
var matsCollections, matsCurveUtils, matsGraphUtils, matsMethods, matsParamUtils, matsPlotUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  },
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  },
  matsGraphUtils: function (v) {
    matsGraphUtils = v;
  },
  matsMethods: function (v) {
    matsMethods = v;
  },
  matsParamUtils: function (v) {
    matsParamUtils = v;
  },
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  },
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 3);
var Template;
module.link("meteor/templating", {
  Template: function (v) {
    Template = v;
  }
}, 4);
var FlowRouter;
module.link("meteor/ostrio:flow-router-extra", {
  FlowRouter: function (v) {
    FlowRouter = v;
  }
}, 5);
module.link("./graphStandAlone.html");
var annotation = "";
var resizeOptions;
Template.GraphStandAlone.onCreated(function () {
  // get the params for what this window will contain from the route
  console.log("GraphStandAlone.onCreated");
  Session.set('route', FlowRouter.getRouteName());
  Session.set("graphFunction", FlowRouter.getParam('graphFunction'));
  Session.set("plotResultKey", FlowRouter.getParam('key'));
  Session.set("plotParameter", FlowRouter.getParam('matching'));
  Session.set("appName", FlowRouter.getParam('appName'));
});
Template.GraphStandAlone.onRendered(function () {
  // the window resize event needs to also resize the graph
  $(window).resize(function () {
    document.getElementById('placeholder').style.width = matsGraphUtils.standAloneWidth();
    document.getElementById('placeholder').style.height = matsGraphUtils.standAloneHeight();
    var dataset = matsCurveUtils.getGraphResult().data;
    Plotly.newPlot($("#placeholder")[0], dataset, resizeOptions, {
      showLink: true
    });
  });
  document.getElementById('graph-container').style.backgroundColor = 'white';
});
Template.GraphStandAlone.helpers({
  /**
   * @return {string}
   * @return {string}
   */
  graphFunction: function (params) {
    // causes graph display routine to be processed
    var graphFunction = FlowRouter.getParam('graphFunction');
    var key = FlowRouter.getParam('key');
    matsMethods.getGraphDataByKey.call({
      resultKey: key
    }, function (error, ret) {
      if (error !== undefined) {
        setError(error);
        matsCurveUtils.resetGraphResult();
        return false;
      }

      matsCurveUtils.setGraphResult(ret.result);
      Session.set("plotResultKey", ret.key);
      Session.set('Curves', ret.result.basis.plotParams.curves);
      Session.set('graphFunction', graphFunction);
      Session.set('PlotResultsUpDated', new Date());
      Session.set('PlotParams', ret.result.basis.plotParams);
      var ptypes = Object.keys(ret.result.basis.plotParams.plotTypes);

      for (var i = 0; i < ptypes.length; i++) {
        if (ret.result.basis.plotParams.plotTypes[ptypes[i]] === true) {
          Session.set('plotType', ptypes[i]);
          break;
        }
      }

      delete ret;

      if (graphFunction) {
        module.runSetters(eval(graphFunction))(key);
        var plotType = Session.get('plotType');
        var dataset = matsCurveUtils.getGraphResult().data;
        var options = matsCurveUtils.getGraphResult().options;

        if (dataset === undefined) {
          return false;
        } // make sure to capture the options (layout) from the old graph - which were stored in graph.js


        matsMethods.getLayout.call({
          resultKey: key
        }, function (error, ret) {
          if (error !== undefined) {
            setError(error);
            return false;
          }

          var mapLoadPause = 0;
          options = ret.layout;

          if (plotType === matsTypes.PlotTypes.map) {
            options.mapbox.zoom = 2.75;
            mapLoadPause = 1000;
          }

          resizeOptions = options; // initial plot

          $("#legendContainer").empty();
          $("#placeholder").empty(); // need a slight delay for plotly to load

          setTimeout(function () {
            Plotly.newPlot($("#placeholder")[0], dataset, options, {
              showLink: false
            }); // update changes to the curve ops -- need to pause if we're doing a map so the map can finish loading before we try to edit it

            setTimeout(function () {
              var updates = ret.curveOpsUpdate.curveOpsUpdate;

              for (var uidx = 0; uidx < updates.length; uidx++) {
                var curveOpsUpdate = {};
                var updatedKeys = Object.keys(updates[uidx]);

                for (var kidx = 0; kidx < updatedKeys.length; kidx++) {
                  var jsonHappyKey = updatedKeys[kidx]; // turn the json placeholder back into .

                  var updatedKey = jsonHappyKey.split("____").join(".");
                  curveOpsUpdate[updatedKey] = updates[uidx][jsonHappyKey];
                }

                Plotly.restyle($("#placeholder")[0], curveOpsUpdate, uidx);
              }
            }, mapLoadPause);
          }, 100); // append annotations

          if (plotType !== matsTypes.PlotTypes.map) {
            annotation = "";

            for (var i = 0; i < dataset.length; i++) {
              if (plotType !== matsTypes.PlotTypes.histogram && dataset[i].curveId !== undefined) {
                annotation = annotation + "<div id='" + dataset[i].curveId + "-annotation' style='color:" + dataset[i].annotateColor + "'>" + dataset[i].annotation + " </div>";
              }
            }

            $("#legendContainer").append("<div id='annotationContainer' style='font-size:smaller'>" + annotation + "</div>");
          }

          document.getElementById("gsaSpinner").style.display = "none";
        });
      }
    });
  },
  graphFunctionDispay: function () {
    return "block";
  },
  Title: function () {
    return Session.get('appName');
  },
  width: function () {
    return matsGraphUtils.standAloneWidth();
  },
  height: function () {
    return matsGraphUtils.standAloneHeight();
  },
  curves: function () {
    return Session.get('Curves');
  },
  plotName: function () {
    return Session.get('PlotParams') === [] || Session.get('PlotParams').plotAction === undefined || Session.get('plotType') === matsTypes.PlotTypes.map ? "" : Session.get('PlotParams').plotAction.toUpperCase();
  },
  curveText: function () {
    if (this.diffFrom === undefined) {
      var plotType = Session.get('plotType');

      if (plotType === undefined) {
        pfuncs = matsCollections.PlotGraphFunctions.find({}).fetch();

        for (var i = 0; i < pfuncs.length; i++) {
          if (pfuncs[i].checked === true) {
            Session.set('plotType', pfuncs[i].plotType);
          }
        }

        plotType = Session.get('plotType');
      }

      return matsPlotUtils.getCurveText(plotType, this);
    } else {
      return this.label + ":  Difference";
    }
  },
  plotText: function () {
    var p = Session.get('PlotParams');

    if (p !== undefined) {
      var format = p.plotFormat;

      if (matsCollections.PlotParams.findOne({
        name: 'plotFormat'
      }) && matsCollections.PlotParams.findOne({
        name: 'plotFormat'
      }).optionsMap && matsCollections.PlotParams.findOne({
        name: 'plotFormat'
      }).optionsMap[p.plotFormat] !== undefined) {
        format = matsCollections.PlotParams.findOne({
          name: 'plotFormat'
        }).optionsMap[p.plotFormat];
      }

      if (format === undefined) {
        format = "Unmatched";
      }

      var plotType = Session.get('plotType');

      switch (plotType) {
        case matsTypes.PlotTypes.timeSeries:
          return "TimeSeries " + p.dates + " : " + format;

        case matsTypes.PlotTypes.profile:
          return "Profile: " + format;

        case matsTypes.PlotTypes.dieoff:
          return "DieOff: " + format;

        case matsTypes.PlotTypes.threshold:
          return "Threshold: " + format;

        case matsTypes.PlotTypes.validtime:
          return "ValidTime: " + format;

        case matsTypes.PlotTypes.dailyModelCycle:
          return "DailyModelCycle " + p.dates + " : " + format;

        case matsTypes.PlotTypes.reliability:
          return "Reliability: " + p.dates + " : " + format;

        case matsTypes.PlotTypes.map:
          return "Map " + p.dates + " ";

        case matsTypes.PlotTypes.histogram:
          return "Histogram: " + format;

        case matsTypes.PlotTypes.contour:
          return "Contour " + p.dates + " : " + format;

        case matsTypes.PlotTypes.contourDiff:
          return "ContourDiff " + p.dates + " : " + format;

        case matsTypes.PlotTypes.scatter2d:
          break;

        default:
          return "Scatter: " + p.dates + " : " + format;
      }
    } else {
      return "no plot params";
    }
  },
  color: function () {
    return this.color;
  },
  annotateButtonText: function () {
    var sval = this.label + "annotateButtonText";

    if (Session.get(sval) === undefined) {
      Session.set(sval, 'hide annotation');
    }

    return Session.get(sval);
  },
  annotateShowHideDisplay: function () {
    var plotType = Session.get('plotType');

    if (plotType === matsTypes.PlotTypes.map || plotType === matsTypes.PlotTypes.histogram) {
      return 'none';
    } else {
      return 'block';
    }
  },
  matsplotFilemname: function () {
    return "matsplot-" + moment(new Date()).format("DD-MM-YYYY-hh:mm:ss");
  },
  image: function () {
    var img = Session.get("spinner_img");

    if (img == undefined) {
      img = "spinner.gif";
      Session.set("spinner_img", "../../../../../image/spinner.gif");
    }

    return img;
  }
});
Template.GraphStandAlone.events({
  'click .annotateVisibility': function (event) {
    event.preventDefault();
    var id = event.target.id;
    var label = id.replace('-curve-show-hide-annotate', '');

    if ($('#' + label + "-annotation")[0].hidden) {
      $('#' + label + "-annotation")[0].style.display = "block";
      $('#' + label + "-curve-show-hide-annotate")[0].value = "hide annotation";
      $('#' + label + "-annotation")[0].hidden = false;
    } else {
      $('#' + label + "-annotation")[0].style.display = "none";
      $('#' + label + "-curve-show-hide-annotate")[0].value = "show annotation";
      $('#' + label + "-annotation")[0].hidden = true;
    }

    annotation = $('#annotationContainer')[0].innerHTML;
  },
  'click .exportpdf': function (e) {
    $(".previewCurveButtons").each(function (i, obj) {
      obj.style.display = "none";
    }); //const filename  = 'MATSPlot' + moment(new Date()).format("DD-MM-YYYY-hh:mm:ss") + '.pdf';

    html2canvas(document.querySelector('#graph-container'), {
      scale: 3.0
    }).then(function (canvas) {
      var h = 419.53;
      var w = 595.28;
      var filename = document.getElementById("exportFileName").value;
      var pdf = new jsPDF('letter', 'pt', 'a5');
      pdf.addImage(canvas.toDataURL('image/jpeg'), 'JPEG', 0, 0, w, h);
      pdf.save(filename);
      $(".previewCurveButtons").each(function (i, obj) {
        obj.style.display = "block";
      });
    });
  },
  'click .exportpng': function (e) {
    $(".previewCurveButtons").each(function (i, obj) {
      obj.style.display = "none";
    });
    html2canvas(document.querySelector('#graph-container'), {
      scale: 3.0
    }).then(function (canvas) {
      var h = 419.53;
      var w = 595.28;
      var filename = document.getElementById("exportFileName").value;
      saveAs(canvas.toDataURL(), filename + '.png');
      $(".previewCurveButtons").each(function (i, obj) {
        obj.style.display = "block";
      });
    });

    function saveAs(uri, filename) {
      var link = document.createElement('a');

      if (typeof link.download === 'string') {
        link.href = uri;
        link.download = filename; //Firefox requires the link to be in the body

        document.body.appendChild(link); //simulate click

        link.click(); //remove the link when done

        document.body.removeChild(link);
      } else {
        window.open(uri);
      }
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"common":{"template.text_input.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/template.text_input.js                                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("textInput");
Template["textInput"] = new Template("Template.textInput", (function() {
  var view = this;
  return HTML.INPUT({
    id: function() {
      return [ Spacebars.mustache(view.lookup("name")), "-", Spacebars.mustache(view.lookup("type")) ];
    },
    class: "data-input textInput",
    type: "text",
    name: function() {
      return Spacebars.mustache(view.lookup("name"));
    },
    value: function() {
      return Spacebars.mustache(view.lookup("defaultTextInput"));
    }
  });
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"text_input.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/text_input.js                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 0);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 1);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 2);
Template.textInput.helpers({
  defaultTextInput: function () {
    if (this.name == 'label') {
      // labels are handled specially
      var label;
      var input = document.getElementById('label-textInput');
      var value = document.getElementById('controlButton-label-value');

      if (input && value) {
        if (label !== input.value || label != value.textContent) {
          if (!Session.get('NextCurveLabel')) {
            label = matsCurveUtils.getNextCurveLabel();
          } else {
            label = Session.get('NextCurveLabel');
          }

          input.value = label;
          value.textContent = label;
          return label;
        }
      } else {
        // must be initialization
        label = matsCurveUtils.getNextCurveLabel();
        return label;
      }
    } else {
      return this.default;
    }
  }
});
Template.textInput.events({
  'click, blur': function (event) {
    try {
      // label is handled differently - special case because of NextCurveLabel stored in Session
      var text = event.currentTarget.value;

      if (event.target.name == "label" && Session.get('NextCurveLabel') == text) {} else {
        matsParamUtils.setValueTextForParamName(event.target.name, text);
      }
    } catch (error) {
      matsParamUtils.setValueTextForParamName(event.target.name, "");
    }
  },
  'change': function (event) {
    try {
      // label is handled differently - special case because of NextCurveLabel stored in Session
      var text = event.currentTarget.value;

      if (Object.values(matsTypes.ReservedWords).indexOf(text) === -1) {
        matsParamUtils.setValueTextForParamName(event.target.name, text);
        Session.set("NextCurveLabel", text);
      } else {
        console.log("that curve label is not allowed");
        setTimeout(function () {
          matsParamUtils.setValueTextForParamName(event.target.name, "LabelNotAllowed");
        }, 10);
      }
    } catch (error) {
      matsParamUtils.setValueTextForParamName(event.target.name, "");
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.select.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/template.select.js                                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("select");
Template["select"] = new Template("Template.select", (function() {
  var view = this;
  return [ HTML.DIV("\n        ", HTML.DIV({
    class: "btn-group btn-group-xs table-bordered",
    style: "border: solid;border-width: thick;border-color: white;"
  }, "\n            ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isMultiple"));
  }, function() {
    return [ "\n                ", HTML.BUTTON({
      type: "button",
      class: "btn btn-info btn-xs selectAll",
      id: function() {
        return [ Spacebars.mustache(view.lookup("name")), "-", Spacebars.mustache(view.lookup("type")), "-all" ];
      }
    }, " select all "), "\n                ", HTML.BUTTON({
      type: "button",
      class: "btn btn-warning btn-xs clearSelections",
      id: function() {
        return [ Spacebars.mustache(view.lookup("name")), "-", Spacebars.mustache(view.lookup("type")), "-clear" ];
      }
    }, " clear selections"), "\n                ", HTML.BUTTON({
      type: "button",
      class: "btn btn-success btn-xs doneSelecting",
      id: function() {
        return [ Spacebars.mustache(view.lookup("name")), "-", Spacebars.mustache(view.lookup("type")), "-done" ];
      }
    }, " done selecting"), "\n            " ];
  }), "\n            ", Blaze.If(function() {
    return Spacebars.call(view.lookup("selectionIsOptional"));
  }, function() {
    return [ "\n                ", HTML.BUTTON({
      type: "button",
      class: "btn btn-warning btn-xs doNotUse",
      id: function() {
        return [ Spacebars.mustache(view.lookup("name")), "-", Spacebars.mustache(view.lookup("type")), "-unused" ];
      }
    }, " do not use"), "\n            " ];
  }), "\n        "), "\n    "), "\n    ", HTML.DIV("\n        ", HTML.SELECT(HTML.Attrs({
    style: function() {
      return [ "width:", Spacebars.mustache(view.lookup("optionMaxLength")), "em;" ];
    },
    class: function() {
      return [ "data-input ", Spacebars.mustache(view.lookup("name")) ];
    },
    size: "10",
    name: function() {
      return Spacebars.mustache(view.lookup("name"));
    },
    id: function() {
      return [ Spacebars.mustache(view.lookup("name")), "-", Spacebars.mustache(view.lookup("type")) ];
    }
  }, function() {
    return Spacebars.attrMustache(view.lookup("multiple"));
  }), "\n            ", HTML.Raw('<option initial="">initial</option>'), "\n        "), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"select.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/select.js                                                              //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 2);
var matsSelectUtils;
module.link("meteor/randyp:mats-common", {
  matsSelectUtils: function (v) {
    matsSelectUtils = v;
  }
}, 3);

/*
    Much of the work for select widgets happens in mats-common->imports->client->select_util.js. Especially the refresh
    routine which sets all the options. Don't forget to look there for much of the handling.
 */
Template.select.onRendered(function () {
  var ref = this.data.name + '-' + this.data.type;
  $("#" + ref).select2({
    minimumResultsForSearch: 20,
    closeOnSelect: false
  });
  var elem = document.getElementById(ref);

  try {
    // register refresh event for axis change to use to enforce a refresh
    elem && elem.addEventListener('axisRefresh', function (event) {
      // Don't know why I have to do this, I expected the parameter data to be in the context....
      var paramData = matsCollections.CurveParams.findOne({
        name: this.name
      }, {
        dependentNames: 1,
        peerName: 1
      });
      matsSelectUtils.refreshPeer(event, paramData);
    }); // register refresh event for any superior to use to enforce a refresh of the options list

    if (ref.search('axis') === 1) {
      // this is a "brother" (hidden) scatterplot param. There is no need to refresh it or add event listeners etc.
      return;
    }

    elem.options = [];
    elem && elem.addEventListener('refresh', function (event) {
      matsSelectUtils.refresh(event, this.name);
    });
  } catch (e) {
    e.message = "Error in select.js rendered: " + e.message;
    setError(e);
  }

  try {
    matsSelectUtils.checkHideOther(this.data, true); // calls checkDisable

    matsSelectUtils.refresh(null, this.data.name);
  } catch (e) {
    e.message = "Error in select.js rendered function checking to hide or disable other elements: " + e.message;
    setError(e);
  }
});
Template.select.helpers({
  optionMaxLength: function () {
    var sOptions = [];

    if (!this.options) {
      return 10;
    }

    var longest = this.options.reduce(function (a, b) {
      if (a === null && b === null) {
        return null;
      }

      if (a === null) {
        return b;
      }

      if (b === null) {
        return a;
      }

      return a.length > b.length ? a : b;
    });

    if (!longest) {
      return 10;
    }

    var ret = longest.length <= 10 ? 10 : Math.round(longest.length * 0.8);
    return ret;
  },
  isSelectedByDefault: function (p) {
    if (p.default == this) {
      return "selected"; // the selected option
    } else {
      return ""; // not the selected option
    }
  },
  options: function () {
    var sOptions = []; //process options as an option list

    if (this.options === matsTypes.InputTypes.unused) {
      return [];
    } else if (this.optionsGroups) {
      // options have optionGroups
      this.optionsGroups.foreach(function (value) {
        Soptions.concat(value);
      });
    } else {
      sOptions = matsParamUtils.typeSort(this.options);
    }

    return sOptions;
  },
  multiple: function () {
    if (this.multiple === true) {
      return "multiple";
    }
  },
  isMultiple: function () {
    return this.multiple === true;
  },
  selectionIsOptional: function () {
    return this.selectionOptional === true;
  }
});

var setValue = function (pName) {
  var elem = matsParamUtils.getInputElementForParamName(pName);
  var selectedOptions = elem.selectedOptions;
  var options = elem.options;

  if (selectedOptions === undefined || selectedOptions.length === 0 || elem.selectedIndex === -1) {
    // set to the default - the 0th one
    matsParamUtils.setValueTextForParamName(pName, matsTypes.InputTypes.unused);
  } else {
    if (selectedOptions.length === 1) {
      matsParamUtils.setValueTextForParamName(pName, selectedOptions[0].text);
    } else {
      // selected options is greater than 1 - must be a multiple
      var firstOption = selectedOptions[0];
      var lastOption = selectedOptions[selectedOptions.length - 1];
      var text = firstOption.text + " .. " + lastOption.text;
      matsParamUtils.setValueTextForParamName(pName, text);
    }
  }
};

Template.select.events({
  'change .data-input': function (event) {
    Session.set("elementChanged", Date.now());
    var paramName = event.target.name;

    if (paramName === undefined) {
      return false;
    } // These need to be done in the right order!
    // always check to see if an "other" needs to be hidden or disabled before refreshing


    matsSelectUtils.checkHideOther(this, false);
    matsSelectUtils.refreshPeer(event, this);
    document.getElementById("element-" + this.name).style.display = "none"; // be sure to hide the element div

    var curveItem = document.getElementById("curveItem-" + Session.get("editMode"));
    curveItem && curveItem.scrollIntoView(false);
    setValue(paramName);

    if (this.multiple) {
      return true; // prevents the select 2 from closing on multiple selectors
    }

    $('#' + this.name + "-" + this.type).select2('close');
    matsSelectUtils.refreshDependents(event, this);
    Session.set('lastUpdate', Date.now());
    return false;
  },
  'click .doneSelecting': function (event) {
    Session.set("elementChanged", Date.now());
    var controlElem = matsParamUtils.getControlElementForParamName(this.name);
    $('#' + this.name + "-" + this.type).select2("close").trigger('change'); // apply the selection choices to the select2

    var editMode = Session.get("editMode");
    var curveItem = editMode === undefined && editMode === "" ? undefined : document.getElementById("curveItem-" + editMode);

    if (curveItem) {
      $('#save').trigger('click');
    }

    if (editMode) {
      $('#' + this.name + "-" + this.type).select2("close"); // use the close on the selector when editing
    } else {
      $(controlElem).trigger('click'); // clicking the control element hides the selector when not editing

      $('#' + this.name + "-" + this.type).select2("close");
    }

    return false;
  },
  'click .selectAll': function (event) {
    var elem = matsParamUtils.getInputElementForParamName(this.name);
    var values = [];

    for (var i = 0; i < elem.options.length; i++) {
      values.push(elem.options[i].text);
    }

    $('#' + this.name + "-" + this.type).select2().val(values).trigger('change');
    return false;
  },
  'click .clearSelections': function (event) {
    var elem = matsParamUtils.getInputElementForParamName(this.name);
    $('#' + this.name + "-" + this.type).select2().val(null).trigger('change');
    return false;
  },
  'click .doNotUse': function (event) {
    var elem = matsParamUtils.getInputElementForParamName(this.name);
    $('#' + this.name + "-" + this.type).select2().val(null).trigger('change');
    return false;
  },
  'change, blur .item': function (event) {
    try {
      var text = "";

      if (this.type == matsTypes.InputTypes.selectOrderEnforced) {
        /* check the validity of the order enforcement.
           The requirement for order enforced selectors is that
           some curve must have previously selected the earlier (lower ordered)
           options in the options array, not counting the default option to make this a valid selection.
           For example if my options are... ['auto by variable','y1','y2',y3'] and 'auto by variable'
           is the selectors default then choosing 'y2' or 'y3' prior to choosing 'y1' is not valid and
           choosing 'y3' prior to choosing 'y1' and 'y2' is not valid.
         */
        // what is the default?
        var defaultOption = this.default;
        var selection = $(event.target).val();
        var curves = Session.get('Curves');
        var options = this.options;
        var priorSelected = [defaultOption];

        for (var ci = 0; ci < curves.length; ci++) {
          var curve = curves[ci];
          var curveOption = curve[this.name];
          priorSelected.push(curveOption);
        }

        var unusedOption = "";

        if (!priorSelected.includes(selection)) {
          // this option has not been selected prior
          // check to see if all the prior options to this one are selected
          for (var oi = 0; oi < options.length; oi++) {
            var option = options[oi]; // We reached the selected option

            if (option == selection) {
              break;
            }

            if (!priorSelected.includes(option)) {
              unusedOption = option;
              break;
            }
          }

          if (unusedOption === "") {
            // is valid all prior options were selected
            event.target.setCustomValidity(this.name, "");
          } else {
            // HACK ALERT! the customValidity stuff seems to have been overridden in the invalid event event handler of item.js
            Session.set('errorMessage', "The prior option: " + unusedOption + " was not selected for this selector, you must use that first.");
            event.target.setCustomValidity(this.name, "The prior option: " + unusedOption + " was not selected for this selector, you must use that first.");
            event.target.checkValidity(); //                        matsParamUtils.setInputForParamName(this.name,this.default);
          }
        }
      }

      if (event.target.multiple) {
        var _values = $(event.target).val();

        if (_values === null) {
          // happens if unused or empty
          text = matsTypes.InputTypes.unused;
        } else {
          var firstOption = _values[0];
          var lastOption = _values[_values.length - 1];
          text = firstOption + " .. " + lastOption;
        }
      } else {
        text = $(event.target).val();
      }

      if (this.type === matsTypes.InputTypes.select && (text === "" || text === undefined || text === null) && (this.default === -1 || this.default === undefined || this.default === null || event.currentTarget.selectedIndex == -1)) {
        text = matsTypes.InputTypes.unused; //$('#' + this.name + "-" + this.type).select2().val(null).trigger('change');
      }

      matsParamUtils.setValueTextForParamName(event.target.name, text);
    } catch (error) {
      matsParamUtils.setValueTextForParamName(event.target.name, "");
    }

    var editMode = Session.get("editMode");
    var curveItem = editMode === undefined && editMode === "" ? undefined : document.getElementById("curveItem-" + editMode);

    if (curveItem) {
      $('#save').trigger('click');
    }

    if (event.target.multiple) {
      Session.set('editMode', editMode); // restore the editing of the curve item for muli selects

      var controlElem = matsParamUtils.getControlElementForParamName(this.name);
      $(controlElem).trigger('click'); // reopen the select2 - the regular open is not located properly so do it by clicking the control element button
    }

    return false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.map.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/template.map.js                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("map");
Template["map"] = new Template("Template.map", (function() {
  var view = this;
  return HTML.DIV({
    id: "mapModal",
    class: "modal",
    role: "dialog",
    "data-backdrop": "false"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog modal-lg"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title">Map</h4>\n                    <button class="btn btn-xs col-2 btn-success selectSites">Select All Sites</button>\n                    <button id="gc-spacer" type="button" class="btn spacebutton"></button>\n                    <button class="btn btn-xs col-2 btn-danger deselectSites">Deselect All Sites</button>\n                </div>'), "\n                ", HTML.DIV({
    class: "modal-body"
  }, "\n                    ", HTML.DIV({
    class: "modal-body",
    id: function() {
      return [ Spacebars.mustache(view.lookup("name")), "-", Spacebars.mustache(view.lookup("type")) ];
    }
  }), "\n                "), "\n                ", HTML.Raw('<div class="modal-footer btn-group">\n                    <button type="button" class="close-map btn btn-info" data-dismiss="modal" style="background-color: #9900ff;">&nbsp;&nbsp;Close</button>\n                </div>'), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-content -->"), "\n        "), HTML.Raw("\n        <!-- /.modal-dialog -->\n    "));
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"map.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/map.js                                                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 0);
Template.map.onRendered(function () {
  var defaultAttrs = this; // save for when we need to reset to defaults

  $.getScript("https://cdn.plot.ly/plotly-latest.min.js", function () {
    var targetId = '';
    var peerName = '';
    var markers = [];
    var thisMarkers = [];
    var peerOptions = [];
    var selectedValues = [];
    var divElement = '';
    var divId = '';
    var layout = {};
    var dataset = {}; // method to initialize the map selector

    var initializeSelectorMap = function (item) {
      var defaultPoint = item.data.defaultMapView.point;
      var defaultZoomLevel = item.data.defaultMapView.zoomLevel;
      peerName = item.data.peerName;
      var targetElement = document.getElementsByName(peerName)[0];

      if (!targetElement) {
        return;
      }

      targetId = '#' + targetElement.id;
      markers = item.data.optionsMap; // from app startup

      thisMarkers = []; // markers valid for this data source
      // find out what peer options are available for this data source

      peerOptions = [];

      if (targetElement.options) {
        for (var i = 0; i < targetElement.options.length; i++) {
          peerOptions.push(targetElement.options[i].text);
        }
      }

      selectedValues = $(targetId).val() ? $(targetId).val() : [];
      divElement = item.data.name + '-' + item.data.type;
      divId = '#' + divElement;
      layout = {
        autosize: true,
        // height: 500,
        // width: 840,
        hovermode: 'closest',
        mapbox: {
          bearing: 0,
          center: {
            lat: defaultPoint[0],
            lon: defaultPoint[1]
          },
          pitch: 0,
          zoom: defaultZoomLevel,
          accesstoken: 'pk.eyJ1IjoibWF0cy1nc2QiLCJhIjoiY2pvN2l1N2MyMG9xdTN3bWR3ODV5a2E2ZiJ9.PtgcGhxaoD43N0OwJSNVMg',
          style: 'light'
        },
        margin: {
          l: 10,
          r: 10,
          b: 10,
          t: 10,
          pad: 4
        },
        showlegend: false
      };
      dataset = {
        label: 'sitesMap',
        siteName: [],
        lat: [],
        lon: [],
        text: [],
        type: 'scattermapbox',
        mode: 'markers',
        marker: {
          color: [],
          opacity: 1
        }
      }; // set the initial site marker locations and colors

      var marker;

      for (var sidx = 0; sidx < peerOptions.length; sidx++) {
        marker = markers.find(function (obj) {
          return obj.name === peerOptions[sidx];
        });
        thisMarkers[sidx] = marker;
        dataset.siteName[sidx] = marker.name;
        dataset.text[sidx] = marker.name;
        dataset.lat[sidx] = marker.point[0];
        dataset.lon[sidx] = marker.point[1];

        if (selectedValues.indexOf(marker.name) === -1) {
          dataset.marker.color[sidx] = marker.options.color;
        } else {
          dataset.marker.color[sidx] = marker.options.highLightColor;
        }
      }
    }; // call the above initialization for the first time


    initializeSelectorMap(defaultAttrs); // draw the map for the first time

    Plotly.newPlot($(divId)[0], [dataset], layout);
    /*
     The following lines of code are event handlers for if a user clicks on a single station, or uses the area select
    tools to highlight a group of stations. For now, the logic is such that individual stations can toggle between
    chosen and unchosen by clicking them, but the area select tools will just choose everything that is outlined.
    This is so that if a user has been manually choosing stations and then gives up and uses the area select, all of
    their intended stations will be chosen (the ones they had already manually selected won't be unchosen). There will
    be some sort of 'deselect all' button on this modal to unchoose everything.
     NOTE: We are using plotly's event handlers here, but we are not using its native chosen/unchosen capabilities.
    Instead, we are getting the chosen values back from the area select and adding them into out own arrays. We then
    finish by telling plotly to deselect everything in its own internal accounting. There are two reasons for this:
        1) plotly's ways of handling chosen/unchosen values are way more complicated than is needed here
        2) under plotly's system, if we use the area select once, we then can't go back and add other areas or
        individual stations without losing the original selection.
     However, we may want to explore plotly's native chosen/unchosen capabilities in the future for our process-oriented
    verification.
     --MBS, 11/13/18
      */
    // event handler for clicking individual stations

    $(divId)[0].on('plotly_click', function (eventdata) {
      //get index of current station
      var currPoint = eventdata.points[0].pointNumber;

      if (dataset.marker.color[currPoint] === thisMarkers[currPoint].options.color) {
        // switch to selected color and add this station to our selected values array
        dataset.marker.color[currPoint] = thisMarkers[currPoint].options.highLightColor;
        selectedValues.push(eventdata.points[0].text);
      } else {
        // switch to deselected color and remove this station from our selected values array
        dataset.marker.color[currPoint] = thisMarkers[currPoint].options.color;
        var tidx = selectedValues.indexOf(eventdata.points[0].text);

        if (tidx > -1) {
          selectedValues.splice(tidx, 1);
        }
      } // update the marker color on the plot and the values in the site selector


      var update = {
        'marker': {
          color: dataset.marker.color,
          opacity: 1
        }
      };
      Plotly.restyle($(divId)[0], update, eventdata.points[0].curveNumber);
      $(targetId).val(selectedValues).trigger("change");
      matsParamUtils.collapseParam(peerName);
      $(targetId).select2("close");
    }); // event handler for outlining multiple stations

    $(divId)[0].on('plotly_selected', function (eventdata) {
      if (eventdata === undefined || eventdata.points.length < 1) {
        // the user has clicked outside of the select area, so make sure plotly's area select is disabled.
        // otherwise the user won't be able to choose individual stations after choosing an area select
        $(divId + " .select-outline").remove();
        Plotly.restyle($(divId)[0], {
          selectedpoints: [null]
        });
      } else {
        // the user has selected all the points in an area. Iterate through them and select any that are not already selected.
        var currPoint;
        eventdata.points.forEach(function (pt) {
          currPoint = pt.pointNumber;

          if (dataset.marker.color[currPoint] === thisMarkers[currPoint].options.color) {
            // switch to selected color and add this station to our selected values array
            dataset.marker.color[currPoint] = thisMarkers[currPoint].options.highLightColor;
            selectedValues.push(pt.text);
          }
        }); // update the marker color on the plot and the values in the site selector

        var update = {
          'marker': {
            color: dataset.marker.color,
            opacity: 1
          }
        };
        Plotly.restyle($(divId)[0], update, eventdata.points[0].curveNumber);
        $(targetId).val(selectedValues).trigger("change");
        matsParamUtils.collapseParam(peerName);
        $(targetId).select2("close"); // As per the comment block above, we're done here, so make sure plotly's area select is disabled.
        // otherwise the user won't be able to choose individual stations after choosing an area select.

        $(divId + " .select-outline").remove();
        Plotly.restyle($(divId)[0], {
          selectedpoints: [null]
        });
      }
    }); // event handler for selecting all stations

    $('.selectSites').on('click', function () {
      event.preventDefault(); // fill the selected values array with all available options and change the marker to its highlight color

      $(targetId).val(peerOptions).trigger("change");
      matsParamUtils.collapseParam(peerName);
      $(targetId).select2("close");

      for (var sidx = 0; sidx < thisMarkers.length; sidx++) {
        dataset.marker.color[sidx] = thisMarkers[sidx].options.highLightColor;
      }

      var update = {
        'marker': {
          color: dataset.marker.color,
          opacity: 1
        }
      };
      Plotly.restyle($(divId)[0], update, [0]);
    }); // event handler for deselecting all stations

    $('.deselectSites').on('click', function () {
      event.preventDefault(); // empty the selected values array and return the marker to its original color

      $(targetId).val([]).trigger("change");
      matsParamUtils.collapseParam(peerName);
      $(targetId).select2("close");

      for (var sidx = 0; sidx < thisMarkers.length; sidx++) {
        dataset.marker.color[sidx] = thisMarkers[sidx].options.color;
      }

      var update = {
        'marker': {
          color: dataset.marker.color,
          opacity: 1
        }
      };
      Plotly.restyle($(divId)[0], update, [0]);
    }); // method to see if the available sites have changed for this data source

    var refreshOptionsForPeer = function (peerElement) {
      // find out what peer options are available
      peerOptions = [];

      if (peerElement.options) {
        for (var i = 0; i < peerElement.options.length; i++) {
          peerOptions.push(peerElement.options[i].text);
        }
      }
    }; // method to sync the map up with the sites selector


    var refresh = function (peerElement) {
      if (!peerElement) {
        return;
      }

      var peerId = peerElement.id;
      refreshOptionsForPeer(peerElement);
      selectedValues = $('#' + peerId).val() ? $('#' + peerId).val() : []; // need to redo these in case the available sites have changed for this data source

      thisMarkers = [];
      dataset.siteName = [];
      dataset.text = [];
      dataset.lat = [];
      dataset.lon = [];
      dataset.marker.color = [];
      var marker;

      for (var sidx = 0; sidx < peerOptions.length; sidx++) {
        marker = markers.find(function (obj) {
          return obj.name === peerOptions[sidx];
        });
        thisMarkers[sidx] = marker;
        dataset.siteName[sidx] = marker.name;
        dataset.text[sidx] = marker.name;
        dataset.lat[sidx] = marker.point[0];
        dataset.lon[sidx] = marker.point[1];

        if (selectedValues.indexOf(marker.name) === -1) {
          dataset.marker.color[sidx] = marker.options.color;
        } else {
          dataset.marker.color[sidx] = marker.options.highLightColor;
        }
      }

      $(divId)[0].data[0] = dataset;
      Plotly.redraw($(divId)[0]);
    }; // method to reset the map to defaults


    var resetMap = function (item) {
      initializeSelectorMap(item);
      $(divId)[0].data[0] = dataset;
      $(divId)[0].layout = layout;
      Plotly.redraw($(divId)[0]);
    }; // register an event listener so that the select.js can ask the map div to refresh after a selection


    var elem = document.getElementById(divElement);
    elem.addEventListener('refresh', function (e) {
      refresh(e.detail.refElement);
    }); // register an event listener so that the param_util.js can ask the map div to reset when someone clicks 'reset to defaults'

    elem = document.getElementById(divElement);
    elem.addEventListener('reset', function (e) {
      resetMap(defaultAttrs);
    });
  });
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.date_range.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/template.date_range.js                                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("dateRange");
Template["dateRange"] = new Template("Template.dateRange", (function() {
  var view = this;
  return "";
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"date_range.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/date_range.js                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections, matsCurveUtils, matsParamUtils, matsTypes;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  },
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  },
  matsParamUtils: function (v) {
    matsParamUtils = v;
  },
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
Template.dateRange.onRendered(function () {
  //NOTE: Date fields are special in that they are qualified by plotType.
  //TimeSeries and Scatter plots have a common date range
  // but profile plots have a date range for each curve.
  // The decision to hide or show a dataRange is made here in the dateRange template
  // it seems that when the page is first rendered the checkbox might be yet defined (especially in safari).
  // in that event we test for undefined and block the curve-dates-item anyway
  if (document.getElementById('plot-type-' + matsTypes.PlotTypes.timeSeries) == undefined || document.getElementById('plot-type-' + matsTypes.PlotTypes.timeSeries).checked === true || document.getElementById('plot-type-' + matsTypes.PlotTypes.dailyModelCycle) == undefined || document.getElementById('plot-type-' + matsTypes.PlotTypes.dailyModelCycle).checked === true || document.getElementById('plot-type-' + matsTypes.PlotTypes.scatter2d) == undefined || document.getElementById('plot-type-' + matsTypes.PlotTypes.scatter2d).checked === true) {
    if (document.getElementById('curve-dates-item')) {
      document.getElementById('curve-dates-item').style.display = "none";
    }

    if (document.getElementById('dates-item')) {
      document.getElementById('dates-item').style.display = "block";
    }
  } else {
    if (document.getElementById('curve-dates-item')) {
      document.getElementById('curve-dates-item').style.display = "block";
    }

    if (document.getElementById('dates-item')) {
      document.getElementById('dates-item').style.display = "none";
    }
  }

  var name = this.data.name;
  var idref = name + "-item";
  var elem = document.getElementById('element-' + name);
  var superiorNames = this.data.superiorNames;
  var defaultDateRange = matsParamUtils.getDefaultDateRange(name);
  var startInit = defaultDateRange.startDate;
  var stopInit = defaultDateRange.stopDate;
  var dstr = defaultDateRange.dstr;
  $(function () {
    $('#' + idref).daterangepicker({
      "autoApply": true,
      "parentEL": $('#' + idref),
      "timePicker": true,
      "timePicker24Hour": true,
      "timePickerIncrement": 1,
      "startDate": startInit,
      "endDate": stopInit,
      "showDropdowns": true,
      "drops": "up",
      locale: {
        format: 'MM/DD/YYYY HH:mm'
      },
      ranges: {
        'Today': [moment().startOf('day'), moment().endOf('day')],
        'Yesterday': [moment().subtract(1, 'days').startOf('day'), moment().subtract(1, 'days').endOf('day')],
        'Last 7 Full Days': [moment().subtract(7, 'days').startOf('day'), moment().startOf('day')],
        'Last 30 Full Days': [moment().subtract(30, 'days').startOf('day'), moment().startOf('day')],
        'Last 60 Full Days': [moment().subtract(60, 'days').startOf('day'), moment().startOf('day')],
        'Last 90 Full Days': [moment().subtract(90, 'days').startOf('day'), moment().startOf('day')],
        'Last 180 Full Days': [moment().subtract(180, 'days').startOf('day'), moment().startOf('day')]
      },
      "alwaysShowCalendars": true
    });
    matsParamUtils.setValueTextForParamName(name, dstr);
  });
  $('#' + idref).on('apply.daterangepicker', function (ev, picker) {
    if (picker.startDate.toString() == picker.endDate.toString()) {
      setError(new Error("date_range error:  Your start and end dates coincide, you must select a range! This is " + "because METARs and other obs can come in at slightly different times, so selecting only one time might " + "leave you with very few (or no) valid obs. Instead, try using a small range. For example, if you're " + "targeting the top-of-the-hour METARs at 2:00 am, set your time range from 1:45 am to 2:00 am, because " + "METARs often come in early."));
      return false;
    }

    var valStr = picker.startDate.format('MM/DD/YYYY H:mm') + ' - ' + picker.endDate.format('MM/DD/YYYY H:mm');
    matsParamUtils.setValueTextForParamName(name, valStr);
    elem.style.display = "none";
    var curveItem = Session.get("editMode") === undefined && Session.get("editMode") === "" ? undefined : document.getElementById("curveItem-" + Session.get("editMode"));

    if (curveItem) {
      $('#save').trigger('click');
    }
  });
  $('#' + idref).on('cancel.daterangepicker', function () {
    elem.style.display = "none";
  });

  var refresh = function () {
    try {
      // get the current values from the element and check for invalid
      var curVals = matsParamUtils.getValueForParamName(name).split(" - "); // it is a date object values are "someFromDate - someToDate"

      var startDsr = moment(curVals[0], "MM/DD/YYYY HH:mm");
      var endDsr = moment(curVals[1], "MM/DD/YYYY HH:mm");

      if (!startDsr.isValid()) {
        // error
        setError("date_range refresh error: Your date range selector has an invalid start date-time: " + curVals[0]);
        return false;
      }

      if (!endDsr.isValid()) {
        // error
        setError("date_range refresh error: Your date range selector has an invalid end date-time:" + curVals[1]);
        return false;
      }

      if (startDsr.isAfter(endDsr)) {
        // error
        setError("date_range refresh error: Your date range selector has a start date/time that is later than the end date-time " + startDsr.toString() + " is not prior to " + endDsr.toString());
        return false;
      } // get superior values and check for errors


      var superiorVals = [];

      if (superiorNames !== undefined) {
        var superiorDimensionality = superiorNames !== null && superiorNames.length > 0 && Array.isArray(superiorNames[0]) ? superiorNames.length : 1;

        for (var si = 0; si < superiorDimensionality; si++) {
          var superiors = [];

          if (superiorDimensionality === 1) {
            superiors = superiorNames;
          } else {
            superiors = superiorNames[si];
          }

          var datesMap = undefined;

          for (var si2 = 0; si2 < superiors.length; si2++) {
            var thisSuperior = superiors[si2];
            datesMap = datesMap === undefined ? matsCollections.CurveParams.findOne({
              name: thisSuperior
            }).dates : datesMap;
            var sval = matsParamUtils.getInputElementForParamName(thisSuperior).options[matsParamUtils.getInputElementForParamName(thisSuperior).selectedIndex].text;

            if (sval === matsTypes.InputTypes.unused || sval === null || datesMap === undefined || matsParamUtils.getInputElementForParamName(thisSuperior) === undefined || isNaN(matsParamUtils.getInputElementForParamName(thisSuperior).selectedIndex) || matsParamUtils.getInputElementForParamName(thisSuperior).selectedIndex === -1) {
              // skip this superior - it isn't being used right now
              continue;
            }

            datesMap = datesMap[sval];
          }

          var superiorMinimumDateStr = datesMap.minDate;
          var superiorMinimumMoment = moment(superiorMinimumDateStr, "MM/DD/YYYY HH:mm");

          if (superiorMinimumMoment.isValid()) {
            superiorVals[si] = superiorVals[si] === undefined ? {} : superiorVals[si];
            superiorVals[si].min = superiorMinimumMoment;
          } else {
            setError("date_range refresh error: The end date for the superiors: " + superiors + " is invalid: " + superiorMinimumDateStr);
            return false;
          }

          var superiorMaximumDateStr = datesMap.maxDate;
          var superiorMaximumMoment = moment(superiorMaximumDateStr, "MM/DD/YYYY HH:mm");

          if (superiorMaximumMoment.isValid()) {
            superiorVals[si] = superiorVals[si] === undefined ? {} : superiorVals[si];
            superiorVals[si].max = superiorMaximumMoment;
          } else {
            setError("date_range refresh error: The end date for the superiors: " + superiors + " is invalid: " + superiorMaximumDateStr);
            return false;
          }

          if (superiorVals[si].min.isAfter(superiorVals[si].max)) {
            // error
            setError("date_range refresh error: The date range for the superiors: " + superiors + " is invalid. It has a start date/time that is later than the end date/time - " + superiorVals[si].min.toString() + " is after " + superiorVals[si].max.toString());
            return false;
          }
        }
      } // get data range from superiors


      if (superiorVals.length === 0) {
        // no superiors involved - just leave the DSR alone
        return false;
      } // these need to be the values for the superiors as they will be not as they are


      var dataStart = superiorVals[0].min;
      var dataEnd = superiorVals[0].max;

      if (superiorVals.length > 1) {
        for (si = 1; si < superiorVals.length; si++) {
          var tStart = superiorVals[si].min;
          var tEnd = superiorVals[si].max;

          if (dataEnd.isBefore(tStart)) {
            // NCD not coincindebtal data?
            setInfo("You do not have any coincidental data with these two selections: The valid date ranges do not overlap - " + dataStart.toString() + " to " + dataEnd.toString() + " and " + tStart.toString() + " to " + tEnd.toString());
            return false;
          } else if (tEnd.isBefore(dataStart)) {
            // NCD not coincindebtal data?
            setInfo("You do not have any coincidental data with these two selections: The valid date ranges do not overlap - " + dataStart.toString() + " to " + dataEnd.toString() + " and " + tStart.toString() + " to " + tEnd.toString());
            return false;
          } else {
            // overlapping data
            if (tStart.isAfter(dataStart)) {
              dataStart = tStart;
            }

            if (tEnd.isBefore(dataEnd)) {
              dataEnd = tEnd;
            }
          }
        }
      } // now we have a normalized date range for the selected superiors.
      // evaluate DRS


      if (dataEnd.isBefore(startDsr) || dataStart.isAfter(endDsr)) {
        // the current user setting and the valid range do not overlap so just set the DSR to the most recent 30 days of the valid range
        endDsr = dataEnd; // set startDsr to the endDsr less 30 days or less the startDsr whichever is later

        var endDsrLess30 = moment(endDsr).subtract(30, "days");

        if (endDsrLess30.isAfter(dataStart)) {
          startDsr = endDsrLess30;
        } else {
          startDsr = dataStart;
        }
      } else {
        // the current user setting and the valid range overlap
        if (startDsr.isBefore(dataStart)) {
          startDsr = dataStart;
        }

        if (endDsr.isAfter(dataEnd)) {
          endDsr = dataEnd;
        }
      } // now reset the DSR with the evaluated date range


      var jqIdRef = "#" + idref;
      $(jqIdRef).data('daterangepicker').setStartDate(startDsr);
      $(jqIdRef).data('daterangepicker').setStartDate(endDsr);
      var newDateStr = startDsr.format('MM/DD/YYYY HH:mm') + ' - ' + endDsr.format('MM/DD/YYYY HH:mm');
      matsParamUtils.setValueTextForParamName(name, newDateStr);
    } catch (error) {
      console.log("Error in date_range.js.refresh : " + error.message);
    }
  }; // register refresh event for superior to use to enforce a refresh of the options list


  elem.addEventListener('refresh', function (e) {
    refresh();
  });
  refresh(); // initial value based on what is in the superior
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.checkbox_group.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/template.checkbox_group.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("checkboxGroup");
Template["checkboxGroup"] = new Template("Template.checkboxGroup", (function() {
  var view = this;
  return [ HTML.Raw("&nbsp;"), HTML.LABEL({
    class: "checkbox-inline",
    for: function() {
      return [ Spacebars.mustache(Spacebars.dot(view.lookup("..."), "name")), "-", Spacebars.mustache(Spacebars.dot(view.lookup("..."), "type")), "-", Spacebars.mustache(view.lookup(".")) ];
    }
  }, Blaze.View("lookup:labelValue", function() {
    return Spacebars.mustache(view.lookup("labelValue"), Spacebars.dot(view.lookup("..."), "optionsMap"));
  })), HTML.Raw("\n    &nbsp;"), HTML.INPUT(HTML.Attrs({
    type: "checkbox",
    class: "data-input",
    name: function() {
      return Spacebars.mustache(Spacebars.dot(view.lookup("..."), "name"));
    },
    id: function() {
      return [ Spacebars.mustache(Spacebars.dot(view.lookup("..."), "name")), "-", Spacebars.mustache(Spacebars.dot(view.lookup("..."), "type")), "-", Spacebars.mustache(view.lookup(".")) ];
    },
    value: function() {
      return Spacebars.mustache(view.lookup("."));
    }
  }, function() {
    return Spacebars.attrMustache(view.lookup("checkedByDefault"), Spacebars.dot(view.lookup("..."), "default"));
  })) ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"checkbox_group.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/checkbox_group.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
Template.checkboxGroup.helpers({
  checkedByDefault: function (def) {
    if (def == this) {
      return "checked";
    } else {
      return "";
    }
  },
  labelValue: function (optionsMap) {
    return optionsMap[this];
  }
}); // Currently have no checkboxGroup params - this is undoubtedly broken - FIX ME

Template.checkboxGroup.events({
  'change, blur': function (event) {
    try {
      var text = event.currentTarget.value;
      matsParamUtils.setValueTextForParamName(event.target.name, text);
    } catch (error) {
      matsParamUtils.setValueTextForParamName(event.target.name, "");
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.number_spinner.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/template.number_spinner.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("numberSpinner");
Template["numberSpinner"] = new Template("Template.numberSpinner", (function() {
  var view = this;
  return HTML.INPUT({
    class: "data-input input-sm",
    id: function() {
      return [ Spacebars.mustache(view.lookup("name")), "-", Spacebars.mustache(view.lookup("type")) ];
    },
    type: "number",
    value: function() {
      return Spacebars.mustache(view.lookup("defaultValue"));
    },
    name: function() {
      return Spacebars.mustache(view.lookup("name"));
    },
    min: function() {
      return Spacebars.mustache(view.lookup("min"));
    },
    max: function() {
      return Spacebars.mustache(view.lookup("max"));
    },
    step: function() {
      return Spacebars.mustache(view.lookup("step"));
    }
  });
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"number_spinner.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/number_spinner.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);

var refresh = function (name) {
  var paramData = matsCollections.CurveParams.findOne({
    name: name
  }, {
    dependentNames: 1,
    peerName: 1
  });
  var optionsMap = paramData.optionsMap;
  var superiorNames = paramData.superiorNames;
  var ref = paramData.name + '-' + paramData.type;
  var refValueDisplay = "controlButton-" + paramData.name + "-value";
  var dispElem = document.getElementById(refValueDisplay);
  var elem = document.getElementById(ref);
  var dispDefault = paramData.default;
  var min = paramData.min;
  var step = paramData.step === undefined ? "any" : paramData.step;
  var max = paramData.max;

  for (var si = 0; si < superiorNames.length; si++) {
    var superiorElement = matsParamUtils.getInputElementForParamName(superiorNames[si]);
    var selectedSuperiorValue = superiorElement.options[superiorElement.selectedIndex] && superiorElement.options[superiorElement.selectedIndex].text;
    var options = optionsMap[selectedSuperiorValue];

    if (options === undefined) {
      continue;
    }

    min = Number(options.min) < Number(min) ? options.min : min;
    max = Number(options.max) > Number(max) ? options.max : max;

    if (step !== "any" && options.step !== "any") {
      step = Number(options.step) < Number(step) ? options.step : step;
    }

    dispDefault = options.default !== undefined ? options.default : dispDefault;
  }

  elem.setAttribute("min", min);
  elem.setAttribute("max", max);
  elem.setAttribute("step", step);
  elem.value = dispDefault;
};

Template.numberSpinner.helpers({
  defaultValue: function () {
    return this.default;
  },
  min: function () {
    //default
    return this.min;
  },
  max: function () {
    //default
    return this.max;
  },
  step: function () {
    //default
    return this.step;
  }
});
Template.numberSpinner.onRendered(function () {
  // register an event listener so that the select.js can ask the map div to refresh after a selection
  var ref = this.data.name + '-' + this.data.type;
  var elem = document.getElementById(ref);

  if (ref.search('axis') === 1) {
    // this is a "brother" (hidden) scatterplot param. There is no need to refresh it or add event listeners etc.
    return;
  }

  elem.addEventListener('refresh', function (e) {
    refresh(this.name);
  });
});
Template.numberSpinner.events({
  'change, blur': function (event) {
    try {
      event.target.checkValidity();
      var text = event.currentTarget.value;
      matsParamUtils.setValueTextForParamName(event.target.name, text);
    } catch (error) {
      matsParamUtils.setValueTextForParamName(event.target.name, "");
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.radio_group_option.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/template.radio_group_option.js                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("radioGroup");
Template["radioGroup"] = new Template("Template.radioGroup", (function() {
  var view = this;
  return [ HTML.LABEL({
    class: "radio-inline",
    for: function() {
      return [ Spacebars.mustache(Spacebars.dot(view.lookup("..."), "name")), "-", Spacebars.mustache(Spacebars.dot(view.lookup("..."), "type")), "-", Spacebars.mustache(view.lookup(".")) ];
    }
  }, Blaze.View("lookup:labelValue", function() {
    return Spacebars.mustache(view.lookup("labelValue"), Spacebars.dot(view.lookup("..."), "optionsMap"));
  })), "\n    ", HTML.INPUT(HTML.Attrs({
    type: "radio",
    class: "data-input",
    name: function() {
      return Spacebars.mustache(Spacebars.dot(view.lookup("..."), "name"));
    },
    id: function() {
      return [ Spacebars.mustache(Spacebars.dot(view.lookup("..."), "name")), "-", Spacebars.mustache(Spacebars.dot(view.lookup("..."), "type")), "-", Spacebars.mustache(view.lookup(".")) ];
    },
    value: function() {
      return Spacebars.mustache(view.lookup("."));
    }
  }, function() {
    return Spacebars.attrMustache(view.lookup("checkedByDefault"), Spacebars.dot(view.lookup("..."), "default"));
  })) ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"radio_group_option.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/radio_group_option.js                                                  //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
Template.radioGroup.helpers({
  checkedByDefault: function (def) {
    if (def == this) {
      return "checked";
    } else {
      return "";
    }
  },
  labelValue: function (optionsMap) {
    return optionsMap[this];
  }
}); // Currently have no radioGroup params - this is undoubtedly broken - FIX ME

Template.radioGroup.events({
  'change, blur': function (event) {
    try {
      var text = event.currentTarget.value;
      matsParamUtils.setValueTextForParamName(event.target.name, text);
    } catch (error) {
      matsParamUtils.setValueTextForParamName(event.target.name, "");
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.item.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/template.item.js                                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("item");
Template["item"] = new Template("Template.item", (function() {
  var view = this;
  return HTML.DIV({
    id: function() {
      return [ Spacebars.mustache(view.lookup("name")), "-item" ];
    },
    class: "item btn-group",
    role: "group",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("display")) ];
    }
  }, "\n        ", HTML.BUTTON({
    type: "button",
    class: "control-button btn btn-primary fa fa-hand-o-up",
    id: function() {
      return Spacebars.mustache(view.lookup("controlButton"));
    },
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("controlButtonVisibility")) ];
    }
  }, Blaze.View("lookup:cbname", function() {
    return Spacebars.mustache(view.lookup("cbname"));
  })), HTML.Raw('\n        <span style="display:inline-block;">&nbsp;</span>\n        '), HTML.DIV({
    id: function() {
      return Spacebars.mustache(view.lookup("element"));
    },
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("elementHidden")), ";position:absolute;z-index: 5;float:right;background-color: white;" ];
    }
  }, "\n            ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isSelect"));
  }, function() {
    return [ "\n                ", Blaze._TemplateWith(function() {
      return Spacebars.call(view.lookup("."));
    }, function() {
      return Spacebars.include(view.lookupTemplate("select"));
    }), "\n            " ];
  }, function() {
    return [ " ", Blaze.If(function() {
      return Spacebars.call(view.lookup("isSpinner"));
    }, function() {
      return [ "\n                ", Blaze._TemplateWith(function() {
        return Spacebars.call(view.lookup("."));
      }, function() {
        return Spacebars.include(view.lookupTemplate("numberSpinner"));
      }), "\n            " ];
    }, function() {
      return [ " ", Blaze.If(function() {
        return Spacebars.call(view.lookup("isInput"));
      }, function() {
        return [ "\n                ", Blaze._TemplateWith(function() {
          return Spacebars.call(view.lookup("."));
        }, function() {
          return Spacebars.include(view.lookupTemplate("textInput"));
        }), "\n            " ];
      }, function() {
        return [ " ", Blaze.If(function() {
          return Spacebars.call(view.lookup("isDateRange"));
        }, function() {
          return [ "\n                ", Blaze._TemplateWith(function() {
            return Spacebars.call(view.lookup("."));
          }, function() {
            return Spacebars.include(view.lookupTemplate("dateRange"));
          }), "\n            " ];
        }, function() {
          return [ " ", Blaze.If(function() {
            return Spacebars.call(view.lookup("isCheckBoxGroup"));
          }, function() {
            return [ "\n                ", HTML.DIV({
              class: "container",
              style: "background-color:lightcyan;width:100%"
            }, "\n                    ", Blaze.View("lookup:name", function() {
              return Spacebars.mustache(view.lookup("name"));
            }), ":\n                    ", Blaze.Each(function() {
              return Spacebars.call(view.lookup("options"));
            }, function() {
              return [ "\n                        ", Blaze._TemplateWith(function() {
                return Spacebars.call(view.lookup("."));
              }, function() {
                return Spacebars.include(view.lookupTemplate("checkboxGroup"));
              }), "\n                    " ];
            }), "\n                "), "\n            " ];
          }, function() {
            return [ " ", Blaze.If(function() {
              return Spacebars.call(view.lookup("isRadioGroup"));
            }, function() {
              return [ "\n                ", HTML.DIV({
                class: "container btn-group",
                style: "font-size:large;background-color:lightcyan;width:100%;display:inline-block;"
              }, "\n                    ", HTML.SPAN({
                style: "vertical-align: bottom;"
              }, Blaze.View("lookup:name", function() {
                return Spacebars.mustache(view.lookup("name"));
              }), ":"), "\n                    ", Blaze.Each(function() {
                return Spacebars.call(view.lookup("options"));
              }, function() {
                return [ "\n                        ", Blaze._TemplateWith(function() {
                  return Spacebars.call(view.lookup("."));
                }, function() {
                  return Spacebars.include(view.lookupTemplate("radioGroup"));
                }), "\n                    " ];
              }), "\n                "), "\n            " ];
            }, function() {
              return [ " ", Blaze.If(function() {
                return Spacebars.call(view.lookup("isSelectMap"));
              }, function() {
                return [ "\n                ", Blaze._TemplateWith(function() {
                  return Spacebars.call(view.lookup("."));
                }, function() {
                  return Spacebars.include(view.lookupTemplate("map"));
                }), "\n            " ];
              }), " " ];
            }), " " ];
          }), " " ];
        }), " " ];
      }), " " ];
    }), " " ];
  }), "\n        "), "\n        ", HTML.BUTTON({
    type: "button",
    class: "control-button btn btn-info fa fa-label",
    name: function() {
      return [ Spacebars.mustache(view.lookup("controlButton")), "-value" ];
    },
    id: function() {
      return [ Spacebars.mustache(view.lookup("controlButton")), "-value" ];
    },
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("controlButtonVisibility")) ];
    }
  }, " ", Blaze.View("lookup:textValue", function() {
    return Spacebars.mustache(view.lookup("textValue"));
  })), "\n        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("hasHelp"));
  }, function() {
    return [ "\n            ", HTML.BUTTON({
      style: "background-color:#bbffbb",
      type: "button",
      class: "btn btn-default  btn-xs  help fa fa-question"
    }), "\n        " ];
  }), HTML.Raw('\n        <button type="button" class="btn spacebutton"></button>\n    '));
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"item.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/common/item.js                                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 1);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 2);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 3);
Template.item.helpers({
  cbname: function () {
    if (this.controlButtonText !== undefined) {
      return this.controlButtonText.toUpperCase();
    }

    return this.name.toUpperCase();
  },
  textValue: function () {
    Session.get('lastUpdate');

    if (this.name === "label") {
      // label is handled specially
      return;
    }

    if (matsParamUtils.getInputElementForParamName(this.name)) {
      return this.default;
    }

    if (this.value) {
      return this.value;
    } else {
      if (this.type === matsTypes.InputTypes.select && (this.default === -1 || this.default === undefined || this.default === matsTypes.InputTypes.unused)) {
        return matsTypes.InputTypes.unused;
      } else {
        return this.default;
      }
    }
  },
  hasHelp: function () {
    return this.help !== undefined;
  },
  isSelect: function () {
    /* A selectOrderEnforced differs from a select
        only in that the options - other than the default first option -
        must be chosen in order. In other words if the user attempts to select
        the second option prior to selecting the first option a validation error occurs.
     */
    return typeof this.type !== 'undefined' && (this.type == matsTypes.InputTypes.select || this.type == matsTypes.InputTypes.selectOrderEnforced);
  },
  isSelectMap: function () {
    return typeof this.type !== 'undefined' && this.type == matsTypes.InputTypes.selectMap;
  },
  isInput: function () {
    return typeof this.type !== 'undefined' && this.type == matsTypes.InputTypes.textInput;
  },
  isSpinner: function () {
    return typeof this.type !== 'undefined' && this.type == matsTypes.InputTypes.numberSpinner;
  },
  isDateRange: function () {
    return typeof this.type !== 'undefined' && this.type == matsTypes.InputTypes.dateRange;
  },
  isCheckBoxGroup: function () {
    return typeof this.type !== 'undefined' && this.type == matsTypes.InputTypes.checkBoxGroup;
  },
  isRadioGroup: function () {
    return typeof this.type !== 'undefined' && this.type == matsTypes.InputTypes.radioGroup;
  },
  controlButton: function () {
    return matsTypes.InputTypes.controlButton + "-" + this.name;
  },
  resetButton: function () {
    return matsTypes.InputTypes.resetButton + "-" + this.type;
  },
  element: function () {
    return matsTypes.InputTypes.element + "-" + this.name;
  },
  display: function () {
    if (this.hidden) {
      return "none;margin-top: 1.5em;";
    }

    if (this.displayPriority !== undefined && this.displayPriority > Session.get('displayPriority')) {
      return "none;margin-top: 1.5em;";
    } else {
      return "block;margin-top: 1.5em;";
    }
  },
  controlButtonVisibility: function () {
    if (this.controlButtonCovered) {
      return "block;";
    } else {
      return "none";
    }
  },
  elementHidden: function () {
    if (this.controlButtonCovered) {
      return "none";
    } else {
      return "block";
    }
  }
});
Template.item.events({
  'click .control-button': function (event) {
    Session.set("elementChanged", Date.now());
    var elem = document.getElementById(matsTypes.InputTypes.element + "-" + this.name);

    if (elem === undefined) {
      return false;
    }

    if (elem !== null && elem.style.display === "block") {
      elem.style.display = "none";
    } else {
      matsParamUtils.collapseParams();

      if (elem !== null) {
        elem.style.display = "block";

        if (this.type == matsTypes.InputTypes.select) {
          var s = document.getElementById(this.name + '-' + this.type);
          var ref = "#" + this.name + "-" + this.type;
          $(ref).select2("open"); // need to foricibly open the selector for the select2
        }

        if (this.type == matsTypes.InputTypes.selectMap) {
          $("#mapModal").modal('show');
          window.dispatchEvent(new Event('resize'));
        }
      }
    }
  },
  'click .data-input': function (event) {
    Session.set("elementChanged", Date.now());

    if (this.displayPriority !== undefined) {
      Session.set('displayPriority', this.displayPriority + 1);
    }

    var formats = Object.keys(matsTypes.PlotFormats);

    if ($.inArray(this, formats) !== -1) {
      Session.set('diffStatus', this);
    }

    if (this.multiple !== true && this.type !== matsTypes.InputTypes.numberSpinner && this.type !== matsTypes.InputTypes.textInput) {
      // not too cool to collapse when trying to do a multi-select, a textInput, or a numberspinner
      matsParamUtils.collapseParam(this.name);
    }
  },
  'change .data-input': function (event) {
    Session.set("elementChanged", Date.now());
    event.target.checkValidity();

    if (this.type !== matsTypes.InputTypes.numberSpinner) {
      event.target.checkValidity();
      var elem = document.getElementById(matsTypes.InputTypes.element + "-" + this.name);

      if (elem === undefined) {
        return false;
      }

      if (elem !== null && elem.style.display === "block" && this.multiple !== true) {
        elem.style.display = "none";
      } else {
        if (elem !== null) {
          elem.style.display = "block";
        }
      }
    }

    var curveItem = Session.get("editMode") === undefined && Session.get("editMode") === "" ? undefined : document.getElementById("curveItem-" + Session.get("editMode"));

    if (curveItem) {
      $('#save').trigger('click');
    }
  },
  'click .help': function () {
    var helpref = Session.get("app").helpref;
    $("#matshelp").load(helpref + "/" + this.help + " #matshelp");
    $("#helpModal").modal('show');
  },
  'invalid': function (event) {
    if (this.type === matsTypes.InputTypes.numberSpinner) {
      var param = matsCollections.CurveParams.findOne({
        name: event.currentTarget.name
      });

      if (param === undefined) {
        return;
      }

      setError(new Error('invalid value (' + event.currentTarget.value + ') for ' + event.currentTarget.name + " it must be between " + event.currentTarget.min + " and " + event.currentTarget.max + " -- resetting to default value: " + default_value));
    } else {
      var errMsg = Session.get('errorMessage');

      if (errMsg === "") {
        errMsg = 'invalid value (' + event.currentTarget.value + ') for ' + event.currentTarget.name;
      }

      setError(new Error(errMsg));
    }

    var default_value = matsCollections.CurveParams.findOne({
      name: event.currentTarget.name
    }).default;
    event.currentTarget.value = default_value;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"curves":{"template.curve_item.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/curves/template.curve_item.js                                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("curveItem");
Template["curveItem"] = new Template("Template.curveItem", (function() {
  var view = this;
  return [ HTML.DIV({
    class: "modal modal-dialog fade",
    id: "modal-confirm-remove-curve",
    tabindex: "-1",
    role: "dialog",
    "aria-labelledby": "confirmRemoveCurve",
    "aria-hidden": "true",
    style: "background-color: cornflowerblue"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, HTML.Raw('<i class="fa fa-4x fa-question" style="color:cornflowerblue"></i>'), "\n                ", HTML.H2({
    class: "modal-title",
    style: "text-align: center; color: red;"
  }, "Remove ", Blaze.View("lookup:removeCurve", function() {
    return Spacebars.mustache(view.lookup("removeCurve"));
  }), "?"), "\n                ", HTML.DIV({
    class: "modal-body"
  }, "\n                    ", HTML.H4({
    style: "color:cornflowerblue"
  }, "Are you sure you want to remove curve ", Blaze.View("lookup:removeCurve", function() {
    return Spacebars.mustache(view.lookup("removeCurve"));
  }), "?"), "\n                "), "\n                ", HTML.DIV({
    class: "modal-footer"
  }, "\n                    ", HTML.Raw('<button id="cancle-remove-curve" class="cancle-remove-curve btn btn-success" data-dismiss="modal">Cancel the Remove</button>'), "\n                    ", HTML.BUTTON({
    id: "confirm-remove-curve",
    class: "btn btn-danger confirm-remove-curve",
    "data-dismiss": "modal"
  }, "Remove curve ", Blaze.View("lookup:removeCurve", function() {
    return Spacebars.mustache(view.lookup("removeCurve"));
  })), "\n                "), "\n            "), "\n        "), "\n    "), "\n\n    ", HTML.DIV({
    id: function() {
      return [ "curveItem-", Spacebars.mustache(view.lookup("label")) ];
    }
  }, "\n        ", HTML.DIV({
    class: "pull-left clearfix col-lg-12",
    role: "toolbar"
  }, "\n                ", HTML.DIV({
    style: function() {
      return [ "padding:0.5%;margin-bottom:0.5%;display:inline-block;background-color: #f5f5f5;border:solid;border-width:thick;border-color: ", Spacebars.mustache(view.lookup("defaultColor")), ";border-radius: 10px;" ];
    }
  }, "\n                    ", HTML.SPAN("\n                        ", HTML.SPAN({
    class: "rounded input-group displayItemLabelSpan label label-default ",
    style: "vertical-align: middle; align-content: center; font-size:large;margin:5px;",
    id: function() {
      return [ "LABEL-curve-", Spacebars.mustache(view.lookup("curveNumber")), "-Item" ];
    }
  }, Blaze.View("lookup:label", function() {
    return Spacebars.mustache(view.lookup("label"));
  })), "\n                        ", HTML.INPUT({
    id: function() {
      return [ Spacebars.mustache(view.lookup("label")), "-color-value" ];
    },
    type: "text",
    class: function() {
      return [ "input-sm form-control ", Spacebars.mustache(view.lookup("colorpick")) ];
    },
    value: function() {
      return Spacebars.mustache(view.lookup("defaultColor"));
    },
    style: "display:inline-block;width:10em;"
  }), "\n                        ", Blaze.If(function() {
    return Spacebars.call(view.lookup("DBcurve"));
  }, function() {
    return [ "\n                            ", Blaze.If(function() {
      return Spacebars.call(view.lookup("editingThis"));
    }, function() {
      return [ "\n                                ", HTML.DIV({
        id: "editMode",
        class: "btn-toolbar-sm btn-group",
        role: "group"
      }, "\n                                    ", HTML.BUTTON({
        name: "save",
        id: "curve-list-save",
        class: "save-changes btn-success btn fa fa-line-chart"
      }, HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), "Save ", Blaze.View("lookup:editCurve", function() {
        return Spacebars.mustache(view.lookup("editCurve"));
      }), " Changes"), "\n                                    ", HTML.BUTTON({
        name: "cancel",
        id: "curve-list-cancel",
        class: "cancel btn-info btn fa icon-remove-sign"
      }, HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), "Cancel"), "\n                                "), "\n                            " ];
    }, function() {
      return [ "\n                                ", HTML.DIV({
        id: "nonEditMode",
        class: "btn-toolbar-sm btn-group",
        role: "group"
      }, "\n                                    ", HTML.BUTTON({
        id: "curve-list-remove",
        class: "remove-curve btn-danger btn fa fa-times "
      }, " ", HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), "Remove  ", Blaze.View("lookup:label", function() {
        return Spacebars.mustache(view.lookup("label"));
      }), " "), "\n                                    ", HTML.BUTTON({
        id: "curve-list-edit",
        class: function() {
          return [ "edit-curve edit-curve-", Spacebars.mustache(view.lookup("label")), " btn-info btn fa fa-pencil-square-o" ];
        },
        style: function() {
          return [ "display:", Spacebars.mustache(view.lookup("displayEdit")) ];
        }
      }, HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), "Edit  ", Blaze.View("lookup:label", function() {
        return Spacebars.mustache(view.lookup("label"));
      })), "\n                                    ", HTML.BUTTON({
        id: "curve-list-edit-xaxis",
        class: function() {
          return [ "edit-curve-xaxis edit-curve-xaxis-", Spacebars.mustache(view.lookup("label")), " btn-info btn fa fa-pencil-square-o" ];
        },
        style: function() {
          return [ "display:", Spacebars.mustache(view.lookup("displayEditXaxis")) ];
        }
      }, HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), "Edit ", Blaze.View("lookup:label", function() {
        return Spacebars.mustache(view.lookup("label"));
      }), "  X Axis"), "\n                                    ", HTML.BUTTON({
        id: "curve-list-edit-yaxis",
        class: function() {
          return [ "edit-curve-yaxis edit-curve-yaxis-", Spacebars.mustache(view.lookup("label")), "  btn btn-info fa fa-pencil-square-o" ];
        },
        style: function() {
          return [ "display:", Spacebars.mustache(view.lookup("displayEditYaxis")) ];
        }
      }, HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), "Edit ", Blaze.View("lookup:label", function() {
        return Spacebars.mustache(view.lookup("label"));
      }), "  Y Axis"), "\n                                "), "\n                            " ];
    }), "\n                        " ];
  }), "\n                    "), "\n                    ", Blaze._TemplateWith(function() {
    return Spacebars.call(view.lookup("."));
  }, function() {
    return Spacebars.include(view.lookupTemplate("curveParamItemGroup"));
  }), "\n                "), "\n          "), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"curve_item.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/curves/curve_item.js                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 2);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 3);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 4);
label;
Template.curveItem.onRendered(function () {
  // the value used for the colorpicker (l) MUST match the returned value in the colorpick helper
  label = this.data.label;
  $(function () {
    var l = '.' + label + '-colorpick';
    $(l).colorpicker({
      format: "rgb",
      align: "left"
    });
  });
});
Template.curveItem.helpers({
  removeCurve: function () {
    var confirmRemoveCurve = Session.get("confirmRemoveCurve");
    return confirmRemoveCurve ? confirmRemoveCurve.label : null;
  },
  displayEditXaxis: function () {
    if (Session.get('plotType') === matsTypes.PlotTypes.scatter2d) {
      return "block";
    }

    return "none";
  },
  displayEditYaxis: function () {
    if (Session.get('plotType') === matsTypes.PlotTypes.scatter2d) {
      return "block";
    }

    return "none";
  },
  displayEdit: function () {
    if (Session.get('plotType') === matsTypes.PlotTypes.scatter2d) {
      return "none";
    }

    return "block";
  },
  colorpick: function () {
    var l = this.label + '-colorpick';
    return l;
  },
  text: function () {
    if (this.diffFrom === undefined) {
      var plotType = Session.get('plotType');

      if (plotType === undefined) {
        var pfuncs = matsCollections.PlotGraphFunctions.find({}).fetch();

        for (var i = 0; i < pfuncs.length; i++) {
          if (pfuncs[i].checked === true) {
            Session.set('plotType', pfuncs[i].plotType);
          }
        }

        plotType = Session.get('plotType');
      }

      if (this.region) {
        this.regionName = this.region.split(' ')[0];
      }

      return matsPlotUtils.getCurveText(plotType, this);
    } else {
      return this.label + ":  Difference";
    }
  },
  color: function () {
    return this.color;
  },
  label: function () {
    return this.label;
  },
  defaultColor: function () {
    var curves = Session.get('Curves');
    var label = this.label;

    for (var i = 0; i < curves.length; i++) {
      if (curves[i].label === label) {
        return curves[i].color;
      }
    }
  },
  curveNumber: function () {
    var label = this.label;
    var curves = Session.get("Curves");
    var index = curves.findIndex(function (obj) {
      return obj.label === label;
    });
    return index;
  },
  log: function () {
    console.log(this);
  },
  DBcurve: function () {
    return this.diffFrom === undefined;
  },
  editingThis: function () {
    return Session.get('editMode') === this.label;
  },
  editCurve: function () {
    return Session.get('editMode');
  },
  editTarget: function () {
    return Session.get("eventTargetCurve");
  }
});

var setParamsToAxis = function (newAxis, currentParams) {
  // reset scatter plot apply stuff
  matsCurveUtils.resetScatterApply(); // set param values to this curve
  // reset the form parameters for the superiors first

  var currentParamName;
  var params = matsCollections.CurveParams.find({
    "dependentNames": {
      "$exists": true
    }
  }).fetch();

  for (var p = 0; p < params.length; p++) {
    var plotParam = params[p]; // do any date parameters - there are no axis date params in a scatter plot

    if (plotParam.type === matsTypes.InputTypes.dateRange) {
      if (currentParams[plotParam.name] === undefined) {
        continue; // just like continue
      }

      var dateArr = currentParams[plotParam.name].split(' - ');
      var from = dateArr[0];
      var to = dateArr[1];
      var idref = "#" + plotParam.name + "-item";
      $(idref).data('daterangepicker').setStartDate(moment(from, 'MM-DD-YYYY HH:mm'));
      $(idref).data('daterangepicker').setEndDate(moment(to, 'MM-DD-YYYY HH:mm'));
      matsParamUtils.setValueTextForParamName(plotParam.name, currentParams[plotParam.name]);
    } else {
      currentParamName = currentParams[newAxis + "-" + plotParam.name] === undefined ? plotParam.name : newAxis + "-" + plotParam.name;
      var val = currentParams[currentParamName] === null || currentParams[currentParamName] === undefined ? matsTypes.InputTypes.unused : currentParams[currentParamName];
      matsParamUtils.setInputForParamName(plotParam.name, val);
    }
  } // now reset the form parameters for the dependents


  params = matsCollections.CurveParams.find({
    "dependentNames": {
      "$exists": false
    }
  }).fetch();

  for (var p = 0; p < params.length; p++) {
    var plotParam = params[p]; // do any plot date parameters

    currentParamName = currentParams[newAxis + "-" + plotParam.name] === undefined ? plotParam.name : newAxis + "-" + plotParam.name;

    if (plotParam.type === matsTypes.InputTypes.dateRange) {
      if (currentParams[currentParamName] === undefined) {
        continue; // just like continue
      }

      var _dateArr = currentParams[currentParamName].split(' - ');

      var _from = _dateArr[0];
      var _to = _dateArr[1];

      var _idref = "#" + plotParam.name + "-item";

      $(_idref).data('daterangepicker').setStartDate(moment(_from, 'MM-DD-YYYY HH:mm'));
      $(_idref).data('daterangepicker').setEndDate(moment(_to, 'MM-DD-YYYY HH:mm'));
      matsParamUtils.setValueTextForParamName(plotParam.name, currentParams[currentParamName]);
    } else {
      var _val = currentParams[currentParamName] === null || currentParams[currentParamName] === undefined ? matsTypes.InputTypes.unused : currentParams[currentParamName];

      matsParamUtils.setInputForParamName(plotParam.name, _val);
    }
  } // reset the scatter parameters


  params = matsCollections.Scatter2dParams.find({}).fetch();

  for (var p = 0; p < params.length; p++) {
    var plotParam = params[p];
    currentParamName = currentParams[newAxis + "-" + plotParam.name] === undefined ? plotParam.name : newAxis + "-" + plotParam.name;

    var _val2 = currentParams[currentParamName] === null || currentParams[currentParamName] === undefined ? matsTypes.InputTypes.unused : currentParams[currentParamName];

    matsParamUtils.setInputForParamName(plotParam.name, _val2);
  }

  matsParamUtils.collapseParams();
  return false;
};

var curveListEditNode; // used to pass the edit button to the modal continue

Template.curveItem.events({
  'click .save-changes': function () {
    $(".displayBtn").css({
      border: ""
    }); // clear any borders from any display buttons

    document.getElementById('save').click();
    Session.set("paramWellColor", "#f5f5f5");
  },
  'click .cancel': function () {
    $(".displayBtn").css({
      border: ""
    }); // clear any borders from any display buttons

    document.getElementById('cancel').click();
    Session.set("paramWellColor", "#f5f5f5");
  },
  'click .remove-curve': function (event) {
    var removeCurve = Session.get("confirmRemoveCurve");

    if (removeCurve && removeCurve.confirm) {
      var label = removeCurve.label;
      var color = removeCurve.color;

      var Curves = _.reject(Session.get('Curves'), function (item) {
        return item.label === label;
      });

      Session.set('Curves', Curves);
      matsCurveUtils.clearUsedLabel(label);
      matsCurveUtils.clearUsedColor(color);
      matsCurveUtils.checkDiffs();
      Session.set("confirmRemoveCurve", "");
      Session.set("lastUpdate", Date.now());

      if (Curves.length === 0) {
        location.reload(true);
      }

      return false;
    } else {
      Session.set("confirmRemoveCurve", {
        label: this.label,
        color: this.color
      });
      $("#modal-confirm-remove-curve").modal();
    }
  },
  'click .confirm-remove-curve': function () {
    var confirmCurve = Session.get("confirmRemoveCurve");
    Session.set("confirmRemoveCurve", {
      label: confirmCurve.label,
      color: confirmCurve.color,
      confirm: true
    });
    $("#curve-list-remove").trigger('click');
  },
  'click .edit-curve-xaxis': function (event) {
    Session.set('axis', 'xaxis');
    Session.set('editMode', this.label);
    var currentParams = jQuery.extend({}, this);
    setParamsToAxis('xaxis', currentParams);
  },
  'click .edit-curve-yaxis': function (event) {
    Session.set('axis', 'yaxis');
    Session.set('editMode', this.label);
    var currentParams = jQuery.extend({}, this);
    setParamsToAxis('yaxis', currentParams);
  },
  'click .edit-curve': function (event) {
    var srcEditButton = event.currentTarget;
    var name = srcEditButton.name;
    var editingCurve = Session.get('editMode');
    curveListEditNode = $(event.currentTarget.parentNode.parentNode.parentNode.parentNode).find("#curve-list-edit");
    var eventTargetCurve = $(event.currentTarget.parentNode.parentNode.parentNode).find(".displayItemLabelSpan").text().trim();
    Session.set("eventTargetCurve", eventTargetCurve);
    Session.set("intendedActiveDisplayButton", name);
    Session.set("activeDisplayButton", name);

    if (editingCurve !== undefined && editingCurve !== "" && editingCurve !== eventTargetCurve) {
      // editing a different curve // have to do the modal for confirmation
      $("#confirm-lost-edits").modal();
      return;
    }

    Session.set('editMode', this.label); // reset scatter plot apply stuff

    matsCurveUtils.resetScatterApply(); // capture the current parameters from the curveItem

    var currentParams = jQuery.extend({}, this); // set param values to this curve
    // reset the form parameters for the superiors first

    var params = matsCollections.CurveParams.find({
      "dependentNames": {
        "$exists": true
      }
    }).fetch();

    for (var p = 0; p < params.length; p++) {
      var plotParam = params[p]; // do any curve date parameters

      if (plotParam.type === matsTypes.InputTypes.dateRange) {
        if (currentParams[plotParam.name] === undefined) {
          continue; // just like continue
        }

        var dateArr = currentParams[plotParam.name].split(' - ');
        var from = dateArr[0];
        var to = dateArr[1];
        var idref = "#" + plotParam.name + "-item";
        $(idref).data('daterangepicker').setStartDate(moment(from, 'MM-DD-YYYY HH:mm'));
        $(idref).data('daterangepicker').setEndDate(moment(to, 'MM-DD-YYYY HH:mm'));
        matsParamUtils.setValueTextForParamName(plotParam.name, currentParams[plotParam.name]);
      } else {
        var val = currentParams[plotParam.name] === null || currentParams[plotParam.name] === undefined ? matsTypes.InputTypes.unused : currentParams[plotParam.name];
        matsParamUtils.setInputForParamName(plotParam.name, val); // refresh its dependents

        matsSelectUtils.refreshDependents(null, plotParam);
      }
    } // now reset the form parameters for anything with hide/disable controls


    params = matsCollections.CurveParams.find({
      "$and": [{
        "dependentNames": {
          "$exists": false
        }
      }, {
        "$or": [{
          "hideOtherFor": {
            "$exists": true
          }
        }, {
          "disableOtherFor": {
            "$exists": true
          }
        }]
      }]
    }).fetch();

    for (var p = 0; p < params.length; p++) {
      var plotParam = params[p]; // do any plot date parameters

      if (plotParam.type === matsTypes.InputTypes.dateRange) {
        if (currentParams[plotParam.name] === undefined) {
          continue; // just like continue
        }

        var _dateArr2 = currentParams[plotParam.name].split(' - ');

        var _from2 = _dateArr2[0];
        var _to2 = _dateArr2[1];

        var _idref2 = "#" + plotParam.name + "-item";

        $(_idref2).data('daterangepicker').setStartDate(moment(_from2, 'MM-DD-YYYY HH:mm'));
        $(_idref2).data('daterangepicker').setEndDate(moment(_to2, 'MM-DD-YYYY HH:mm'));
        matsParamUtils.setValueTextForParamName(plotParam.name, currentParams[plotParam.name]);
      } else {
        var val = currentParams[plotParam.name] === null || currentParams[plotParam.name] === undefined ? matsTypes.InputTypes.unused : currentParams[plotParam.name];
        matsParamUtils.setInputForParamName(plotParam.name, val);
      }
    } // now reset the form parameters for everything else


    params = matsCollections.CurveParams.find({
      "$and": [{
        "dependentNames": {
          "$exists": false
        }
      }, {
        "$and": [{
          "hideOtherFor": {
            "$exists": false
          }
        }, {
          "disableOtherFor": {
            "$exists": false
          }
        }]
      }]
    }).fetch();

    for (var p = 0; p < params.length; p++) {
      var plotParam = params[p]; // do any plot date parameters

      if (plotParam.type === matsTypes.InputTypes.dateRange) {
        if (currentParams[plotParam.name] === undefined) {
          continue; // just like continue
        }

        var _dateArr3 = currentParams[plotParam.name].split(' - ');

        var _from3 = _dateArr3[0];
        var _to3 = _dateArr3[1];

        var _idref3 = "#" + plotParam.name + "-item";

        $(_idref3).data('daterangepicker').setStartDate(moment(_from3, 'MM-DD-YYYY HH:mm'));
        $(_idref3).data('daterangepicker').setEndDate(moment(_to3, 'MM-DD-YYYY HH:mm'));
        matsParamUtils.setValueTextForParamName(plotParam.name, currentParams[plotParam.name]);
      } else {
        var val = currentParams[plotParam.name] === null || currentParams[plotParam.name] === undefined ? matsTypes.InputTypes.unused : currentParams[plotParam.name];
        matsParamUtils.setInputForParamName(plotParam.name, val);
      }
    } // reset the scatter parameters


    params = matsCollections.Scatter2dParams.find({}).fetch();

    for (var p = 0; p < params.length; p++) {
      var plotParam = params[p];

      var _val3 = currentParams[plotParam.name] === null || currentParams[plotParam.name] === undefined ? matsTypes.InputTypes.unused : currentParams[plotParam.name];

      matsParamUtils.setInputForParamName(plotParam.name, _val3);
    }

    matsParamUtils.collapseParams();
    return false;
  },
  'hidePicker': function () {
    var Curves = Session.get('Curves');
    var label = this.label;

    for (var i = 0; i < Curves.length; i++) {
      if (label === Curves[i].label) {
        Curves[i].color = document.getElementById(label + "-color-value").value;
      }
    }

    Session.set('Curves', Curves);
    return false;
  },
  'click .displayBtn': function (event) {
    var srcDisplayButton = event.currentTarget;
    var name = srcDisplayButton.name;
    var inputElem = matsParamUtils.getInputElementForParamName(name);
    var controlElem = matsParamUtils.getControlElementForParamName(name);
    var editingCurve = Session.get('editMode');

    if (name.startsWith('xaxis')) {
      curveListEditNode = $(event.currentTarget.parentNode.parentNode.parentNode.parentNode).find("#curve-list-edit-xaxis");
    } else if (name.startsWith('yaxis')) {
      curveListEditNode = $(event.currentTarget.parentNode.parentNode.parentNode.parentNode).find("#curve-list-edit-yaxis");
    } else {
      if (matsPlotUtils.getPlotType() === matsTypes.PlotTypes.scatter2d) {
        // for a scatter param that is not axis specific we still have to choos an axis - just choose x
        curveListEditNode = $(event.currentTarget.parentNode.parentNode.parentNode.parentNode).find("#curve-list-edit-xaxis");
      } else {
        curveListEditNode = $(event.currentTarget.parentNode.parentNode.parentNode.parentNode).find("#curve-list-edit");
      }
    }

    var eventTargetCurve = $(event.currentTarget.parentNode.parentNode.parentNode).find(".displayItemLabelSpan").text().trim();
    Session.set("eventTargetCurve", eventTargetCurve);
    Session.set("intendedActiveDisplayButton", name);
    Session.set("activeDisplayButton", name);

    if (editingCurve !== undefined && editingCurve !== "" && editingCurve !== eventTargetCurve) {
      // editing a different curve // have to do the modal for confirmation
      $("#confirm-lost-edits").modal();
      return;
    }

    inputElem && inputElem.focus();
    curveListEditNode.click();
    controlElem && controlElem.click();
    Session.set("elementChanged", Date.now());
  },
  'click .continue-lose-edits': function () {
    var intendedName = Session.get("intendedActiveDisplayButton");
    var activeDisplayButton = Session.set("activeDisplayButton", intendedName);
    document.getElementById('cancel').click();
    Session.set("paramWellColor", "#f5f5f5");
    var controlElem = matsParamUtils.getControlElementForParamName(intendedName);
    var inputElem = matsParamUtils.getInputElementForParamName(intendedName);
    inputElem && inputElem.focus();
    curveListEditNode.click();
    controlElem && controlElem.click();
    Session.set("elementChanged", Date.now());
  },
  'click .cancle-lose-edits': function () {
    // don't change the active button
    var name = Session.get("activeDisplayButton");
    var controlElem = matsParamUtils.getControlElementForParamName(name);
    var inputElem = matsParamUtils.getInputElementForParamName(name);
    inputElem && inputElem.focus();
    controlElem && controlElem.click();
    Session.set("elementChanged", Date.now());
  },
  'click .fa-paint-brush': function () {
    $("#" + this.label + "-color-value").trigger('click');
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.curve_param_item_group.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/curves/template.curve_param_item_group.js                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("curveParamItemGroup");
Template["curveParamItemGroup"] = new Template("Template.curveParamItemGroup", (function() {
  var view = this;
  return HTML.DIV({
    id: "curveParamItemGroup"
  }, "\n        ", HTML.DIV({
    class: "modal modal-dialog fade",
    id: "confirm-lost-edits",
    tabindex: "-1",
    role: "dialog",
    "aria-labelledby": "confirmLostEdits",
    "aria-hidden": "true",
    style: "background-color: cornflowerblue"
  }, "\n            ", HTML.DIV({
    class: "modal-dialog"
  }, "\n                ", HTML.DIV({
    class: "modal-content"
  }, HTML.Raw('<i class="fa fa-4x fa-question" style="color:cornflowerblue"></i>'), "\n                    ", HTML.Raw('<h2 class="modal-title" style="text-align: center; color: red;">Lose Edits?</h2>'), "\n                    ", HTML.DIV({
    class: "modal-body"
  }, "\n                        ", HTML.H4({
    style: "color:cornflowerblue"
  }, "\n                            You were editing ", Blaze.View("lookup:editCurve", function() {
    return Spacebars.mustache(view.lookup("editCurve"));
  }), " and clicked on controls for ", Blaze.View("lookup:editTarget", function() {
    return Spacebars.mustache(view.lookup("editTarget"));
  }), "\n                        "), "\n                        ", HTML.H4({
    style: "color:red"
  }, "\n                            Any changes to ", Blaze.View("lookup:editCurve", function() {
    return Spacebars.mustache(view.lookup("editCurve"));
  }), " will be lost if you continue.\n                        "), "\n                    "), "\n                    ", HTML.DIV({
    class: "modal-footer"
  }, "\n                        ", HTML.BUTTON({
    id: "cancle-lose-edits",
    class: "cancle-lose-edits btn btn-success",
    "data-dismiss": "modal"
  }, "Cancel and keep editing ", Blaze.View("lookup:editCurve", function() {
    return Spacebars.mustache(view.lookup("editCurve"));
  })), "\n                        ", HTML.BUTTON({
    id: "continue-lose-edits",
    class: "btn btn-danger continue-lose-edits",
    "data-dismiss": "modal"
  }, "Edit ", Blaze.View("lookup:editTarget", function() {
    return Spacebars.mustache(view.lookup("editTarget"));
  }), " and lose changes to ", Blaze.View("lookup:editCurve", function() {
    return Spacebars.mustache(view.lookup("editCurve"));
  })), "\n                    "), "\n                "), "\n            "), "\n        "), "\n\n        ", Blaze.Each(function() {
    return Spacebars.dataMustache(view.lookup("curveParamGroups"), view.lookup("."));
  }, function() {
    return [ "\n                ", HTML.DIV({
      class: "btn-toolbar btn-toolbar-xs",
      role: "toolbar"
    }, "\n                    ", Blaze.Each(function() {
      return Spacebars.dataMustache(view.lookup("curveParams"), view.lookup("."));
    }, function() {
      return [ "\n                        ", HTML.BUTTON({
        type: "button",
        class: "displayBtn btn btn-sm btn-default",
        name: function() {
          return Spacebars.mustache(view.lookup("name"), view.lookup("."));
        },
        id: function() {
          return Spacebars.mustache(view.lookup("buttonId"), view.lookup("."));
        },
        style: function() {
          return [ "margin:3px 3px 3px 3px;border:", Spacebars.mustache(view.lookup("border"), view.lookup(".")), ";border-radius:10px;display:", Spacebars.mustache(view.lookup("displayParam"), view.lookup(".")) ];
        }
      }, "\n                            ", HTML.LABEL({
        for: function() {
          return Spacebars.mustache(view.lookup("buttonId"), view.lookup("."));
        }
      }, Blaze.View("lookup:label", function() {
        return Spacebars.mustache(view.lookup("label"), view.lookup("."));
      }), ":", HTML.CharRef({
        html: "&nbsp;",
        str: ""
      }), HTML.CharRef({
        html: "&nbsp;",
        str: ""
      })), "\n                            ", HTML.SPAN({
        class: "displayItemSpan",
        id: function() {
          return Spacebars.mustache(view.lookup("spanId"), view.lookup("."));
        }
      }, Blaze.View("lookup:value", function() {
        return Spacebars.mustache(view.lookup("value"), view.lookup("."));
      })), "\n                        "), "\n                    " ];
    }), "\n                "), "\n            " ];
  }), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"curve_param_item_group.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/curves/curve_param_item_group.js                                              //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 2);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 3);
var allGroups = {};
Template.curveParamItemGroup.helpers({
  curveParamGroups: function (c) {
    var label = c.label;
    var curves = Session.get("Curves");
    var index = curves.findIndex(function (obj) {
      return obj.label === label;
    }); // create a set of groups each with an array of 6 params for display

    var lastUpdate = Session.get('lastUpdate');
    var plotType = matsPlotUtils.getPlotType();
    var elmementValues = matsParamUtils.getElementValues().curveParams; // derive the sorted pValues, xpValues, and ypValues from the sorted params and the elementValues

    var pValues = [];
    var pattern;

    switch (plotType) {
      case matsTypes.PlotTypes.profile:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.profile
        });
        break;

      case matsTypes.PlotTypes.dieoff:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.dieoff
        });
        break;

      case matsTypes.PlotTypes.threshold:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.threshold
        });
        break;

      case matsTypes.PlotTypes.validtime:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.validtime
        });
        break;

      case matsTypes.PlotTypes.dailyModelCycle:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.dailyModelCycle
        });
        break;

      case matsTypes.PlotTypes.reliability:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.reliability
        });
        break;

      case matsTypes.PlotTypes.map:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.map
        });
        break;

      case matsTypes.PlotTypes.histogram:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.histogram
        });
        break;

      case matsTypes.PlotTypes.contour:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.contour
        });
        break;

      case matsTypes.PlotTypes.contourDiff:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.contourDiff
        });
        break;

      case matsTypes.PlotTypes.scatter2d:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.scatter2d
        });
        break;

      case matsTypes.PlotTypes.timeSeries:
      default:
        pattern = matsCollections.CurveTextPatterns.findOne({
          plotType: matsTypes.PlotTypes.timeSeries
        });
        break;
    }

    var groupSize = pattern.groupSize;
    var displayParams = pattern.displayParams;

    for (var di = 0; di < displayParams.length; di++) {
      pValues.push({
        name: displayParams[di],
        value: c[displayParams[di]],
        color: c.color,
        curve: c.label,
        index: index
      });
    } // create array of parameter value display groups each of groupSize


    var pGroups = [];
    var groupParams = [];
    var pvi = 0;

    while (pvi < pValues.length) {
      if (pValues[pvi] && (pValues[pvi].name == 'xaxis' || pValues[pvi].name == 'yaxis')) {
        if (groupParams.length > 0) {
          // finish the old group and make a new group for 'xaxis' or 'yaxis'
          pGroups.push(groupParams);
        }

        groupParams = [];
      }

      pValues[pvi] && groupParams.push(pValues[pvi]);

      if (groupParams.length >= groupSize) {
        pGroups.push(groupParams);
        groupParams = [];
      }

      pvi++;
    } // check for a partial last group


    if (groupParams.length > 0) {
      pGroups.push(groupParams);
    }

    allGroups[c.label] = pGroups;
    return pGroups;
  },
  curveNumber: function (elem) {
    return elem.index;
  },
  curveParams: function (paramGroup) {
    return paramGroup;
  },
  label: function (elem) {
    if (matsPlotUtils.getPlotType() === matsTypes.PlotTypes.scatter2d) {
      var pNameArr = elem.name.match(/([xy]axis-)(.*)/);

      if (pNameArr === null) {
        return elem.name.toUpperCase();
      }

      var prefix = pNameArr[1];
      var pName = pNameArr[2];
      var p = matsCollections.CurveParams.findOne({
        name: pName
      });

      if (p.controlButtonText) {
        return (prefix + p.controlButtonText).toUpperCase();
      } else {
        return elem.name.toUpperCase();
      }
    } else {
      var _p = matsCollections.CurveParams.findOne({
        name: elem.name
      });

      if (_p.controlButtonText) {
        return _p.controlButtonText.toUpperCase();
      } else {
        return elem.name.toUpperCase();
      }
    } // should never get here


    return elem.name.toUpperCase();
  },
  name: function (elem) {
    return elem.name;
  },
  id: function (elem) {
    return elem.name;
  },
  buttonId: function (elem) {
    var name = new String(elem.name);
    var upperName = name.toUpperCase();
    var curveNumber = elem.index;
    var spanId = upperName + "-curve-" + curveNumber + "-Button";
    return spanId;
  },
  spanId: function (elem) {
    var name = new String(elem.name);
    var upperName = name.toUpperCase();
    var curveNumber = elem.index;
    var spanId = upperName + "-curve-" + curveNumber + "-Item";
    return spanId;
  },
  value: function (elem) {
    // have to get this from the session
    var curve = Session.get("Curves")[elem.index];

    if (curve === undefined) {
      return "";
    }

    var value = curve[elem.name];
    var text = "";

    if (Object.prototype.toString.call(value) === '[object Array]') {
      if (value.length === 1) {
        text = value[0];
      } else if (value.length > 1) {
        text = value[0] + " .. " + value[value.length - 1];
      }
    } else {
      text = value;
    }

    return text;
  },
  defaultColor: function (elem) {
    return elem.color;
  },
  border: function (elem) {
    var elementChanged = Session.get("elementChanged");
    var name = elem.name; // for xaxis params

    var curve = elem.curve;
    var adb = name === Session.get("activeDisplayButton");
    var isEditMode = curve === Session.get("editMode");
    var inputElemIsVisible = matsParamUtils.isInputElementVisible(name);

    if (adb && isEditMode && inputElemIsVisible) {
      return "solid";
    }

    return "";
  },
  editCurve: function () {
    return Session.get('editMode');
  },
  editTarget: function () {
    return Session.get("eventTargetCurve");
  },
  displayParam: function (elem) {
    if (elem.name === "label") {
      return "none";
    } // it isn't good enough to just check the item control button. Need to evaluate the hideOtherFor functionality with
    // respect to this particular curve item
    // First - determine if my visibility is controlled by another


    var visibilityControllingParam = matsParamUtils.visibilityControllerForParam(elem.name); // Second - Check the hide/show state based on the parameter hideOtherFor map in the parameter nad the state of this particular curve

    if (visibilityControllingParam !== undefined) {
      var curve = Session.get("Curves")[elem.index];
      var hideOtherFor = visibilityControllingParam.hideOtherFor[elem.name][0];

      if (curve !== undefined && visibilityControllingParam !== undefined && curve[visibilityControllingParam.name] !== undefined && curve[visibilityControllingParam.name] === hideOtherFor) {
        return "none";
      }
    }

    return "block";
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.curve_list.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/curves/template.curve_list.js                                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("curveList");
Template["curveList"] = new Template("Template.curveList", (function() {
  var view = this;
  return [ HTML.Raw('<div class="modal modal-dialog fade" id="modal-confirm-remove-all" tabindex="-1" role="dialog" aria-labelledby="confirmRemoveAll" aria-hidden="true" style="background-color: cornflowerblue">\n        <div class="modal-dialog">\n            <div class="modal-content"><i class="fa fa-4x fa-question" style="color:cornflowerblue"></i>\n                <h2 class="modal-title" style="text-align: center; color: red;">Remove All Curves?</h2>\n                <div class="modal-body">\n                    <h4 style="color:cornflowerblue">\n                        Are you sure you want to remove all the curves?\n                    </h4>\n                </div>\n                <div class="modal-footer">\n                    <button id="cancle-remove-all" class="cancle-remove-all btn btn-success" data-dismiss="modal">Cancel the Remove</button>\n                    <button id="confirm-remove-all" class="btn btn-danger confirm-remove-all" data-dismiss="modal">Remove all the curves</button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    '), HTML.DIV({
    id: "curveList",
    class: "well-sm clearfix col-lg-12",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("displayCurves")), ";" ];
    }
  }, "\n        ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("curves"));
  }, function() {
    return [ "\n            ", Blaze._TemplateWith(function() {
      return Spacebars.call(view.lookup("."));
    }, function() {
      return Spacebars.include(view.lookupTemplate("curveItem"));
    }), "\n        " ];
  }), "\n        ", HTML.DIV({
    class: "clearfix btn-toolbar  well well-sm pull-left",
    role: "toolbar"
  }, "\n            ", HTML.Raw('<button id="remove-all" class="remove-all btn btn-danger fa fa-times fa-sm">&nbsp;&nbsp;Remove All </button>'), "\n            ", HTML.BUTTON({
    type: "button",
    name: "save",
    id: "save ",
    class: "save-settings btn btn-success fa fa-cloud-upload",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("displaySaveSettings")), ";" ];
    }
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Save All Curve Settings"), "\n            ", HTML.Raw('<button type="button" class="btn spacebutton" id="cl-spacer"></button>'), "\n            ", HTML.BUTTON(HTML.Attrs({
    type: "button",
    name: "plotUnMatched",
    id: "plotUnmatched",
    class: "plot-curves-unmatched btn btn-success  fa fa-area-chart",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("displayPlotUnMatched")), ";" ];
    }
  }, function() {
    return Spacebars.attrMustache(view.lookup("identicalContourDisabled"));
  }, function() {
    return Spacebars.attrMustache(view.lookup("mismatchContourDiffDisabled"));
  }), HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Plot Unmatched"), "\n            ", HTML.BUTTON(HTML.Attrs({
    type: "button",
    name: "plotMatched",
    id: "plotMatched",
    class: "plot-curves-matched btn btn-success  fa fa-area-chart",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("displayPlotMatched")), ";" ];
    }
  }, function() {
    return Spacebars.attrMustache(view.lookup("averagesDisabled"));
  }, function() {
    return Spacebars.attrMustache(view.lookup("identicalContourDisabled"));
  }, function() {
    return Spacebars.attrMustache(view.lookup("mismatchContourDiffDisabled"));
  }), "  Plot Matched"), "\n            ", HTML.DIV({
    id: "disabledPlots",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("disabledPlotsHidden")) ];
    }
  }, HTML.Raw('<span style="color: red;">Matched plotting is disabled because curve averages are disparate</span>')), "\n            ", HTML.DIV({
    id: "identicalContour",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("identicalContourHidden")) ];
    }
  }, HTML.Raw('<span style="color: red;">Making contour plots with the same parameter on both axes is not recommended</span>')), "\n            ", HTML.DIV({
    id: "identicalContour",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("mismatchContourDiffHidden")) ];
    }
  }, HTML.Raw('<span style="color: red;">The x-axis-parameter and y-axis-parameter must be consistent across both curves</span>')), "\n        "), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"curve_list.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/curves/curve_list.js                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 2);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 3);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 4);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 5);
Template.curveList.helpers({
  displayPlotUnMatched: function () {
    // scatter plots can't match
    if (Session.get('plotType') === matsTypes.PlotTypes.scatter2d) {
      return "none";
    } // don't allow plotting when editing


    var mode = Session.get("editMode");

    if (mode === undefined || mode === "") {
      return "block";
    } else {
      return "none";
    }
  },
  displayPlotMatched: function () {
    // don't allow plotting when editing
    var mode = Session.get("editMode");

    if (mode === undefined || mode === "") {
      return "block";
    } else {
      return "none";
    }
  },
  displaySaveSettings: function () {
    // don't allow saving settings when editing
    var mode = Session.get("editMode");

    if (mode === undefined || mode === "") {
      return "block";
    } else {
      return "none";
    }
  },
  curves: function () {
    return Session.get('Curves');
  },
  displayCurves: function () {
    if (Session.get('Curves') === undefined || Session.get('Curves').length === 0) {
      return "none";
    } else {
      return "block";
    }
  },
  log: function () {
    console.log(this);
  },
  averagesDisabled: function () {
    var curves = Session.get('Curves');

    if (curves === undefined || curves.length == 0 || Session.get('plotType') !== matsTypes.PlotTypes.timeSeries) {
      return "";
    }

    var average = curves[0].average;

    for (var i = 0; i < curves.length; i++) {
      if (average != curves[i].average) {
        return "disabled";
      }
    }
  },
  disabledPlotsHidden: function () {
    var curves = Session.get('Curves');

    if (curves === undefined || curves.length == 0 || Session.get('plotType') !== matsTypes.PlotTypes.timeSeries) {
      return "none";
    }

    var average = curves[0].average;

    for (var i = 0; i < curves.length; i++) {
      if (average != curves[i].average) {
        return "block";
      }
    }

    return "none";
  },
  identicalContourDisabled: function () {
    var curves = Session.get('Curves');

    if (curves === undefined || curves.length == 0 || Session.get('plotType') !== matsTypes.PlotTypes.contour) {
      return "";
    }

    var xAxis = curves[0]['x-axis-parameter'];
    var yAxis = curves[0]['y-axis-parameter'];

    if (xAxis === yAxis) {
      return "disabled";
    }

    return "";
  },
  identicalContourHidden: function () {
    var curves = Session.get('Curves');

    if (curves === undefined || curves.length == 0 || Session.get('plotType') !== matsTypes.PlotTypes.contour) {
      return "none";
    }

    var xAxis = curves[0]['x-axis-parameter'];
    var yAxis = curves[0]['y-axis-parameter'];

    if (xAxis === yAxis) {
      return "block";
    }

    return "none";
  },
  mismatchContourDiffDisabled: function () {
    var curves = Session.get('Curves');

    if (curves === undefined || curves.length < 2 || Session.get('plotType') !== matsTypes.PlotTypes.contourDiff) {
      return "";
    }

    var xAxis0 = curves[0]['x-axis-parameter'];
    var yAxis0 = curves[0]['y-axis-parameter'];
    var xAxis1 = curves[1]['x-axis-parameter'];
    var yAxis1 = curves[1]['y-axis-parameter'];

    if (xAxis0 !== xAxis1 || yAxis0 !== yAxis1) {
      return "disabled";
    }

    return "";
  },
  mismatchContourDiffHidden: function () {
    var curves = Session.get('Curves');

    if (curves === undefined || curves.length < 2 || Session.get('plotType') !== matsTypes.PlotTypes.contourDiff) {
      return "none";
    }

    var xAxis0 = curves[0]['x-axis-parameter'];
    var yAxis0 = curves[0]['y-axis-parameter'];
    var xAxis1 = curves[1]['x-axis-parameter'];
    var yAxis1 = curves[1]['y-axis-parameter'];

    if (xAxis0 !== xAxis1 || yAxis0 !== yAxis1) {
      return "block";
    }

    return "none";
  },
  editMode: function () {
    if (Session.get('editMode') === '') {
      return '';
    } else {
      return "Changing " + Session.get('editMode');
    }
  },
  matchedLabel: function () {
    if (Session.get('matchName' === undefined)) {
      if (setMatchName) {
        setMatchName();
      } else {
        Session.set('matchName', 'plot matched');
      }
    } else {
      Session.set('matchName', 'plot matched');
    }

    return Session.get('matchName');
  }
});
Template.curveList.events({
  'click .remove-all': function () {
    if (Session.get("confirmRemoveAll")) {
      matsCurveUtils.clearAllUsed();
      matsParamUtils.setAllParamsToDefault();
      Session.set("editMode", "");
      Session.set("paramWellColor", "#f5f5f5"); // default grey

      Session.set("lastUpdate", Date.now());
      Session.set("confirmRemoveAll", "");
      return false;
    } else {
      if (Session.get("Curves").length > 0) {
        $("#modal-confirm-remove-all").modal();
      }
    }
  },
  'click .confirm-remove-all': function () {
    Session.set("confirmRemoveAll", Date.now());
    $("#remove-all").trigger('click');
  },
  'click .plot-curves-unmatched': function (event) {
    document.getElementById("spinner").style.display = "block";
    matsPlotUtils.disableActionButtons();
    event.preventDefault(); // trigger the submit on the plot_list plot_list.js - click .submit-params

    Session.set('plotParameter', matsTypes.PlotActions.unmatched);
    document.getElementById("plot-curves").click();
    return false;
  },
  'click .plot-curves-matched': function (event) {
    document.getElementById("spinner").style.display = "block";
    matsPlotUtils.disableActionButtons();
    event.preventDefault(); // trigger the submit on the plot_list plot_list.js - click .submit-params

    Session.set('plotParameter', matsTypes.PlotActions.matched);
    document.getElementById("plot-curves").click();
    return false;
  },
  'click .save-settings': function (event) {
    event.preventDefault();
    document.getElementById("save-settings").click();
    return false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"params":{"template.param_list.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/params/template.param_list.js                                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("paramList");
Template["paramList"] = new Template("Template.paramList", (function() {
  var view = this;
  return HTML.DIV({
    id: "paramList",
    class: "clearfix  pull-left"
  }, "\n        ", HTML.FORM({
    id: "paramForm",
    name: "paramForm",
    novalidate: ""
  }, "\n            ", HTML.DIV({
    id: "paramWell",
    class: "clearfix well well-sm pull-left",
    style: function() {
      return [ "background-blend-mode: lighten; background-color: ", Spacebars.mustache(view.lookup("paramWellColor")), ";" ];
    }
  }, "\n            ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("CurveParamGroups"));
  }, function() {
    return [ "\n                ", Spacebars.include(view.lookupTemplate("curveParamGroup")), "\n            " ];
  }), "\n            "), "\n            ", Blaze.If(function() {
    return Spacebars.call(view.lookup("isEdit"));
  }, function() {
    return [ "\n                ", HTML.DIV({
      class: "row clearfix well-sm col-lg-12 pull-left btn-toolbar btn-group btn-lg",
      role: "toolbar"
    }, "\n                    ", HTML.BUTTON({
      type: "submit",
      name: "save",
      id: "save",
      class: "btn btn-success fa fa-line-chart"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Save Changes"), "\n                    ", HTML.BUTTON({
      type: "button",
      name: "cancel",
      id: "cancel",
      class: "edit-cancel btn btn-info fa icon-remove-sign"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Cancel"), "\n                "), "\n            " ];
  }, function() {
    return [ "\n                ", HTML.DIV({
      class: "row clearfix well-sm col-lg-12 pull-left btn-toolbar btn-group btn-lg",
      role: "toolbar"
    }, "\n                    ", HTML.BUTTON({
      type: "submit",
      name: "add",
      id: "add",
      class: "btn btn-success fa fa-line-chart"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Add Curve"), "\n                    ", HTML.BUTTON({
      type: "button",
      name: "restore",
      id: "restore",
      class: "restore-settings btn btn-success  fa fa-cloud-download"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Restore Settings"), "\n                    ", HTML.BUTTON({
      type: "button",
      name: "reset",
      id: "reset",
      class: "reset btn btn-success fa fa-refresh"
    }, HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), "Reset to Defaults"), "\n                "), "\n            " ];
  }), "\n        "), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"param_list.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/params/param_list.js                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 2);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 3);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 4);
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 5);

function shadeRGBColor(color, percent) {
  var f = color.split(","),
      t = percent < 0 ? 0 : 255,
      p = percent < 0 ? percent * -1 : percent,
      R = parseInt(f[0].slice(4)),
      G = parseInt(f[1]),
      B = parseInt(f[2]);
  return "rgb(" + (Math.round((t - R) * p) + R) + "," + (Math.round((t - G) * p) + G) + "," + (Math.round((t - B) * p) + B) + ")";
}

Template.paramList.helpers({
  CurveParamGroups: function () {
    var lastUpdate = Session.get('lastUpdate');
    var groupNums = [];
    var params = matsCollections.CurveParams.find({}).fetch();

    for (var i = 0; i < params.length; i++) {
      groupNums.push(params[i].displayGroup);
    }

    var res = _.uniq(groupNums).sort();

    return res;
  },
  isEdit: function () {
    return Session.get('editMode') != '';
  },
  log: function () {
    console.log(this);
  },
  paramWellColor: function () {
    if (Session.get("paramWellColor") === undefined) {
      Session.set("paramWellColor", "rgb(245,245,245)");
    }

    if (Session.get("editMode") !== "") {
      var curveBeingEdited = $.grep(Session.get("Curves"), function (c) {
        return c.label == Session.get("editMode");
      });

      if (curveBeingEdited === undefined || curveBeingEdited[0] === undefined) {
        Session.set("paramWellColor", "rgb(245,245,245)");
        return "rgb(245,245,245)";
      }

      var color = curveBeingEdited[0].color;
      var lighterShadeOfColor = shadeRGBColor(color, 0.2);
      Session.set("paramWellColor", lighterShadeOfColor);
    }

    return Session.get("paramWellColor");
  }
});
Template.paramList.events({
  'click .edit-cancel': function () {
    Session.set('editMode', '');
    Session.set("paramWellColor", "rgb(245,245,245)");
    var labelId = 'label-' + matsTypes.InputTypes.textInput;
    var label = document.getElementById(labelId);
    label.disabled = false; // reset parameters to match edited curve.....

    matsParamUtils.setInputForParamName('label', matsCurveUtils.getNextCurveLabel());
    matsParamUtils.collapseParams();
  },
  'click .reset': function (event, template) {
    var plotType = $('input[name=plot-type]:checked').val();
    event.preventDefault();
    Session.set("paramWellColor", "rgb(245,245,245)");
    var paramView = document.getElementById('paramList');
    var plotView = document.getElementById('plotList');
    document.getElementById('plot-type-' + plotType).checked = true;
    matsMethods.refreshMetaData.call({}, function (error, result) {
      if (error !== undefined) {
        setError(new Error(error.message));
      }

      matsParamUtils.setAllParamsToDefault();
    });
  },
  'click .expand': function () {
    matsParamUtils.expandParams();
  },
  'click .collapse': function () {
    matsParamUtils.collapseParams();
  },
  // restore settings
  'click .restore-settings': function (event) {
    Session.set("paramWellColor", "rgb(245,245,245)");
    event.preventDefault();
    document.getElementById("restore-settings").click();
    return false;
  },
  // add curve
  // save changes

  /*
      Note: when adding a curve or saving changes after editing a curve there is a special
      case for scatter plots. Each hidden axis parameter must get set with the value from the regular parameter.
   */
  'submit form': function (event, template) {
    event.preventDefault();

    if (!matsParamUtils.getValueForParamName('label')) {
      setError('Label cannot be blank');
      return;
    }

    var isScatter = matsPlotUtils.getPlotType() === matsTypes.PlotTypes.scatter2d;
    var isMap = matsPlotUtils.getPlotType() === matsTypes.PlotTypes.map;
    var isReliability = matsPlotUtils.getPlotType() === matsTypes.PlotTypes.reliability;
    var isContour = matsPlotUtils.getPlotType() === matsTypes.PlotTypes.contour;
    var isContourDiff = matsPlotUtils.getPlotType() === matsTypes.PlotTypes.contourDiff;
    var curves = Session.get('Curves');
    var p = {};
    var elems = event.target.valueOf().elements;
    var curveParams = matsCollections.CurveParams.find({}, {
      fields: {
        name: 1
      }
    }).fetch();

    var curveNames = _.pluck(curveParams, "name"); // remove any hidden params or unused ones
    // iterate backwards so that we can splice to remove


    for (var cindex = curveNames.length - 1; cindex >= 0; cindex--) {
      var cname = curveNames[cindex];
      var ctlElem = document.getElementById(cname + "-item");
      var isHidden = matsParamUtils.getInputElementForParamName(cname) && matsParamUtils.getInputElementForParamName(cname).style && matsParamUtils.getInputElementForParamName(cname).style.display === 'none' || ctlElem && ctlElem.style && ctlElem.style.display === 'none';
      var isUnused = matsParamUtils.getInputElementForParamName(cname) !== undefined && matsParamUtils.getValueForParamName(cname) == matsTypes.InputTypes.unused;

      if (isHidden || isUnused) {
        //if (isHidden) {
        curveNames.splice(cindex, 1);
      }
    }

    var dateParams = matsCollections.CurveParams.find({
      type: matsTypes.InputTypes.dateRange
    }, {
      fields: {
        name: 1
      }
    }).fetch();

    var dateParamNames = _.pluck(dateParams, "name"); // remove any hidden date params or unused ones
    // iterate backwards so that we can splice to remove
    // dates are a little different - there is no element named paramName-paramtype because of the way daterange widgets are attached
    // Instead we have to look for a document element with an id element-paramName


    for (var dindex = dateParamNames.length - 1; dindex >= 0; dindex--) {
      var dElem = document.getElementById(dateParamNames[dindex] + "-item");

      if (dElem && dElem.style && dElem.style.display === 'none') {
        dateParamNames.splice(dindex, 1);
      }
    }

    if (isScatter) {
      var scatterCurveNames = [];

      for (var i = 0; i < curveNames.length; i++) {
        scatterCurveNames.push(curveNames[i]);
        scatterCurveNames.push("xaxis-" + curveNames[i]);
        scatterCurveNames.push("yaxis-" + curveNames[i]);
      }

      curveNames = scatterCurveNames;
    }

    var paramElems = _.filter(elems, function (elem) {
      return _.contains(curveNames, elem.name);
    }); // add in any date params (they aren't technically elements)


    paramElems.push.apply(paramElems, dateParamNames); // add in the scatter2d parameters if it is a scatter plot.

    if (isScatter) {
      $(":input[id^='Fit-Type']:input[name*='Fit-Type']").each(function () {
        paramElems.push(this);
      });
    }

    var l = paramElems.length;

    if (Session.get('editMode')) {
      var changingCurveLabel = Session.get('editMode');
      Session.set('editMode', '');
      Session.set("paramWellColor", "rgb(245,245,245)");
      var labelId = 'label-' + matsTypes.InputTypes.textInput;
      var label = document.getElementById(labelId);
      label.disabled = false;

      for (var i = 0; i < l; i++) {
        if (paramElems[i].name == "label") {
          p[paramElems[i].name] = changingCurveLabel; // don't change the label when editing a curve

          continue;
        }

        if (paramElems[i] instanceof Element === false) {
          // isn't really an element - must be a date field - these are only strings
          p[paramElems[i]] = matsParamUtils.getValueForParamName(paramElems[i]);
        } else if (paramElems[i].type === "select-multiple") {
          // define a p value if it doesn't exist (necessary for adding truth values)
          p[paramElems[i].name] = p[paramElems[i].name] === undefined ? "" : p[paramElems[i].name];
          p[paramElems[i].name] = $(paramElems[i].selectedOptions).map(function () {
            return this.value;
          }).get();
        } else {
          if (paramElems[i].type === "radio") {
            if (paramElems[i].checked) {
              p[paramElems[i].name] = paramElems[i].value;
            }
          } else if (paramElems[i].type === "checkbox") {
            if (paramElems[i].checked) {
              p[paramElems[i].name].push(paramElems[i].value);
            }
          } else if (paramElems[i].type === "button") {
            p[paramElems[i].id] = paramElems[i].value;
          } else {
            p[paramElems[i].name] = paramElems[i].value;
          }
        }
      }

      var index = -1;

      for (var i = 0; i < curves.length; i++) {
        if (curves[i].label === p.label) {
          index = i;
          p.color = curves[i].color;
        }
      }

      if (index != -1) {
        if (isScatter) {
          // copy the params to the current axis paremeters
          var axis = Session.get('axis');
          var axisParams = Object.keys(p).filter(function (key) {
            return key.startsWith(axis);
          });

          for (var api = 0; api < axisParams.length; api++) {
            var ap = axisParams[api];
            var pp = ap.replace(axis + '-', '');
            p[ap] = p[pp];
            curves[index][ap] = p[pp];
          }

          curves[index]['Fit-Type'] = p['Fit-Type'];
        } else {
          curves[index] = p;
        }
      }
    } else {
      if (isMap && curves.length >= 1) {
        setError(new Error('ERROR: Map plot-type can only have one curve!'));
        return false;
      } else if (isContour && curves.length >= 1) {
        setError(new Error('ERROR: Contour plot-type can only have one curve!'));
        return false;
      } else if (isContourDiff && curves.length >= 2) {
        setError(new Error('ERROR: Contour Diff plot-type can only have two curves!'));
        return false;
      } else if (isReliability && curves.length >= 1) {
        setError(new Error('ERROR: Reliability plot-type can only have one curve right now!'));
        return false;
      } else {
        for (var i = 0; i < l; i++) {
          if (paramElems[i] instanceof Element === false) {
            // isn't really an element - must be a date field - these are only strings
            p[paramElems[i]] = matsParamUtils.getValueForParamName(paramElems[i]);
          } else if (paramElems[i].type === "select-multiple") {
            p[paramElems[i].name] = $(paramElems[i].selectedOptions).map(function () {
              return this.value;
            }).get();
          } else {
            if (paramElems[i].type === "radio") {
              if (paramElems[i].checked) {
                p[paramElems[i].name] = paramElems[i].value;
              }
            } else if (paramElems[i].type === "checkbox") {
              if (paramElems[i].checked) {
                if (p[paramElems[i].name] === undefined) {
                  p[paramElems[i].name] = [];
                }

                p[paramElems[i].name].push(paramElems[i].value);
              }
            } else if (paramElems[i].type === "button") {
              p[paramElems[i].id] = paramElems[i].value;
            } else {
              if (isScatter) {
                p[paramElems[i].name] = paramElems[i].value;
              } else {
                p[paramElems[i].name] = matsParamUtils.getValueForParamName(paramElems[i].name);
              }
            }
          }

          if (paramElems[i].name && paramElems[i].name === 'label') {
            if (_.indexOf(matsCurveUtils.getUsedLabels(), paramElems[i].value) != -1) {
              setError(new Error('labels need to be unique - change ' + paramElems[i].value + " to something else"));
              return false;
            }
          }
        }
      }

      p.color = matsCurveUtils.getNextCurveColor();
      curves.push(p);
      var elem = document.getElementById("curveList");
      elem.style.display = "block";
    }

    Session.set('Curves', curves);
    matsCurveUtils.setUsedColorsAndLabels(); // we have used a color and label so we have to set the next one

    matsCurveUtils.checkDiffs();
    matsParamUtils.collapseParams();
    matsParamUtils.setInputForParamName('label', matsCurveUtils.getNextCurveLabel());
    return false;
  }
});
Template.paramList.onRendered(function () {
  Session.set('displayPriority', 1);
  Session.set('editMode', ''); //hide sites and sitesMap selectors for anything that isn't a map plot or wfip2

  var elem;
  var ptype = matsPlotUtils.getPlotType();
  elem = document.getElementById('sites-item');
  var sitesParamHidden;

  if (elem && elem.style) {
    sitesParamHidden = matsCollections.CurveParams.findOne({
      name: 'sites'
    }).hiddenForPlotTypes;

    if (sitesParamHidden) {
      if (sitesParamHidden.indexOf(ptype) === -1) {
        elem.style.display = "block";
      } else {
        elem.style.display = "none";
      }
    }
  }

  elem = document.getElementById('sitesMap-item');

  if (elem && elem.style) {
    sitesParamHidden = matsCollections.CurveParams.findOne({
      name: 'sitesMap'
    }).hiddenForPlotTypes;

    if (sitesParamHidden) {
      if (sitesParamHidden.indexOf(ptype) === -1) {
        elem.style.display = "block";
      } else {
        elem.style.display = "none";
      }
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.curve_param_group.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/params/template.curve_param_group.js                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("curveParamGroup");
Template["curveParamGroup"] = new Template("Template.curveParamGroup", (function() {
  var view = this;
  return HTML.DIV({
    id: "curveParamGroup",
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("displayGroup")) ];
    }
  }, "\n        ", HTML.DIV({
    class: "btn-toolbar btn-group-inline",
    role: "toolbar"
  }, "\n            ", Blaze.Each(function() {
    return Spacebars.dataMustache(view.lookup("CurveParams"), view.lookup("."));
  }, function() {
    return [ "\n                ", Spacebars.include(view.lookupTemplate("item")), "\n            " ];
  }), "\n        "), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"curve_param_group.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/params/curve_param_group.js                                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 2);

var duplicate = function (param) {
  var obj = {};
  var keys = Object.keys(param);

  for (var i = 0; i < keys.length; i++) {
    if (keys[i] !== "_id") {
      obj[keys[i]] = param[keys[i]];
    }
  }

  return obj;
};

filterParams = function (params) {
  /*
  If the plottype is a 2d scatter plot we need to basically create a new set of parameters (except for the label)
  for each axis. The double set of parameters will get sent back to the backend.
   */
  if (matsPlotUtils.getPlotType() === matsTypes.PlotTypes.scatter2d) {
    var xparams = [];
    var yparams = [];
    var newParams = [];

    for (var i = 0; i < params.length; i++) {
      var xp = duplicate(params[i]);
      xp.name = "xaxis-" + params[i].name;
      xp.hidden = true;
      xparams.push(xp);
      var yp = duplicate(params[i]);
      yp.name = "yaxis-" + params[i].name;
      yp.hidden = true;
      yparams.push(yp);
    }

    newParams = newParams.concat(params);
    newParams = newParams.concat(xparams);
    newParams = newParams.concat(yparams);
    return newParams;
  } else {
    return params;
  }
};

Template.curveParamGroup.helpers({
  CurveParams: function (num) {
    var restoreSettingsTime = Session.get("restoreSettingsTime"); // used to force re-render

    var lastUpdate = Session.get('lastUpdate');
    var params = matsCollections.CurveParams.find({
      displayGroup: num
    }, {
      sort: ["displayOrder", "asc"]
    }).fetch();
    params = filterParams(params);
    return params;
  },
  displayGroup: function () {
    return "block";
  },
  log: function () {
    console.log(this);
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.scatter_axis.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/params/template.scatter_axis.js                                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("scatter2d");
Template["scatter2d"] = new Template("Template.scatter2d", (function() {
  var view = this;
  return HTML.DIV({
    class: "well well-sm pull-left",
    id: function() {
      return Spacebars.mustache(view.lookup("plotType"));
    },
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("displayScatter2d")), ";" ];
    }
  }, "\n        ", HTML.DIV({
    style: "font-size:large; font-weight: bold;"
  }, Blaze.View("lookup:title", function() {
    return Spacebars.mustache(view.lookup("title"));
  })), "\n        ", HTML.DIV("\n            ", HTML.SPAN({
    class: "btn-success",
    style: function() {
      return [ "font-size: large;display:", Spacebars.mustache(view.lookup("creating")), ";" ];
    }
  }, Blaze.View("lookup:modeText", function() {
    return Spacebars.mustache(view.lookup("modeText"));
  })), "\n            ", HTML.SPAN({
    class: "btn-info",
    style: function() {
      return [ "font-size: large;display:", Spacebars.mustache(view.lookup("editing")), ";" ];
    }
  }, Blaze.View("lookup:modeText", function() {
    return Spacebars.mustache(view.lookup("modeText"));
  })), "\n        "), "\n        ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("scatter2dParams"));
  }, function() {
    return [ "\n            ", HTML.DIV({
      class: "well well-sm pull-left"
    }, "\n                ", Blaze.If(function() {
      return Spacebars.dataMustache(view.lookup("isNumberSpinner"), view.lookup("."));
    }, function() {
      return [ "\n                    ", HTML.INPUT({
        class: "data-input input-sm",
        id: function() {
          return Spacebars.mustache(view.lookup("idParam"));
        },
        type: "number",
        value: function() {
          return Spacebars.mustache(view.lookup("default"));
        },
        name: function() {
          return Spacebars.mustache(view.lookup("name"), view.lookup("."));
        },
        min: function() {
          return Spacebars.mustache(view.lookup("min"));
        },
        max: function() {
          return Spacebars.mustache(view.lookup("max"));
        },
        step: function() {
          return Spacebars.mustache(view.lookup("step"));
        }
      }), "\n                    ", HTML.LABEL({
        for: function() {
          return Spacebars.mustache(view.lookup("idParam"));
        }
      }, Blaze.View("lookup:labelParam", function() {
        return Spacebars.mustache(view.lookup("labelParam"));
      })), "\n                " ];
    }, function() {
      return [ "\n                    ", HTML.H4(Blaze.View("lookup:name", function() {
        return Spacebars.mustache(view.lookup("name"), view.lookup("."));
      }), "\n                    ", HTML.SMALL(Blaze.If(function() {
        return Spacebars.call(view.lookup("hasHelp"));
      }, function() {
        return [ "\n                        ", HTML.BUTTON({
          style: "background-color:#bbffbb",
          type: "button",
          class: "btn btn-default  btn-xs  help fa fa-question"
        }), "\n                    " ];
      }), " "), "\n                    "), "\n                    ", Blaze.Each(function() {
        return Spacebars.call(view.lookup("scatter2dOptions"));
      }, function() {
        return [ "\n                        ", HTML.INPUT(HTML.Attrs({
          class: function() {
            return [ "data-input ", Spacebars.mustache(view.lookup("className"), view.lookup("..")) ];
          },
          type: function() {
            return Spacebars.mustache(view.lookup("type"), view.lookup(".."));
          },
          name: function() {
            return Spacebars.mustache(view.lookup("name"), view.lookup(".."));
          },
          id: function() {
            return Spacebars.mustache(view.lookup("idOption"), view.lookup(".."));
          },
          value: function() {
            return Spacebars.mustache(view.lookup("."));
          }
        }, function() {
          return Spacebars.attrMustache(view.lookup("isDefault"), view.lookup(".."));
        })), "\n                        ", HTML.LABEL({
          for: function() {
            return Spacebars.mustache(view.lookup("idParam"), view.lookup(".."));
          }
        }, Blaze.View("lookup:label", function() {
          return Spacebars.mustache(view.lookup("label"), view.lookup("."), view.lookup(".."));
        })), "\n                    " ];
      }), "\n                " ];
    }), "\n                ", HTML.DIV("\n                    ", HTML.DIV({
      class: "btn-toolbar btn-group btn-xs",
      role: "toolbar"
    }, "\n                        ", HTML.BUTTON({
      type: "submit",
      name: "apply-params-to-X-axis",
      id: "apply-params-to-xaxis",
      class: "btn btn-success apply-params-to-xaxis fa fa-line-chart"
    }, HTML.SPAN({
      style: "font-size: large"
    }, "Apply params to X axis")), "\n                    "), "\n                    ", HTML.DIV({
      class: "btn-toolbar btn-group btn-xs",
      role: "toolbar"
    }, "\n                        ", HTML.BUTTON(HTML.Attrs({
      type: "submit",
      name: "apply-params-to-Y-axis",
      id: "apply-params-to-yaxis",
      class: "btn btn-success apply-params-to-yaxis fa fa-line-chart"
    }, function() {
      return Spacebars.attrMustache(view.lookup("yApplyEnabled"));
    }), HTML.SPAN({
      style: "font-size: large"
    }, "Apply params to Y axis")), "\n                    "), "\n                    ", HTML.DIV("\n                        ", HTML.SPAN({
      id: "xaxis-curve",
      style: function() {
        return [ "color:", Spacebars.mustache(view.lookup("xaxisCurveColor")) ];
      },
      class: function() {
        return [ "fa ", Spacebars.mustache(view.lookup("curveIcon")) ];
      }
    }, Blaze.View("lookup:xaxisCurveText", function() {
      return Spacebars.mustache(view.lookup("xaxisCurveText"));
    })), "\n                        ", HTML.SPAN(HTML.CharRef({
      html: "&nbsp;",
      str: ""
    })), "\n                        ", HTML.SPAN({
      id: "yaxis-curve",
      style: function() {
        return [ "color:", Spacebars.mustache(view.lookup("yaxisCurveColor")) ];
      },
      class: function() {
        return [ "fa ", Spacebars.mustache(view.lookup("curveIcon")) ];
      }
    }, Blaze.View("lookup:yaxisCurveText", function() {
      return Spacebars.mustache(view.lookup("yaxisCurveText"));
    })), "\n                    "), "\n                "), "\n            "), "\n        " ];
  }), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"scatter_axis.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/params/scatter_axis.js                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsPlotUtils;
module.link("meteor/randyp:mats-common", {
  matsPlotUtils: function (v) {
    matsPlotUtils = v;
  }
}, 2);

var isEditing = function () {
  var mode = Session.get('editMode');
  return !(mode === "" || mode === undefined || mode === null);
};

var setAxisText = function (axis) {
  Session.set(axis + 'CurveText', axis + " " + matsPlotUtils.getAxisText(matsPlotUtils.getPlotType()));
  Session.set(axis + 'CurveColor', 'green');
  Session.set('axisCurveIcon', "fa-check");
};

Template.scatter2d.helpers({
  modeText: function () {
    return isEditing() ? "Editing the curve " + Session.get('editMode') + " (" + Session.get('axis') + ")" : "Creating a new curve";
  },
  creating: function () {
    if (isEditing()) {
      return "none";
    } else {
      return "block";
    }
  },
  editing: function () {
    if (isEditing()) {
      return "block";
    } else {
      return "none";
    }
  },
  xaxisCurveText: function () {
    if (isEditing()) {
      setAxisText("xaxis");
    }

    var t = Session.get('xaxisCurveText');

    if (t) {
      return t;
    } else {
      Session.set('xaxisCurveText', 'XAXIS NOT YET APPLIED');
      return 'XAXIS NOT YET APPLIED';
    }
  },
  yaxisCurveText: function () {
    if (isEditing()) {
      setAxisText("yaxis");
    }

    var t = Session.get('yaxisCurveText');

    if (t || isEditing()) {
      return t;
    } else {
      Session.set('yaxisCurveText', 'YAXIS NOT YET APPLIED');
      return 'YAXIS NOT YET APPLIED';
    }
  },
  yApplyEnabled: function () {
    var c = Session.get('xaxisCurveColor');

    if (c === 'red' && !isEditing()) {
      return "disabled";
    } else {
      return "";
    }
  },
  xaxisCurveColor: function () {
    var t = Session.get('xaxisCurveColor');

    if (t) {
      return t;
    } else {
      Session.set('xaxisCurveColor', 'red');
      return 'red';
    }
  },
  yaxisCurveColor: function () {
    var t = Session.get('yaxisCurveColor');

    if (t) {
      return t;
    } else {
      Session.set('yaxisCurveColor', 'red');
      return 'red';
    }
  },
  curveIcon: function () {
    var t = Session.get('axisCurveIcon');

    if (t) {
      return t;
    } else {
      Session.set('axisCurveIcon', 'fa-asterisk');
      return 'fa-asterisk';
    }
  },
  title: function () {
    return "Scatter Plot parameters";
  },
  scatter2dParams: function () {
    var params = matsCollections.Scatter2dParams.find({}).fetch();
    return params;
  },
  scatter2dOptions: function () {
    var options = this.options;
    return options;
  },
  name: function (param) {
    //console.log("name: " + param.name);
    var name = param.name.replace(/ /g, '-');
    return name;
  },
  className: function (param) {
    //console.log("name: " + param.name);
    var cname = param.name.replace(/ /g, '-') + "-" + param.type;
    return cname;
  },
  type: function (param) {
    switch (param.type) {
      case matsTypes.InputTypes.checkBoxGroup:
        return "checkbox";
        break;

      case matsTypes.InputTypes.radioGroup:
        return "radio";
        break;

      case matsTypes.InputTypes.select:
        return "select";
        break;

      case matsTypes.InputTypes.numberSpinner:
        return "number";
        break;

      default:
        return "text";
    }
  },
  "default": function () {
    return this.default;
  },
  idOption: function (param) {
    var id = param.name + "-" + param.type + "-" + this;
    id = id.replace(/ /g, '-');
    return id;
  },
  idParam: function () {
    var id = this.name + "-" + this.type;
    id = id.replace(/ /g, '-');
    return id;
  },
  plotType: function () {
    return matsTypes.PlotTypes.scatter2d;
  },
  isDefault: function (param) {
    var def = param.default;

    if (def == this) {
      return "checked";
    } else {
      return "";
    }
  },
  displayScatter2d: function () {
    if (matsPlotUtils.getPlotType() == matsTypes.PlotTypes.scatter2d) {
      return "block";
    } else {
      return "none";
    }
  },
  label: function (param, parent) {
    if (parent.name === "Fit Type") {
      return parent.optionsMap[this];
    } else {
      return this;
    }
  },
  labelParam: function () {
    return this.name;
  },
  log: function () {
    console.log(this);
  },
  axis: function (param) {
    var axis = Session.get('axis');

    if (axis === undefined) {
      if (param) {
        return param.default;
      } else {
        return 'xaxis';
      }
    }

    return axis;
  },
  isNumberSpinner: function (param) {
    return param.type === matsTypes.InputTypes.numberSpinner;
  },
  hasHelp: function () {
    return this.help !== undefined;
  }
});

var apply = function (axis) {
  var elems = document.getElementsByClassName("data-input");
  var curveParams = matsCollections.CurveParams.find({}, {
    fields: {
      name: 1
    }
  }).fetch();

  var curveNames = _.pluck(curveParams, "name");

  var param_elems = _.filter(elems, function (elem) {
    return _.contains(curveNames, elem.name);
  });

  var l = param_elems.length;

  for (var i = 0; i < l; i++) {
    var pelem = param_elems[i]; //console.log("pelem.type is " + pelem.type);

    var elem_id = pelem.id;
    var target_id = axis + "-" + elem_id;
    var telem = document.getElementById(target_id); // Notice that these types are not matsTypes these are javascript types

    if (pelem.type === "select-multiple") {
      var $options = $("#" + elem_id + " > option").clone();
      $("#" + target_id).empty().append($options);
      var selectedOptions = $(pelem.selectedOptions).map(function () {
        return this.value;
      }).get();

      for (var x = 0; x < telem.options.length; x++) {
        if ($.inArray(telem.options[x].value, selectedOptions) !== -1) {
          telem.options[x].selected = true;
        } else {
          telem.options[x].selected = false;
        }
      }
    } else if (pelem.type === "select-one") {
      var $options = $("#" + elem_id + " > option").clone();
      $("#" + target_id).empty().append($options);
      telem.selectedIndex = pelem.selectedIndex;
    } else if (pelem.type === "radio") {
      // NOT SURE THIS IS RIGHT
      //console.log(pelem.name + " is " + $('input[name="' + pelem.name + '"]:checked').val());
      $('input[name="' + telem.name + '"]:checked');
    } else if (pelem.type === "button") {
      telem.value = pelem.value;
    } else {
      telem.value = pelem.value;
    }
  }

  setAxisText(axis);
};

Template.scatter2d.events({
  'click .apply-params-to-xaxis': function (event) {
    apply('xaxis');
  },
  'click .apply-params-to-yaxis': function (event) {
    apply('yaxis');
  },
  'change .axis-selector-radioGroup': function (event) {
    var newAxis = event.currentTarget.value;
    Session.set('axis', newAxis);
    var elems = document.getElementsByClassName("data-input");

    var axis_elems = _.filter(elems, function (elem) {
      return elem.name.indexOf(newAxis) > -1;
    });

    var l = axis_elems.length;

    for (var i = 0; i < l; i++) {
      var aelem = axis_elems[i];
      var aelem_id = aelem.id; // remove the axis part at the front

      var target_id = aelem_id.substring(newAxis.length + 1, aelem_id.length);
      var telem = document.getElementById(target_id);

      if (aelem.type === "select-multiple") {
        $(telem).val($(aelem.selectedOptions).map(function () {
          return this.value;
        }).get());
      } else if (aelem.type === "radio") {
        // NOT SURE THIS IS RIGHT
        //console.log(pelem.name + " is " + $('input[name="' + pelem.name + '"]:checked').val());
        $('input[name="' + telem.name + '"]:checked');
      } else if (aelem.type === "button") {
        telem.value = aelem.value;
      } else {
        telem.value = aelem.value;
      }

      telem.dispatchEvent(new CustomEvent("axisRefresh"));
    }
  },
  'click .axishelp': function () {
    $("#matshelp").load("/help/scatter-help.html #matshelp");
    $("#helpModal").modal('show');
  },
  'click .help': function () {
    $("#matshelp").load("/help/" + this.help + " #matshelp");
    $("#helpModal").modal('show');
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"plotType":{"template.plot_type.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/plotType/template.plot_type.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("plotType");
Template["plotType"] = new Template("Template.plotType", (function() {
  var view = this;
  return HTML.DIV({
    id: "plotType",
    class: "container pull-left",
    style: "display:block;"
  }, "\n        ", HTML.DIV({
    class: "row text-center"
  }, "\n            ", HTML.SPAN({
    style: "align-content:center;font-size:xx-large; font-weight: bold;"
  }, Blaze.View("lookup:title", function() {
    return Spacebars.mustache(view.lookup("title"));
  })), "\n        "), "\n        ", HTML.DIV({
    class: "row well well-sm pull-left"
  }, "\n            ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("plotTypes"));
  }, function() {
    return [ "\n                ", HTML.INPUT(HTML.Attrs({
      class: function() {
        return [ "plot-type-", Spacebars.mustache(view.lookup("plotType")) ];
      },
      type: "radio",
      name: "plot-type",
      id: function() {
        return [ "plot-type-", Spacebars.mustache(view.lookup("plotType")) ];
      },
      value: function() {
        return Spacebars.mustache(view.lookup("plotType"));
      },
      checked: function() {
        return Spacebars.mustache(view.lookup("checked"));
      }
    }, function() {
      return Spacebars.attrMustache(view.lookup("display"));
    })), " ", HTML.LABEL({
      style: "font-size: large;"
    }, Blaze.View("lookup:plotType", function() {
      return Spacebars.mustache(view.lookup("plotType"));
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    }), HTML.CharRef({
      html: "&nbsp;",
      str: ""
    })), "\n            " ];
  }), "\n        "), "\n    ");
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"plot_type.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/plotType/plot_type.js                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsCurveUtils;
module.link("meteor/randyp:mats-common", {
  matsCurveUtils: function (v) {
    matsCurveUtils = v;
  }
}, 2);
var matsParamUtils;
module.link("meteor/randyp:mats-common", {
  matsParamUtils: function (v) {
    matsParamUtils = v;
  }
}, 3);
Template.plotType.helpers({
  plotTypes: function () {
    return matsCollections.PlotGraphFunctions.find({}).fetch();
  },
  title: function () {
    if (matsCollections.Settings === undefined || matsCollections.Settings.findOne({}, {
      fields: {
        Title: 1
      }
    }) === undefined) {
      return "";
    } else {
      return matsCollections.Settings.findOne({}, {
        fields: {
          Title: 1
        }
      }).Title;
    }
  },
  display: function () {
    // don't display the choice if there is only one choice
    if (matsCollections.PlotGraphFunctions.find({}).fetch().length === 1) {
      return "hidden";
    } else {
      return "";
    }
  }
});
Template.plotType.events({
  'click .plot-type-TimeSeries': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'dates' parameter
      var oldDatesExist = matsParamUtils.isParamVisible('dates');
      matsCurveUtils.showTimeseriesFace();
      var curves = Session.get('Curves'); // if a 'dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

      if (!oldDatesExist) {
        var curveDate = $('#controlButton-curve-dates-value').text();
        matsParamUtils.setValueTextForParamName('dates', curveDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          // the average may not have been carried over from other curve types so let it default
          if (!curves[ci]['average'] && matsCollections.CurveParams.findOne({
            name: 'average'
          }) && matsCollections.CurveParams.findOne({
            name: 'average'
          }).default) {
            curves[ci]['average'] = matsCollections.CurveParams.findOne({
              name: 'average'
            }).default;
          }

          if (!curves[ci]['valid-time'] && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }) && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }).default) {
            curves[ci]['valid-time'] = matsCollections.CurveParams.findOne({
              name: 'valid-time'
            }).default;
          }

          if (!curves[ci]['threshold'] && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }) && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }).default) {
            curves[ci]['threshold'] = matsCollections.CurveParams.findOne({
              name: 'threshold'
            }).default;
          }

          if (!curves[ci]['forecast-length'] && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }) && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }).default) {
            curves[ci]['forecast-length'] = matsCollections.CurveParams.findOne({
              name: 'forecast-length'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.timeSeries);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the timeseries face
        // see if the previous plot type also used the 'dates' parameter
        var _oldDatesExist = matsParamUtils.isParamVisible('dates');

        matsCurveUtils.showTimeseriesFace(); // if a 'dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

        if (!_oldDatesExist) {
          var _curveDate = $('#controlButton-curve-dates-value').text();

          matsParamUtils.setValueTextForParamName('dates', _curveDate);
        }
      }
    }
  },
  'click .plot-type-Profile': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'curve-dates' parameter
      var oldCurveDatesExist = matsParamUtils.isParamVisible('curve-dates');
      matsCurveUtils.showProfileFace();
      var curves = Session.get('Curves'); // if a 'curve-dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

      var tsDate = $('#controlButton-dates-value').text();

      if (!oldCurveDatesExist) {
        matsParamUtils.setValueTextForParamName('curve-dates', tsDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          if (tsDate !== undefined && tsDate !== "" && !oldCurveDatesExist) {
            curves[ci]['curve-dates'] = tsDate;
          }

          if (!curves[ci]['valid-time'] && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }) && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }).default) {
            curves[ci]['valid-time'] = matsCollections.CurveParams.findOne({
              name: 'valid-time'
            }).default;
          }

          if (!curves[ci]['threshold'] && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }) && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }).default) {
            curves[ci]['threshold'] = matsCollections.CurveParams.findOne({
              name: 'threshold'
            }).default;
          }

          if (!curves[ci]['forecast-length'] && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }) && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }).default) {
            curves[ci]['forecast-length'] = matsCollections.CurveParams.findOne({
              name: 'forecast-length'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.profile);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the profile face
        // see if the previous plot type also used the 'curve-dates' parameter
        var _oldCurveDatesExist = matsParamUtils.isParamVisible('curve-dates');

        matsCurveUtils.showProfileFace(); // if a 'curve-dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

        if (!_oldCurveDatesExist) {
          var _tsDate = $('#controlButton-dates-value').text();

          matsParamUtils.setValueTextForParamName('curve-dates', _tsDate);
        }
      }
    }
  },
  'click .plot-type-DieOff': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'curve-dates' parameter
      var oldCurveDatesExist = matsParamUtils.isParamVisible('curve-dates');
      matsCurveUtils.showDieOffFace();
      var curves = Session.get('Curves'); // if a 'curve-dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

      var tsDate = $('#controlButton-dates-value').text();

      if (!oldCurveDatesExist) {
        matsParamUtils.setValueTextForParamName('curve-dates', tsDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          if (tsDate !== undefined && tsDate !== "" && !oldCurveDatesExist) {
            curves[ci]['curve-dates'] = tsDate;
          }

          if (!curves[ci]['valid-time'] && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }) && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }).default) {
            curves[ci]['valid-time'] = matsCollections.CurveParams.findOne({
              name: 'valid-time'
            }).default;
          }

          if (!curves[ci]['threshold'] && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }) && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }).default) {
            curves[ci]['threshold'] = matsCollections.CurveParams.findOne({
              name: 'threshold'
            }).default;
          }

          if (!curves[ci]['dieoff-type'] && matsCollections.CurveParams.findOne({
            name: 'dieoff-type'
          }) && matsCollections.CurveParams.findOne({
            name: 'dieoff-type'
          }).default) {
            curves[ci]['dieoff-type'] = matsCollections.CurveParams.findOne({
              name: 'dieoff-type'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.dieoff);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the dieoff face
        // see if the previous plot type also used the 'curve-dates' parameter
        var _oldCurveDatesExist2 = matsParamUtils.isParamVisible('curve-dates');

        matsCurveUtils.showDieOffFace(); // if a 'curve-dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

        if (!_oldCurveDatesExist2) {
          var _tsDate2 = $('#controlButton-dates-value').text();

          matsParamUtils.setValueTextForParamName('curve-dates', _tsDate2);
        }
      }
    }
  },
  'click .plot-type-Threshold': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'curve-dates' parameter
      var oldCurveDatesExist = matsParamUtils.isParamVisible('curve-dates');
      matsCurveUtils.showThresholdFace();
      var curves = Session.get('Curves'); // if a 'curve-dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

      var tsDate = $('#controlButton-dates-value').text();

      if (!oldCurveDatesExist) {
        matsParamUtils.setValueTextForParamName('curve-dates', tsDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          if (tsDate !== undefined && tsDate !== "" && !oldCurveDatesExist) {
            curves[ci]['curve-dates'] = tsDate;
          }

          if (!curves[ci]['valid-time'] && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }) && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }).default) {
            curves[ci]['valid-time'] = matsCollections.CurveParams.findOne({
              name: 'valid-time'
            }).default;
          }

          if (!curves[ci]['forecast-length'] && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }) && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }).default) {
            curves[ci]['forecast-length'] = matsCollections.CurveParams.findOne({
              name: 'forecast-length'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.threshold);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the threshold face
        // see if the previous plot type also used the 'curve-dates' parameter
        var _oldCurveDatesExist3 = matsParamUtils.isParamVisible('curve-dates');

        matsCurveUtils.showThresholdFace(); // if a 'curve-dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

        if (!_oldCurveDatesExist3) {
          var _tsDate3 = $('#controlButton-dates-value').text();

          matsParamUtils.setValueTextForParamName('curve-dates', _tsDate3);
        }
      }
    }
  },
  'click .plot-type-ValidTime': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'curve-dates' parameter
      var oldCurveDatesExist = matsParamUtils.isParamVisible('curve-dates');
      matsCurveUtils.showValidTimeFace();
      var curves = Session.get('Curves'); // if a 'curve-dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

      var tsDate = $('#controlButton-dates-value').text();

      if (!oldCurveDatesExist) {
        matsParamUtils.setValueTextForParamName('curve-dates', tsDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          if (tsDate !== undefined && tsDate !== "" && !oldCurveDatesExist) {
            curves[ci]['curve-dates'] = tsDate;
          }

          if (!curves[ci]['threshold'] && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }) && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }).default) {
            curves[ci]['threshold'] = matsCollections.CurveParams.findOne({
              name: 'threshold'
            }).default;
          }

          if (!curves[ci]['forecast-length'] && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }) && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }).default) {
            curves[ci]['forecast-length'] = matsCollections.CurveParams.findOne({
              name: 'forecast-length'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.validtime);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the valid time face
        // see if the previous plot type also used the 'curve-dates' parameter
        var _oldCurveDatesExist4 = matsParamUtils.isParamVisible('curve-dates');

        matsCurveUtils.showValidTimeFace(); // if a 'curve-dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

        if (!_oldCurveDatesExist4) {
          var _tsDate4 = $('#controlButton-dates-value').text();

          matsParamUtils.setValueTextForParamName('curve-dates', _tsDate4);
        }
      }
    }
  },
  'click .plot-type-DailyModelCycle': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'dates' parameter
      var oldDatesExist = matsParamUtils.isParamVisible('dates');
      matsCurveUtils.showDailyModelCycleFace();
      var curves = Session.get('Curves'); // if a 'dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

      if (!oldDatesExist) {
        var curveDate = $('#controlButton-curve-dates-value').text();
        matsParamUtils.setValueTextForParamName('dates', curveDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          if (!curves[ci]['threshold'] && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }) && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }).default) {
            curves[ci]['threshold'] = matsCollections.CurveParams.findOne({
              name: 'threshold'
            }).default;
          }

          if (!curves[ci]['utc-cycle-start'] && matsCollections.CurveParams.findOne({
            name: 'utc-cycle-start'
          }) && matsCollections.CurveParams.findOne({
            name: 'utc-cycle-start'
          }).default) {
            curves[ci]['utc-cycle-start'] = matsCollections.CurveParams.findOne({
              name: 'utc-cycle-start'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.dailyModelCycle);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the daily model cycle face
        // see if the previous plot type also used the 'dates' parameter
        var _oldDatesExist2 = matsParamUtils.isParamVisible('dates');

        matsCurveUtils.showDailyModelCycleFace(); // if a 'dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

        if (!_oldDatesExist2) {
          var _curveDate2 = $('#controlButton-curve-dates-value').text();

          matsParamUtils.setValueTextForParamName('dates', _curveDate2);
        }
      }
    }
  },
  'click .plot-type-Reliability': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'dates' parameter
      var oldDatesExist = matsParamUtils.isParamVisible('dates');
      matsCurveUtils.showReliabilityFace();
      var curves = Session.get('Curves'); // if a 'dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

      if (!oldDatesExist) {
        var curveDate = $('#controlButton-curve-dates-value').text();
        matsParamUtils.setValueTextForParamName('dates', curveDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          // the average may not have been carried over from other curve types so let it default
          if (!curves[ci]['average'] && matsCollections.CurveParams.findOne({
            name: 'average'
          }) && matsCollections.CurveParams.findOne({
            name: 'average'
          }).default) {
            curves[ci]['average'] = matsCollections.CurveParams.findOne({
              name: 'average'
            }).default;
          }

          if (!curves[ci]['valid-time'] && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }) && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }).default) {
            curves[ci]['valid-time'] = matsCollections.CurveParams.findOne({
              name: 'valid-time'
            }).default;
          }

          if (!curves[ci]['threshold'] && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }) && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }).default) {
            curves[ci]['threshold'] = matsCollections.CurveParams.findOne({
              name: 'threshold'
            }).default;
          }

          if (!curves[ci]['forecast-length'] && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }) && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }).default) {
            curves[ci]['forecast-length'] = matsCollections.CurveParams.findOne({
              name: 'forecast-length'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.reliability);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the reliability face
        // see if the previous plot type also used the 'dates' parameter
        var _oldDatesExist3 = matsParamUtils.isParamVisible('dates');

        matsCurveUtils.showReliabilityFace(); // if a 'dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

        if (!_oldDatesExist3) {
          var _curveDate3 = $('#controlButton-curve-dates-value').text();

          matsParamUtils.setValueTextForParamName('dates', _curveDate3);
        }
      }
    }
  },
  'click .plot-type-Map': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'dates' parameter
      var oldDatesExist = matsParamUtils.isParamVisible('dates');
      matsCurveUtils.showMapFace();
      var curves = Session.get('Curves'); // if a 'dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

      if (!oldDatesExist) {
        var curveDate = $('#controlButton-curve-dates-value').text();
        matsParamUtils.setValueTextForParamName('dates', curveDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          if (!curves[ci]['valid-time'] && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }) && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }).default) {
            curves[ci]['valid-time'] = matsCollections.CurveParams.findOne({
              name: 'valid-time'
            }).default;
          }

          if (!curves[ci]['forecast-length'] && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }) && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }).default) {
            curves[ci]['forecast-length'] = matsCollections.CurveParams.findOne({
              name: 'forecast-length'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.map);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the map face
        // see if the previous plot type also used the 'dates' parameter
        var _oldDatesExist4 = matsParamUtils.isParamVisible('dates');

        matsCurveUtils.showMapFace(); // if a 'dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

        if (!_oldDatesExist4) {
          var _curveDate4 = $('#controlButton-curve-dates-value').text();

          matsParamUtils.setValueTextForParamName('dates', _curveDate4);
        }
      }
    }
  },
  'click .plot-type-Histogram': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'curve-dates' parameter
      var oldCurveDatesExist = matsParamUtils.isParamVisible('curve-dates');
      matsCurveUtils.showHistogramFace();
      var curves = Session.get('Curves'); // if a 'curve-dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

      var tsDate = $('#controlButton-dates-value').text();

      if (!oldCurveDatesExist) {
        matsParamUtils.setValueTextForParamName('curve-dates', tsDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          if (tsDate !== undefined && tsDate !== "" && !oldCurveDatesExist) {
            curves[ci]['curve-dates'] = tsDate;
          }

          if (!curves[ci]['valid-time'] && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }) && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }).default) {
            curves[ci]['valid-time'] = matsCollections.CurveParams.findOne({
              name: 'valid-time'
            }).default;
          }

          if (!curves[ci]['threshold'] && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }) && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }).default) {
            curves[ci]['threshold'] = matsCollections.CurveParams.findOne({
              name: 'threshold'
            }).default;
          }

          if (!curves[ci]['forecast-length'] && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }) && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }).default) {
            curves[ci]['forecast-length'] = matsCollections.CurveParams.findOne({
              name: 'forecast-length'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }

          if (!curves[ci]['histogram-bin-controls'] && matsCollections.CurveParams.findOne({
            name: 'histogram-bin-controls'
          }) && matsCollections.CurveParams.findOne({
            name: 'histogram-bin-controls'
          }).default) {
            curves[ci]['histogram-bin-controls'] = matsCollections.CurveParams.findOne({
              name: 'histogram-bin-controls'
            }).default;
          }

          if (!curves[ci]['histogram-yaxis-controls'] && matsCollections.CurveParams.findOne({
            name: 'histogram-yaxis-controls'
          }) && matsCollections.CurveParams.findOne({
            name: 'histogram-yaxis-controls'
          }).default) {
            curves[ci]['histogram-yaxis-controls'] = matsCollections.CurveParams.findOne({
              name: 'histogram-yaxis-controls'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.histogram);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the histogram face
        // see if the previous plot type also used the 'curve-dates' parameter
        var _oldCurveDatesExist5 = matsParamUtils.isParamVisible('curve-dates');

        matsCurveUtils.showHistogramFace(); // if a 'curve-dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'curve-dates' parameter to whatever 'dates' was set to.

        if (!_oldCurveDatesExist5) {
          var _tsDate5 = $('#controlButton-dates-value').text();

          matsParamUtils.setValueTextForParamName('curve-dates', _tsDate5);
        }
      }
    }
  },
  'click .plot-type-Contour': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'dates' parameter
      var oldDatesExist = matsParamUtils.isParamVisible('dates');
      matsCurveUtils.showContourFace();
      var curves = Session.get('Curves'); // if a 'dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

      if (!oldDatesExist) {
        var curveDate = $('#controlButton-curve-dates-value').text();
        matsParamUtils.setValueTextForParamName('dates', curveDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          // the average may not have been carried over from other curve types so let it default
          if (!curves[ci]['valid-time'] && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }) && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }).default) {
            curves[ci]['valid-time'] = matsCollections.CurveParams.findOne({
              name: 'valid-time'
            }).default;
          }

          if (!curves[ci]['utc-cycle-start'] && matsCollections.CurveParams.findOne({
            name: 'utc-cycle-start'
          }) && matsCollections.CurveParams.findOne({
            name: 'utc-cycle-start'
          }).default) {
            curves[ci]['utc-cycle-start'] = matsCollections.CurveParams.findOne({
              name: 'utc-cycle-start'
            }).default;
          }

          if (!curves[ci]['threshold'] && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }) && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }).default) {
            curves[ci]['threshold'] = matsCollections.CurveParams.findOne({
              name: 'threshold'
            }).default;
          }

          if (!curves[ci]['forecast-length'] && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }) && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }).default) {
            curves[ci]['forecast-length'] = matsCollections.CurveParams.findOne({
              name: 'forecast-length'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }

          if (!curves[ci]['x-axis-parameter'] && matsCollections.CurveParams.findOne({
            name: 'x-axis-parameter'
          }) && matsCollections.CurveParams.findOne({
            name: 'x-axis-parameter'
          }).default) {
            curves[ci]['x-axis-parameter'] = matsCollections.CurveParams.findOne({
              name: 'x-axis-parameter'
            }).default;
          }

          if (!curves[ci]['y-axis-parameter'] && matsCollections.CurveParams.findOne({
            name: 'y-axis-parameter'
          }) && matsCollections.CurveParams.findOne({
            name: 'y-axis-parameter'
          }).default) {
            curves[ci]['y-axis-parameter'] = matsCollections.CurveParams.findOne({
              name: 'y-axis-parameter'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.contour);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the contour face
        // see if the previous plot type also used the 'dates' parameter
        var _oldDatesExist5 = matsParamUtils.isParamVisible('dates');

        matsCurveUtils.showContourFace(); // if a 'dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

        if (!_oldDatesExist5) {
          var _curveDate5 = $('#controlButton-curve-dates-value').text();

          matsParamUtils.setValueTextForParamName('dates', _curveDate5);
        }
      }
    }
  },
  'click .plot-type-ContourDiff': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'dates' parameter
      var oldDatesExist = matsParamUtils.isParamVisible('dates');
      matsCurveUtils.showContourFace();
      var curves = Session.get('Curves'); // if a 'dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

      if (!oldDatesExist) {
        var curveDate = $('#controlButton-curve-dates-value').text();
        matsParamUtils.setValueTextForParamName('dates', curveDate);
      }

      if (curves.length > 0) {
        // initialize parameters that may not have been used yet
        for (var ci = 0; ci < curves.length; ci++) {
          // the average may not have been carried over from other curve types so let it default
          if (!curves[ci]['valid-time'] && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }) && matsCollections.CurveParams.findOne({
            name: 'valid-time'
          }).default) {
            curves[ci]['valid-time'] = matsCollections.CurveParams.findOne({
              name: 'valid-time'
            }).default;
          }

          if (!curves[ci]['utc-cycle-start'] && matsCollections.CurveParams.findOne({
            name: 'utc-cycle-start'
          }) && matsCollections.CurveParams.findOne({
            name: 'utc-cycle-start'
          }).default) {
            curves[ci]['utc-cycle-start'] = matsCollections.CurveParams.findOne({
              name: 'utc-cycle-start'
            }).default;
          }

          if (!curves[ci]['threshold'] && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }) && matsCollections.CurveParams.findOne({
            name: 'threshold'
          }).default) {
            curves[ci]['threshold'] = matsCollections.CurveParams.findOne({
              name: 'threshold'
            }).default;
          }

          if (!curves[ci]['forecast-length'] && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }) && matsCollections.CurveParams.findOne({
            name: 'forecast-length'
          }).default) {
            curves[ci]['forecast-length'] = matsCollections.CurveParams.findOne({
              name: 'forecast-length'
            }).default;
          }

          if (!curves[ci]['region'] && matsCollections.CurveParams.findOne({
            name: 'region'
          }) && matsCollections.CurveParams.findOne({
            name: 'region'
          }).default) {
            curves[ci]['region'] = matsCollections.CurveParams.findOne({
              name: 'region'
            }).default;
          }

          if (!curves[ci]['statistic'] && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }) && matsCollections.CurveParams.findOne({
            name: 'statistic'
          }).default) {
            curves[ci]['statistic'] = matsCollections.CurveParams.findOne({
              name: 'statistic'
            }).default;
          }

          if (!curves[ci]['truth'] && matsCollections.CurveParams.findOne({
            name: 'truth'
          }) && matsCollections.CurveParams.findOne({
            name: 'truth'
          }).default) {
            curves[ci]['truth'] = matsCollections.CurveParams.findOne({
              name: 'truth'
            }).default;
          }

          if (!curves[ci]['x-axis-parameter'] && matsCollections.CurveParams.findOne({
            name: 'x-axis-parameter'
          }) && matsCollections.CurveParams.findOne({
            name: 'x-axis-parameter'
          }).default) {
            curves[ci]['x-axis-parameter'] = matsCollections.CurveParams.findOne({
              name: 'x-axis-parameter'
            }).default;
          }

          if (!curves[ci]['y-axis-parameter'] && matsCollections.CurveParams.findOne({
            name: 'y-axis-parameter'
          }) && matsCollections.CurveParams.findOne({
            name: 'y-axis-parameter'
          }).default) {
            curves[ci]['y-axis-parameter'] = matsCollections.CurveParams.findOne({
              name: 'y-axis-parameter'
            }).default;
          }
        }

        Session.set('Curves', curves);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.contourDiff);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the contour face
        // see if the previous plot type also used the 'dates' parameter
        var _oldDatesExist6 = matsParamUtils.isParamVisible('dates');

        matsCurveUtils.showContourFace(); // if a 'dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

        if (!_oldDatesExist6) {
          var _curveDate6 = $('#controlButton-curve-dates-value').text();

          matsParamUtils.setValueTextForParamName('dates', _curveDate6);
        }
      }
    }
  },
  'click .plot-type-Scatter2d': function (event) {
    if (Session.get("confirmPlotChange")) {
      // change has been confirmed
      // see if the previous plot type also used the 'dates' parameter
      var oldDatesExist = matsParamUtils.isParamVisible('dates');
      matsCurveUtils.showScatterFace(); // if a 'dates' parameter was already in use, we want to keep that value.
      // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

      if (!oldDatesExist) {
        var curveDate = $('#controlButton-curve-dates-value').text();
        matsParamUtils.setValueTextForParamName('dates', curveDate);
      }

      Session.set("confirmPlotChange", "");
      Session.set('plotChangeType', "");
    } else {
      // no confirmation yet so check to see if we have any curves and if so then show the confirm dialog
      if (Session.get("Curves").length > 0) {
        Session.set('plotChangeType', matsTypes.PlotTypes.scatter2d);
        $("#modal-change-plot-type").modal();
      } else {
        // no curves - just set the scatter face
        // see if the previous plot type also used the 'dates' parameter
        var _oldDatesExist7 = matsParamUtils.isParamVisible('dates');

        matsCurveUtils.showScatterFace(); // if a 'dates' parameter was already in use, we want to keep that value.
        // otherwise, set the 'dates' parameter to whatever 'curve-dates' was set to.

        if (!_oldDatesExist7) {
          var _curveDate7 = $('#controlButton-curve-dates-value').text();

          matsParamUtils.setValueTextForParamName('dates', _curveDate7);
        }
      }
    }
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"administration":{"template.reset.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.reset.js                                              //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("reset");
Template["reset"] = new Template("Template.reset", (function() {
  var view = this;
  return HTML.Raw('<div id="resetModal" class="modal" role="dialog">\n        <div class="modal-dialog">\n            <div class="modal-content">\n                <div class="modal-header">\n                    <h4 class="modal-title">Reset</h4>\n                </div>\n                <form class="form-horizontal" name="resetForm" novalidate="">\n                    <div class="modal-body">\n                        <p style="color: red">\n                            This action will reset all of the administrative data to hard coded defaults.\n                            You will lose any changes that were made with the administrative\n                            interface or by changing the data externally.\n                        </p>\n                        <div class="modal-footer btn-group">\n                            <button name="cancelReset" type="button" class="cancel-reset btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                            <button name="applyReset" type="button" class="apply_reset btn btn-primary">&nbsp;&nbsp;Reset</button>\n                        </div>\n                    </div>\n                </form>\n            </div>\n            <!-- /.modal-content -->\n        </div>\n        <!-- /.modal-dialog -->\n    </div>');
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"reset.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/reset.js                                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 0);
Template.reset.events({
  'click .apply_reset': function () {
    var settings = matsCollections.Settings.findOne({});

    if (settings === undefined) {
      setError(new Error("reset failed - cannot readsettings"));
      return;
    }

    var appName = settings.Title;
    var appVersion = settings.version;
    matsMethods.reset.call({
      appName: appName,
      appVersion: appVersion
    }, function (error) {
      if (error) {
        setError(new Error("matsMethods.reset from reset.js " + error.message));
      }
    });
    $("#resetModal").modal('hide');
    return false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.export.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.export.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("export");
Template["export"] = new Template("Template.export", (function() {
  var view = this;
  return HTML.DIV({
    id: "exportModal",
    class: "modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title">Export</h4>\n                </div>'), "\n                ", HTML.FORM({
    class: "form-horizontal",
    name: "epForm",
    novalidate: ""
  }, "\n                    ", HTML.DIV({
    class: "modal-body"
  }, "\n                        ", HTML.Raw('<p style="color: red">\n                            Choose what data you want to export. A separate file dialog for each selection will be generated.\n                        </p>'), "\n                        ", HTML.FIELDSET("\n                            DataFiles\n                            ", HTML.UL("\n                            ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("dataFiles"));
  }, function() {
    return [ "\n                                ", HTML.LI(HTML.INPUT({
      type: "checkbox",
      name: "dataFiles",
      id: function() {
        return Spacebars.mustache(view.lookup("."));
      },
      value: function() {
        return Spacebars.mustache(view.lookup("."));
      }
    }), Blaze.View("lookup:.", function() {
      return Spacebars.mustache(view.lookup("."));
    })), "\n                            " ];
  }), "\n                            "), "\n                        "), "\n                        ", HTML.FIELDSET("\n                            GraphFiles\n                            ", HTML.UL("\n                            ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("graphFiles"));
  }, function() {
    return [ "\n                                ", HTML.LI(HTML.INPUT({
      type: "checkbox",
      name: "graphFiles",
      id: function() {
        return Spacebars.mustache(view.lookup("."));
      },
      value: function() {
        return Spacebars.mustache(view.lookup("."));
      }
    }), Blaze.View("lookup:.", function() {
      return Spacebars.mustache(view.lookup("."));
    })), "\n                            " ];
  }), "\n                            "), "\n                        "), "\n                        ", HTML.Raw('<fieldset>\n                            Parameters\n                            <ul>\n                                <li><input type="checkbox" name="parameterFile" id="parameterFile" value="parameters">parameters</li>\n                            </ul>\n                        </fieldset>'), "\n                        ", HTML.Raw('<div class="modal-footer btn-group">\n                            <button name="cancelExport" type="button" class="cancel-export btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                            <button name="applyExport" type="button" class="apply_export btn btn-primary">&nbsp;&nbsp;Export</button>\n                        </div>'), "\n                    "), "\n                "), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-content -->"), "\n        "), HTML.Raw("\n        <!-- /.modal-dialog -->\n    "));
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"export.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/export.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 0);
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 1);
Template.export.onRendered(function () {
  matsMethods.getDataFunctionFileList.call(function (error, result) {
    //    //console.log ('result is : ' + JSON.stringify(result, null, '\t'));
    if (error !== undefined) {
      setError(new Error("matsMethods.getDataFunctionFileList from template export error: " + error.toLocaleString()));
      return false;
    }

    Session.set('dataFunctionFileList', result);
  });
  matsMethods.getGraphFunctionFileList.call(function (error, result) {
    //    //console.log ('result is : ' + JSON.stringify(result, null, '\t'));
    if (error !== undefined) {
      setError(new Error())("matsMethods.graphFunctionFileList from export.js error: " + error.toLocaleString());
      return false;
    }

    Session.set('graphFunctionFileList', result);
  });
});
Template.export.helpers({
  dataFiles: function () {
    return Session.get('dataFunctionFileList');
  },
  graphFiles: function () {
    return Session.get('graphFunctionFileList');
  }
});
Template.export.events({
  'click .apply_export': function (event) {
    event.preventDefault();
    var parameterOut = document.getElementById('parameterFile').checked;
    var dataFiles = [];
    var graphFiles = [];
    $("input:checkbox[name=dataFiles]:checked").each(function () {
      dataFiles.push($(this).val());
    });
    $("input:checkbox[name=graphFiles]:checked").each(function () {
      graphFiles.push($(this).val());
    });

    if (parameterOut) {
      var data = {};
      data.CurveParams = matsCollections.CurveParams.find({}).fetch();
      data.PlotParams = matsCollections.PlotParams.find({}).fetch();
      data.PlotGraphFunctions = matsCollections.PlotGraphFunctions.find({}).fetch();
      data.Settings = matsCollections.Settings.find({}).fetch();
      data.ColorScheme = matsCollections.ColorScheme.find({}).fetch();
      data.Authorization = matsCollections.Authorization.find({}).fetch();
      data.Roles = matsCollections.Roles.find({}).fetch();
      data.Databases = matsCollections.Databases.find({}).fetch();
      data.Credentials = matsCollections.Credentials.find({}).fetch();
      var json = JSON.stringify(data, null, 2);
      var blob = new Blob([json], {
        type: "application/json"
      });
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.download = "export.json";
      a.href = url;
      a.target = '_blank';
      a.textContent = "export.json";
      document.body.appendChild(a);
      a.click();
    }

    if (dataFiles.length > 0) {
      dataFiles.forEach(function (file) {
        matsMethods.readFunctionFile('data', file, function (error, result) {
          if (error !== undefined) {
            setError(new Error(error.toLocaleString()));
            return false;
          }

          data = result;
          var blob = new Blob([result], {
            type: "application/javascript"
          });
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a');
          a.download = file;
          a.href = url;
          a.target = '_blank';
          a.textContent = file;
          document.body.appendChild(a);
          a.click();
        });
      });
    }

    if (graphFiles.length > 0) {
      graphFiles.forEach(function (file) {
        matsMethods.readFunctionFile('graph', file, function (error, result) {
          if (error !== undefined) {
            setError(new Error(error.toLocaleString()));
            return false;
          }

          data = result;
          var blob = new Blob([result], {
            type: "application/javascript"
          });
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a');
          a.download = file;
          a.href = url;
          a.target = '_blank';
          a.textContent = file;
          document.body.appendChild(a);
          a.click();
        });
      });
    }

    $("#exportModal").modal('hide');
    return false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.import.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.import.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("import");
Template["import"] = new Template("Template.import", (function() {
  var view = this;
  return HTML.Raw('<div id="importModal" class="modal" role="dialog">\n        <div class="modal-dialog">\n            <div class="modal-content">\n                <div class="modal-header">\n                    <h4 class="modal-title">Import</h4>\n                </div>\n                <form class="form-horizontal" name="inpForm" novalidate="">\n                    <div class="modal-body">\n                        <p style="color: red">\n                            Choose what data you want to import. A separate file dialog for each selection will be generated.\n                        </p>\n                        <fieldset>\n                            DataFiles\n                            <ul>\n                                <li>\n                                    <span class="btn btn-primary btn-file">\n                                        <input id="dataFileImport" type="file" multiple="" class="btn btn-primary data_file_import">\n                                    </span>\n                                </li>\n                            </ul>\n                        </fieldset>\n                        <fieldset>\n                            GraphFiles\n                            <ul>\n                               <li>\n                                    <span class="btn btn-primary btn-file">\n                                        <input id="graphFileImport" type="file" multiple="" class="btn btn-primary graph_file_import">\n                                    </span>\n                               </li>\n                            </ul>\n                        </fieldset>\n                        <fieldset>\n                            Parameters\n                            <ul>\n                                <li>\n                                    <span class="btn btn-primary btn-file">\n                                        <input id="parameterFileImport" type="file" class="btn btn-primary parameter_file_import">\n                                    </span>\n                                </li>\n                            </ul>\n                        </fieldset>\n\n                        <div class="modal-footer btn-group">\n                            <span class="btn btn-primary btn-file">\n                                <button name="cancelImport" type="" class="cancel-import btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                            </span>\n                        </div>\n                    </div>\n                </form>\n            </div>\n            <!-- /.modal-content -->\n        </div>\n        <!-- /.modal-dialog -->\n    </div>');
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"import.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/import.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 0);
Template.import.events({
  'change .data_file_import': function (event, template) {
    event.preventDefault();

    if (window.File && window.FileReader && window.FileList && window.Blob) {// Great success! All the File APIs are supported.
    } else {
      alert('The File APIs are not fully supported in this browser.');
    }

    var files = event.target.files;

    for (var i = 0, f; f = files[i]; i++) {
      var reader = new FileReader();
      reader.fileName = f.name;

      reader.onload = function (f) {
        return function (e) {
          var name = e.target.fileName;

          try {
            matsMethods.restoreFromFile({
              type: "graph",
              name: name,
              data: e.target.result
            }, function (error) {
              if (error) {
                setError(new Error(error.message));
              }
            });
          } catch (exc) {
            setError(new Error("Error reading file: " + name + " - " + exc.toLocaleString()));
          }
        };
      }(f);

      reader.readAsText(f);
    }

    document.getElementById("dataFileImport").value = "";
    $("#importModal").modal('hide');
    return false;
  },
  'change .graph_file_import': function (event, template) {
    event.preventDefault();

    if (window.File && window.FileReader && window.FileList && window.Blob) {// Great success! All the File APIs are supported.
    } else {
      alert('The File APIs are not fully supported in this browser.');
    }

    var files = event.target.files;

    for (var i = 0, f; f = files[i]; i++) {
      var reader = new FileReader();
      reader.fileName = f.name;

      reader.onload = function (f) {
        return function (e) {
          var name = e.target.fileName;

          try {
            matsMethods.restoreFromFile({
              type: "graph",
              name: name,
              data: e.target.result
            }, function (error) {
              if (error) {
                setError(new Error(error.message));
              }
            });
          } catch (exc) {
            setError(new Error("Error reading file: " + name + " - " + exc.toLocaleString()));
          }
        };
      }(f);

      reader.readAsText(f);
    }

    document.getElementById("graphFileImport").value = "";
    $("#importModal").modal('hide');
    return false;
  },
  'change .parameter_file_import': function (event, template) {
    event.preventDefault();

    if (window.File && window.FileReader && window.FileList && window.Blob) {// Great success! All the File APIs are supported.
    } else {
      alert('The File APIs are not fully supported in this browser.');
    }

    var files = event.target.files;

    for (var i = 0, f; f = files[i]; i++) {
      var reader = new FileReader();
      reader.fileName = f.name;

      reader.onload = function (f) {
        return function (e) {
          var name = e.target.fileName;

          try {
            var data = JSON.parse(e.target.result);
            matsMethods.restoreFromParameterFile({
              name: name,
              data: data
            }, function (error) {
              if (error) {
                setError(new Error(error.message));
              }
            });
          } catch (exc) {
            setError(new Error("Error reading file: " + name + " - " + exc.toLocaleString()));
          }
        };
      }(f);

      reader.readAsText(f);
    }

    document.getElementById("parameterFileImport").value = "";
    $("#importModal").modal('hide');
    return false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.settings.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.settings.js                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("settings");
Template["settings"] = new Template("Template.settings", (function() {
  var view = this;
  return [ HTML.STYLE({
    id: "jsbin-css"
  }, "\n        #apstMoleculeModal .form-group {\n            padding-right:20px;\n            position:relative;\n        }\n\n        #apstMoleculeModal .help {\n            position:absolute;\n            right:-8px;\n            top:12px;\n        }\n    "), "\n    ", HTML.DIV({
    id: "settingsModal",
    class: "modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title">Settings</h4>\n                </div>'), "\n                ", HTML.FORM({
    class: "form-horizontal",
    name: "settingsForm",
    novalidate: ""
  }, "\n                    ", HTML.DIV({
    class: "modal-body"
  }, "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>LabelPrefix</label>\n                            </div>'), "\n                            ", HTML.DIV({
    class: "controls col-xs-12"
  }, "\n                                ", HTML.INPUT({
    id: "LabelPrefix",
    class: "form-control data-input textInput LabelPrefix",
    type: "text",
    required: "",
    placeholder: function() {
      return Spacebars.mustache(view.lookup("LabelPrefix"));
    },
    name: "LabelPrefix"
  }), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Title</label>\n                            </div>'), "\n                            ", HTML.DIV({
    class: "controls col-xs-12"
  }, "\n                                ", HTML.INPUT({
    id: "Title",
    class: "form-control data-input textInput Title",
    type: "text",
    required: "",
    placeholder: function() {
      return Spacebars.mustache(view.lookup("Title"));
    },
    name: "Title"
  }), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>LineWidth</label>\n                            </div>'), "\n                            ", HTML.DIV({
    class: "controls col-xs-12"
  }, "\n                                ", HTML.INPUT({
    id: "LineWidth",
    class: "form-control data-input textInput LineWidth",
    type: "number",
    min: "1",
    max: "100",
    step: ".5",
    required: "",
    placeholder: function() {
      return Spacebars.mustache(view.lookup("LineWidth"));
    },
    name: "LineWidth"
  }), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>NullFillString</label>\n                            </div>'), "\n                            ", HTML.DIV({
    class: "controls col-xs-12"
  }, "\n                                ", HTML.INPUT({
    id: "NullFillString",
    class: "form-control data-input textInput NullFillString",
    type: "text",
    required: "",
    placeholder: function() {
      return Spacebars.mustache(view.lookup("NullFillString"));
    },
    name: "NullFillString"
  }), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.DIV({
    class: "controls col-xs-2"
  }, "\n                                ", HTML.LABEL("ResetFromCode", HTML.INPUT(HTML.Attrs({
    type: "checkbox",
    id: "ResetFromCode",
    class: "data-input ResetFromCode",
    name: "ResetFromCode"
  }, function() {
    return Spacebars.attrMustache(view.lookup("ResetFromCodeChecked"));
  }))), "\n                            "), "\n                        "), "\n                        ", HTML.Raw('<div class="modal-footer btn-group">\n                            <button name="cancelSettings" type="button" class="cancel-settings btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                            <button name="applySettings" id="applySettings" type="button" class="apply_settings btn btn-primary">&nbsp;&nbsp;Apply</button>\n                        </div>'), "\n                    "), "\n                "), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-content -->"), "\n        "), "\n        ", HTML.Raw("<!-- /.modal-dialog -->"), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"settings.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/settings.js                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 2);
Template.settings.helpers({
  LabelPrefix: function () {
    var settings = matsCollections.Settings.findOne({});
    return settings === undefined ? "" : settings.LabelPrefix;
  },
  Title: function () {
    var settings = matsCollections.Settings.findOne({});
    return settings === undefined ? "" : settings.Title;
  },
  LineWidth: function () {
    var settings = matsCollections.Settings.findOne({});
    return settings === undefined ? "" : settings.LineWidth;
  },
  NullFillString: function () {
    var settings = matsCollections.Settings.findOne({});
    return settings === undefined ? "" : settings.NullFillString;
  },
  ResetFromCodeChecked: function () {
    var settings = matsCollections.Settings.findOne({});

    if (settings && settings.resetFromCode == true) {
      return "checked";
    } else {
      return "";
    }
  }
});
Template.settings.events({
  'click .apply_settings': function () {
    // var labelPrefix = document.getElementById("LabelPrefix").value;
    // var title = document.getElementById("Title").value;
    // var lineWidth = document.getElementById("LineWidth").value;
    // var nullFillString = document.getElementById("NullFillString").value;
    // var resetFromCode = document.getElementById("ResetFromCode").checked;
    // var settings = {};
    // settings.labelPrefix = labelPrefix;
    // settings.title = title;
    // settings.lineWidth = lineWidth;
    // settings.nullFillString = nullFillString;
    // settings.resetFromCode = resetFromCode;
    // matsMethods.setSettings.call({'settings':settings}, function (error) {
    //     if (error) {
    //         setError(new Error(error.message));
    //     }
    // });
    //// reset modal
    //document.getElementById("LabelPrefix").value = "";
    //document.getElementById("Title").value = "";
    //document.getElementById("LineWidth").value = "";
    //document.getElementById("NullFillString").value = "";
    //document.getElementById("ResetFromCode").checked = false;
    $("#settingsModal").modal('hide');
    Session.set("adminChanged", new Date());
    return false;
  },
  'click .cancel-settings': function () {
    // reset the form
    document.getElementById("LabelPrefix").value = "";
    document.getElementById("Title").value = "";
    document.getElementById("LineWidth").value = "";
    document.getElementById("NullFillString").value = "";
    document.getElementById("ResetFromCode").checked = false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.databases.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.databases.js                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("databases");
Template["databases"] = new Template("Template.databases", (function() {
  var view = this;
  return [ HTML.STYLE({
    id: "jsbin-css"
  }, "\n        #apstMoleculeModal .form-group {\n            padding-right: 20px;\n            position: relative;\n        }\n\n        #apstMoleculeModal .help {\n            position: absolute;\n            right: -8px;\n            top: 12px;\n        }\n    "), "\n    ", HTML.DIV({
    id: "databasesModal",
    class: "modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title">Databases</h4>\n                </div>'), "\n                ", HTML.DIV({
    class: "modal-body"
  }, "\n                    ", HTML.FORM({
    class: "form-horizontal",
    name: "dbForm",
    novalidate: ""
  }, "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.DIV({
    class: "form-group"
  }, "\n                                ", HTML.Raw('<div class="controls col-xs-2">\n                                    <label>Database (or new)</label>\n                                </div>'), "\n                                ", HTML.DIV({
    class: "controls col-xs-2"
  }, "\n                                    ", HTML.SELECT({
    class: "database",
    size: "5",
    name: "database",
    id: "database-selection"
  }, "\n                                        ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("databases"));
  }, function() {
    return [ "\n                                            ", HTML.OPTION({
      value: function() {
        return Spacebars.mustache(view.lookup("name"));
      }
    }, Blaze.View("lookup:name", function() {
      return Spacebars.mustache(view.lookup("name"));
    })), "\n                                        " ];
  }), "\n                                    "), "\n                                "), "\n                            "), "\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "name");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Name</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                    <input id="database-name" class="form-control data-input textInput name" type="text" required="" placeholder="name" name="name">\n                            </div>'), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "role");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Role</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                <input type="radio" id="database-role-model" name="database-role" value="model" checked="">Model\n                                <input type="radio" id="database-role-ua" name="database-role" value="ua">Ua\n                            </div>'), "\n\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Status</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                <input type="radio" id="database-status-standby" name="database-status" value="standby" checked="">Standby\n                                <input type="radio" id="database-status-active" name="database-status" value="active">Active\n                            </div>'), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "host");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Host</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                <input id="database-host" class="form-control data-input textInput databaseHost" type="text" required="" placeholder="host" name="database-host">\n                            </div>'), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "database");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Database</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                <input id="database-database" class="form-control data-input textInput database" type="text" required="" placeholder="database" name="database">\n                            </div>'), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "user");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>User</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                <input id="database-user" class="form-control data-input textInput database-user" type="text" required="" placeholder="user" name="database-user">\n                            </div>'), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "password");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Password</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                <input id="database-password" class="form-control data-input textInput database-password" type="password" required="" placeholder="password" name="database-password">\n                            </div>'), "\n\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Verify Password</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                <input id="database-verify" class="form-control data-input textInput database-verify" type="password" required="" placeholder="verify password" name="database-verify">\n                            </div>'), "\n                        "), "\n\n                        ", HTML.Raw('<div class="modal-footer btn-group">\n                            <button name="cancelDatabase" type="button" class="cancel-database btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel\n                            </button>\n                            <button name="applyDatabase" type="button" class="apply-database btn btn-primary">\n                                &nbsp;&nbsp;Apply\n                            </button>\n                            <button name="removeDatabase" type="button" class="remove-database btn btn-primary">\n                                &nbsp;&nbsp;Remove\n                            </button>\n                        </div>'), "\n                    "), "\n                "), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-content -->"), "\n        "), "\n        ", HTML.Raw("<!-- /.modal-dialog -->"), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"databases.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/databases.js                                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 0);
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 1);
Template.databases.onRendered(function () {
  reset();
});
Template.databases.helpers({
  databases: function () {
    dbs = matsCollections.Databases.find({}).fetch();
    dbs.unshift({
      name: "New Database"
    });
    return dbs;
  },
  errorMessage: function () {
    return Session.get("databaseErrorMessage");
  },
  errorTypeIs: function (type) {
    return Session.get("databaseErrorType") === type;
  }
});

var reset = function () {
  document.getElementById("database-selection").value = "";
  document.getElementById("database-name").value = "";
  document.getElementById("database-role-model").checked = false;
  document.getElementById("database-role-ua").checked = false;
  document.getElementById("database-status-standby").checked = false;
  document.getElementById("database-status-active").checked = false;
  document.getElementById("database-host").value = "";
  document.getElementById("database-database").value = "";
  document.getElementById("database-user").value = "";
  document.getElementById("database-password").value = "";
  document.getElementById("database-verify").value = "";
  resetError();
};

var resetError = function () {
  errorMessage = "";
  Session.set("databaseErrorMessage", "");
  Session.set("databaseErrorType", "");

  if (document.getElementById("errorMessage")) {
    document.getElementById("errorMessage").style.display = "none";
  }
};

var setError = function (type, message) {
  Session.set("databaseErrorMessage", message);
  Session.set("databaseErrorType", type);
  document.getElementById("errorMessage").style.display = "block";
};

Template.databases.events({
  'click .database': function () {
    resetError();
    var dbName = document.getElementById("database-selection").value;

    if (dbName == "New Database") {
      reset();
      return false;
    }

    var db = matsCollections.Databases.findOne({
      name: dbName
    });
    document.getElementById("database-selection").value = "";
    document.getElementById("database-name").value = db.name;
    document.getElementById("database-role-model").checked = db.role == "model";
    document.getElementById("database-role-ua").checked = db.role == "ua";
    document.getElementById("database-status-standby").checked = db.status == "standby";
    document.getElementById("database-status-active").checked = db.status == "active";
    document.getElementById("database-host").value = db.host;
    document.getElementById("database-database").value = db.database;
    document.getElementById("database-user").value = db.user;
    document.getElementById("database-password").value = db.password;
    document.getElementById("database-verify").value = db.password;
  },
  'click .apply-database': function () {
    var settings = {};
    resetError();
    settings.name = document.getElementById("database-name").value;

    if (document.getElementById("database-role-model").checked === true) {
      settings.role = "model";
    } else if (document.getElementById("database-role-ua").checked === true) {
      settings.role = "ua";
    }

    if (document.getElementById("database-status-standby").checked === true) {
      settings.status = "standby";
    } else if (document.getElementById("database-status-active").checked === true) {
      // set any other database with this role to standby
      matsCollections.Databases.upsert({});
      settings.status = "active";
    }

    settings.host = document.getElementById("database-host").value;
    settings.database = document.getElementById("database-database").value;
    settings.user = document.getElementById("database-user").value;
    settings.password = document.getElementById("database-password").value;
    var verify = document.getElementById("database-verify").value;

    if (settings.password != verify) {
      setError('password', "Password and Verify do not match!");
      return false;
    }

    if (settings.name === "") {
      setError("name", "you have to set a name");
      return false;
    } // ONLY ONE CAN BE ACTIVE FOR A GIVEN ROLE
    //if (settings.role === "") {
    //    setError(role,"you have to set a role");
    //    return false;
    //}


    if (settings.host === "") {
      setError('host', "you have to set a host");
      return false;
    }

    if (settings.database === "") {
      setError('database', "you have to set a database");
      return false;
    }

    if (settings.user === "") {
      setError('user', "you have to set a user");
      return false;
    }

    matsMethods.applyDatabaseSettings.call(settings, function (error) {
      if (error) {
        setError(new error('matsMethods.applyDatabaseSettings from Template.databases.events: 121 error:' + error.message));
        return false;
      }
    });
    reset();
    $("#databasesModal").modal('hide');
    return false;
  },
  'click .remove-database': function () {
    var dbName = document.getElementById("database-name").value;
    matsMethods.removeDatabase.call(dbName, function (error) {
      if (error) {
        setError(new Error('matsMethods.removeDatabase from Template.databases.events: 121 error:' + error.message));
      }
    });
    reset();
    $("#databasesModal").modal('hide');
    return false;
  },
  'click .cancel-database': function () {
    reset();
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"plotParams.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/plotParams.js                                                  //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*
 * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.
 */

/**
 * Created by pierce on 8/13/15.
 */
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.colorsScheme.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.colorsScheme.js                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("colorScheme");
Template["colorScheme"] = new Template("Template.colorScheme", (function() {
  var view = this;
  return [ HTML.STYLE({
    id: "jsbin-css"
  }, "\n        #apstMoleculeModal .form-group {\n            padding-right: 20px;\n            position: relative;\n        }\n\n        #apstMoleculeModal .help {\n            position: absolute;\n            right: -8px;\n            top: 12px;\n        }\n    "), "\n    ", HTML.DIV({
    id: "colorSchemeModal",
    class: "modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title">Color Scheme</h4>\n                </div>'), "\n                ", HTML.DIV({
    class: "modal-body"
  }, "\n                    ", HTML.FORM({
    class: "form-horizontal",
    name: "csForm",
    novalidate: ""
  }, "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>new</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <div class="input-group colorSchemePicker" col-xs-2="">\n                                <span class="input-group-addon"><input id="colorSchemePicker" type="text" class="colorpicker-component colorSchemePicker" value="rgb(255,255,255)" style="background:transparent;background-color:rgb(255,255,255);">\n                                <i id="colorSchemePickerIndicator" style="background-color: rgb(255,255,255);"></i></span>\n                                </div>\n                            </div>'), "\n                            ", HTML.DIV({
    class: "controls col-xs-2"
  }, "\n                                ", HTML.SCRIPT("\n                                    $(function () {\n                                        $('.colorSchemePicker').colorpicker();\n                                    });\n                                "), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>insert after</label>\n                            </div>'), "\n                            ", HTML.DIV({
    class: "controls col-xs-2"
  }, "\n                                ", HTML.SELECT({
    class: "data-input insert-after-color",
    size: "5",
    name: "insert_after_color",
    id: "insertAfterColor"
  }, "\n                                    ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("colorOptions"));
  }, function() {
    return [ "\n                                        ", HTML.OPTION({
      value: function() {
        return Spacebars.mustache(view.lookup("color"));
      },
      style: function() {
        return [ "color:", Spacebars.mustache(view.lookup("color")), ";" ];
      }
    }, Blaze.View("lookup:color", function() {
      return Spacebars.mustache(view.lookup("color"));
    }), ">"), "\n                                    " ];
  }), "\n                                "), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Remove</label>\n                            </div>'), "\n                            ", HTML.DIV({
    class: "controls col-xs-2"
  }, "\n                                ", HTML.SELECT({
    class: "data-input remove-color",
    size: "5",
    name: "remove_color",
    id: "removeColor"
  }, "\n                                    ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("colorOptions"));
  }, function() {
    return [ "\n                                        ", HTML.OPTION({
      value: function() {
        return Spacebars.mustache(view.lookup("color"));
      },
      style: function() {
        return [ "color:", Spacebars.mustache(view.lookup("color")), ";" ];
      }
    }, Blaze.View("lookup:color", function() {
      return Spacebars.mustache(view.lookup("color"));
    })), "\n                                    " ];
  }), "\n                                "), "\n                            "), "\n                        "), "\n                        ", HTML.Raw('<div class="modal-footer btn-group">\n                            <button name="cancelColorScheme" type="button" class="cancel-color-scheme btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel\n                            </button>\n                            <button name="applyColorScheme" type="button" class="apply-color-scheme btn btn-primary">\n                                &nbsp;&nbsp;Apply\n                            </button>\n                        </div>'), "\n                    "), "\n                "), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-content -->"), "\n        "), "\n        ", HTML.Raw("<!-- /.modal-dialog -->"), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"colorScheme.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/colorScheme.js                                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 2);
Template.colorScheme.helpers({
  colorOptions: function () {
    var colorScheme = matsCollections.ColorScheme.findOne({});

    if (colorScheme === undefined) {
      return false;
    }

    var colors = colorScheme.colors;
    var colorOptions = [];

    for (var i = 0; i < colors.length; i++) {
      colorOptions.push({
        color: colors[i]
      });
    }

    return colorOptions;
  }
});
Template.colorScheme.events({
  'click .apply-color-scheme': function () {
    var removeColor = document.getElementById("removeColor").value;
    var insertAfterColor = document.getElementById("insertAfterColor").value;
    var newColor = document.getElementById("colorSchemePicker").value;
    var colors = matsCollections.ColorScheme.findOne({}).colors;

    if (newColor) {
      var insertAfterIndex = 0;

      if (insertAfterColor) {
        insertAfterIndex = colors.indexOf(insertAfterColor);
      }

      matsMethods.insertColor({
        newColor: newColor,
        insertAfterIndex: insertAfterIndex
      }, function (error) {
        if (error) {
          setError(new Error(error.message));
        }
      });
    }

    if (removeColor) {
      Meteor.call('removeColor', removeColor, function (error) {
        if (error) {
          setError(new Error(error.message));
        }
      });
    } // reset modal


    document.getElementById("removeColor").value = "";
    document.getElementById("insertAfterColor").value = "";
    document.getElementById("colorSchemePicker").color = "rgb(255,255,255)";
    document.getElementById("colorSchemePicker").value = "rgb(255,255,255)";
    document.getElementById("colorSchemePickerIndicator").style.backgroundColor = "rgb(255,255,255)";
    $("#colorSchemeModal").modal('hide');
    return false;
  },
  'click .cancel-color-scheme': function () {
    // reset the form
    document.getElementById("removeColor").value = null;
    document.getElementById("removeColor").value = "";
    document.getElementById("insertAfterColor").value = "";
    document.getElementById("colorSchemePicker").color = "rgb(255,255,255)";
    document.getElementById("colorSchemePicker").value = "rgb(255,255,255)";
    document.getElementById("colorSchemePickerIndicator").style.backgroundColor = "rgb(255,255,255)";
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.curveParams.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.curveParams.js                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("curveParams");
Template["curveParams"] = new Template("Template.curveParams", (function() {
  var view = this;
  return [ HTML.STYLE({
    id: "jsbin-css"
  }, "\n        #apstMoleculeModal .form-group {\n            padding-right: 20px;\n            position: relative;\n        }\n\n        #apstMoleculeModal .help {\n            position: absolute;\n            right: -8px;\n            top: 12px;\n        }\n    "), "\n    ", HTML.DIV({
    id: "curveParamsModal",
    class: "modal wide-modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog",
    style: "width:80%;"
  }, "\n            ", HTML.DIV({
    class: "modal-content container"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title">Curve Parameters</h4>\n                </div>'), "\n                ", HTML.DIV({
    class: "modal-body container"
  }, "\n                    ", HTML.FORM({
    class: "form-horizontal",
    name: "cpForm",
    novalidate: ""
  }, "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.DIV({
    class: "form-group row"
  }, "\n                                ", HTML.Raw('<div class="controls col-xs-1" style="min-width:6em">\n                                    <label>Parameter</label>\n                                </div>'), "\n                                ", HTML.Raw('<div class="controls col-xs-1">\n                                    <button type="button" id="curveParams-selection-add" class="curveParams-selection-add btn btn-xs btn-success fa fa-plus"></button>\n                                    <button type="button" id="curveParams-selection-remove" class="curveParams-selection-remove btn btn-xs btn-danger fa fa-minus"></button>\n                                </div>'), "\n                                ", HTML.DIV({
    class: "controls col-xs-8"
  }, "\n                                    ", HTML.SELECT({
    class: "curveParams-selection",
    size: "5",
    name: "curveParams-selection",
    id: "curveParams-selection"
  }, "\n                                      ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("curveParams"));
  }, function() {
    return [ "\n                                          ", HTML.OPTION({
      value: function() {
        return Spacebars.mustache(view.lookup("name"));
      }
    }, Blaze.View("lookup:name", function() {
      return Spacebars.mustache(view.lookup("name"));
    })), "\n                                      " ];
  }), "\n                                    "), "\n                                "), "\n\n\n                            "), "\n\n                          ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "");
  }, function() {
    return [ "\n                              ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                          " ];
  }), "\n\n                          ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "name");
  }, function() {
    return [ "\n                              ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                          " ];
  }), "\n                            ", HTML.Raw('<div class="form-group row">\n                                <div class="controls col-xs-2">\n                                    <label>Name</label>\n                                </div>\n                                <div class="controls col-xs-2" style="min-width:12em;">\n                                    <input id="curveParams-name" data-field="name" class="form-control data-input textInput name" type="text" placeholder="name" name="name">\n                                </div>\n                            </div>'), "\n                          ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "type");
  }, function() {
    return [ "\n                              ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                          " ];
  }), "\n                            ", HTML.DIV({
    class: "form-group row"
  }, "\n                                ", HTML.Raw('<div class="controls col-xs-2">\n                                    <label>Type</label>\n                                </div>'), "\n                                ", HTML.DIV({
    class: "controls col-xs-4"
  }, "\n                                    ", HTML.SELECT({
    class: "data-value curveParamsType",
    size: "5",
    "data-field": "type",
    id: "curveParams-type"
  }, "\n                                      ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("types"));
  }, function() {
    return [ "\n                                          ", HTML.OPTION({
      value: function() {
        return Spacebars.mustache(view.lookup("."));
      }
    }, Blaze.View("lookup:.", function() {
      return Spacebars.mustache(view.lookup("."));
    })), "\n                                      " ];
  }), "\n                                    "), "\n                                "), "\n                            "), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "options");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.DIV({
    class: "form-group row"
  }, "\n                                ", HTML.Raw('<div class="controls col-xs-1" style="min-width:8em;">\n                                    <label>Options Map</label>\n                                </div>'), "\n                                ", HTML.Raw('<div class="controls col-xs-1">\n                                    <button type="button" id="curveParams-option-add" class="curveParams-option-add btn btn-xs btn-success fa fa-plus"></button>\n                                    <button type="button" id="curveParams-option-remove" class="curveParams-option-remove btn btn-xs btn-danger fa fa-minus"></button>\n                                </div>'), "\n                                ", HTML.DIV({
    class: "controls col-xs-10"
  }, "\n                                    ", HTML.TABLE({
    class: "table table-condensed table-responsive table-bordered",
    id: "optionsTable"
  }, "\n                                        ", HTML.TBODY("\n                                        ", Blaze.View("lookup:optionRows", function() {
    return Spacebars.makeRaw(Spacebars.mustache(view.lookup("optionRows")));
  }), "\n                                        "), "\n                                    "), "\n                                "), "\n                            "), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "controlButtonCovered");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="form-group row">\n                                <div class="controls col-xs-2" style="min-width:12em;">\n                                    <label>Control Button Covered</label>\n                                </div>\n                                <div class="controls col-xs-2">\n                                        <input class="data-radio" type="radio" id="curveParams-controlButtonCovered-true" data-field="controlButtonCovered" name="controlButtonCovered" value="true" checked="">True\n                                        <input class="data-radio" type="radio" id="curveParams-controlButtonCovered-false" data-field="controlButtonCovered" name="controlButtonCovered" value="false">False\n                                </div>\n                            </div>'), "\n\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "unique");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="form-group row">\n                                <div class="controls col-xs-2" style="min-width:12em;">\n                                    <label>Ensure Uniqueness</label>\n                                </div>\n                                <div class="controls col-xs-2">\n                                    <input class="data-radio" type="radio" id="curveParams-unique-true" data-field="unique" name="unique" value="true" checked="">True\n                                    <input class="data-radio" type="radio" id="curveParams-unique-false" data-field="unique" name="unique" value="false">False\n                                </div>\n                            </div>'), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "default");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.DIV({
    class: "form-group row"
  }, "\n                                ", HTML.Raw('<div class="controls col-xs-2" style="min-width:12em;">\n                                    <label>Default Value</label>\n                                </div>'), "\n                                ", HTML.DIV({
    class: "controls col-xs-4"
  }, "\n                                    ", HTML.INPUT({
    id: "curveParams-default",
    "data-field": "default",
    class: "form-control data-input textInput default",
    type: "text",
    placeholder: function() {
      return Spacebars.mustache(view.lookup("default"));
    }
  }), "\n                                "), "\n                            "), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "controlButtonVisibility");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="form-group row">\n                                <div class="controls col-xs-2" style="min-width:12em;">\n                                    <label>Control Button Visibility</label>\n                                </div>\n                                <div class="controls col-xs-2">\n                                    <input class="data-radio" type="radio" id="curveParams-controlButtonVisibility-block" data-field="curveParams-controlButtonVisibility" name="curveParams-controlButtonVisibility" value="block" checked="">Visible\n                                    <input class="data-radio" type="radio" id="curveParams-controlButtonVisibility-none" data-field="curveParams-controlButtonVisibility" name="curveParams-controlButtonVisibility" value="none">Hidden\n                                </div>\n                            </div>'), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "displayOrder");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.DIV({
    class: "form-group row"
  }, "\n                                ", HTML.Raw('<div class="controls col-xs-2" style="min-width:12em;">\n                                    <label>DisplayOrder</label>\n                                </div>'), "\n                                ", HTML.DIV({
    class: "controls col-xs-4"
  }, "\n                                    ", HTML.INPUT({
    id: "curveParams-displayOrder",
    "data-field": "displayOrder",
    class: "form-control data-input textInput displayOrder",
    type: "number",
    placeholder: function() {
      return Spacebars.mustache(view.lookup("displayOrder"));
    },
    min: "1",
    max: "25",
    step: "1"
  }), "\n                                "), "\n                            "), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "displayPriority");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.DIV({
    class: "form-group row"
  }, "\n                                ", HTML.Raw('<div class="controls col-xs-2" style="min-width:12em;">\n                                    <label>displayPriority</label>\n                                </div>'), "\n                                ", HTML.DIV({
    class: "controls col-xs-4"
  }, "\n                                    ", HTML.INPUT({
    id: "curveParams-displayPriority",
    "data-field": "displayPriority",
    class: "form-control data-input textInput displayPriority",
    type: "number",
    placeholder: function() {
      return Spacebars.mustache(view.lookup("displayPriority"));
    },
    min: "1",
    max: "10",
    step: "1"
  }), "\n                                "), "\n                            "), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "displayGroup");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.DIV({
    class: "form-group row"
  }, "\n                                ", HTML.Raw('<div class="controls col-xs-2" style="min-width:12em;">\n                                    <label>displayGroup</label>\n                                </div>'), "\n                                ", HTML.DIV({
    class: "controls col-xs-4"
  }, "\n                                    ", HTML.INPUT({
    id: "curveParams-displayGroup",
    "data-field": "displayGroup",
    class: "form-control data-input textInput displayGroup",
    type: "number",
    placeholder: function() {
      return Spacebars.mustache(view.lookup("displayGroup"));
    },
    min: "1",
    max: "10",
    step: "1"
  }), "\n                                "), "\n                                ", HTML.Raw('<div class="col-xs-9"></div>'), "\n                            "), "\n\n                        "), "\n                        ", HTML.DIV({
    id: "applyCurveParamsModal",
    class: "modal",
    role: "dialog"
  }, "\n                            ", HTML.DIV({
    class: "modal-dialog"
  }, "\n                                ", HTML.DIV({
    class: "modal-content"
  }, "\n                                    ", HTML.Raw('<div class="modal-header">\n                                        <h4>Apply Curve Params</h4>\n                                    </div>'), "\n                                    ", HTML.Raw('<div class="modal-body">\n                                        <label>Apply Comment...</label>\n                                    </div>'), "\n                                    ", HTML.DIV({
    class: "controls col-xs-4"
  }, "\n                                        ", HTML.TEXTAREA({
    id: "applyCurveParamsComment",
    class: "applyCurveParamsComment textInput",
    value: "Enter Comment",
    placeholder: "Enter Comment"
  }), "\n                                    "), "\n                                    ", HTML.Raw('<div class="modal-footer btn-group">\n                                        <button type="button" class="cancel-restore btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                                        <button name="applyCurveParamsWithComment" class="applyCurveParamsWithComment btn btn-primary">&nbsp;&nbsp;Apply</button>\n                                    </div>'), "\n                                "), "\n                                ", HTML.Raw("<!-- /.modal-content -->"), "\n                            "), "\n                            ", HTML.Raw("<!-- /.modal-dialog -->"), "\n                        "), "\n\n                        ", HTML.DIV({
    id: "restoreCurveParamsModal",
    class: "modal",
    role: "dialog"
  }, "\n                            ", HTML.DIV({
    class: "modal-dialog"
  }, "\n                                ", HTML.DIV({
    class: "modal-content"
  }, "\n                                    ", HTML.Raw('<div class="modal-header">\n                                        <h4>Restore Curve Params</h4>\n                                    </div>'), "\n                                    ", HTML.DIV({
    class: "modal-body"
  }, "\n                                        ", HTML.Raw("<label>Restore from date...</label>"), "\n                                        ", HTML.Raw('<input style="font-size: x-small" type="text" class="restoreFromSeconds form-control" id="restoreFromSeconds" placeholder="choose from Restore From">'), "\n                                        ", HTML.DIV({
    class: "dropdown"
  }, "\n                                            ", HTML.Raw('<button id="restore-choose-date-toggle" class="btn btn-default btn-xs dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">\n                                                Choose Date (toggle user for comments)<span class="caret"></span>\n                                            </button>'), "\n                                            ", HTML.UL({
    class: "dropdown-menu"
  }, "\n                                                ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("restoreDates"));
  }, function() {
    return [ "\n                                                    ", HTML.LI("\n                                                        ", HTML.DIV({
      class: "btn-toolbar btn-group-xs",
      role: "toolbar"
    }, "\n                                                        ", HTML.BUTTON({
      class: "restoreCurveParamsDate btn  btn-primary",
      "data-date": function() {
        return Spacebars.mustache(view.lookup("date"));
      },
      "data-second": function() {
        return Spacebars.mustache(view.lookup("second"));
      },
      "data-user": function() {
        return Spacebars.mustache(view.lookup("userName"));
      },
      "data-comment": function() {
        return Spacebars.mustache(view.lookup("commentStr"));
      },
      id: function() {
        return [ "restoreCurveParamsDate-", Spacebars.mustache(view.lookup("second")) ];
      }
    }, Blaze.View("lookup:date", function() {
      return Spacebars.mustache(view.lookup("date"));
    })), "\n                                                        ", Blaze.View("lookup:user", function() {
      return Spacebars.makeRaw(Spacebars.mustache(view.lookup("user")));
    }), "\n                                                        ", Blaze.View("lookup:comment", function() {
      return Spacebars.makeRaw(Spacebars.mustache(view.lookup("comment")));
    }), "\n                                                        "), "\n                                                    "), "\n                                                " ];
  }), "\n                                            "), "\n                                        "), "\n                                    "), "\n                                    ", HTML.Raw('<div class="modal-footer btn-group">\n                                        <button type="button" class="cancel-restoreCurveParamsFromDate btn btn-info">&nbsp;&nbsp;Cancel</button>\n                                        <button name="restoreCurveParamsFromDate" class="restoreCurveParamsFromDate btn btn-primary">&nbsp;&nbsp;Restore From</button>\n                                    </div>'), "\n                                "), "\n                                ", HTML.Raw("<!-- /.modal-content -->"), "\n                            "), "\n                            ", HTML.Raw("<!-- /.modal-dialog -->"), "\n                        "), "\n                        ", HTML.Raw('<div class="modal-footer btn-group">\n                            <button name="cancelCurveParams" type="button" class="cancel-curveParams btn btn-info" data-dismiss="modal">Cancel</button>\n                            <button name="applyCurveParams" type="button" class="applyCurveParams btn btn-primary">Apply</button>\n                            <button name="restoreCurveParams" type="button" class="restoreCurveParams btn btn-primary">Restore Previous</button>\n                        </div>'), "\n                    "), "\n                "), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-content -->"), "\n        "), "\n        ", HTML.Raw("<!-- /.modal-dialog -->"), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"curveParams.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/curveParams.js                                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 2);

/**
 * Created by pierce on 8/13/15.
 */
Template.curveParams.onRendered(function () {
  reset();
});
Template.curveParams.helpers({
  curveParams: function () {
    if (Session.get('params') === undefined) {
      var params = matsCollections.CurveParams.find({}, {
        sort: {
          displayOrder: 1
        }
      }).fetch();
      Session.set('params', params);
    }

    return Session.get('params');
  },
  optionRows: function () {
    var rows = ""; // find the object in the session that is associated with the currently selected name

    var params = Session.get('params');

    if (params == undefined) {
      return "";
    }

    if (!document.getElementById('curveParams-selection') || document.getElementById('curveParams-selection') == "") {
      return "";
    }

    var paramSelectedName = document.getElementById('curveParams-selection').value;
    var param = params.filter(function (obj) {
      return obj.name === paramSelectedName;
    })[0];

    if (param == undefined) {
      return;
    }

    var optionsMap = param.optionsMap;

    if (optionsMap == undefined) {
      return "";
    } // create the options table rows


    var optionKeys = Object.keys(optionsMap);
    param.options = optionKeys;

    for (var i = 0; i < optionKeys.length; i++) {
      var optionList = optionsMap[optionKeys[i]];
      rows += '<tr><td contentEditable width="10%" style="min-width:3em;"><input data-field="optionsMap.' + optionKeys[i] + "_" + i + '" id="curveParams-option-' + i + '" class="form-control data-input textInput" type="text" value="' + optionKeys[i] + '"/></td>';

      for (var oli = 0; oli < optionList.length; oli++) {
        rows += '<td contentEditable><textarea data-field="optionsMap.' + optionKeys[i] + '_' + i + '[' + oli + ']' + '" id="curveParams-optionList-' + i + '-' + oli + '" class="form-control data-input optionsTable"' + '<span style="font-size:x-small">' + optionList[oli] + '</textarea></td>';
      }

      rows += '<td><span><button id="curveParams-option-field-add-' + optionKeys[i] + '" class="option-field-add btn btn-xs btn-success fa fa-plus"/>';
      rows += '<button id="curveParams-option-field-del-' + optionKeys[i] + '" class="option-field-del btn btn-xs btn-danger fa fa-minus"/></span></td>';
      rows += "</tr>";
    }

    Session.set('params', params);
    return rows;
  },
  "default": function () {
    try {
      var cname = document.getElementById("curveParams-selection").value;
      var c = Session.get('params').filter(function (obj) {
        return obj.name == cname;
      });

      if (c) {
        return c.default;
      } else {
        return "";
      }
    } catch (Exception) {
      return "";
    }
  },
  displayOrder: function () {
    try {
      var cname = document.getElementById("curveParams-selection").value;
      var c = Session.get('params').filter(function (obj) {
        return obj.name == cname;
      });

      if (c) {
        return c.displayOrder;
      } else {
        return 1;
      }
    } catch (Exception) {
      return 1;
    }
  },
  displayPriority: function () {
    try {
      var cname = document.getElementById("curveParams-selection").value;
      var c = Session.get('params').filter(function (obj) {
        return obj.name == cname;
      });

      if (c) {
        return c.displayPriority;
      } else {
        return 1;
      }
    } catch (Exception) {
      return 1;
    }
  },
  displayGroup: function () {
    try {
      var cname = document.getElementById("curveParams-selection").value;
      var c = Session.get('params').filter(function (obj) {
        return obj.name == cname;
      });

      if (c) {
        return c.displayGroup;
      } else {
        return 1;
      }
    } catch (Exception) {
      return 1;
    }
  },
  types: function () {
    return Object.keys(matsTypes.InputTypes);
  },
  errorMessage: function () {
    return Session.get("curveParamsErrorMessage");
  },
  errorTypeIs: function (errType) {
    return Session.get("curveParamsErrorType") === errType;
  },
  restoreDates: function () {
    try {
      var scp = matsCollections.SavedCurveParams.findOne({
        'clName': 'changeList'
      });
      var cl = scp.changeList;
      var dates = [];

      for (var i = 0; i < cl.length; i++) {
        var utcSeconds = cl[i].savedAt;
        var comment = "<textarea id='ta-" + utcSeconds + "' style='display:none'>" + cl[i].comment + "</textarea>";
        var userName = cl[i].user.split('@')[0].replace('.', ' ');
        var user = "<button id='btnUser-" + utcSeconds + "' class='btnUser btn  btn-info'>" + userName + "</button>";
        var d = new Date(0);
        d.setUTCSeconds(utcSeconds);
        var mo = d.getMonth();
        var day = d.getDate();
        var yr = d.getFullYear();
        var hr = d.getHours();
        var mn = d.getMinutes();
        var sec = d.getSeconds();
        var dStr = mo + "-" + day + "-" + yr + "-" + hr + ":" + mn + ":" + sec;
        dates.push({
          second: utcSeconds,
          date: dStr,
          user: user,
          userName: userName,
          commentStr: cl[i].comment,
          comment: comment
        });
      }

      return dates;
    } catch (e) {
      return [];
    }
  },
  restoreDate: function () {
    try {
      var scp = matsCollections.SavedCurveParams.findOne({
        'clName': 'changeList'
      });
      var cl = scp.changeList;
      var utcSeconds = cl[cl.length - 1].savedAt;
      var user = cl[cl.length - 1].user.split('@')[0].replace('.', ' ');
      var comment = cl[cl.length - 1].comment;
      var d = new Date(0);
      d.setUTCSeconds(utcSeconds);
      var mo = d.getMonth();
      var day = d.getDate();
      var yr = d.getFullYear();
      var hr = d.getHours();
      var mn = d.getMinutes();
      var sec = d.getSeconds();
      return mo + "-" + day + "-" + yr + "-" + hr + ":" + mn + ":" + sec + " " + user + " ... " + comment;
    } catch (e) {
      return "";
    }
  }
});

var reset = function () {
  document.getElementById("curveParams-name").value = "";
  document.getElementById("curveParams-type").value = "";
  document.getElementById("curveParams-controlButtonCovered-true").checked = true;
  document.getElementById("curveParams-controlButtonCovered-false").checked = false;
  document.getElementById("curveParams-controlButtonVisibility-block").checked = true;
  document.getElementById("curveParams-controlButtonVisibility-none").checked = false;
  document.getElementById("curveParams-unique-true").checked = false;
  document.getElementById("curveParams-unique-false").checked = true;
  document.getElementById("curveParams-default").value = "";
  document.getElementById("curveParams-displayOrder").value = 1;
  document.getElementById("curveParams-displayPriority").value = 1;
  document.getElementById("curveParams-displayGroup").value = 1;
  resetError();
};

var resetError = function () {
  errorMessage = "";
  Session.set("curveParamsErrorMessage", "");
  Session.set("curveParamsErrorType", "");

  if (document.getElementById("errorMessage")) {
    document.getElementById("errorMessage").style.display = "none";
  }
};

var setError = function (type, message) {
  Session.set("curveParamsErrorMessage", message);
  Session.set("curveParamsErrorType", type);
  document.getElementById("errorMessage").style.display = "block";
};

Template.curveParams.events({
  'click .curveParams-selection': function () {
    event.preventDefault();

    try {
      resetError();
      var cname = document.getElementById("curveParams-selection").value;
      reset();
      var params = Session.get('params');
      var c = params.filter(function (obj) {
        return obj.name == cname;
      })[0]; // want the first one - like collection.findOne({name:cname})

      if (!c) {
        return false;
      }

      document.getElementById("curveParams-name").value = c.name;
      document.getElementById("curveParams-type").value = c.type;

      if (c.controlButtonCovered) {
        document.getElementById("curveParams-controlButtonCovered-true").checked = true;
        document.getElementById("curveParams-controlButtonCovered-false").checked = false;
      } else {
        document.getElementById("curveParams-controlButtonCovered-true").checked = false;
        document.getElementById("curveParams-controlButtonCovered-false").checked = true;
      }

      if (c.controlButtonVisibility == "block") {
        document.getElementById("curveParams-controlButtonVisibility-block").checked = true;
        document.getElementById("curveParams-controlButtonVisibility-none").checked = false;
      } else {
        document.getElementById("curveParams-controlButtonVisibility-block").checked = false;
        document.getElementById("curveParams-controlButtonVisibility-none").checked = true;
      }

      document.getElementById("curveParams-default").value = c.default;
      document.getElementById("curveParams-displayOrder").value = c.displayOrder;
      document.getElementById("curveParams-displayPriority").value = c.displayPriority;
      document.getElementById("curveParams-displayGroup").value = c.displayGroup;
      Session.set('lastUpdate', Date.now()); // force re-render to get the optionMap
    } catch (Exception) {
      console.log(Exception);
    }

    return false;
  },
  'click .curveParams-selection-add': function () {
    event.preventDefault();
    var dispOrder = 1;
    var dispPri = 1;
    var dispGroup = 1;
    var seconds = new Date() / 1000 | 0;
    var params = Session.get('params');
    var optionsMap = {};
    params.push({
      name: 'New-' + seconds,
      type: matsTypes.InputTypes.textInput,
      optionsMap: optionsMap,
      options: Object.keys(optionsMap),
      // convenience
      controlButtonCovered: true,
      "default": '',
      unique: false,
      controlButtonVisibility: 'block',
      displayOrder: dispOrder,
      displayPriority: dispPri,
      displayGroup: dispGroup
    });
    Session.set('params', params);
    return false;
  },
  'click .curveParams-selection-remove': function () {
    event.preventDefault();
    var removeName = document.getElementById("curveParams-selection").value;
    var params = Session.get('params');
    var newParams = params.filter(function (value) {
      return value.name != removeName;
    });
    Session.set('params', newParams);
    reset();
    return false;
  },
  'click .curveParams-option-add': function (event) {
    event.preventDefault();

    try {
      var params = Session.get('params'); // find the object in the session that is associated with the currently selected name

      var paramSelectedName = document.getElementById('curveParams-selection').value;
      var param = params.filter(function (obj) {
        return obj.name === paramSelectedName;
      })[0];
      var optionsMap = param.optionsMap;
      var seconds = new Date() / 1000 | 0;
      optionsMap['new-' + seconds] = [];
      param.optionsMap = optionsMap;
      param.options = Object.keys(optionsMap);
      params[paramSelectedName] = param;
      Session.set('params', params);
    } catch (Exception) {
      console.log(Exception);
    }

    return false;
  },
  'click .curveParams-option-remove': function (event) {
    event.preventDefault();

    try {
      var params = Session.get('params'); // find the object in the session that is associated with the currently selected name

      var paramSelectedName = document.getElementById('curveParams-selection').value;
      var param = params.filter(function (obj) {
        return obj.name === paramSelectedName;
      })[0];
      var optionsMap = param.optionsMap;
      var optionSelected = Session.get('optionSelected');
      var selectedKey = "";

      if (optionSelected) {
        selectedKey = optionSelected.key;
      } else {
        var keys = Object.keys(optionsMap);
        selectedKey = keys[keys.length - 1];
      }

      param.optionsMap = _.omit(optionsMap, selectedKey);
      param.options = Object.keys(optionsMap);
      params[paramSelectedName] = param;
      Session.set('params', params);
      Session.set('optionSelected', "");
    } catch (Exception) {
      console.log(Exception);
    }

    return false;
  },
  'click .option-field-add': function (event) {
    event.preventDefault();

    try {
      var params = Session.get('params'); // find the object in the session that is associated with the currently selected name

      var paramSelectedName = document.getElementById('curveParams-selection').value;
      var param = params.filter(function (obj) {
        return obj.name === paramSelectedName;
      })[0];
      var options = param.optionsMap;
      var optionSelected = Session.get('optionSelected');
      var selectedKey = undefined;

      if (optionSelected) {
        selectedKey = Session.get('optionSelected').key;
      }

      if (selectedKey === undefined || selectedKey === "") {
        selectedKey = event.target.id.replace('curveParams-option-field-add-', '');
      }

      options[selectedKey].push('');
      param.optionsMap = options;
      params[paramSelectedName] = param;
      Session.set('params', params);
    } catch (Exception) {
      console.log(Exception);
    }

    return false;
  },
  'click .option-field-del': function () {
    event.preventDefault();
    var params = Session.get('params'); // find the object in the session that is associated with the currently selected name

    var paramSelectedName = document.getElementById('curveParams-selection').value;
    var param = params.filter(function (obj) {
      return obj.name === paramSelectedName;
    })[0];
    var options = param.optionsMap;
    var optionSelected = Session.get('optionSelected');
    var selectedKey = "";
    var listIndex = -1;

    if (optionSelected) {
      selectedKey = optionSelected.key;
      listIndex = optionSelected.listIndex;
    } else {
      var targetId = event.target.id;
      selectedKey = targetId.replace('curveParams-option-field-del-', '');
    }

    if (options[selectedKey] && options[selectedKey].length > 0) {
      if (listIndex == -1) {
        options[selectedKey] = [];
      } else {
        options[selectedKey].splice(listIndex, 1);
      }
    }

    param.optionsMap = options;
    params[paramSelectedName] = param;
    Session.set('params', params);
    Session.set('optionSelected', "");
    return false;
  },
  'click .optionsTable': function (event) {
    event.preventDefault();
    var targetId = event.target.id;

    if (targetId.indexOf('curveParams-option-') === 0) {
      var key = document.getElementById(event.target.id).value;
      var rowIndex = targetId.replace('curveParams-option-', '');
      Session.set('optionSelected', {
        key: key,
        rowIndex: rowIndex,
        listIndex: -1
      });
    } else if (targetId.indexOf('curveParams-optionList-') === 0) {
      var indexStr = targetId.replace('curveParams-optionList-', '');
      var indexes = indexStr.split('-');
      var rowIndex = indexes[0];
      var listIndex = indexes[1];
      var key = document.getElementById('curveParams-option-' + rowIndex).value;
      Session.set('optionSelected', {
        key: key,
        rowIndex: rowIndex,
        listIndex: listIndex
      });
    }

    return false;
  },
  'click .applyCurveParamsWithComment': function () {
    // actually do the apply
    event.preventDefault(); // first backup the existing parameters

    Meteor.call('getUserAddress', function (error, result) {
      if (error !== undefined) {
        setError(new Error(error.message));
        return false;
      }

      var emailAddress = result; // save the current settings and mark comment as prior to

      var saveSecond = new Date() / 1000 | 0;
      var comment = document.getElementById('applyCurveParamsComment').value;
      var paramsCursor = matsCollections.CurveParams.find({});
      var cl = matsCollections.SavedCurveParams.findOne({
        'clName': 'changeList'
      }, {
        _id: 1
      });

      if (cl === undefined) {
        matsCollections.SavedCurveParams.insert({
          clName: 'changeList',
          changeList: []
        });
        cl = matsCollections.SavedCurveParams.findOne({
          'clName': 'changeList'
        }, {
          _id: 1
        });
      }

      var id = cl._id;
      matsCollections.SavedCurveParams.update({
        _id: id
      }, {
        $push: {
          changeList: {
            user: emailAddress,
            comment: "prior to ..." + comment,
            savedAt: saveSecond
          }
        }
      });
      paramsCursor.forEach(function (doc) {
        delete doc._id;
        doc.savedSecond = saveSecond;
        matsCollections.SavedCurveParams.insert(doc);
      }); // now reconcile the session values and the CurveParams collection

      resetError();
      var params = Session.get('params');
      var curveParams = matsCollections.CurveParams.find({}).fetch();

      var paramNames = _.pluck(params, 'name');

      var curveParamNames = _.pluck(curveParams, 'name'); // find any superfluous params in CurveParams (this is a remove) and remove them from collection


      var namesToRemoveFromCollection = paramNames.filter(function (el) {
        return curveParamNames.indexOf(el) < 0;
      });

      for (var i = 0; i < namesToRemoveFromCollection.length; i++) {
        var rName = namesToRemoveFromCollection[i];
        var cParam = matsCollections.CurveParams.findOne({
          name: rName
        });
        var cid = cParam._id;
        matsCollections.CurveParams.remove({
          _id: cid
        });
      } // iterate all the params in the session and overwrite/insert them


      for (var pi = 0; pi < paramNames.length; pi++) {
        var paramName = paramNames[pi];
        var param = params.filter(function (obj) {
          return obj.name === paramName;
        })[0];
        var curveParam = matsCollections.CurveParams.findOne({
          name: paramName
        });

        if (curveParam) {
          // update
          var cid = curveParam._id;
          delete param._id;
          matsCollections.CurveParams.update({
            _id: cid
          }, {
            $set: param
          });
        } else {
          //insert
          matsCollections.CurveParams.insert(param);
        }
      } // now save the settings after modification


      saveSecond = saveSecond + 1;
      paramsCursor = matsCollections.CurveParams.find({});
      cl = matsCollections.SavedCurveParams.findOne({
        'clName': 'changeList'
      }, {
        _id: 1
      });
      id = cl._id;
      matsCollections.SavedCurveParams.update({
        _id: id
      }, {
        $push: {
          changeList: {
            user: emailAddress,
            comment: "post ..." + comment,
            savedAt: saveSecond
          }
        }
      });
      paramsCursor.forEach(function (doc) {
        delete doc._id;
        doc.savedSecond = saveSecond;
        matsCollections.SavedCurveParams.insert(doc);
      });
      reset(); // read the params back out from the DB and set them into the Session (resets the form)

      params = matsCollections.CurveParams.find({}, {
        sort: {
          displayOrder: 1
        }
      }).fetch();
      Session.set('params', params);
      Session.set('lastUpdate', Date.now()); // force re-render to get the optionMap

      $("#applyCurveParamsModal").modal('hide');
    });
    return false;
  },
  'click .cancel-curveParams': function () {
    event.preventDefault();
    reset();
    var params = matsCollections.CurveParams.find({}, {
      sort: {
        displayOrder: 1
      }
    }).fetch();
    Session.set('params', params);
    document.getElementById("curveParams-selection").value = "";
    Session.set('lastUpdate', Date.now()); // force re-render to get the optionMap

    return false;
  },
  'click .applyCurveParams': function () {
    // show the apply modal dialogue
    event.preventDefault();
    $("#applyCurveParamsModal").modal('show');
    return false;
  },
  'click .restoreCurveParams': function () {
    event.preventDefault();
    $("#restoreCurveParamsModal").modal('show');
    return false;
  },
  'click .btnUser': function (event) {
    event.preventDefault();
    var targetId = event.target.id;
    var taId = targetId.replace('btnUser-', 'ta-');

    if (document.getElementById(taId).style.display == 'block') {
      document.getElementById(taId).style.display = 'none';
    } else {
      document.getElementById(taId).style.display = 'block';
    }

    return false;
  },
  'click .restoreCurveParamsDate': function (event) {
    //populate input restoreFromSeconds input box with selected value and data attributes
    event.preventDefault();
    var targetId = event.target.id;
    var elem = document.getElementById(targetId);
    var second = elem.getAttribute('data-second');
    var date = elem.getAttribute('data-date');
    var user = elem.getAttribute('data-user');
    var comment = elem.getAttribute('data-comment');
    var rfd = document.getElementById('restoreFromSeconds');
    rfd.setAttribute('data-second', second);
    rfd.setAttribute('data-date', date);
    rfd.setAttribute('data-user', user);
    rfd.setAttribute('data-comment', comment);
    rfd.value = date + " " + user + " ... " + comment;
    document.getElementById("restore-choose-date-toggle").click();
    return false;
  },
  'click .restoreCurveParamsFromDate': function (event) {
    // copy all dated elements with the selected savedSecond back to curveParams
    event.preventDefault();
    var restoreFromSeconds = document.getElementById("restoreFromSeconds");
    var savedSecond = restoreFromSeconds.getAttribute('data-second');
    var savedParams = matsCollections.SavedCurveParams.find({
      'savedSecond': Number(savedSecond)
    });
    savedParams.forEach(function (doc) {
      delete doc._id;
      delete doc.savedSecond;
      var name = doc.name;
      var curveParam = matsCollections.CurveParams.findOne({
        name: name
      });
      var id = curveParam._id;
      matsCollections.CurveParams.update({
        _id: id
      }, {
        $set: doc
      });
    });
    Session.set('lastUpdate', Date.now()); // force re-render

    $("#restoreCurveParamsModal").modal('hide');
    return false;
  },
  'click .cancel-restoreCurveParamsFromDate': function (event) {
    // copy all dated elements with the selected savedSecond back to curveParams
    event.preventDefault();
    $("#restoreCurveParamsModal").modal('hide');
    return false;
  },
  'change': function (event) {
    // should catch all the widgets whenever a change happens.
    // This is where we capture changes and move them to the session.
    // When the apply is hit a different event listener will migrate the modified
    // session settings to the collection.
    event.preventDefault();
    var params = Session.get('params');
    var targetId = event.target.id;

    if (targetId == "curveParams-selection") {
      // ignore changes to the main selector
      return false;
    }

    var elem = document.getElementById(targetId);
    var value = elem.value; // find the object in the session that is associated with the currently selected name

    var paramSelectedName = document.getElementById('curveParams-selection').value;
    var param = params.filter(function (obj) {
      return obj.name === paramSelectedName;
    })[0]; // each curveParameter is made up of several fields...
    // the name, type, optionsMap, options (is derived from optionsMap), controlButtonCovered, unique, default, controlButtonVisibility, displayOrder, displayPriority, and displayGroup
    // Which of these is captured by an element is set in the data-field attribute.

    var dataField = elem.getAttribute('data-field');

    if (!dataField) {
      return false;
    }

    if (dataField.indexOf('optionsMap') == 0) {
      // For an optionsMap the dataField is a cell in the optionsMap table.
      // If it is the first column it is something like optionsMap.RH_n   i.e. RH is the value of the leftmost cell
      // and RH is also a key of the params.optionsMap object. n is the row that the key is in.
      // If it is the second column it is something like optionsMap.RH_n[0].
      // That is because the in memory representation (params.optionsMap object) uses the value of the first column to
      // denote a hashmap key, and the rest of the columns are contained in a list starting
      // with index 0 at the left of the table.
      // like .. key:[col2,col3,....coln], so it might be...
      // optionsMap.RH:[0,1..n] to denote the rest of a row.
      //NOTE: we trim the keys but not the other cell values - they might contain necessary white space.
      var keyParts = dataField.replace('optionsMap.', '').split('_');
      var key = keyParts[0];
      var optionsMap = param.optionsMap;

      if (keyParts[1].indexOf('[') !== -1) {
        // this is a key and list index
        var index = keyParts[1].split('[')[1].replace(']', '');
        optionsMap[key][index] = value;
      } else {
        //  we are essentially renaming the key to new value and deleting the old key
        value = value.trim(); // trim the whitespace from both ends

        if (key != value) {
          // don't do it if it is somehow the same.
          Object.defineProperty(optionsMap, value, Object.getOwnPropertyDescriptor(optionsMap, key));
          delete optionsMap[key];
        }
      } // optionsMap has been changed...


      param.optionsMap = optionsMap;
      param.options = Object.keys(optionsMap);
    } else {
      // regular field - just set the value
      param.field = value;
    } //console.log ("change:  value:" + value + "\n  field: " + dataField + "\n  paramSelectedName " + paramSelectedName + "  \n param: \n" + JSON.stringify(param));


    Session.set('params', params);
    Session.set('lastUpdate', Date.now()); // force re-render to get the optionMap

    return false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.authorization.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.authorization.js                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("authorization");
Template["authorization"] = new Template("Template.authorization", (function() {
  var view = this;
  return HTML.DIV({
    id: "authorizationModal",
    class: "modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.FORM({
    name: "authForm",
    novalidate: ""
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4>Authorization</h4>\n                </div>'), "\n                ", HTML.DIV({
    class: "modal-body"
  }, "\n                    ", HTML.Raw('<div>\n                        <label>Apply new role ...</label>\n                        <input id="userRoleName" class="data-input textInput user_role_name" type="text" required="" placeholder="Enter a new role name" name="new_role_name">\n                        <input id="userRoleDescription" class="data-input textInput user_role_description" type="text" required="" placeholder="Enter new role description" name="new_role_description">\n                    </div>'), "\n                    ", HTML.DIV("\n                        ", HTML.Raw("<label>Apply existing role...</label>"), "\n                        ", HTML.SELECT({
    class: "data-input role-select",
    size: "5",
    name: "authorization_role",
    id: "authorizationRole"
  }, "\n                            ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("roleOptions"));
  }, function() {
    return [ "\n                                ", HTML.OPTION({
      value: function() {
        return Spacebars.mustache(view.lookup("name"));
      }
    }, Blaze.View("lookup:name", function() {
      return Spacebars.mustache(view.lookup("name"));
    }), " - ", Blaze.View("lookup:description", function() {
      return Spacebars.mustache(view.lookup("description"));
    })), "\n                            " ];
  }), "\n                        "), "\n                    "), "\n                    ", HTML.Raw('<div>\n                        <label>Apply to unauthorized user email ...</label>\n                        <input id="newUserEmail" class="data-input textInput user-email" type="email" required="" placeholder="Enter a valid email address" name="apply_role_to_new">\n                    </div>'), "\n                    ", HTML.DIV("\n                        ", HTML.Raw("<label>Apply to previously authorized email...</label>"), "\n                        ", HTML.SELECT({
    class: "data-input user-select",
    size: "5",
    name: "apply_role_to",
    id: "existingUserEmail"
  }, "\n                            ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("emailOptions"));
  }, function() {
    return [ "\n                                ", HTML.OPTION({
      value: function() {
        return Spacebars.mustache(view.lookup("email"));
      }
    }, Blaze.View("lookup:email", function() {
      return Spacebars.mustache(view.lookup("email"));
    }), ":", Blaze.View("lookup:roles", function() {
      return Spacebars.mustache(view.lookup("roles"));
    })), "\n                            " ];
  }), "\n                        "), "\n                    "), "\n                    ", HTML.Raw('<div class="modal-footer btn-group">\n                        <button name="cancelAuthorization" type="button" class="cancel-authorization btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                        <button name="applyAuthorization" type="button" class="apply_authorization btn btn-primary">&nbsp;&nbsp;Apply</button>\n                        <button name="removeAuthorization" type="button" class="remove_authorization btn btn-primary">&nbsp;&nbsp;Remove Selected</button>\n                    </div>'), "\n                "), "\n                "), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-content -->"), "\n        "), HTML.Raw("\n        <!-- /.modal-dialog -->\n    "));
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"authorization.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/authorization.js                                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
Template.authorization.helpers({
  roleOptions: function () {
    return matsCollections.Roles.find({}).fetch();
  },
  emailOptions: function () {
    return matsCollections.Authorization.find({}).fetch();
  }
});
Template.authorization.events({
  'click .apply_authorization': function () {
    var userRoleName = document.getElementById("userRoleName").value;
    var userRoleDescription = document.getElementById("userRoleDescription").value;
    var authorizationRole = document.getElementById("authorizationRole").value;
    var newUserEmail = document.getElementById("newUserEmail").value;
    var existingUserEmail = document.getElementById("existingUserEmail").value;
    var settings = {};
    settings.userRoleName = userRoleName;
    settings.userRoleDescription = userRoleDescription;
    settings.authorizationRole = authorizationRole;
    settings.newUserEmail = newUserEmail;
    settings.existingUserEmail = existingUserEmail;
    Meteor.call('applyAuthorization', settings, function (error) {
      if (error) {
        setError(new Error(error.message));
      }
    }); // reset modal

    document.getElementById("userRoleName").value = "";
    document.getElementById("userRoleDescription").value = "";
    document.getElementById("authorizationRole").value = "";
    document.getElementById("newUserEmail").value = "";
    document.getElementById("existingUserEmail").value = "";
    $("#authorizationModal").modal('hide');
    return false;
  },
  'click .remove_authorization': function () {
    var userRoleName = document.getElementById("userRoleName").value;
    var userRoleDescription = document.getElementById("userRoleDescription").value;
    var authorizationRole = document.getElementById("authorizationRole").value;
    var newUserEmail = document.getElementById("newUserEmail").value;
    var existingUserEmail = document.getElementById("existingUserEmail").value;
    var settings = {};
    settings.userRoleName = userRoleName;
    settings.userRoleDescription = userRoleDescription;
    settings.authorizationRole = authorizationRole;
    settings.newUserEmail = newUserEmail;
    settings.existingUserEmail = existingUserEmail;
    Meteor.call('removeAuthorization', settings, function (error) {
      if (error) {
        setError(new Error(error.message));
      }
    }); // reset modal

    document.getElementById("userRoleName").value = "";
    document.getElementById("userRoleDescription").value = "";
    document.getElementById("authorizationRole").value = "";
    document.getElementById("newUserEmail").value = "";
    document.getElementById("existingUserEmail").value = "";
    $("#authorizationModal").modal('hide');
    return false;
  },
  'click .cancel-authorization': function () {
    // reset the form
    document.getElementById("userRoleName").value = "";
    document.getElementById("userRoleDescription").value = "";
    document.getElementById("authorizationRole").value = "";
    document.getElementById("newUserEmail").value = "";
    document.getElementById("existingUserEmail").value = "";
  },
  'click .user_role_description': function () {
    document.getElementById('authorizationRole').value = '';
  },
  'click .user_role_name': function () {
    document.getElementById('authorizationRole').value = '';
  },
  'change .role-select': function () {
    document.getElementById('userRoleName').value = '';
    document.getElementById('userRoleDescription').value = '';
  },
  'click .user-email': function () {
    document.getElementById('existingUserEmail').value = '';
  },
  'change .user-select': function () {
    document.getElementById('newUserEmail').value = '';
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.mail_credentials.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.mail_credentials.js                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("mailCredentials");
Template["mailCredentials"] = new Template("Template.mailCredentials", (function() {
  var view = this;
  return [ HTML.STYLE({
    id: "jsbin-css"
  }, "\n        #apstMoleculeModal .form-group {\n            padding-right:20px;\n            position:relative;\n        }\n\n        #apstMoleculeModal .help {\n            position:absolute;\n            right:-8px;\n            top:12px;\n        }\n    "), "\n    ", HTML.DIV({
    id: "mailCredentialsModal",
    class: "modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title">Mail Credentials</h4>\n                </div>'), "\n                ", HTML.FORM({
    class: "form-horizontal",
    name: "credForm",
    novalidate: ""
  }, "\n                    ", HTML.DIV({
    class: "modal-body"
  }, "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.DIV({
    class: "controls col-xs-12"
  }, "\n                                ", HTML.Raw("<label>name</label>"), "\n                                ", HTML.INPUT({
    id: "credentials-name",
    class: "form-control data-input textInput credentials_name",
    type: "text",
    value: function() {
      return Spacebars.mustache(view.lookup("name"));
    },
    name: "credentials__name"
  }), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.DIV({
    class: "controls col-xs-12"
  }, "\n                                ", HTML.Raw("<label>id</label>"), "\n                                ", HTML.INPUT({
    id: "credentials_client_id",
    class: "form-control data-input textInput credentials_client_id",
    type: "text",
    value: function() {
      return Spacebars.mustache(view.lookup("client_id"));
    },
    name: "credentials_client_id"
  }), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.DIV({
    class: "controls col-xs-12"
  }, "\n                                ", HTML.Raw("<label>secret</label>"), "\n                                ", HTML.INPUT({
    id: "credentials_client_secret",
    class: "form-control data-input textInput credentials_client_secret",
    type: "text",
    value: function() {
      return Spacebars.mustache(view.lookup("client_secret"));
    },
    name: "credentials_client_secret"
  }), "\n                            "), "\n                        "), "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.DIV({
    class: "controls col-xs-12"
  }, "\n                                ", HTML.Raw("<label>refresh token</label>"), "\n                                ", HTML.INPUT({
    id: "credentials_client_refresh_token",
    class: "form-control data-input textInput credentials_client_refresh_token",
    type: "text",
    value: function() {
      return Spacebars.mustache(view.lookup("refresh_token"));
    },
    name: "credentials_client_refresh_token"
  }), "\n                            "), "\n                        "), "\n                        ", HTML.Raw('<div class="modal-footer btn-group">\n                            <button name="cancelCredentials" type="button" class="cancel-credentials btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel</button>\n                            <button name="applyCredentials" type="button" class="apply_credentials btn btn-primary">&nbsp;&nbsp;Apply</button>\n                        </div>'), "\n                    "), "\n                "), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-content -->"), "\n        "), "\n        ", HTML.Raw("<!-- /.modal-dialog -->"), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"mail_credentials.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/mail_credentials.js                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 1);
var methods;
module.link("meteor/randyp:mats-common", {
  methods: function (v) {
    methods = v;
  }
}, 2);
Template.mailCredentials.helpers({
  name: function () {
    var credentials = matsCollections.Credentials.findOne({});
    return credentials === undefined ? "" : credentials.name;
  },
  client_id: function () {
    var credentials = matsCollections.Credentials.findOne({});
    return credentials === undefined ? "" : credentials.clientId;
  },
  client_secret: function () {
    var credentials = matsCollections.Credentials.findOne({});
    return credentials === undefined ? "" : credentials.clientSecret;
  },
  refresh_token: function () {
    var credentials = matsCollections.Credentials.findOne({});
    return credentials === undefined ? "" : credentials.refresh_token;
  }
});
Template.mailCredentials.events({
  'click .apply_credentials': function () {
    var name = document.getElementById("credentials-name").value;
    var clientId = document.getElementById("credentials_client_id").value;
    var clientSecret = document.getElementById("credentials_client_secret").value;
    var clientRefreshToken = document.getElementById("credentials_client_refresh_token").value;
    var settings = {};
    settings.name = name;
    settings.clientId = clientId;
    settings.clientSecret = clientSecret;
    settings.clientRefreshToken = clientRefreshToken;
    methods.setCredentials(settings, function (error) {
      if (error) {
        setError(new Error(error.message));
      }
    }); // reset modal

    document.getElementById("credentials-name").value = "";
    document.getElementById("credentials_client_id").value = "";
    document.getElementById("credentials_client_secret").value = "";
    document.getElementById("credentials_client_refresh_token").value = "";
    $("#authorizationModal").modal('hide');
    return false;
  },
  'click .cancel-credentials': function () {
    // reset the form
    var credentials = matsCollections.Credentials.findOne({});
    document.getElementById("credentials-name").value = credentials.name;
    document.getElementById("credentials_client_id").value = credentials.clientId;
    document.getElementById("credentials_client_secret").value = credentials.clientSecret;
    document.getElementById("credentials_client_refresh_token").value = credentials.refresh_token;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.PlotGraphFunctions.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.PlotGraphFunctions.js                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("plotGraphFunctions");
Template["plotGraphFunctions"] = new Template("Template.plotGraphFunctions", (function() {
  var view = this;
  return [ HTML.STYLE({
    id: "jsbin-css"
  }, "\n        #apstMoleculeModal .form-group {\n            padding-right: 20px;\n            position: relative;\n        }\n\n        #apstMoleculeModal .help {\n            position: absolute;\n            right: -8px;\n            top: 12px;\n        }\n    "), "\n    ", HTML.DIV({
    id: "plotGraphFunctionsModal",
    class: "modal",
    role: "dialog"
  }, "\n        ", HTML.DIV({
    class: "modal-dialog"
  }, "\n            ", HTML.DIV({
    class: "modal-content"
  }, "\n                ", HTML.Raw('<div class="modal-header">\n                    <h4 class="modal-title">PlotGraphFunctions</h4>\n                </div>'), "\n                ", HTML.DIV({
    class: "modal-body"
  }, "\n                    ", HTML.FORM({
    class: "form-horizontal",
    name: "pgForm",
    novalidate: ""
  }, "\n                        ", HTML.DIV({
    class: "form-group"
  }, "\n                            ", HTML.DIV({
    class: "form-group"
  }, "\n                                ", HTML.Raw('<div class="controls col-xs-2">\n                                    <label>Plot Graph</label>\n                                </div>'), "\n                                ", HTML.Raw('<div class="controls col-xs-1">\n                                    <button type="button" id="plotGraphFunction-selection-add" class="plotGraphFunction-selection-add btn btn-xs btn-success fa fa-plus"></button>\n                                    <button type="button" id="plotGraphFunction-selection-remove" class="plotGraphFunction-selection-remove btn btn-xs btn-danger fa fa-minus"></button>\n                                </div>'), "\n\n                                ", HTML.DIV({
    class: "controls col-xs-2"
  }, "\n                                    ", HTML.SELECT({
    class: "plotGraphFunction",
    size: "5",
    name: "plotGraphFunction",
    id: "plotGraphFunction-selection"
  }, "\n                                        ", Blaze.Each(function() {
    return Spacebars.call(view.lookup("plotGraphFunction"));
  }, function() {
    return [ "\n                                            ", HTML.OPTION({
      value: function() {
        return Spacebars.mustache(view.lookup("plotType"));
      }
    }, Blaze.View("lookup:plotType", function() {
      return Spacebars.mustache(view.lookup("plotType"));
    })), "\n                                        " ];
  }), "\n                                    "), "\n                                "), "\n                            "), "\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "plotType");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Plot Type</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                    <input id="plotType" class="form-control data-input textInput plotType" type="text" required="" placeholder="plotType" name="plotType">\n                            </div>'), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "dataFunction");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Data Function</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                <input id="dataFunction" class="form-control data-input textInput dataFunction" type="text" required="" placeholder="dataFunction" name="dataFunction">\n                            </div>'), "\n\n                            ", Blaze.If(function() {
    return Spacebars.dataMustache(view.lookup("errorTypeIs"), "graphFunction");
  }, function() {
    return [ "\n                                ", HTML.DIV({
      id: "errorMessage",
      class: "errorMessage",
      style: "color: red; display: none"
    }, Blaze.View("lookup:errorMessage", function() {
      return Spacebars.mustache(view.lookup("errorMessage"));
    })), "\n                            " ];
  }), "\n                            ", HTML.Raw('<div class="controls col-xs-2">\n                                <label>Graph Function</label>\n                            </div>'), "\n                            ", HTML.Raw('<div class="controls col-xs-12">\n                                <input id="graphFunction" class="form-control data-input textInput graphFunction" type="text" required="" placeholder="graphFunction" name="graphFunction">\n                            </div>'), "\n\n                        "), "\n\n                        ", HTML.Raw('<div class="modal-footer btn-group">\n                            <button name="cancelPlotgraphFunction" type="button" class="cancel-plotGraphFunction btn btn-info" data-dismiss="modal">&nbsp;&nbsp;Cancel\n                            </button>\n                            <button name="applyPlotGraphFunction" type="button" class="apply-plotGraphFunction btn btn-primary">\n                                &nbsp;&nbsp;Apply\n                            </button>\n                        </div>'), "\n                    "), "\n                "), "\n            "), "\n            ", HTML.Raw("<!-- /.modal-content -->"), "\n        "), "\n        ", HTML.Raw("<!-- /.modal-dialog -->"), "\n    ") ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"PlotGraphFunctions.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/PlotGraphFunctions.js                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 0);
Template.plotGraphFunctions.helpers({
  plotGraphFunction: function () {
    if (Session.get("PlotGraphFunctions") === undefined || Session.get("PlotGraphFunctions").length == 0) {
      Session.set("PlotGraphFunctions", matsCollections.PlotGraphFunctions.find({}).fetch());
    }

    return Session.get("PlotGraphFunctions");
  },
  errorMessage: function () {
    return Session.get("errorMessage");
  },
  errorTypeIs: function (type) {
    return Session.get("errorType") === type;
  }
});

var resetError = function () {
  errorMessage = "";
  Session.set("errorMessage", "");
  Session.set("errorType", "");

  if (document.getElementById("errorMessage")) {
    document.getElementById("errorMessage").style.display = "none";
  }
};

var setError = function (type, message) {
  Session.set("errorMessage", message);
  Session.set("errorType", type);
  document.getElementById("errorMessage").style.display = "block";
};

Template.plotGraphFunctions.events({
  'click .plotGraphFunction': function (event) {
    event.preventDefault();
    resetError();
    var plotTypeStr = document.getElementById('plotGraphFunction-selection').value;
    var plotGraphFunctions = Session.get("PlotGraphFunctions");
    var plotGraphFunction = plotGraphFunctions.filter(function (obj) {
      return obj.plotType === plotTypeStr;
    })[0];
    document.getElementById("plotType").value = plotGraphFunction.plotType;
    document.getElementById("dataFunction").value = plotGraphFunction.dataFunction;
    document.getElementById("graphFunction").value = plotGraphFunction.graphFunction;
    return false;
  },
  'click .plotGraphFunction-selection-add': function (event) {
    event.preventDefault();
    resetError();
    var d = (Date.now() / 1000 | 0).toString();
    var plotGraphFunctions = Session.get("PlotGraphFunctions");
    plotGraphFunctions.push({
      plotType: d,
      graphFunction: "graph...",
      dataFunction: "data..."
    });
    Session.set("PlotGraphFunctions", plotGraphFunctions);
    return false;
  },
  'click .plotGraphFunction-selection-remove': function (event) {
    event.preventDefault();
    resetError();
    var plotTypeStr = document.getElementById('plotGraphFunction-selection').value;
    var plotGraphFunctions = Session.get("PlotGraphFunctions");

    for (i = plotGraphFunctions.length - 1; i >= 0; i--) {
      if (plotGraphFunctions[i].plotType == plotTypeStr) plotGraphFunctions.splice(i, 1);
    }

    Session.set("PlotGraphFunctions", plotGraphFunctions);
    return false;
  },
  'click .apply-plotGraphFunction': function () {
    event.preventDefault(); //

    var sPlotGraphFunctions = Session.get("PlotGraphFunctions");
    var plotGraphFunctions = matsCollections.PlotGraphFunctions.find({}).fetch();

    var sPlotTypes = _.pluck(sPlotGraphFunctions, 'plotType');

    var plotTypes = _.pluck(plotGraphFunctions, 'plotType'); // find any superfluous ones in plotTypes (this is a remove) and remove them from collection


    var toRemoveFromCollection = plotTypes.filter(function (el) {
      return sPlotTypes.indexOf(el) < 0;
    });

    for (var ip = 0; ip < toRemoveFromCollection.length; ip++) {
      var p = toRemoveFromCollection[ip];
      var plotType = matsCollections.PlotGraphFunctions.findOne({
        plotType: p
      });
      var id = plotType._id;
      matsCollections.PlotGraphFunctions.remove({
        _id: id
      });
    } // iterate all the ones in the session and overwrite/add them


    for (var i = 0; i < sPlotTypes.length; i++) {
      var s = sPlotTypes[i];
      var spgf = sPlotGraphFunctions.filter(function (obj) {
        return obj.plotType === s;
      })[0];
      var pt = matsCollections.PlotGraphFunctions.findOne({
        plotType: s
      });

      if (pt) {
        // update
        var ptid = pt._id;
        delete spgf._id;
        matsCollections.PlotGraphFunctions.update({
          _id: ptid
        }, {
          $set: spgf
        });
      } else {
        //insert
        matsCollections.PlotGraphFunctions.insert(spgf);
      }
    }

    Session.set("PlotGraphFunctions", matsCollections.PlotGraphFunctions.find({}).fetch());
    $("#plotGraphFunctionsModal").modal('hide');
    return false;
  },
  'click .cancel-plotGraphFunction': function () {
    event.preventDefault();
    $("#plotGraphFunctionsModal").modal('hide');
    return false;
  },
  'change .plotType, change .dataFunction, change .graphFunction': function () {
    var plotTypeStr = document.getElementById('plotGraphFunction-selection').value;
    var sPlotGraphFunctions = Session.get("PlotGraphFunctions");
    var spgf = sPlotGraphFunctions.filter(function (obj) {
      return obj.plotType === plotTypeStr;
    })[0];
    var plotType = document.getElementById('plotType').value;
    var dataFunction = document.getElementById('dataFunction').value;
    var graphFunction = document.getElementById('graphFunction').value;
    spgf.plotType = plotType;
    spgf.dataFunction = dataFunction;
    spgf.graphFunction = graphFunction;
    Session.set("PlotGraphFunctions", sPlotGraphFunctions);
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"template.administration.js":function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/template.administration.js                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //

Template.__checkName("administration");
Template["administration"] = new Template("Template.administration", (function() {
  var view = this;
  return [ HTML.DIV(HTML.Attrs({
    id: "adminContainer",
    style: "display:none;"
  }, function() {
    return Spacebars.attrMustache(view.lookup("adminChanged"));
  }), "\n    ", HTML.DIV({
    id: "administration",
    class: "container-fluid pull-right",
    style: "height:100%;margin-top:0; padding: 0;"
  }, "\n        ", HTML.SPAN({
    style: "background-color: lightgreen;font-size: small;color: black; "
  }, Blaze.View("lookup:signedIn", function() {
    return Spacebars.mustache(view.lookup("signedIn"));
  })), "\n        ", HTML.DIV({
    class: "btn-toolbar btn-group btn-xs",
    role: "toolbar"
  }, "\n            ", HTML.BUTTON({
    style: function() {
      return [ "color: black;background-color:lightgreen;display:", Spacebars.mustache(view.lookup("showAdministratorDiv")) ];
    },
    type: "button",
    name: "authorization",
    id: "authorization",
    class: "authorization btn btn-success btn-xs fa fa-users"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Authorization"), "\n            ", HTML.BUTTON({
    style: function() {
      return [ "color: black;background-color:lightgreen;display:", Spacebars.mustache(view.lookup("showAdministratorDiv")) ];
    },
    type: "button",
    name: "database",
    id: "database",
    class: "database btn btn-success  btn-xs fa fa-database"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Database"), "\n            ", HTML.BUTTON({
    style: function() {
      return [ "color: black;background-color:lightgreen;display:", Spacebars.mustache(view.lookup("showAdministratorDiv")) ];
    },
    type: "button",
    name: "credentials",
    id: "credentials",
    class: "credentials btn btn-success btn-xs fa fa-envelope-o"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Email Credentials"), "\n            ", HTML.BUTTON({
    style: function() {
      return [ "color: black;background-color:lightgreen;display:", Spacebars.mustache(view.lookup("showAdministratorDiv")) ];
    },
    type: "button",
    name: "curveParams",
    id: "credentials",
    class: "curveParams btn btn-success btn-xs fa fa-align-center"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Curve Parameters"), "\n            ", HTML.BUTTON({
    style: function() {
      return [ "color: black;background-color:lightgreen;display:", Spacebars.mustache(view.lookup("showAdministratorDiv")) ];
    },
    type: "button",
    name: "plotGraphFunctions",
    id: "plotGraphFunctions",
    class: "plotGraphFunctions btn btn-success btn-xs fa fa-align-center"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Plot Graph Functions"), "\n            ", HTML.BUTTON({
    style: function() {
      return [ "color: black;background-color:lightgreen;display:", Spacebars.mustache(view.lookup("showAdministratorDiv")) ];
    },
    type: "button",
    name: "export",
    id: "export",
    class: "export btn btn-success btn-xs fa fa-download"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Export"), "\n            ", HTML.BUTTON({
    style: function() {
      return [ "color: black;background-color:lightgreen;display:", Spacebars.mustache(view.lookup("showAdministratorDiv")) ];
    },
    type: "button",
    name: "import",
    id: "import",
    class: "import btn btn-success btn-xs fa fa-upload"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Import"), "\n        "), "\n        ", HTML.DIV("\n        ", HTML.DIV({
    class: "pull-right btn-toolbar btn-group btn-xs",
    role: "toolbar"
  }, "\n            ", HTML.BUTTON({
    style: function() {
      return [ "color: black;background-color:lightgreen;display:", Spacebars.mustache(view.lookup("showAuthenticatedDiv")) ];
    },
    type: "button",
    name: "colors",
    id: "colors",
    class: "colors btn btn-success btn-xs fa fa-paint-brush"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Colors"), "\n            ", HTML.BUTTON({
    style: function() {
      return [ "color: black;background-color:lightgreen;display:", Spacebars.mustache(view.lookup("showAuthenticatedDiv")) ];
    },
    type: "button",
    name: "settings",
    id: "settings",
    class: "settings btn btn-success btn-xs fa fa-cogs"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Settings"), "\n            ", HTML.BUTTON({
    style: function() {
      return [ "display:", Spacebars.mustache(view.lookup("showResetNow")) ];
    },
    type: "button",
    name: "resetNow",
    id: "resetNow",
    class: "resetNow btn btn-danger btn-xs fa fa-exclamation"
  }, HTML.Raw("&nbsp;"), HTML.Raw("&nbsp;"), "Reset Now"), "\n        "), "\n        "), "\n        ", Spacebars.include(view.lookupTemplate("authorization")), "\n        ", Spacebars.include(view.lookupTemplate("mailCredentials")), "\n        ", Spacebars.include(view.lookupTemplate("settings")), "\n        ", Spacebars.include(view.lookupTemplate("colorScheme")), "\n        ", Spacebars.include(view.lookupTemplate("databases")), "\n        ", Spacebars.include(view.lookupTemplate("curveParams")), "\n        ", Spacebars.include(view.lookupTemplate("plotGraphFunctions")), "\n        ", Spacebars.include(view.lookupTemplate("export")), "\n        ", Spacebars.include(view.lookupTemplate("import")), "\n        ", Spacebars.include(view.lookupTemplate("reset")), "\n    "), "\n    "), HTML.Raw('\n    <div id="showAdministration"><button style="background-color: lightgreen; color: black; display: none;" class="adminControl btn btn-xs pull-right fa fa-gears"></button></div>') ];
}));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"administration.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/randyp_mats-common/templates/administration/administration.js                                              //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Meteor;
module.link("meteor/meteor", {
  Meteor: function (v) {
    Meteor = v;
  }
}, 0);
var Hooks;
module.link("meteor/differential:event-hooks", {
  Hooks: function (v) {
    Hooks = v;
  }
}, 1);
var matsTypes;
module.link("meteor/randyp:mats-common", {
  matsTypes: function (v) {
    matsTypes = v;
  }
}, 2);
var matsCollections;
module.link("meteor/randyp:mats-common", {
  matsCollections: function (v) {
    matsCollections = v;
  }
}, 3);
var matsMethods;
module.link("meteor/randyp:mats-common", {
  matsMethods: function (v) {
    matsMethods = v;
  }
}, 4);
Accounts.onLogin(function () {
  matsMethods.getAuthorizations.call(function (error, result) {
    if (error !== undefined) {
      Session.set('roles', []);
      setError(new Error(error.toLocaleString()));
      return false;
    }

    authList = result;

    for (var ai = 0; ai < authList.length; ai++) {
      var roles = authList[ai];
      Session.set('roles', roles);
      Session.set('signedIn', new Date().getTime()); // force re-render after sign in success
    }
  });
});

Hooks.onLoggedOut = function (userid) {
  Session.set('roles', []);
  var adminContainerDiv = document.getElementById('adminContainer');
  var adminDiv = document.getElementById("administration");
  var userDiv = document.getElementById("administration");
  adminContainerDiv.style.display = "none";
  adminDiv.style.display = "none";
  userDiv.style.display = "none";
};

Template.administration.helpers({
  adminChanged: function () {
    return Session.get('adminChanged');
  },
  signedIn: function () {
    var d = new Date(Session.get('signedIn'));
    return (d.toDateString() + " " + d.toTimeString()).split("+")[0];
  },
  showAdministratorDiv: function () {
    var roles = Session.get('roles');

    if (roles !== undefined && roles.indexOf('administrator') > -1) {
      return "block";
    } else {
      return "none";
    }
  },
  showAuthenticatedDiv: function () {
    var roles = Session.get('roles');

    if (roles !== undefined && roles.indexOf('user') > -1 || roles !== undefined && roles.indexOf('administrator') > -1) {
      return "block";
    } else {
      return "none";
    }
  },
  showResetNow: function () {
    var adminChanged = Session.get('adminChanged');
    var settings = matsCollections.Settings.findOne({});

    if (document.getElementById("ResetFromCode") == null) {
      return "none";
    }

    var resetEnabled = settings === undefined ? false : document.getElementById("ResetFromCode").checked;
    var roles = Session.get('roles');

    if (roles !== undefined && roles.indexOf('administrator') > -1 && resetEnabled) {
      return "block";
    } else {
      return "none";
    }
  }
});
Template.administration.events({
  'click .authorization': function () {
    $("#authorizationModal").modal('show');
  },
  'click .credentials': function () {
    $("#mailCredentialsModal").modal('show');
  },
  'click .database': function () {
    $("#databasesModal").modal('show');
  },
  'click .colors': function () {
    $("#colorSchemeModal").modal('show');
  },
  'click .settings': function () {
    $("#settingsModal").modal('show');
  },
  'click .curveParams': function () {
    var params = matsCollections.CurveParams.find({}, {
      sort: {
        displayOrder: 1
      }
    }).fetch();
    Session.set('params', params);
    $("#curveParamsModal").modal('show');
  },
  'click .plotGraphFunctions': function () {
    $("#plotGraphFunctionsModal").modal('show');
  },
  'click .export': function () {
    $("#exportModal").modal('show');
  },
  'click .import': function () {
    $("#importModal").modal('show');
  },
  'click .adminControl': function () {
    var adminContainerDiv = document.getElementById('adminContainer');
    var adminDiv = document.getElementById("administration");
    var userDiv = document.getElementById("administration");

    if (adminContainerDiv.style.display == "none") {
      adminContainerDiv.style.display = "block";
      var roles = Session.get('roles');

      if (roles !== undefined && Session.get('roles').indexOf('administrator') > -1) {
        adminDiv.style.display = "block";
        userDiv.style.display = "block";
      } else if (roles !== undefined && Session.get('roles').indexOf('user') > -1) {
        userDiv.style.display = "block";
      } else {
        adminContainerDiv.style.display = "none";
        adminDiv.style.display = "none";
        userDiv.style.display = "none";
      }
    } else {
      adminContainerDiv.style.display = "none";
      adminDiv.style.display = "none";
      userDiv.style.display = "none";
    }
  },
  'click .resetNow': function () {
    $("#resetModal").modal('show');
    document.getElementById("ResetFromCode").checked = false;
    var settings = matsCollections.Settings.findOne({});
    settings.resetFromCode = false;
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}},"node_modules":{"@babel":{"runtime":{"helpers":{"interopRequireDefault.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/interopRequireDefault.js                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"typeof.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/typeof.js                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"toConsumableArray.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/toConsumableArray.js                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var arrayWithoutHoles = require("./arrayWithoutHoles");

var iterableToArray = require("./iterableToArray");

var nonIterableSpread = require("./nonIterableSpread");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"arrayWithoutHoles.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"iterableToArray.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/iterableToArray.js                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"nonIterableSpread.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/nonIterableSpread.js                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"objectSpread.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/objectSpread.js                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var defineProperty = require("./defineProperty");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"defineProperty.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/@babel/runtime/helpers/defineProperty.js                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}}},"url":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/url/package.json                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "url",
  "version": "0.11.0",
  "main": "./url.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"url.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/url/url.js                                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"util.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/url/util.js                                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"punycode":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/punycode/package.json                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "punycode",
  "version": "1.3.2",
  "main": "punycode.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"punycode.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/punycode/punycode.js                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"querystring":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/querystring/package.json                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "querystring",
  "version": "0.2.0"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"index.js":function(require,exports){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/querystring/index.js                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"decode.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/querystring/decode.js                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"encode.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/querystring/encode.js                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"csv-stringify":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/csv-stringify/package.json                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "csv-stringify",
  "version": "4.3.1",
  "main": "./lib"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"lib":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/csv-stringify/lib/index.js                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
// Generated by CoffeeScript 2.3.2
// # CSV Stringifier

// Please look at the [project documentation](https://csv.js.org/stringify/) for additional
// information.
var Stringifier, get, stream, util;

stream = require('stream');

util = require('util');

get = require('lodash.get');

// ## Usage

// This module export a function as its main entry point and return a transform
// stream.

// Refers to the [official prject documentation](http://csv.adaltas.com/stringify/)
// on how to call this function.
module.exports = function() {
  var callback, chunks, data, options, stringifier;
  if (arguments.length === 3) {
    data = arguments[0];
    options = arguments[1];
    callback = arguments[2];
  } else if (arguments.length === 2) {
    if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
    if (typeof arguments[1] === 'function') {
      callback = arguments[1];
    } else {
      options = arguments[1];
    }
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      callback = arguments[0];
    } else if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
  }
  if (options == null) {
    options = {};
  }
  stringifier = new Stringifier(options);
  if (data) {
    process.nextTick(function() {
      var d, j, len;
      for (j = 0, len = data.length; j < len; j++) {
        d = data[j];
        stringifier.write(d);
      }
      return stringifier.end();
    });
  }
  if (callback) {
    chunks = [];
    stringifier.on('readable', function() {
      var chunk, results;
      results = [];
      while (chunk = stringifier.read()) {
        results.push(chunks.push(chunk));
      }
      return results;
    });
    stringifier.on('error', function(err) {
      return callback(err);
    });
    stringifier.on('end', function() {
      return callback(null, chunks.join(''));
    });
  }
  return stringifier;
};

// You can also use *util.promisify* native function (Node.js 8+) in order to wrap callbacks into promises for more convenient use when source is a readable stream and you are OK with storing entire result set in memory:

// ```
// const { promisify } = require('util');
// const csv = require('csv');
// const stringifyAsync = promisify(csv.stringify);

// //returns promise
// function generateCsv(sourceData) {
//     return stringifyAsync(sourceData);
// }
// ```

// ## `Stringifier([options])`

// Options are documented [here](http://csv.adaltas.com/stringify/).
Stringifier = function(opts = {}) {
  var base, base1, base10, base11, base12, base13, base14, base2, base3, base4, base5, base6, base7, base8, base9, k, options, v;
  // Immutable options
  options = {};
  for (k in opts) {
    v = opts[k];
    options[k] = v;
  }
  options.objectMode = true;
  stream.Transform.call(this, options);
  //# Default options
  this.options = options;
  if ((base = this.options).delimiter == null) {
    base.delimiter = ',';
  }
  if ((base1 = this.options).quote == null) {
    base1.quote = '"';
  }
  if ((base2 = this.options).quoted == null) {
    base2.quoted = false;
  }
  if ((base3 = this.options).quotedEmpty == null) {
    base3.quotedEmpty = void 0;
  }
  if ((base4 = this.options).quotedString == null) {
    base4.quotedString = false;
  }
  if ((base5 = this.options).eof == null) {
    base5.eof = true;
  }
  if ((base6 = this.options).escape == null) {
    base6.escape = '"';
  }
  if ((base7 = this.options).header == null) {
    base7.header = false;
  }
  // Normalize the columns option
  this.options.columns = Stringifier.normalize_columns(this.options.columns);
  if ((base8 = this.options).formatters == null) {
    base8.formatters = {};
  }
  if (this.options.formatters.bool) {
    // Backward compatibility
    this.options.formatters.boolean = this.options.formatters.bool;
  }
  // Custom formatters
  if ((base9 = this.options.formatters).string == null) {
    base9.string = function(value) {
      return value;
    };
  }
  if ((base10 = this.options.formatters).date == null) {
    base10.date = function(value) {
      // Cast date to timestamp string by default
      return '' + value.getTime();
    };
  }
  if ((base11 = this.options.formatters).boolean == null) {
    base11.boolean = function(value) {
      // Cast boolean to string by default
      if (value) {
        return '1';
      } else {
        return '';
      }
    };
  }
  if ((base12 = this.options.formatters).number == null) {
    base12.number = function(value) {
      // Cast number to string using native casting by default
      return '' + value;
    };
  }
  if ((base13 = this.options.formatters).object == null) {
    base13.object = function(value) {
      // Stringify object as JSON by default
      return JSON.stringify(value);
    };
  }
  if ((base14 = this.options).rowDelimiter == null) {
    base14.rowDelimiter = '\n';
  }
  // Internal usage, state related
  if (this.countWriten == null) {
    this.countWriten = 0;
  }
  switch (this.options.rowDelimiter) {
    case 'auto':
      this.options.rowDelimiter = null;
      break;
    case 'unix':
      this.options.rowDelimiter = "\n";
      break;
    case 'mac':
      this.options.rowDelimiter = "\r";
      break;
    case 'windows':
      this.options.rowDelimiter = "\r\n";
      break;
    case 'ascii':
      this.options.rowDelimiter = "\u001e";
      break;
    case 'unicode':
      this.options.rowDelimiter = "\u2028";
  }
  return this;
};

util.inherits(Stringifier, stream.Transform);

module.exports.Stringifier = Stringifier;

// ## `Stringifier.prototype._transform(chunk, encoding, callback)`

// Implementation of the [transform._transform function](https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback).
Stringifier.prototype._transform = function(chunk, encoding, callback) {
  var base, e, preserve;
  // Nothing to do if null or undefined
  if (chunk == null) {
    return;
  }
  preserve = typeof chunk !== 'object';
  // Emit and stringify the record if an object or an array
  if (!preserve) {
    // Detect columns from the first record
    if (this.countWriten === 0 && !Array.isArray(chunk)) {
      if ((base = this.options).columns == null) {
        base.columns = Stringifier.normalize_columns(Object.keys(chunk));
      }
    }
    try {
      this.emit('record', chunk, this.countWriten);
    } catch (error) {
      e = error;
      return this.emit('error', e);
    }
    // Convert the record into a string
    if (this.options.eof) {
      chunk = this.stringify(chunk);
      if (chunk == null) {
        return;
      }
      chunk = chunk + this.options.rowDelimiter;
    } else {
      chunk = this.stringify(chunk);
      if (chunk == null) {
        return;
      }
      if (this.options.header || this.countWriten) {
        chunk = this.options.rowDelimiter + chunk;
      }
    }
  }
  if (typeof chunk === 'number') {
    // Emit the csv
    chunk = `${chunk}`;
  }
  if (this.countWriten === 0) {
    this.headers();
  }
  if (!preserve) {
    this.countWriten++;
  }
  this.push(chunk);
  return callback();
};

// ## `Stringifier.prototype._flush(callback)`

// Implementation of the [transform._flush function](https://nodejs.org/api/stream.html#stream_transform_flush_callback).
Stringifier.prototype._flush = function(callback) {
  if (this.countWriten === 0) {
    this.headers();
  }
  return callback();
};

// ## `Stringifier.prototype.stringify(line)`

// Convert a line to a string. Line may be an object, an array or a string.
Stringifier.prototype.stringify = function(record) {
  var _record, column, columns, containsEscape, containsQuote, containsRowDelimiter, containsdelimiter, delimiter, err, escape, field, i, j, l, newrecord, quote, ref, ref1, regexp, shouldQuote, type, value;
  if (typeof record !== 'object') {
    return record;
  }
  columns = this.options.columns;
  delimiter = this.options.delimiter;
  quote = this.options.quote;
  escape = this.options.escape;
  if (!Array.isArray(record)) {
    _record = [];
    if (columns) {
      for (i = j = 0, ref = columns.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        value = get(record, columns[i].key);
        _record[i] = (typeof value === 'undefined' || value === null) ? '' : value;
      }
    } else {
      for (column in record) {
        _record.push(record[column]);
      }
    }
    record = _record;
    _record = null;
  } else if (columns) { // Note, we used to have @options.columns
    // We are getting an array but the user want specified output columns. In
    // this case, we respect the columns indexes
    record.splice(columns.length);
  }
  if (Array.isArray(record)) {
    newrecord = '';
    for (i = l = 0, ref1 = record.length; (0 <= ref1 ? l < ref1 : l > ref1); i = 0 <= ref1 ? ++l : --l) {
      field = record[i];
      type = typeof field;
      try {
        if (type === 'string') {
          // fine 99% of the cases
          field = this.options.formatters.string(field);
        } else if (type === 'number') {
          field = this.options.formatters.number(field);
        } else if (type === 'boolean') {
          field = this.options.formatters.boolean(field);
        } else if (field instanceof Date) {
          field = this.options.formatters.date(field);
        } else if (type === 'object' && field !== null) {
          field = this.options.formatters.object(field);
        }
      } catch (error) {
        err = error;
        this.emit('error', err);
        return;
      }
      if (field) {
        if (typeof field !== 'string') {
          this.emit('error', Error('Formatter must return a string, null or undefined'));
          return null;
        }
        containsdelimiter = field.indexOf(delimiter) >= 0;
        containsQuote = (quote !== '') && field.indexOf(quote) >= 0;
        containsEscape = field.indexOf(escape) >= 0 && (escape !== quote);
        containsRowDelimiter = field.indexOf(this.options.rowDelimiter) >= 0;
        shouldQuote = containsQuote || containsdelimiter || containsRowDelimiter || this.options.quoted || (this.options.quotedString && typeof record[i] === 'string');
        if (shouldQuote && containsEscape) {
          regexp = escape === '\\' ? new RegExp(escape + escape, 'g') : new RegExp(escape, 'g');
          field = field.replace(regexp, escape + escape);
        }
        if (containsQuote) {
          regexp = new RegExp(quote, 'g');
          field = field.replace(regexp, escape + quote);
        }
        if (shouldQuote) {
          field = quote + field + quote;
        }
        newrecord += field;
      } else if (this.options.quotedEmpty || ((this.options.quotedEmpty == null) && record[i] === '' && this.options.quotedString)) {
        newrecord += quote + quote;
      }
      if (i !== record.length - 1) {
        newrecord += delimiter;
      }
    }
    record = newrecord;
  }
  return record;
};

// ## `Stringifier.prototype.headers`

// Print the header line if the option "header" is "true".
Stringifier.prototype.headers = function() {
  var headers;
  if (!this.options.header) {
    return;
  }
  if (!this.options.columns) {
    return;
  }
  headers = this.options.columns.map(function(column) {
    return column.header;
  });
  if (this.options.eof) {
    headers = this.stringify(headers) + this.options.rowDelimiter;
  } else {
    headers = this.stringify(headers);
  }
  return this.push(headers);
};

// ## `Stringifier.prototype.headers`

// Print the header line if the option "header" is "true".
Stringifier.normalize_columns = function(columns) {
  var column, k, v;
  if (columns == null) {
    return null;
  }
  if (columns != null) {
    if (typeof columns !== 'object') {
      throw Error('Invalid option "columns": expect an array or an object');
    }
    if (!Array.isArray(columns)) {
      columns = (function() {
        var results;
        results = [];
        for (k in columns) {
          v = columns[k];
          results.push({
            key: k,
            header: v
          });
        }
        return results;
      })();
    } else {
      columns = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = columns.length; j < len; j++) {
          column = columns[j];
          if (typeof column === 'string') {
            results.push({
              key: column,
              header: column
            });
          } else if (typeof column === 'object' && (column != null) && !Array.isArray(column)) {
            if (!column.key) {
              throw Error('Invalid column definition: property "key" is required');
            }
            if (column.header == null) {
              column.header = column.key;
            }
            results.push(column);
          } else {
            throw Error('Invalid column definition: expect a string or an object');
          }
        }
        return results;
      })();
    }
  }
  return columns;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}},"lodash.get":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/lodash.get/package.json                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "lodash.get",
  "version": "4.4.2"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/lodash.get/index.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"fs-extra":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/package.json                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "fs-extra",
  "version": "7.0.0",
  "main": "./lib/index.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"lib":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/index.js                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

module.exports = Object.assign(
  {},
  // Export promiseified graceful-fs:
  require('./fs'),
  // Export extra methods:
  require('./copy-sync'),
  require('./copy'),
  require('./empty'),
  require('./ensure'),
  require('./json'),
  require('./mkdirs'),
  require('./move-sync'),
  require('./move'),
  require('./output'),
  require('./path-exists'),
  require('./remove')
)

// Export fs.promises as a getter property so that we don't trigger
// ExperimentalWarning before fs.promises is actually accessed.
const fs = require('fs')
if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
  Object.defineProperty(module.exports, 'promises', {
    get () { return fs.promises }
  })
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"fs":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/fs/index.js                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'
// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = require('universalify').fromCallback
const fs = require('graceful-fs')

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchown',
  'lchmod',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'readFile',
  'readdir',
  'readlink',
  'realpath',
  'rename',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.copyFile was added in Node.js v8.5.0
  // fs.mkdtemp was added in Node.js v5.10.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
})

// Export all keys:
Object.keys(fs).forEach(key => {
  if (key === 'promises') {
    // fs.promises is a getter property that triggers ExperimentalWarning
    // Don't re-export it here, the getter is defined in "lib/index.js"
    return
  }
  exports[key] = fs[key]
})

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method])
})

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
}

// fs.read() & fs.write need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer })
    })
  })
}

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer })
    })
  })
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"copy-sync":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/copy-sync/index.js                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

module.exports = {
  copySync: require('./copy-sync')
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"copy-sync.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/copy-sync/copy-sync.js                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const fs = require('graceful-fs')
const path = require('path')
const mkdirpSync = require('../mkdirs').mkdirsSync
const utimesSync = require('../util/utimes.js').utimesMillisSync

const notExist = Symbol('notExist')

function copySync (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = {filter: opts}
  }

  opts = opts || {}
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  const destStat = checkPaths(src, dest)

  if (opts.filter && !opts.filter(src, dest)) return

  const destParent = path.dirname(dest)
  if (!fs.existsSync(destParent)) mkdirpSync(destParent)
  return startCopy(destStat, src, dest, opts)
}

function startCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats(destStat, src, dest, opts)
}

function getStats (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync
  const srcStat = statSync(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
}

function onFile (srcStat, destStat, src, dest, opts) {
  if (destStat === notExist) return copyFile(srcStat, src, dest, opts)
  return mayCopyFile(srcStat, src, dest, opts)
}

function mayCopyFile (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest)
    return copyFile(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile (srcStat, src, dest, opts) {
  if (typeof fs.copyFileSync === 'function') {
    fs.copyFileSync(src, dest)
    fs.chmodSync(dest, srcStat.mode)
    if (opts.preserveTimestamps) {
      return utimesSync(dest, srcStat.atime, srcStat.mtime)
    }
    return
  }
  return copyFileFallback(srcStat, src, dest, opts)
}

function copyFileFallback (srcStat, src, dest, opts) {
  const BUF_LENGTH = 64 * 1024
  const _buff = require('../util/buffer')(BUF_LENGTH)

  const fdr = fs.openSync(src, 'r')
  const fdw = fs.openSync(dest, 'w', srcStat.mode)
  let pos = 0

  while (pos < srcStat.size) {
    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
    fs.writeSync(fdw, _buff, 0, bytesRead)
    pos += bytesRead
  }

  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)

  fs.closeSync(fdr)
  fs.closeSync(fdw)
}

function onDir (srcStat, destStat, src, dest, opts) {
  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts)
  if (destStat && !destStat.isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
  }
  return copyDir(src, dest, opts)
}

function mkDirAndCopy (srcStat, src, dest, opts) {
  fs.mkdirSync(dest)
  copyDir(src, dest, opts)
  return fs.chmodSync(dest, srcStat.mode)
}

function copyDir (src, dest, opts) {
  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))
}

function copyDirItem (item, src, dest, opts) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  const destStat = checkPaths(srcItem, destItem)
  return startCopy(destStat, srcItem, destItem, opts)
}

function onLink (destStat, src, dest, opts) {
  let resolvedSrc = fs.readlinkSync(src)

  if (opts.dereference) {
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
  }

  if (destStat === notExist) {
    return fs.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest
    try {
      resolvedDest = fs.readlinkSync(dest)
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest)
    }
    if (isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink(resolvedSrc, dest)
  }
}

function copyLink (resolvedSrc, dest) {
  fs.unlinkSync(dest)
  return fs.symlinkSync(resolvedSrc, dest)
}

// return true if dest is a subdir of src, otherwise false.
function isSrcSubdir (src, dest) {
  const srcArray = path.resolve(src).split(path.sep)
  const destArray = path.resolve(dest).split(path.sep)
  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)
}

function checkStats (src, dest) {
  const srcStat = fs.statSync(src)
  let destStat
  try {
    destStat = fs.statSync(dest)
  } catch (err) {
    if (err.code === 'ENOENT') return {srcStat, destStat: notExist}
    throw err
  }
  return {srcStat, destStat}
}

function checkPaths (src, dest) {
  const {srcStat, destStat} = checkStats(src, dest)
  if (destStat.ino && destStat.ino === srcStat.ino) {
    throw new Error('Source and destination must not be the same.')
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)
  }
  return destStat
}

module.exports = copySync

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"mkdirs":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/mkdirs/index.js                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'
const u = require('universalify').fromCallback
const mkdirs = u(require('./mkdirs'))
const mkdirsSync = require('./mkdirs-sync')

module.exports = {
  mkdirs,
  mkdirsSync,
  // alias
  mkdirp: mkdirs,
  mkdirpSync: mkdirsSync,
  ensureDir: mkdirs,
  ensureDirSync: mkdirsSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"mkdirs.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/mkdirs/mkdirs.js                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const fs = require('graceful-fs')
const path = require('path')
const invalidWin32Path = require('./win32').invalidWin32Path

const o777 = parseInt('0777', 8)

function mkdirs (p, opts, callback, made) {
  if (typeof opts === 'function') {
    callback = opts
    opts = {}
  } else if (!opts || typeof opts !== 'object') {
    opts = { mode: opts }
  }

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.')
    errInval.code = 'EINVAL'
    return callback(errInval)
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (mode === undefined) {
    mode = o777 & (~process.umask())
  }
  if (!made) made = null

  callback = callback || function () {}
  p = path.resolve(p)

  xfs.mkdir(p, mode, er => {
    if (!er) {
      made = made || p
      return callback(null, made)
    }
    switch (er.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) return callback(er)
        mkdirs(path.dirname(p), opts, (er, made) => {
          if (er) callback(er, made)
          else mkdirs(p, opts, callback, made)
        })
        break

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) => {
          // if the stat fails, then that's super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made)
          else callback(null, made)
        })
        break
    }
  })
}

module.exports = mkdirs

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"win32.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/mkdirs/win32.js                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const path = require('path')

// get drive on windows
function getRootPath (p) {
  p = path.normalize(path.resolve(p)).split(path.sep)
  if (p.length > 0) return p[0]
  return null
}

// http://stackoverflow.com/a/62888/10333 contains more accurate
// TODO: expand to include the rest
const INVALID_PATH_CHARS = /[<>:"|?*]/

function invalidWin32Path (p) {
  const rp = getRootPath(p)
  p = p.replace(rp, '')
  return INVALID_PATH_CHARS.test(p)
}

module.exports = {
  getRootPath,
  invalidWin32Path
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"mkdirs-sync.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js                              //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const fs = require('graceful-fs')
const path = require('path')
const invalidWin32Path = require('./win32').invalidWin32Path

const o777 = parseInt('0777', 8)

function mkdirsSync (p, opts, made) {
  if (!opts || typeof opts !== 'object') {
    opts = { mode: opts }
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.')
    errInval.code = 'EINVAL'
    throw errInval
  }

  if (mode === undefined) {
    mode = o777 & (~process.umask())
  }
  if (!made) made = null

  p = path.resolve(p)

  try {
    xfs.mkdirSync(p, mode)
    made = made || p
  } catch (err0) {
    if (err0.code === 'ENOENT') {
      if (path.dirname(p) === p) throw err0
      made = mkdirsSync(path.dirname(p), opts, made)
      mkdirsSync(p, opts, made)
    } else {
      // In the case of any other error, just see if there's a dir there
      // already. If so, then hooray!  If not, then something is borked.
      let stat
      try {
        stat = xfs.statSync(p)
      } catch (err1) {
        throw err0
      }
      if (!stat.isDirectory()) throw err0
    }
  }

  return made
}

module.exports = mkdirsSync

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"util":{"utimes.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/util/utimes.js                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const fs = require('graceful-fs')
const os = require('os')
const path = require('path')

// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
function hasMillisResSync () {
  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))
  tmpfile = path.join(os.tmpdir(), tmpfile)

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862)
  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')
  const fd = fs.openSync(tmpfile, 'r+')
  fs.futimesSync(fd, d, d)
  fs.closeSync(fd)
  return fs.statSync(tmpfile).mtime > 1435410243000
}

function hasMillisRes (callback) {
  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))
  tmpfile = path.join(os.tmpdir(), tmpfile)

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862)
  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
    if (err) return callback(err)
    fs.open(tmpfile, 'r+', (err, fd) => {
      if (err) return callback(err)
      fs.futimes(fd, d, d, err => {
        if (err) return callback(err)
        fs.close(fd, err => {
          if (err) return callback(err)
          fs.stat(tmpfile, (err, stats) => {
            if (err) return callback(err)
            callback(null, stats.mtime > 1435410243000)
          })
        })
      })
    })
  })
}

function timeRemoveMillis (timestamp) {
  if (typeof timestamp === 'number') {
    return Math.floor(timestamp / 1000) * 1000
  } else if (timestamp instanceof Date) {
    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
  } else {
    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
  }
}

function utimesMillis (path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs.open(path, 'r+', (err, fd) => {
    if (err) return callback(err)
    fs.futimes(fd, atime, mtime, futimesErr => {
      fs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr)
      })
    })
  })
}

function utimesMillisSync (path, atime, mtime) {
  const fd = fs.openSync(path, 'r+')
  fs.futimesSync(fd, atime, mtime)
  return fs.closeSync(fd)
}

module.exports = {
  hasMillisRes,
  hasMillisResSync,
  timeRemoveMillis,
  utimesMillis,
  utimesMillisSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"buffer.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/util/buffer.js                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'
/* eslint-disable node/no-deprecated-api */
module.exports = function (size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    try {
      return Buffer.allocUnsafe(size)
    } catch (e) {
      return new Buffer(size)
    }
  }
  return new Buffer(size)
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"copy":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/copy/index.js                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
module.exports = {
  copy: u(require('./copy'))
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"copy.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/copy/copy.js                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const fs = require('graceful-fs')
const path = require('path')
const mkdirp = require('../mkdirs').mkdirs
const pathExists = require('../path-exists').pathExists
const utimes = require('../util/utimes').utimesMillis

const notExist = Symbol('notExist')

function copy (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts
    opts = {}
  } else if (typeof opts === 'function') {
    opts = {filter: opts}
  }

  cb = cb || function () {}
  opts = opts || {}

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  checkPaths(src, dest, (err, destStat) => {
    if (err) return cb(err)
    if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
    return checkParentDir(destStat, src, dest, opts, cb)
  })
}

function checkParentDir (destStat, src, dest, opts, cb) {
  const destParent = path.dirname(dest)
  pathExists(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return startCopy(destStat, src, dest, opts, cb)
    mkdirp(destParent, err => {
      if (err) return cb(err)
      return startCopy(destStat, src, dest, opts, cb)
    })
  })
}

function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) {
      if (destStat) return onInclude(destStat, src, dest, opts, cb)
      return onInclude(src, dest, opts, cb)
    }
    return cb()
  }, error => cb(error))
}

function startCopy (destStat, src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
  return getStats(destStat, src, dest, opts, cb)
}

function getStats (destStat, src, dest, opts, cb) {
  const stat = opts.dereference ? fs.stat : fs.lstat
  stat(src, (err, srcStat) => {
    if (err) return cb(err)

    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isFile() ||
             srcStat.isCharacterDevice() ||
             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
  })
}

function onFile (srcStat, destStat, src, dest, opts, cb) {
  if (destStat === notExist) return copyFile(srcStat, src, dest, opts, cb)
  return mayCopyFile(srcStat, src, dest, opts, cb)
}

function mayCopyFile (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile(srcStat, src, dest, opts, cb)
    })
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile (srcStat, src, dest, opts, cb) {
  if (typeof fs.copyFile === 'function') {
    return fs.copyFile(src, dest, err => {
      if (err) return cb(err)
      return setDestModeAndTimestamps(srcStat, dest, opts, cb)
    })
  }
  return copyFileFallback(srcStat, src, dest, opts, cb)
}

function copyFileFallback (srcStat, src, dest, opts, cb) {
  const rs = fs.createReadStream(src)
  rs.on('error', err => cb(err)).once('open', () => {
    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })
    ws.on('error', err => cb(err))
      .on('open', () => rs.pipe(ws))
      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))
  })
}

function setDestModeAndTimestamps (srcStat, dest, opts, cb) {
  fs.chmod(dest, srcStat.mode, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) {
      return utimes(dest, srcStat.atime, srcStat.mtime, cb)
    }
    return cb()
  })
}

function onDir (srcStat, destStat, src, dest, opts, cb) {
  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts, cb)
  if (destStat && !destStat.isDirectory()) {
    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
  }
  return copyDir(src, dest, opts, cb)
}

function mkDirAndCopy (srcStat, src, dest, opts, cb) {
  fs.mkdir(dest, err => {
    if (err) return cb(err)
    copyDir(src, dest, opts, err => {
      if (err) return cb(err)
      return fs.chmod(dest, srcStat.mode, cb)
    })
  })
}

function copyDir (src, dest, opts, cb) {
  fs.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  })
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop()
  if (!item) return cb()
  return copyDirItem(items, item, src, dest, opts, cb)
}

function copyDirItem (items, item, src, dest, opts, cb) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  checkPaths(srcItem, destItem, (err, destStat) => {
    if (err) return cb(err)
    startCopy(destStat, srcItem, destItem, opts, err => {
      if (err) return cb(err)
      return copyDirItems(items, src, dest, opts, cb)
    })
  })
}

function onLink (destStat, src, dest, opts, cb) {
  fs.readlink(src, (err, resolvedSrc) => {
    if (err) return cb(err)

    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
    }

    if (destStat === notExist) {
      return fs.symlink(resolvedSrc, dest, cb)
    } else {
      fs.readlink(dest, (err, resolvedDest) => {
        if (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)
          return cb(err)
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest)
        }
        if (isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
        }

        // do not copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
        }
        return copyLink(resolvedSrc, dest, cb)
      })
    }
  })
}

function copyLink (resolvedSrc, dest, cb) {
  fs.unlink(dest, err => {
    if (err) return cb(err)
    return fs.symlink(resolvedSrc, dest, cb)
  })
}

// return true if dest is a subdir of src, otherwise false.
function isSrcSubdir (src, dest) {
  const srcArray = path.resolve(src).split(path.sep)
  const destArray = path.resolve(dest).split(path.sep)
  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)
}

function checkStats (src, dest, cb) {
  fs.stat(src, (err, srcStat) => {
    if (err) return cb(err)
    fs.stat(dest, (err, destStat) => {
      if (err) {
        if (err.code === 'ENOENT') return cb(null, {srcStat, destStat: notExist})
        return cb(err)
      }
      return cb(null, {srcStat, destStat})
    })
  })
}

function checkPaths (src, dest, cb) {
  checkStats(src, dest, (err, stats) => {
    if (err) return cb(err)
    const {srcStat, destStat} = stats
    if (destStat.ino && destStat.ino === srcStat.ino) {
      return cb(new Error('Source and destination must not be the same.'))
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))
    }
    return cb(null, destStat)
  })
}

module.exports = copy

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"path-exists":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/path-exists/index.js                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'
const u = require('universalify').fromPromise
const fs = require('../fs')

function pathExists (path) {
  return fs.access(path).then(() => true).catch(() => false)
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"empty":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/empty/index.js                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
const fs = require('fs')
const path = require('path')
const mkdir = require('../mkdirs')
const remove = require('../remove')

const emptyDir = u(function emptyDir (dir, callback) {
  callback = callback || function () {}
  fs.readdir(dir, (err, items) => {
    if (err) return mkdir.mkdirs(dir, callback)

    items = items.map(item => path.join(dir, item))

    deleteItem()

    function deleteItem () {
      const item = items.pop()
      if (!item) return callback()
      remove.remove(item, err => {
        if (err) return callback(err)
        deleteItem()
      })
    }
  })
})

function emptyDirSync (dir) {
  let items
  try {
    items = fs.readdirSync(dir)
  } catch (err) {
    return mkdir.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path.join(dir, item)
    remove.removeSync(item)
  })
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"remove":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/remove/index.js                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
const rimraf = require('./rimraf')

module.exports = {
  remove: u(rimraf),
  removeSync: rimraf.sync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"rimraf.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/remove/rimraf.js                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const fs = require('graceful-fs')
const path = require('path')
const assert = require('assert')

const isWindows = (process.platform === 'win32')

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
}

function rimraf (p, options, cb) {
  let busyTries = 0

  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++
        const time = busyTries * 100
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null
    }

    cb(er)
  })
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er) {
    assert(er instanceof Error)
  }

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er)
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er)
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb)
        } else {
          options.unlink(p, cb)
        }
      })
    }
  })
}

function fixWinEPERMSync (p, options, er) {
  let stats

  assert(p)
  assert(options)
  if (er) {
    assert(er instanceof Error)
  }

  try {
    options.chmodSync(p, 0o666)
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er)
  } else {
    options.unlinkSync(p)
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr) {
    assert(originalEr instanceof Error)
  }
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb)
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr)
    } else {
      cb(er)
    }
  })
}

function rmkids (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length
    let errState

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb)
        }
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st

  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  try {
    st = options.lstatSync(p)
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er)
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null)
    } else {
      options.unlinkSync(p)
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er)
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr) {
    assert(originalEr instanceof Error)
  }

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options)
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows ? 100 : 1
  let i = 0
  do {
    let threw = true
    try {
      const ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw) continue // eslint-disable-line
    }
  } while (true)
}

module.exports = rimraf
rimraf.sync = rimrafSync

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"ensure":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/ensure/index.js                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const file = require('./file')
const link = require('./link')
const symlink = require('./symlink')

module.exports = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"file.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/ensure/file.js                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
const path = require('path')
const fs = require('graceful-fs')
const mkdir = require('../mkdirs')
const pathExists = require('../path-exists').pathExists

function createFile (file, callback) {
  function makeFile () {
    fs.writeFile(file, '', err => {
      if (err) return callback(err)
      callback()
    })
  }

  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path.dirname(file)
    pathExists(dir, (err, dirExists) => {
      if (err) return callback(err)
      if (dirExists) return makeFile()
      mkdir.mkdirs(dir, err => {
        if (err) return callback(err)
        makeFile()
      })
    })
  })
}

function createFileSync (file) {
  let stats
  try {
    stats = fs.statSync(file)
  } catch (e) {}
  if (stats && stats.isFile()) return

  const dir = path.dirname(file)
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  fs.writeFileSync(file, '')
}

module.exports = {
  createFile: u(createFile),
  createFileSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"link.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/ensure/link.js                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
const path = require('path')
const fs = require('graceful-fs')
const mkdir = require('../mkdirs')
const pathExists = require('../path-exists').pathExists

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null)
    })
  }

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink')
        return callback(err)
      }

      const dir = path.dirname(dstpath)
      pathExists(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath)
        })
      })
    })
  })
}

function createLinkSync (srcpath, dstpath) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  try {
    fs.lstatSync(srcpath)
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink')
    throw err
  }

  const dir = path.dirname(dstpath)
  const dirExists = fs.existsSync(dir)
  if (dirExists) return fs.linkSync(srcpath, dstpath)
  mkdir.mkdirsSync(dir)

  return fs.linkSync(srcpath, dstpath)
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"symlink.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/ensure/symlink.js                                  //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
const path = require('path')
const fs = require('graceful-fs')
const _mkdirs = require('../mkdirs')
const mkdirs = _mkdirs.mkdirs
const mkdirsSync = _mkdirs.mkdirsSync

const _symlinkPaths = require('./symlink-paths')
const symlinkPaths = _symlinkPaths.symlinkPaths
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync

const _symlinkType = require('./symlink-type')
const symlinkType = _symlinkType.symlinkType
const symlinkTypeSync = _symlinkType.symlinkTypeSync

const pathExists = require('../path-exists').pathExists

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err)
      srcpath = relative.toDst
      symlinkType(relative.toCwd, type, (err, type) => {
        if (err) return callback(err)
        const dir = path.dirname(dstpath)
        pathExists(dir, (err, dirExists) => {
          if (err) return callback(err)
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
          mkdirs(dir, err => {
            if (err) return callback(err)
            fs.symlink(srcpath, dstpath, type, callback)
          })
        })
      })
    })
  })
}

function createSymlinkSync (srcpath, dstpath, type) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  const relative = symlinkPathsSync(srcpath, dstpath)
  srcpath = relative.toDst
  type = symlinkTypeSync(relative.toCwd, type)
  const dir = path.dirname(dstpath)
  const exists = fs.existsSync(dir)
  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir)
  return fs.symlinkSync(srcpath, dstpath, type)
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"symlink-paths.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/ensure/symlink-paths.js                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const path = require('path')
const fs = require('graceful-fs')
const pathExists = require('../path-exists').pathExists

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths (srcpath, dstpath, callback) {
  if (path.isAbsolute(srcpath)) {
    return fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink')
        return callback(err)
      }
      return callback(null, {
        'toCwd': srcpath,
        'toDst': srcpath
      })
    })
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    return pathExists(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          'toCwd': relativeToDst,
          'toDst': srcpath
        })
      } else {
        return fs.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink')
            return callback(err)
          }
          return callback(null, {
            'toCwd': srcpath,
            'toDst': path.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync (srcpath, dstpath) {
  let exists
  if (path.isAbsolute(srcpath)) {
    exists = fs.existsSync(srcpath)
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      'toCwd': srcpath,
      'toDst': srcpath
    }
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    exists = fs.existsSync(relativeToDst)
    if (exists) {
      return {
        'toCwd': relativeToDst,
        'toDst': srcpath
      }
    } else {
      exists = fs.existsSync(srcpath)
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        'toCwd': srcpath,
        'toDst': path.relative(dstdir, srcpath)
      }
    }
  }
}

module.exports = {
  symlinkPaths,
  symlinkPathsSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"symlink-type.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/ensure/symlink-type.js                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const fs = require('graceful-fs')

function symlinkType (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type
  if (type) return callback(null, type)
  fs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file'
    callback(null, type)
  })
}

function symlinkTypeSync (srcpath, type) {
  let stats

  if (type) return type
  try {
    stats = fs.lstatSync(srcpath)
  } catch (e) {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

module.exports = {
  symlinkType,
  symlinkTypeSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"json":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/json/index.js                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
const jsonFile = require('./jsonfile')

jsonFile.outputJson = u(require('./output-json'))
jsonFile.outputJsonSync = require('./output-json-sync')
// aliases
jsonFile.outputJSON = jsonFile.outputJson
jsonFile.outputJSONSync = jsonFile.outputJsonSync
jsonFile.writeJSON = jsonFile.writeJson
jsonFile.writeJSONSync = jsonFile.writeJsonSync
jsonFile.readJSON = jsonFile.readJson
jsonFile.readJSONSync = jsonFile.readJsonSync

module.exports = jsonFile

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"jsonfile.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/json/jsonfile.js                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
const jsonFile = require('jsonfile')

module.exports = {
  // jsonfile exports
  readJson: u(jsonFile.readFile),
  readJsonSync: jsonFile.readFileSync,
  writeJson: u(jsonFile.writeFile),
  writeJsonSync: jsonFile.writeFileSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"output-json.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/json/output-json.js                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const path = require('path')
const mkdir = require('../mkdirs')
const pathExists = require('../path-exists').pathExists
const jsonFile = require('./jsonfile')

function outputJson (file, data, options, callback) {
  if (typeof options === 'function') {
    callback = options
    options = {}
  }

  const dir = path.dirname(file)

  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return jsonFile.writeJson(file, data, options, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)
      jsonFile.writeJson(file, data, options, callback)
    })
  })
}

module.exports = outputJson

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"output-json-sync.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/json/output-json-sync.js                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const fs = require('graceful-fs')
const path = require('path')
const mkdir = require('../mkdirs')
const jsonFile = require('./jsonfile')

function outputJsonSync (file, data, options) {
  const dir = path.dirname(file)

  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  jsonFile.writeJsonSync(file, data, options)
}

module.exports = outputJsonSync

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"move-sync":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/move-sync/index.js                                 //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const fs = require('graceful-fs')
const path = require('path')
const copySync = require('../copy-sync').copySync
const removeSync = require('../remove').removeSync
const mkdirpSync = require('../mkdirs').mkdirsSync
const buffer = require('../util/buffer')

function moveSync (src, dest, options) {
  options = options || {}
  const overwrite = options.overwrite || options.clobber || false

  src = path.resolve(src)
  dest = path.resolve(dest)

  if (src === dest) return fs.accessSync(src)

  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`)

  mkdirpSync(path.dirname(dest))
  tryRenameSync()

  function tryRenameSync () {
    if (overwrite) {
      try {
        return fs.renameSync(src, dest)
      } catch (err) {
        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {
          removeSync(dest)
          options.overwrite = false // just overwriteed it, no need to do it again
          return moveSync(src, dest, options)
        }

        if (err.code !== 'EXDEV') throw err
        return moveSyncAcrossDevice(src, dest, overwrite)
      }
    } else {
      try {
        fs.linkSync(src, dest)
        return fs.unlinkSync(src)
      } catch (err) {
        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
          return moveSyncAcrossDevice(src, dest, overwrite)
        }
        throw err
      }
    }
  }
}

function moveSyncAcrossDevice (src, dest, overwrite) {
  const stat = fs.statSync(src)

  if (stat.isDirectory()) {
    return moveDirSyncAcrossDevice(src, dest, overwrite)
  } else {
    return moveFileSyncAcrossDevice(src, dest, overwrite)
  }
}

function moveFileSyncAcrossDevice (src, dest, overwrite) {
  const BUF_LENGTH = 64 * 1024
  const _buff = buffer(BUF_LENGTH)

  const flags = overwrite ? 'w' : 'wx'

  const fdr = fs.openSync(src, 'r')
  const stat = fs.fstatSync(fdr)
  const fdw = fs.openSync(dest, flags, stat.mode)
  let pos = 0

  while (pos < stat.size) {
    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
    fs.writeSync(fdw, _buff, 0, bytesRead)
    pos += bytesRead
  }

  fs.closeSync(fdr)
  fs.closeSync(fdw)
  return fs.unlinkSync(src)
}

function moveDirSyncAcrossDevice (src, dest, overwrite) {
  const options = {
    overwrite: false
  }

  if (overwrite) {
    removeSync(dest)
    tryCopySync()
  } else {
    tryCopySync()
  }

  function tryCopySync () {
    copySync(src, dest, options)
    return removeSync(src)
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir (src, dest) {
  try {
    return fs.statSync(src).isDirectory() &&
           src !== dest &&
           dest.indexOf(src) > -1 &&
           dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src)
  } catch (e) {
    return false
  }
}

module.exports = {
  moveSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"move":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/move/index.js                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
const fs = require('graceful-fs')
const path = require('path')
const copy = require('../copy').copy
const remove = require('../remove').remove
const mkdirp = require('../mkdirs').mkdirp
const pathExists = require('../path-exists').pathExists

function move (src, dest, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  const overwrite = opts.overwrite || opts.clobber || false

  src = path.resolve(src)
  dest = path.resolve(dest)

  if (src === dest) return fs.access(src, cb)

  fs.stat(src, (err, st) => {
    if (err) return cb(err)

    if (st.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`))
    }
    mkdirp(path.dirname(dest), err => {
      if (err) return cb(err)
      return doRename(src, dest, overwrite, cb)
    })
  })
}

function doRename (src, dest, overwrite, cb) {
  if (overwrite) {
    return remove(dest, err => {
      if (err) return cb(err)
      return rename(src, dest, overwrite, cb)
    })
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err)
    if (destExists) return cb(new Error('dest already exists.'))
    return rename(src, dest, overwrite, cb)
  })
}

function rename (src, dest, overwrite, cb) {
  fs.rename(src, dest, err => {
    if (!err) return cb()
    if (err.code !== 'EXDEV') return cb(err)
    return moveAcrossDevice(src, dest, overwrite, cb)
  })
}

function moveAcrossDevice (src, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  }

  copy(src, dest, opts, err => {
    if (err) return cb(err)
    return remove(src, cb)
  })
}

function isSrcSubdir (src, dest) {
  const srcArray = src.split(path.sep)
  const destArray = dest.split(path.sep)

  return srcArray.reduce((acc, current, i) => {
    return acc && destArray[i] === current
  }, true)
}

module.exports = {
  move: u(move)
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"output":{"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fs-extra/lib/output/index.js                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

const u = require('universalify').fromCallback
const fs = require('graceful-fs')
const path = require('path')
const mkdir = require('../mkdirs')
const pathExists = require('../path-exists').pathExists

function outputFile (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding
    encoding = 'utf8'
  }

  const dir = path.dirname(file)
  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return fs.writeFile(file, data, encoding, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)

      fs.writeFile(file, data, encoding, callback)
    })
  })
}

function outputFileSync (file, ...args) {
  const dir = path.dirname(file)
  if (fs.existsSync(dir)) {
    return fs.writeFileSync(file, ...args)
  }
  mkdir.mkdirsSync(dir)
  fs.writeFileSync(file, ...args)
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}}},"universalify":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/universalify/package.json                                       //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "universalify",
  "version": "0.1.2"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"index.js":function(require,exports){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/universalify/index.js                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

exports.fromCallback = function (fn) {
  return Object.defineProperty(function () {
    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
    else {
      return new Promise((resolve, reject) => {
        arguments[arguments.length] = (err, res) => {
          if (err) return reject(err)
          resolve(res)
        }
        arguments.length++
        fn.apply(this, arguments)
      })
    }
  }, 'name', { value: fn.name })
}

exports.fromPromise = function (fn) {
  return Object.defineProperty(function () {
    const cb = arguments[arguments.length - 1]
    if (typeof cb !== 'function') return fn.apply(this, arguments)
    else fn.apply(this, arguments).then(r => cb(null, r), cb)
  }, 'name', { value: fn.name })
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"graceful-fs":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/graceful-fs/package.json                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "graceful-fs",
  "version": "4.1.15",
  "main": "graceful-fs.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"graceful-fs.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/graceful-fs/graceful-fs.js                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var fs = require('fs')
var polyfills = require('./polyfills.js')
var legacy = require('./legacy-streams.js')
var clone = require('./clone.js')

var queue = []

var util = require('util')

function noop () {}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
  process.on('exit', function() {
    debug(queue)
    require('assert').equal(queue.length, 0)
  })
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

// Always patch fs.close/closeSync, because we want to
// retry() whenever a close happens *anywhere* in the program.
// This is essential when multiple graceful-fs instances are
// in play at the same time.
module.exports.close = (function (fs$close) { return function (fd, cb) {
  return fs$close.call(fs, fd, function (err) {
    if (!err)
      retry()

    if (typeof cb === 'function')
      cb.apply(this, arguments)
  })
}})(fs.close)

module.exports.closeSync = (function (fs$closeSync) { return function (fd) {
  // Note that graceful-fs also retries when fs.closeSync() fails.
  // Looks like a bug to me, although it's probably a harmless one.
  var rval = fs$closeSync.apply(fs, arguments)
  retry()
  return rval
}})(fs.closeSync)

// Only patch fs once, otherwise we'll run into a memory leak if
// graceful-fs is loaded multiple times, such as in test environments that
// reset the loaded modules between tests.
// We look for the string `graceful-fs` from the comment above. This
// way we are not adding any extra properties and it will detect if older
// versions of graceful-fs are installed.
if (!/\bgraceful-fs\b/.test(fs.closeSync.toString())) {
  fs.closeSync = module.exports.closeSync;
  fs.close = module.exports.close;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch
  fs.FileReadStream = ReadStream;  // Legacy name.
  fs.FileWriteStream = WriteStream;  // Legacy name.
  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  function readdir (path, options, cb) {
    var args = [path]
    if (typeof options !== 'function') {
      args.push(options)
    } else {
      cb = options
    }
    args.push(go$readdir$cb)

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort()

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]])

      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments)
        retry()
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  fs.ReadStream = ReadStream
  fs.WriteStream = WriteStream

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  queue.push(elem)
}

function retry () {
  var elem = queue.shift()
  if (elem) {
    debug('RETRY', elem[0].name, elem[1])
    elem[0].apply(null, elem[1])
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"polyfills.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/graceful-fs/polyfills.js                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var constants = require('constants')

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

var chdir = process.chdir
process.chdir = function(d) {
  cwd = null
  chdir.call(process, d)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now()
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er)
            })
          }, backoff)
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er)
      })
    }})(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {
    var callback
    if (callback_ && typeof callback_ === 'function') {
      var eagCounter = 0
      callback = function (er, _, __) {
        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          return fs$read.call(fs, fd, buffer, offset, length, position, callback)
        }
        callback_.apply(this, arguments)
      }
    }
    return fs$read.call(fs, fd, buffer, offset, length, position, callback)
  }})(fs.read)

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, cb) {
      return orig.call(fs, target, function (er, stats) {
        if (!stats) return cb.apply(this, arguments)
        if (stats.uid < 0) stats.uid += 0x100000000
        if (stats.gid < 0) stats.gid += 0x100000000
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target) {
      var stats = orig.call(fs, target)
      if (stats.uid < 0) stats.uid += 0x100000000
      if (stats.gid < 0) stats.gid += 0x100000000
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"legacy-streams.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/graceful-fs/legacy-streams.js                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var Stream = require('stream').Stream

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"clone.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/graceful-fs/clone.js                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict'

module.exports = clone

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: obj.__proto__ }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"jsonfile":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/jsonfile/package.json                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "jsonfile",
  "version": "4.0.0",
  "main": "index.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/jsonfile/index.js                                               //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var _fs
try {
  _fs = require('graceful-fs')
} catch (_) {
  _fs = require('fs')
}

function readFile (file, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }

  if (typeof options === 'string') {
    options = {encoding: options}
  }

  options = options || {}
  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err)

    data = stripBom(data)

    var obj
    try {
      obj = JSON.parse(data, options ? options.reviver : null)
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + ': ' + err2.message
        return callback(err2)
      } else {
        return callback(null, null)
      }
    }

    callback(null, obj)
  })
}

function readFileSync (file, options) {
  options = options || {}
  if (typeof options === 'string') {
    options = {encoding: options}
  }

  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  try {
    var content = fs.readFileSync(file, options)
    content = stripBom(content)
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = file + ': ' + err.message
      throw err
    } else {
      return null
    }
  }
}

function stringify (obj, options) {
  var spaces
  var EOL = '\n'
  if (typeof options === 'object' && options !== null) {
    if (options.spaces) {
      spaces = options.spaces
    }
    if (options.EOL) {
      EOL = options.EOL
    }
  }

  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)

  return str.replace(/\n/g, EOL) + EOL
}

function writeFile (file, obj, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }
  options = options || {}
  var fs = options.fs || _fs

  var str = ''
  try {
    str = stringify(obj, options)
  } catch (err) {
    // Need to return whether a callback was passed or not
    if (callback) callback(err, null)
    return
  }

  fs.writeFile(file, str, options, callback)
}

function writeFileSync (file, obj, options) {
  options = options || {}
  var fs = options.fs || _fs

  var str = stringify(obj, options)
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8')
  content = content.replace(/^\uFEFF/, '')
  return content
}

var jsonfile = {
  readFile: readFile,
  readFileSync: readFileSync,
  writeFile: writeFile,
  writeFileSync: writeFileSync
}

module.exports = jsonfile

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"fibers":{"future.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fibers/future.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
"use strict";
var Fiber = require('./fibers');
var util = require('util');
module.exports = Future;
Function.prototype.future = function(detach) {
	var fn = this;
	var ret = function() {
		var future = new FiberFuture(fn, this, arguments);
		if (detach) {
			future.detach();
		}
		return future;
	};
	ret.toString = function() {
		return '<<Future '+ fn+ '.future()>>';
	};
	return ret;
};

function Future() {}

/**
 * Run a function(s) in a future context, and return a future to their return value. This is useful
 * for instances where you want a closure to be able to `.wait()`. This also lets you wait for
 * mulitple parallel opertions to run.
 */
Future.task = function(fn) {
	if (arguments.length === 1) {
		return fn.future()();
	} else {
		var future = new Future, pending = arguments.length, error, values = new Array(arguments.length);
		for (var ii = 0; ii < arguments.length; ++ii) {
			arguments[ii].future()().resolve(function(ii, err, val) {
				if (err) {
					error = err;
				}
				values[ii] = val;
				if (--pending === 0) {
					if (error) {
						future.throw(error);
					} else {
						future.return(values);
					}
				}
			}.bind(null, ii));
		}
		return future;
	}
};

/**
 * Wrap node-style async functions to instead return futures. This assumes that the last parameter
 * of the function is a callback.
 *
 * If a single function is passed a future-returning function is created. If an object is passed a
 * new object is returned with all functions wrapped.
 *
 * The value that is returned from the invocation of the underlying function is assigned to the
 * property `_` on the future. This is useful for functions like `execFile` which take a callback,
 * but also return meaningful information.
 *
 * `multi` indicates that this callback will return more than 1 argument after `err`. For example,
 * `child_process.exec()`
 *
 * `suffix` will append a string to every method that was overridden, if you pass an object to
 * `Future.wrap()`. Default is 'Future'.
 *
 * var readFileFuture = Future.wrap(require('fs').readFile);
 * var fs = Future.wrap(require('fs'));
 * fs.readFileFuture('example.txt').wait();
 */
Future.wrap = function(fnOrObject, multi, suffix, stop) {
	if (typeof fnOrObject === 'object') {
		var wrapped = Object.create(fnOrObject);
		for (var ii in fnOrObject) {
			if (wrapped[ii] instanceof Function) {
				wrapped[suffix === undefined ? ii+ 'Future' : ii+ suffix] = Future.wrap(wrapped[ii], multi, suffix, stop);
			}
		}
		return wrapped;
	} else if (typeof fnOrObject === 'function') {
		var fn = function() {
			var future = new Future;
			var args = Array.prototype.slice.call(arguments);
			if (multi) {
				var cb = future.resolver();
				args.push(function(err) {
					cb(err, Array.prototype.slice.call(arguments, 1));
				});
			} else {
				args.push(future.resolver());
			}
			future._ = fnOrObject.apply(this, args);
			return future;
		}
		// Modules like `request` return a function that has more functions as properties. Handle this
		// in some kind of reasonable way.
		if (!stop) {
			var proto = Object.create(fnOrObject);
			for (var ii in fnOrObject) {
				if (fnOrObject.hasOwnProperty(ii) && fnOrObject[ii] instanceof Function) {
					proto[ii] = proto[ii];
				}
			}
			fn.__proto__ = Future.wrap(proto, multi, suffix, true);
		}
		return fn;
	}
};

/**
 * Wait on a series of futures and then return. If the futures throw an exception this function
 * /won't/ throw it back. You can get the value of the future by calling get() on it directly. If
 * you want to wait on a single future you're better off calling future.wait() on the instance.
 */
Future.wait = function wait(/* ... */) {

	// Normalize arguments + pull out a FiberFuture for reuse if possible
	var futures = [], singleFiberFuture;
	for (var ii = 0; ii < arguments.length; ++ii) {
		var arg = arguments[ii];
		if (arg instanceof Future) {
			// Ignore already resolved fibers
			if (arg.isResolved()) {
				continue;
			}
			// Look for fiber reuse
			if (!singleFiberFuture && arg instanceof FiberFuture && !arg.started) {
				singleFiberFuture = arg;
				continue;
			}
			futures.push(arg);
		} else if (arg instanceof Array) {
			for (var jj = 0; jj < arg.length; ++jj) {
				var aarg = arg[jj];
				if (aarg instanceof Future) {
					// Ignore already resolved fibers
					if (aarg.isResolved()) {
						continue;
					}
					// Look for fiber reuse
					if (!singleFiberFuture && aarg instanceof FiberFuture && !aarg.started) {
						singleFiberFuture = aarg;
						continue;
					}
					futures.push(aarg);
				} else {
					throw new Error(aarg+ ' is not a future');
				}
			}
		} else {
			throw new Error(arg+ ' is not a future');
		}
	}

	// Resumes current fiber
	var fiber = Fiber.current;
	if (!fiber) {
		throw new Error('Can\'t wait without a fiber');
	}

	// Resolve all futures
	var pending = futures.length + (singleFiberFuture ? 1 : 0);
	function cb() {
		if (!--pending) {
			fiber.run();
		}
	}
	for (var ii = 0; ii < futures.length; ++ii) {
		futures[ii].resolve(cb);
	}

	// Reusing a fiber?
	if (singleFiberFuture) {
		singleFiberFuture.started = true;
		try {
			singleFiberFuture.return(
				singleFiberFuture.fn.apply(singleFiberFuture.context, singleFiberFuture.args));
		} catch(e) {
			singleFiberFuture.throw(e);
		}
		--pending;
	}

	// Yield this fiber
	if (pending) {
		Fiber.yield();
	}
};

/**
 * Return a Future that waits on an ES6 Promise.
 */
Future.fromPromise = function(promise) {
	var future = new Future;
	promise.then(function(val) {
		future.return(val);
	}, function(err) {
		future.throw(err);
	});
	return future;
};

Future.prototype = {
	/**
	 * Return the value of this future. If the future hasn't resolved yet this will throw an error.
	 */
	get: function() {
		if (!this.resolved) {
			throw new Error('Future must resolve before value is ready');
		} else if (this.error) {
			// Link the stack traces up
			var error = this.error;
			var localStack = {};
			Error.captureStackTrace(localStack, Future.prototype.get);
			var futureStack = Object.getOwnPropertyDescriptor(error, 'futureStack');
			if (!futureStack) {
				futureStack = Object.getOwnPropertyDescriptor(error, 'stack');
				if (futureStack) {
					Object.defineProperty(error, 'futureStack', futureStack);
				}
			}
			if (futureStack && futureStack.get) {
				Object.defineProperty(error, 'stack', {
					get: function() {
						var stack = futureStack.get.apply(error);
						if (stack) {
							stack = stack.split('\n');
							return [stack[0]]
								.concat(localStack.stack.split('\n').slice(1))
								.concat('    - - - - -')
								.concat(stack.slice(1))
								.join('\n');
						} else {
							return localStack.stack;
						}
					},
					set: function(stack) {
						Object.defineProperty(error, 'stack', {
							value: stack,
							configurable: true,
							enumerable: false,
							writable: true,
						});
					},
					configurable: true,
					enumerable: false,
				});
			}
			throw error;
		} else {
			return this.value;
		}
	},

	/**
	 * Mark this future as returned. All pending callbacks will be invoked immediately.
	 */
	"return": function(value) {
		if (this.resolved) {
			throw new Error('Future resolved more than once');
		}
		this.value = value;
		this.resolved = true;

		var callbacks = this.callbacks;
		if (callbacks) {
			delete this.callbacks;
			for (var ii = 0; ii < callbacks.length; ++ii) {
				try {
					var ref = callbacks[ii];
					if (ref[1]) {
						ref[1](value);
					} else {
						ref[0](undefined, value);
					}
				} catch(ex) {
					// console.log('Resolve cb threw', String(ex.stack || ex.message || ex));
					process.nextTick(function() {
						throw(ex);
					});
				}
			}
		}
	},

	/**
	 * Throw from this future as returned. All pending callbacks will be invoked immediately.
	 */
	"throw": function(error) {
		if (this.resolved) {
			throw new Error('Future resolved more than once');
		} else if (!error) {
			throw new Error('Must throw non-empty error');
		}
		this.error = error;
		this.resolved = true;

		var callbacks = this.callbacks;
		if (callbacks) {
			delete this.callbacks;
			for (var ii = 0; ii < callbacks.length; ++ii) {
				try {
					var ref = callbacks[ii];
					if (ref[1]) {
						ref[0].throw(error);
					} else {
						ref[0](error);
					}
				} catch(ex) {
					// console.log('Resolve cb threw', String(ex.stack || ex.message || ex));
					process.nextTick(function() {
						throw(ex);
					});
				}
			}
		}
	},

	/**
	 * "detach" this future. Basically this is useful if you want to run a task in a future, you
	 * aren't interested in its return value, but if it throws you don't want the exception to be
	 * lost. If this fiber throws, an exception will be thrown to the event loop and node will
	 * probably fall down.
	 */
	detach: function() {
		this.resolve(function(err) {
			if (err) {
				throw err;
			}
		});
	},

	/**
	 * Returns whether or not this future has resolved yet.
	 */
	isResolved: function() {
		return this.resolved === true;
	},

	/**
	 * Returns a node-style function which will mark this future as resolved when called.
	 */
	resolver: function() {
		return function(err, val) {
			if (err) {
				this.throw(err);
			} else {
				this.return(val);
			}
		}.bind(this);
	},

	/**
	 * Waits for this future to resolve and then invokes a callback.
	 *
	 * If two arguments are passed, the first argument is a future which will be thrown to in the case
	 * of error, and the second is a function(val){} callback.
	 *
	 * If only one argument is passed it is a standard function(err, val){} callback.
	 */
	resolve: function(arg1, arg2) {
		if (this.resolved) {
			if (arg2) {
				if (this.error) {
					arg1.throw(this.error);
				} else {
					arg2(this.value);
				}
			} else {
				arg1(this.error, this.value);
			}
		} else {
			(this.callbacks = this.callbacks || []).push([arg1, arg2]);
		}
		return this;
	},

	/**
	 * Resolve only in the case of success
	 */
	resolveSuccess: function(cb) {
		this.resolve(function(err, val) {
			if (err) {
				return;
			}
			cb(val);
		});
		return this;
	},

	/**
	 * Propogate results to another future.
	 */
	proxy: function(future) {
		this.resolve(function(err, val) {
			if (err) {
				future.throw(err);
			} else {
				future.return(val);
			}
		});
	},

	/**
	 * Propogate only errors to an another future or array of futures.
	 */
	proxyErrors: function(futures) {
		this.resolve(function(err) {
			if (!err) {
				return;
			}
			if (futures instanceof Array) {
				for (var ii = 0; ii < futures.length; ++ii) {
					futures[ii].throw(err);
				}
			} else {
				futures.throw(err);
			}
		});
		return this;
	},

	/**
	 * Returns an ES6 Promise
	 */
	promise: function() {
		var that = this;
		return new Promise(function(resolve, reject) {
			that.resolve(function(err, val) {
				if (err) {
					reject(err);
				} else {
					resolve(val);
				}
			});
		});
	},

	/**
	 * Differs from its functional counterpart in that it actually resolves the future. Thus if the
	 * future threw, future.wait() will throw.
	 */
	wait: function() {
		if (this.isResolved()) {
			return this.get();
		}
		Future.wait(this);
		return this.get();
	},
};

/**
 * A function call which loads inside a fiber automatically and returns a future.
 */
function FiberFuture(fn, context, args) {
	this.fn = fn;
	this.context = context;
	this.args = args;
	this.started = false;
	var that = this;
	process.nextTick(function() {
		if (!that.started) {
			that.started = true;
			Fiber(function() {
				try {
					that.return(fn.apply(context, args));
				} catch(e) {
					that.throw(e);
				}
			}).run();
		}
	});
}
util.inherits(FiberFuture, Future);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"fibers.js":function(require,exports,module,__filename,__dirname){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/fibers/fibers.js                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
if (process.fiberLib) {
	module.exports = process.fiberLib;
} else {
	var fs = require('fs'), path = require('path');

	// Seed random numbers [gh-82]
	Math.random();

	// Look for binary for this platform
	var modPath = path.join(__dirname, 'bin', process.platform+ '-'+ process.arch+ '-'+ process.versions.modules, 'fibers');
	try {
		fs.statSync(modPath+ '.node');
	} catch (ex) {
		// No binary!
		console.error(
			'## There is an issue with `node-fibers` ##\n'+
			'`'+ modPath+ '.node` is missing.\n\n'+
			'Try running this to fix the issue: '+ process.execPath+ ' '+ __dirname.replace(' ', '\\ ')+ '/build'
		);
		throw new Error('Missing binary. See message above.');
	}

	// Pull in fibers implementation
	process.fiberLib = module.exports = require(modPath).Fiber;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"node-file-cache":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/node-file-cache/package.json                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "node-file-cache",
  "version": "1.0.2",
  "main": "lib/index.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"lib":{"index.js":function(require,exports){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/node-file-cache/lib/index.js                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict';
var database = require('lowdb');
var util = require('util');
function create(options) {
    return new Cache(options || {});
}
exports.create = create;
var Cache = (function () {
    function Cache(options) {
        this.set = function (key, value, options) {
            var record = this._createRecord(key, value, options || {});
            this.expire(key); // remove previous
            this.db.get('index').push(record).value();
            return this;
        };
        this.get = function (key) {
            var record = this.db.get('index').find({ key: key }).value();
            if (!record)
                return null;
            if (record.life < this._createTimestamp()) {
                this.expire(key);
                return null; // expired 
            }
            return record.val;
        };
        /**
         * Clears all records from cache storage
         */
        this.clear = function () {
            this.db.set('index', []).value();
            return this;
        };
        this.config = this._merge({
            file: 'store.json',
            life: 3600 // one hour
        }, options || {});
        this.db = database(this.config.file);
        this.db.defaults({
            index: []
        }).value();
    }
    /**
     * Removes records from cache storage
     */
    Cache.prototype.expire = function (value) {
        var _ = this.db._;
        var removed, staying;
        switch (true) {
            case util.isFunction(value):
                // remove by filter callback
                removed = this.db.get('index')
                    .filter(value)
                    .map('key')
                    .value();
                break;
            case util.isArray(value):
                // remove by tags
                removed = this.db.get('index')
                    .filter(function (record) { return _.intersection(record.tags, value).length; })
                    .map('key')
                    .value();
                break;
            case util.isString(value):
                // remove by key
                removed = this.db.get('index')
                    .filter(function (record) { return record.key === value; })
                    .map('key')
                    .value();
                break;
            default:
                throw new Error('Unsupported expiration method: ' + (typeof value));
        }
        staying = this.db.get('index')
            .filter(function (record) { return removed.indexOf(record.key) < 0; })
            .value();
        this._set(staying);
        return this;
    };
    Cache.prototype.size = function () {
        return this.db.get('index').value().length;
    };
    Cache.prototype._set = function (records) {
        this.db.set('index', records).value();
    };
    Cache.prototype._createRecord = function (key, value, options) {
        var tags = options.tags || [];
        var span = options.life || this.config.life;
        var life = span * 1000 + this._createTimestamp();
        return {
            key: key,
            val: value,
            life: life,
            tags: tags
        };
    };
    Cache.prototype._createTimestamp = function () {
        return new Date().getTime();
    };
    Cache.prototype._merge = function (a, b) {
        for (var p in b) {
            try {
                if (b[p].constructor === Object) {
                    a[p] = this._merge(a[p], b[p]);
                }
                else {
                    a[p] = b[p];
                }
            }
            catch (e) {
                a[p] = b[p];
            }
        }
        return a;
    };
    return Cache;
}());
exports.Cache = Cache;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}},"lowdb":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/lowdb/package.json                                              //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "lowdb",
  "version": "0.14.0",
  "browser": {
    "./lib/index.node.js": "./lib/index.browser.js"
  },
  "main": "./lib/index.node.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"lib":{"index.node.js":"/node_modules/meteor/randyp:mats-common/node_modules/lowdb/lib/index.browser.js","index.browser.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/lowdb/lib/index.browser.js                                      //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict';

var index = require('./_index');
var storage = require('./browser');

module.exports = function low(source) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { storage: storage };

  return index(source, opts, window._);
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"_index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/lowdb/lib/_index.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict';

var isPromise = require('is-promise');

module.exports = function (source) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$format = _ref.format,
      format = _ref$format === undefined ? null : _ref$format,
      _ref$storage = _ref.storage,
      storage = _ref$storage === undefined ? null : _ref$storage,
      _ref$writeOnChange = _ref.writeOnChange,
      writeOnChange = _ref$writeOnChange === undefined ? true : _ref$writeOnChange;

  var lodash = arguments[2];

  // Create a fresh copy of lodash
  var _ = lodash.runInContext();

  var db = _.chain({});

  if (source) {
    if (format) {
      if (format.serialize) {
        db.serialize = format.serialize;
      }
      if (format.deserialize) {
        db.deserialize = format.deserialize;
      }
    }

    if (storage) {
      if (storage.read) {
        db.read = function () {
          var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : source;

          var res = storage.read(s, db.deserialize);
          var init = function init(obj) {
            db.__wrapped__ = obj;
            db._checksum = JSON.stringify(db.__wrapped__);
          };

          if (isPromise(res)) {
            return res.then(function (obj) {
              init(obj);
              return db;
            });
          }

          init(res);
          return db;
        };
      }

      if (storage.write) {
        db.write = function () {
          var dest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : source;
          return storage.write(dest, db.__wrapped__, db.serialize);
        };
      }
    }
  }

  // Persist database state
  function persist() {
    if (db.source && db.write && writeOnChange) {
      var str = JSON.stringify(db.__wrapped__);

      if (str !== db._checksum) {
        db._checksum = str;
        db.write(db.source);
      }
    }
  }

  // Modify value function to call save before returning result
  _.prototype.value = _.wrap(_.prototype.value, function (value) {
    var v = value.apply(this);
    persist();
    return v;
  });

  // Get or set database state
  db.getState = function () {
    return db.__wrapped__;
  };
  db.setState = function (state) {
    db.__wrapped__ = state;
    persist();
  };

  db._ = _;
  db.source = source;

  // Read
  if (db.read) {
    return db.read();
  } else {
    return db;
  }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"browser.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/lowdb/lib/browser.js                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
'use strict';

/* global localStorage */

module.exports = {
  read: function read(source) {
    var deserialize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : JSON.parse;

    var data = localStorage.getItem(source);
    if (data) {
      return deserialize(data);
    } else {
      localStorage.setItem(source, '{}');
      return {};
    }
  },
  write: function write(dest, obj) {
    var serialize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : JSON.stringify;
    return localStorage.setItem(dest, serialize(obj));
  }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}},"is-promise":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/is-promise/package.json                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "is-promise",
  "version": "2.1.0",
  "main": "index.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"index.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/is-promise/index.js                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}},"jquery-ui":{"package.json":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/jquery-ui/package.json                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
module.exports = {
  "name": "jquery-ui",
  "version": "1.12.1",
  "main": "ui/widget.js"
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

},"ui":{"widget.js":function(require,exports,module){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// node_modules/meteor/randyp_mats-common/node_modules/jquery-ui/ui/widget.js                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

( function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define( [ "jquery", "./version" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

return $.widget;

} ) );

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}}}}}}},{
  "extensions": [
    ".js",
    ".json",
    ".html",
    ".css"
  ]
});

var exports = require("/node_modules/meteor/randyp:mats-common/client/main.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/both/index.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/both/mats-types.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/both/mats-collections.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/api/matsMethods.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/ui/layouts/template.notFound.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/ui/layouts/template.appBody.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/ui/layouts/appBody.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/curve_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/graph_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/select_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/index.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/init.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/client/routes.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_query_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_diff_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_match_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_curve_ops_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_plot_ops_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/data_process_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/plot_spec_util.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/index.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/publications.js");
require("/node_modules/meteor/randyp:mats-common/imports/startup/server/cache.js");
require("/node_modules/meteor/randyp:mats-common/template.footer.js");
require("/node_modules/meteor/randyp:mats-common/client/error.js");
require("/node_modules/meteor/randyp:mats-common/client/info.js");
require("/node_modules/meteor/randyp:mats-common/lib/regression.js");
require("/node_modules/meteor/randyp:mats-common/lib/param_util.js");
require("/node_modules/meteor/randyp:mats-common/lib/plot_util.js");
require("/node_modules/meteor/randyp:mats-common/lib/math_util.js");
require("/node_modules/meteor/randyp:mats-common/templates/topnav/template.top_nav.js");
require("/node_modules/meteor/randyp:mats-common/templates/topnav/top_nav.js");
require("/node_modules/meteor/randyp:mats-common/templates/spinner/template.spinner.js");
require("/node_modules/meteor/randyp:mats-common/templates/spinner/spinner.js");
require("/node_modules/meteor/randyp:mats-common/templates/template.Home.js");
require("/node_modules/meteor/randyp:mats-common/templates/Home.js");
require("/node_modules/meteor/randyp:mats-common/templates/underConstruction/template.underConstruction.js");
require("/node_modules/meteor/randyp:mats-common/templates/underConstruction/underConstruction.js");
require("/node_modules/meteor/randyp:mats-common/templates/template.about.js");
require("/node_modules/meteor/randyp:mats-common/templates/about.js");
require("/node_modules/meteor/randyp:mats-common/templates/version/template.version.js");
require("/node_modules/meteor/randyp:mats-common/templates/version/version.js");
require("/node_modules/meteor/randyp:mats-common/templates/plot/template.plot_list.js");
require("/node_modules/meteor/randyp:mats-common/templates/plot/plot_list.js");
require("/node_modules/meteor/randyp:mats-common/templates/help/template.help.js");
require("/node_modules/meteor/randyp:mats-common/templates/plot/template.plot_param_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/plot/plot_param_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/plot/template.QC_param_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/plot/QC_param_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/error/template.error.js");
require("/node_modules/meteor/randyp:mats-common/templates/error/error.js");
require("/node_modules/meteor/randyp:mats-common/templates/info/template.info.js");
require("/node_modules/meteor/randyp:mats-common/templates/info/info.js");
require("/node_modules/meteor/randyp:mats-common/templates/changePlotType/template.changePlotType.js");
require("/node_modules/meteor/randyp:mats-common/templates/changePlotType/changePlotType.js");
require("/node_modules/meteor/randyp:mats-common/templates/graph/template.graph.js");
require("/node_modules/meteor/randyp:mats-common/templates/graph/graph.js");
require("/node_modules/meteor/randyp:mats-common/templates/graphStandAlone/template.graphStandAlone.js");
require("/node_modules/meteor/randyp:mats-common/templates/graphStandAlone/graphStandAlone.js");
require("/node_modules/meteor/randyp:mats-common/templates/graph/displayFunctions/graph_plotly.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/template.text_input.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/text_input.js");
require("/node_modules/meteor/randyp:mats-common/templates/graph/template.text_output.js");
require("/node_modules/meteor/randyp:mats-common/templates/graph/text_output.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/template.select.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/select.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/template.map.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/map.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/template.date_range.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/date_range.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/template.checkbox_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/checkbox_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/template.number_spinner.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/number_spinner.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/template.radio_group_option.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/radio_group_option.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/template.item.js");
require("/node_modules/meteor/randyp:mats-common/templates/common/item.js");
require("/node_modules/meteor/randyp:mats-common/templates/curves/template.curve_item.js");
require("/node_modules/meteor/randyp:mats-common/templates/curves/curve_item.js");
require("/node_modules/meteor/randyp:mats-common/templates/curves/template.curve_param_item_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/curves/curve_param_item_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/curves/template.curve_list.js");
require("/node_modules/meteor/randyp:mats-common/templates/curves/curve_list.js");
require("/node_modules/meteor/randyp:mats-common/templates/params/template.param_list.js");
require("/node_modules/meteor/randyp:mats-common/templates/params/param_list.js");
require("/node_modules/meteor/randyp:mats-common/templates/params/template.curve_param_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/params/curve_param_group.js");
require("/node_modules/meteor/randyp:mats-common/templates/params/template.scatter_axis.js");
require("/node_modules/meteor/randyp:mats-common/templates/params/scatter_axis.js");
require("/node_modules/meteor/randyp:mats-common/templates/plotType/template.plot_type.js");
require("/node_modules/meteor/randyp:mats-common/templates/plotType/plot_type.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.reset.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/reset.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.export.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/export.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.import.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/import.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.settings.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/settings.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.databases.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/databases.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/plotParams.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.colorsScheme.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/colorScheme.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.curveParams.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/curveParams.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.authorization.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/authorization.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.mail_credentials.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/mail_credentials.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.PlotGraphFunctions.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/PlotGraphFunctions.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/template.administration.js");
require("/node_modules/meteor/randyp:mats-common/templates/administration/administration.js");

/* Exports */
Package._define("randyp:mats-common", exports, {
  matsCollections: matsCollections,
  matsTypes: matsTypes,
  matsMethods: matsMethods,
  matsCurveUtils: matsCurveUtils,
  matsSelectUtils: matsSelectUtils,
  matsGraphUtils: matsGraphUtils,
  matsParamUtils: matsParamUtils,
  matsMathUtils: matsMathUtils,
  matsPlotUtils: matsPlotUtils,
  regression: regression
});

})();
