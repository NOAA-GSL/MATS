{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_contour.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"server/dataFunctions/data_contour.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_contour.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_contour.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/dataFunctions/data_contour.js"}},"code":"let matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 4);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 5);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 6);\n\ndataContour = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const plotType = matsTypes.PlotTypes.contour;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n\n  if (curves.length > 1) {\n    throw new Error(\"INFO:  There must only be one added curve.\");\n  }\n\n  var dataset = [];\n  var axisMap = Object.create(null); // initialize variables specific to the curve\n\n  var curve = curves[0];\n  var label = curve['label'];\n  var xAxisParam = curve['x-axis-parameter'];\n  var yAxisParam = curve['y-axis-parameter'];\n  var xValClause = matsCollections.CurveParams.findOne({\n    name: 'x-axis-parameter'\n  }).optionsMap[xAxisParam];\n  var yValClause = matsCollections.CurveParams.findOne({\n    name: 'y-axis-parameter'\n  }).optionsMap[yAxisParam];\n  var dataSourceStr = curve['data-source'];\n  var data_source = matsCollections.CurveParams.findOne({\n    name: 'data-source'\n  }).optionsMap[curve['data-source']][0];\n  var regionStr = curve['region'];\n  var region = Object.keys(matsCollections.CurveParams.findOne({\n    name: 'region'\n  }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n    name: 'region'\n  }).valuesMap[key] === regionStr);\n  var source = curve['truth'];\n  var sourceStr = \"\";\n\n  if (source !== \"All\") {\n    sourceStr = \"_\" + source;\n  }\n\n  var scaleStr = curve['scale'];\n  var scale = Object.keys(matsCollections.CurveParams.findOne({\n    name: 'scale'\n  }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n    name: 'scale'\n  }).valuesMap[key] === scaleStr);\n  var statisticSelect = curve['statistic'];\n  var statisticOptionsMap = matsCollections.CurveParams.findOne({\n    name: 'statistic'\n  }, {\n    optionsMap: 1\n  })['optionsMap'];\n  var statistic = statisticOptionsMap[statisticSelect][0];\n  var validTimeClause = \"\";\n  var thresholdClause = \"\";\n  var forecastLengthClause = \"\";\n  var dateClause = \"\";\n\n  if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n    var forecastLength = curve['forecast-length'];\n    forecastLengthClause = \"and m0.fcst_len = \" + forecastLength + \" \";\n  }\n\n  if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    thresholdClause = \"and m0.trsh = \" + threshold + \" \";\n  }\n\n  if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n\n    if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n      validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n    }\n  }\n\n  if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date') {\n    dateClause = \"m0.time-m0.fcst_len*3600\";\n  } else {\n    dateClause = \"m0.time\";\n  } // For contours, this functions as the colorbar label.\n\n\n  curve['unitKey'] = statisticOptionsMap[statisticSelect][1];\n  var d; // this is a database driven curve, not a difference curve\n  // prepare the query from the above parameters\n\n  var statement = \"{{xValClause}} \" + \"{{yValClause}} \" + \"count(distinct {{dateClause}}) as N_times, \" + \"min({{dateClause}}) as min_secs, \" + \"max({{dateClause}}) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and {{dateClause}} >= '{{fromSecs}}' \" + \"and {{dateClause}} <= '{{toSecs}}' \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"{{thresholdClause}} \" + \"{{validTimeClause}} \" + \"{{forecastLengthClause}} \" + \"group by xVal,yVal \" + \"order by xVal,yVal\" + \";\";\n  statement = statement.replace('{{xValClause}}', xValClause);\n  statement = statement.replace('{{yValClause}}', yValClause);\n  statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n  statement = statement.replace('{{statistic}}', statistic);\n  statement = statement.replace('{{threshold}}', threshold);\n  statement = statement.replace('{{fromSecs}}', fromSecs);\n  statement = statement.replace('{{toSecs}}', toSecs);\n  statement = statement.replace('{{thresholdClause}}', thresholdClause);\n  statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n  statement = statement.replace('{{validTimeClause}}', validTimeClause);\n  statement = statement.split('{{dateClause}}').join(dateClause);\n  dataRequests[curve.label] = statement; // math is done on forecastLength later on -- set all analyses to 0\n\n  if (forecastLength === \"-99\") {\n    forecastLength = \"0\";\n  }\n\n  var queryResult;\n  var startMoment = moment();\n  var finishMoment;\n\n  try {\n    // send the query statement to the query function\n    queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n    finishMoment = moment();\n    dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n      begin: startMoment.format(),\n      finish: finishMoment.format(),\n      duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n      recordCount: queryResult.data.xTextOutput.length\n    }; // get the data back from the query\n\n    d = queryResult.data;\n  } catch (e) {\n    // this is an error produced by a bug in the query function, not an error returned by the mysql database\n    e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n    throw new Error(e.message);\n  }\n\n  if (queryResult.error !== undefined && queryResult.error !== \"\") {\n    if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n      // this is NOT an error just a no data condition\n      dataFoundForCurve = false;\n    } else {\n      // this is an error returned by the mysql database\n      error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n      throw new Error(error);\n    }\n  }\n\n  var postQueryStartMoment = moment(); // set curve annotation to be the curve mean -- may be recalculated later\n  // also pass previously calculated axis stats to curve options\n\n  const mean = d.glob_stats.mean;\n  const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n  curve['annotation'] = annotation;\n  curve['xmin'] = d.xmin;\n  curve['xmax'] = d.xmax;\n  curve['ymin'] = d.ymin;\n  curve['ymax'] = d.ymax;\n  curve['zmin'] = d.zmin;\n  curve['zmax'] = d.zmax;\n  curve['xAxisKey'] = xAxisParam;\n  curve['yAxisKey'] = yAxisParam;\n  const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n  dataset.push(cOptions);\n  var postQueryFinishMoment = moment();\n  dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n    begin: postQueryStartMoment.format(),\n    finish: postQueryFinishMoment.format(),\n    duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n  }; // process the data returned by the query\n\n  const curveInfoParams = {\n    \"curve\": curves,\n    \"axisMap\": axisMap\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};","map":{"version":3,"sources":["server/dataFunctions/data_contour.js"],"names":["matsCollections","module","link","v","matsTypes","matsDataUtils","matsDataQueryUtils","matsDataCurveOpsUtils","matsDataProcessUtils","moment","dataContour","plotParams","plotFunction","plotType","PlotTypes","contour","dataRequests","dataFoundForCurve","totalProcessingStart","dateRange","getDateRange","dates","fromSecs","fromSeconds","toSecs","toSeconds","error","curves","JSON","parse","stringify","length","Error","dataset","axisMap","Object","create","curve","label","xAxisParam","yAxisParam","xValClause","CurveParams","findOne","name","optionsMap","yValClause","dataSourceStr","data_source","regionStr","region","keys","valuesMap","find","key","source","sourceStr","scaleStr","scale","statisticSelect","statisticOptionsMap","statistic","validTimeClause","thresholdClause","forecastLengthClause","dateClause","forecastLength","thresholdStr","threshold","validTimes","undefined","InputTypes","unused","d","statement","replace","split","join","queryResult","startMoment","finishMoment","queryDBContour","sumPool","begin","format","finish","duration","diff","asSeconds","recordCount","data","xTextOutput","e","message","Messages","NO_DATA_FOUND","postQueryStartMoment","mean","glob_stats","annotation","toPrecision","xmin","xmax","ymin","ymax","zmin","zmax","cOptions","generateContourCurveOptions","push","postQueryFinishMoment","curveInfoParams","bookkeepingParams","result","processDataContour"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataContour = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const plotType = matsTypes.PlotTypes.contour;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    if (curves.length > 1) {\n        throw new Error(\"INFO:  There must only be one added curve.\");\n    }\n    var dataset = [];\n    var axisMap = Object.create(null);\n\n    // initialize variables specific to the curve\n    var curve = curves[0];\n    var label = curve['label'];\n    var xAxisParam = curve['x-axis-parameter'];\n    var yAxisParam = curve['y-axis-parameter'];\n    var xValClause = matsCollections.CurveParams.findOne({name: 'x-axis-parameter'}).optionsMap[xAxisParam];\n    var yValClause = matsCollections.CurveParams.findOne({name: 'y-axis-parameter'}).optionsMap[yAxisParam];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n    if (source !== \"All\") {\n        sourceStr = \"_\" + source;\n    }\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimeClause = \"\";\n    var thresholdClause = \"\";\n    var forecastLengthClause = \"\";\n    var dateClause = \"\";\n    if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n        var forecastLength = curve['forecast-length'];\n        forecastLengthClause = \"and m0.fcst_len = \" + forecastLength + \" \";\n    }\n    if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        thresholdClause = \"and m0.trsh = \" + threshold + \" \";\n    }\n    if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n            validTimeClause = \" and  m0.time%(24*3600)/3600 IN(\" + validTimes + \")\";\n        }\n    }\n    if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && (xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date')) {\n        dateClause = \"m0.time-m0.fcst_len*3600\";\n    } else {\n        dateClause = \"m0.time\";\n    }\n\n    // For contours, this functions as the colorbar label.\n    curve['unitKey'] = statisticOptionsMap[statisticSelect][1];\n\n    var d;\n    // this is a database driven curve, not a difference curve\n    // prepare the query from the above parameters\n    var statement = \"{{xValClause}} \" +\n        \"{{yValClause}} \" +\n        \"count(distinct {{dateClause}}) as N_times, \" +\n        \"min({{dateClause}}) as min_secs, \" +\n        \"max({{dateClause}}) as max_secs, \" +\n        \"{{statistic}} \" +\n        \"from {{data_source}} as m0 \" +\n        \"where 1=1 \" +\n        \"and {{dateClause}} >= '{{fromSecs}}' \" +\n        \"and {{dateClause}} <= '{{toSecs}}' \" +\n        \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n        \"{{thresholdClause}} \" +\n        \"{{validTimeClause}} \" +\n        \"{{forecastLengthClause}} \" +\n        \"group by xVal,yVal \" +\n        \"order by xVal,yVal\" +\n        \";\";\n\n    statement = statement.replace('{{xValClause}}', xValClause);\n    statement = statement.replace('{{yValClause}}', yValClause);\n    statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n    statement = statement.replace('{{statistic}}', statistic);\n    statement = statement.replace('{{threshold}}', threshold);\n    statement = statement.replace('{{fromSecs}}', fromSecs);\n    statement = statement.replace('{{toSecs}}', toSecs);\n    statement = statement.replace('{{thresholdClause}}', thresholdClause);\n    statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n    statement = statement.replace('{{validTimeClause}}', validTimeClause);\n    statement = statement.split('{{dateClause}}').join(dateClause);\n    dataRequests[curve.label] = statement;\n\n    // math is done on forecastLength later on -- set all analyses to 0\n    if (forecastLength === \"-99\") {\n        forecastLength = \"0\";\n    }\n\n    var queryResult;\n    var startMoment = moment();\n    var finishMoment;\n    try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n            begin: startMoment.format(),\n            finish: finishMoment.format(),\n            duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n            recordCount: queryResult.data.xTextOutput.length\n        };\n        // get the data back from the query\n        d = queryResult.data;\n    } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n    }\n    if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n            // this is NOT an error just a no data condition\n            dataFoundForCurve = false;\n        } else {\n            // this is an error returned by the mysql database\n            error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n            throw (new Error(error));\n        }\n    }\n\n    var postQueryStartMoment = moment();\n\n    // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n    const mean = d.glob_stats.mean;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['zmin'] = d.zmin;\n    curve['zmax'] = d.zmax;\n    curve['xAxisKey'] = xAxisParam;\n    curve['yAxisKey'] = yAxisParam;\n    const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n        begin: postQueryStartMoment.format(),\n        finish: postQueryFinishMoment.format(),\n        duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n\n    // process the data returned by the query\n    const curveInfoParams = {\"curve\": curves, \"axisMap\": axisMap};\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};"]},"sourceType":"script","hash":"be12ad5ca6034cf0ca80d6a9158b5139733ce31c"}
