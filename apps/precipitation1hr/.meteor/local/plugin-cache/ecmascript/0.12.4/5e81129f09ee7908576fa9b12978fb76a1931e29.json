{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/ostrio:flow-router-extra/client/router.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/ostrio:flow-router-extra/client/router.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/ostrio:flow-router-extra/client/router.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/ostrio:flow-router-extra/client/router.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ostrio:flow-router-extra/client/router.js"}},"code":"let FlowRouter, Route, Group, Triggers, BlazeRenderer;\nmodule.link(\"./_init.js\", {\n  FlowRouter(v) {\n    FlowRouter = v;\n  },\n\n  Route(v) {\n    Route = v;\n  },\n\n  Group(v) {\n    Group = v;\n  },\n\n  Triggers(v) {\n    Triggers = v;\n  },\n\n  BlazeRenderer(v) {\n    BlazeRenderer = v;\n  }\n\n}, 0);\nlet EJSON;\nmodule.link(\"meteor/ejson\", {\n  EJSON(v) {\n    EJSON = v;\n  }\n\n}, 1);\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 2);\nlet Tracker;\nmodule.link(\"meteor/tracker\", {\n  Tracker(v) {\n    Tracker = v;\n  }\n\n}, 3);\n\nlet _helpers;\n\nmodule.link(\"./../lib/_helpers.js\", {\n  _helpers(v) {\n    _helpers = v;\n  }\n\n}, 4);\nlet page, qs;\nmodule.link(\"./modules.js\", {\n  page(v) {\n    page = v;\n  },\n\n  qs(v) {\n    qs = v;\n  }\n\n}, 5);\n\nclass Router {\n  constructor() {\n    this.pathRegExp = /(:[\\w\\(\\)\\\\\\+\\*\\.\\?\\[\\]\\-]+)+/g;\n    this.globals = [];\n    this.subscriptions = Function.prototype;\n    this.Renderer = new BlazeRenderer();\n    this._tracker = this._buildTracker();\n    this._current = {};\n    this._specialChars = ['/', '%', '+'];\n\n    this._encodeParam = param => {\n      const paramArr = param.split('');\n      let _param = '';\n\n      for (let i = 0; i < paramArr.length; i++) {\n        if (this._specialChars.includes(paramArr[i])) {\n          _param += encodeURIComponent(encodeURIComponent(paramArr[i]));\n        } else {\n          try {\n            _param += encodeURIComponent(paramArr[i]);\n          } catch (e) {\n            _param += paramArr[i];\n          }\n        }\n      }\n\n      return _param;\n    }; // tracks the current path change\n\n\n    this._onEveryPath = new Tracker.Dependency();\n    this._globalRoute = new Route(this); // holds onRoute callbacks\n\n    this._onRouteCallbacks = []; // if _askedToWait is true. We don't automatically start the router\n    // in Meteor.startup callback. (see client/_init.js)\n    // Instead user need to call `.initialize()\n\n    this._askedToWait = false;\n    this._initialized = false;\n    this._triggersEnter = [];\n    this._triggersExit = [];\n    this._routes = [];\n    this._routesMap = {};\n\n    this._updateCallbacks();\n\n    this._notFound = null;\n    this.notfound = this.notFound; // indicate it's okay (or not okay) to run the tracker\n    // when doing subscriptions\n    // using a number and increment it help us to support FlowRouter.go()\n    // and legitimate reruns inside tracker on the same event loop.\n    // this is a solution for #145\n\n    this.safeToRun = 0; // Meteor exposes to the client the path prefix that was defined using the\n    // ROOT_URL environement variable on the server using the global runtime\n    // configuration. See #315.\n\n    this._basePath = window.__meteor_runtime_config__.ROOT_URL_PATH_PREFIX || ''; // this is a chain contains a list of old routes\n    // most of the time, there is only one old route\n    // but when it's the time for a trigger redirect we've a chain\n\n    this._oldRouteChain = [];\n    this.env = {\n      replaceState: new Meteor.EnvironmentVariable(),\n      reload: new Meteor.EnvironmentVariable(),\n      trailingSlash: new Meteor.EnvironmentVariable()\n    }; // Implementing Reactive APIs\n\n    const reactiveApis = ['getParam', 'getQueryParam', 'getRouteName', 'watchPathChange'];\n    reactiveApis.forEach(api => {\n      this[api] = function (arg1) {\n        // when this is calling, there may not be any route initiated\n        // so we need to handle it\n        const currentRoute = this._current.route;\n\n        if (!currentRoute) {\n          this._onEveryPath.depend();\n\n          return void 0;\n        } // currently, there is only one argument. If we've more let's add more args\n        // this is not clean code, but better in performance\n\n\n        return currentRoute[api].call(currentRoute, arg1);\n      };\n    }); // redirect function used inside triggers\n\n    this._redirectFn = (pathDef, fields, queryParams) => {\n      if (/^http(s)?:\\/\\//.test(pathDef)) {\n        throw new Error(\"Redirects to URLs outside of the app are not supported in this version of Flow Router. Use 'window.location = yourUrl' instead\");\n      }\n\n      this.withReplaceState(() => {\n        this._page.redirect(FlowRouter.path(pathDef, fields, queryParams));\n      });\n    };\n\n    this._initTriggersAPI();\n  }\n\n  set notFound(opts) {\n    Meteor._debug('FlowRouter.notFound is deprecated, use FlowRouter.route(\\'*\\', { /*...*/ }) instead!');\n\n    opts.name = opts.name || '__notFound';\n    this._notFound = this.route('*', opts);\n  }\n\n  get notFound() {\n    return this._notFound;\n  }\n\n  get _page() {\n    return page;\n  }\n\n  get _qs() {\n    return qs;\n  }\n\n  route(pathDef) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let group = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (!/^\\//.test(pathDef) && pathDef !== '*') {\n      throw new Error(\"route's path must start with '/'\");\n    }\n\n    const route = new Route(this, pathDef, options, group); // calls when the page route being activates\n\n    route._actionHandle = context => {\n      const oldRoute = this._current.route;\n\n      this._oldRouteChain.push(oldRoute); // _qs.parse() gives us a object without prototypes,\n      // created with Object.create(null)\n      // Meteor's check doesn't play nice with it.\n      // So, we need to fix it by cloning it.\n      // see more: https://github.com/meteorhacks/flow-router/issues/164\n\n\n      const queryParams = this._qs.parse(context.querystring);\n\n      this._current = {\n        path: context.path,\n        params: context.params,\n        route,\n        context,\n        oldRoute,\n        queryParams\n      }; // we need to invalidate if all the triggers have been completed\n      // if not that means, we've been redirected to another path\n      // then we don't need to invalidate\n\n      const afterAllTriggersRan = () => {\n        this._invalidateTracker();\n      };\n\n      route.waitOn(this._current, (current, data) => {\n        Triggers.runTriggers(this._triggersEnter.concat(route._triggersEnter), this._current, this._redirectFn, afterAllTriggersRan, data);\n      });\n    }; // calls when you exit from the page js route\n\n\n    route._exitHandle = (context, next) => {\n      Triggers.runTriggers(this._triggersExit.concat(route._triggersExit), this._current, this._redirectFn, next);\n    };\n\n    this._routes.push(route);\n\n    if (options.name) {\n      this._routesMap[options.name] = route;\n    }\n\n    this._updateCallbacks();\n\n    this._triggerRouteRegister(route);\n\n    return route;\n  }\n\n  group(options) {\n    return new Group(this, options);\n  }\n\n  path(_pathDef) {\n    let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let queryParams = arguments.length > 2 ? arguments[2] : undefined;\n    let pathDef = _pathDef;\n\n    if (this._routesMap[pathDef]) {\n      pathDef = this._routesMap[pathDef].pathDef;\n    }\n\n    let path = ''; // Prefix the path with the router global prefix\n\n    if (this._basePath) {\n      path += \"/\".concat(this._basePath, \"/\");\n    }\n\n    path += pathDef.replace(this.pathRegExp, _key => {\n      const firstRegexpChar = _key.indexOf('('); // get the content behind : and (\\\\d+/)\n\n\n      let key = _key.substring(1, firstRegexpChar > 0 ? firstRegexpChar : undefined); // remove +?*\n\n\n      key = key.replace(/[\\+\\*\\?]+/g, ''); // this is to allow page js to keep the custom characters as it is\n      // we need to encode 2 times otherwise \"/\" char does not work properly\n      // So, in that case, when I includes \"/\" it will think it's a part of the\n      // route. encoding 2times fixes it\n\n      if (fields[key]) {\n        return this._encodeParam(\"\".concat(fields[key]));\n      }\n\n      return '';\n    }); // Replace multiple slashes with single slash\n\n    path = path.replace(/\\/\\/+/g, '/'); // remove trailing slash\n    // but keep the root slash if it's the only one\n\n    path = path.match(/^\\/{1}$/) ? path : path.replace(/\\/$/, ''); // explictly asked to add a trailing slash\n\n    if (this.env.trailingSlash.get() && path[path.length - 1] !== '/') {\n      path += '/';\n    }\n\n    const strQueryParams = this._qs.stringify(queryParams || {});\n\n    if (strQueryParams) {\n      path += \"?\".concat(strQueryParams);\n    }\n\n    path = path.replace(/\\/\\/+/g, '/');\n    return path;\n  }\n\n  go(pathDef, fields, queryParams) {\n    const path = this.path(pathDef, fields, queryParams);\n\n    if (!this.env.reload.get() && path === this._current.path) {\n      return;\n    }\n\n    try {\n      if (this.env.replaceState.get()) {\n        this._page.replace(path);\n      } else {\n        this._page(path);\n      }\n    } catch (e) {\n      Meteor._debug('Malformed URI!', path, e);\n    }\n  }\n\n  reload() {\n    this.env.reload.withValue(true, () => {\n      this._page.replace(this._current.path);\n    });\n  }\n\n  redirect(path) {\n    this._page.redirect(path);\n  }\n\n  setParams(newParams) {\n    if (!this._current.route) {\n      return false;\n    }\n\n    const pathDef = this._current.route.pathDef;\n    const existingParams = this._current.params;\n    let params = {};\n    Object.keys(existingParams).forEach(key => {\n      params[key] = existingParams[key];\n    });\n    params = _helpers.extend(params, newParams);\n    const queryParams = this._current.queryParams;\n    this.go(pathDef, params, queryParams);\n    return true;\n  }\n\n  setQueryParams(newParams) {\n    if (!this._current.route) {\n      return false;\n    }\n\n    const queryParams = _helpers.extend(_helpers.clone(this._current.queryParams), newParams);\n\n    for (const k in queryParams) {\n      if (queryParams[k] === null || queryParams[k] === undefined) {\n        delete queryParams[k];\n      }\n    }\n\n    const pathDef = this._current.route.pathDef;\n    const params = this._current.params;\n    this.go(pathDef, params, queryParams);\n    return true;\n  } // .current is not reactive\n  // This is by design. use .getParam() instead\n  // If you really need to watch the path change, use .watchPathChange()\n\n\n  current() {\n    // We can't trust outside, that's why we clone this\n    // Anyway, we can't clone the whole object since it has non-jsonable values\n    // That's why we clone what's really needed.\n    const current = _helpers.clone(this._current);\n\n    current.queryParams = EJSON.clone(current.queryParams);\n    current.params = EJSON.clone(current.params);\n    return current;\n  }\n\n  track(reactiveMapper) {\n    return (props, onData, env) => {\n      let trackerCleanup = null;\n      const handler = Tracker.nonreactive(() => {\n        return Tracker.autorun(() => {\n          trackerCleanup = reactiveMapper(props, onData, env);\n        });\n      });\n      return () => {\n        if (typeof trackerCleanup === 'function') {\n          trackerCleanup();\n        }\n\n        return handler.stop();\n      };\n    };\n  }\n\n  mapper(props, onData, env) {\n    if (typeof onData === 'function') {\n      onData(null, {\n        route: this.current(),\n        props,\n        env\n      });\n    }\n  }\n\n  trackMapper() {\n    return this.track(this.mapper);\n  }\n\n  subsReady() {\n    let callback = null;\n    const args = Array.from(arguments);\n\n    if (typeof args[args.length - 1] === 'function') {\n      callback = args.pop();\n    }\n\n    const currentRoute = this.current().route;\n    const globalRoute = this._globalRoute; // we need to depend for every route change and\n    // rerun subscriptions to check the ready state\n\n    this._onEveryPath.depend();\n\n    if (!currentRoute) {\n      return false;\n    }\n\n    let subscriptions;\n\n    if (args.length === 0) {\n      subscriptions = Object.values(globalRoute.getAllSubscriptions());\n      subscriptions = subscriptions.concat(Object.values(currentRoute.getAllSubscriptions()));\n    } else {\n      subscriptions = args.map(subName => {\n        return globalRoute.getSubscription(subName) || currentRoute.getSubscription(subName);\n      });\n    }\n\n    const isReady = () => {\n      const ready = subscriptions.every(sub => {\n        return sub && sub.ready();\n      });\n      return ready;\n    };\n\n    if (callback) {\n      Tracker.autorun(c => {\n        if (isReady()) {\n          callback();\n          c.stop();\n        }\n      });\n      return true;\n    }\n\n    return isReady();\n  }\n\n  withReplaceState(fn) {\n    return this.env.replaceState.withValue(true, fn);\n  }\n\n  withTrailingSlash(fn) {\n    return this.env.trailingSlash.withValue(true, fn);\n  }\n\n  initialize() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._initialized) {\n      throw new Error('FlowRouter is already initialized');\n    }\n\n    const self = this;\n\n    this._updateCallbacks(); // Implementing idempotent routing\n    // by overriding page.js`s \"show\" method.\n    // Why?\n    // It is impossible to bypass exit triggers,\n    // because they execute before the handler and\n    // can not know what the next path is, inside exit trigger.\n    //\n    // we need override both show, replace to make this work\n    // since we use redirect when we are talking about withReplaceState\n\n\n    ['show', 'replace'].forEach(fnName => {\n      const original = self._page[fnName];\n\n      self._page[fnName] = function (path, state, dispatch, push) {\n        if (!path || !self.env.reload.get() && self._current.path === path) {\n          return;\n        }\n\n        original.call(this, path.replace(/\\/\\/+/g, '/'), state, dispatch, push);\n      };\n    }); // this is very ugly part of pagejs and it does decoding few times\n    // in unpredicatable manner. See #168\n    // this is the default behaviour and we need keep it like that\n    // we are doing a hack. see .path()\n\n    this._page.base(this._basePath);\n\n    const pageOptions = Object.assign({\n      hashbang: !!options.hashbang,\n      decodeURLComponents: true\n    }, options.page || {});\n\n    this._page(pageOptions);\n\n    this._initialized = true;\n  }\n\n  _buildTracker() {\n    // main autorun function\n    const tracker = Tracker.autorun(() => {\n      if (!this._current || !this._current.route) {\n        return;\n      } // see the definition of `this._processingContexts`\n\n\n      const currentContext = this._current;\n      const route = currentContext.route;\n      const path = currentContext.path;\n\n      if (this.safeToRun === 0) {\n        throw new Error(\"You can't use reactive data sources like Session inside the `.subscriptions` method!\");\n      } // We need to run subscriptions inside a Tracker\n      // to stop subs when switching between routes\n      // But we don't need to run this tracker with\n      // other reactive changes inside the .subscription method\n      // We tackle this with the `safeToRun` variable\n\n\n      this._globalRoute.clearSubscriptions();\n\n      this.subscriptions.call(this._globalRoute, path);\n      route.callSubscriptions(currentContext); // otherwise, computations inside action will trigger to re-run\n      // this computation. which we do not need.\n\n      Tracker.nonreactive(() => {\n        let isRouteChange = currentContext.oldRoute !== currentContext.route; // first route is not a route change\n\n        if (!currentContext.oldRoute) {\n          isRouteChange = false;\n        } // Clear oldRouteChain just before calling the action\n        // We still need to get a copy of the oldestRoute first\n        // It's very important to get the oldest route and registerRouteClose() it\n        // See: https://github.com/kadirahq/flow-router/issues/314\n\n\n        const oldestRoute = this._oldRouteChain[0];\n        this._oldRouteChain = [];\n        currentContext.route.registerRouteChange(currentContext, isRouteChange);\n        route.callAction(currentContext);\n        Tracker.afterFlush(() => {\n          this._onEveryPath.changed();\n\n          if (isRouteChange) {\n            // We need to trigger that route (definition itself) has changed.\n            // So, we need to re-run all the register callbacks to current route\n            // This is pretty important, otherwise tracker\n            // can't identify new route's items\n            // We also need to afterFlush, otherwise this will re-run\n            // helpers on templates which are marked for destroying\n            if (oldestRoute && oldestRoute.registerRouteClose) {\n              oldestRoute.registerRouteClose();\n            }\n          }\n        });\n      });\n      this.safeToRun--;\n    });\n    return tracker;\n  }\n\n  _invalidateTracker() {\n    this.safeToRun++;\n\n    this._tracker.invalidate(); // After the invalidation we need to flush to make changes immediately\n    // otherwise, we have face some issues context mix-matches and so on.\n    // But there are some cases we can't flush. So we need to ready for that.\n    // we clearly know, we can't flush inside an autorun\n    // this may leads some issues on flow-routing\n    // we may need to do some warning\n\n\n    if (!Tracker.currentComputation) {\n      // Still there are some cases where we can't flush\n      //  eg:- when there is a flush currently\n      // But we've no public API or hacks to get that state\n      // So, this is the only solution\n      try {\n        Tracker.flush();\n      } catch (ex) {\n        // only handling \"while flushing\" errors\n        if (!/Tracker\\.flush while flushing/.test(ex.message)) {\n          return;\n        } // XXX: fix this with a proper solution by removing subscription mgt.\n        // from the router. Then we don't need to run invalidate using a tracker\n        // this happens when we are trying to invoke a route change\n        // with inside a route change. (eg:- Template.onCreated)\n        // Since we use page.js and tracker, we don't have much control\n        // over this process.\n        // only solution is to defer route execution.\n        // It's possible to have more than one path want to defer\n        // But, we only need to pick the last one.\n        // self._nextPath = self._current.path;\n\n\n        Meteor.defer(() => {\n          const path = this._nextPath;\n\n          if (!path) {\n            return;\n          }\n\n          delete this._nextPath;\n          this.env.reload.withValue(true, () => {\n            this.go(path);\n          });\n        });\n      }\n    }\n  }\n\n  _updateCallbacks() {\n    this._page.callbacks = [];\n    this._page.exits = [];\n    let catchAll = null;\n\n    this._routes.forEach(route => {\n      if (route.pathDef === '*') {\n        catchAll = route;\n      } else {\n        this._page(route.pathDef, route._actionHandle);\n\n        this._page.exit(route.pathDef, route._exitHandle);\n      }\n    }); // Setting exit triggers on catch all routes leads to weird behavior.\n    // We recommend to avoid enter and exit triggers on catch all (`*`) routes.\n    // Use FlowRouter.triggers.exit([func]) and FlowRouter.triggers.enter([func]) instead\n\n\n    if (catchAll) {\n      this._page(catchAll.pathDef, catchAll._actionHandle); // this._page.exit(catchAll.pathDef, catchAll._exitHandle);\n\n    }\n  }\n\n  _initTriggersAPI() {\n    const self = this;\n    this.triggers = {\n      enter(_triggers, filter) {\n        let triggers = Triggers.applyFilters(_triggers, filter);\n\n        if (triggers.length) {\n          self._triggersEnter = self._triggersEnter.concat(triggers);\n        }\n      },\n\n      exit(_triggers, filter) {\n        let triggers = Triggers.applyFilters(_triggers, filter);\n\n        if (triggers.length) {\n          self._triggersExit = self._triggersExit.concat(triggers);\n        }\n      }\n\n    };\n  }\n\n  wait() {\n    if (this._initialized) {\n      throw new Error(\"can't wait after FlowRouter has been initialized\");\n    }\n\n    this._askedToWait = true;\n  }\n\n  onRouteRegister(cb) {\n    this._onRouteCallbacks.push(cb);\n  }\n\n  _triggerRouteRegister(currentRoute) {\n    // We should only need to send a safe set of fields on the route\n    // object.\n    // This is not to hide what's inside the route object, but to show\n    // these are the public APIs\n    const routePublicApi = _helpers.pick(currentRoute, ['name', 'pathDef', 'path']);\n\n    routePublicApi.options = _helpers.omit(currentRoute.options, ['triggersEnter', 'triggersExit', 'action', 'subscriptions', 'name']);\n\n    this._onRouteCallbacks.forEach(cb => {\n      cb(routePublicApi);\n    });\n  }\n\n  url() {\n    // We need to remove the leading base path, or \"/\", as it will be inserted\n    // automatically by `Meteor.absoluteUrl` as documented in:\n    // http://docs.meteor.com/#/full/meteor_absoluteurl\n    return Meteor.absoluteUrl(this.path.apply(this, arguments).replace(new RegExp('^' + \"/\".concat(this._basePath || '', \"/\").replace(/\\/\\/+/g, '/')), ''));\n  }\n\n}\n\nmodule.exportDefault(Router);","map":{"version":3,"sources":["packages/ostrio:flow-router-extra/client/router.js"],"names":["FlowRouter","Route","Group","Triggers","BlazeRenderer","module","link","v","EJSON","Meteor","Tracker","_helpers","page","qs","Router","constructor","pathRegExp","globals","subscriptions","Function","prototype","Renderer","_tracker","_buildTracker","_current","_specialChars","_encodeParam","param","paramArr","split","_param","i","length","includes","encodeURIComponent","e","_onEveryPath","Dependency","_globalRoute","_onRouteCallbacks","_askedToWait","_initialized","_triggersEnter","_triggersExit","_routes","_routesMap","_updateCallbacks","_notFound","notfound","notFound","safeToRun","_basePath","window","__meteor_runtime_config__","ROOT_URL_PATH_PREFIX","_oldRouteChain","env","replaceState","EnvironmentVariable","reload","trailingSlash","reactiveApis","forEach","api","arg1","currentRoute","route","depend","call","_redirectFn","pathDef","fields","queryParams","test","Error","withReplaceState","_page","redirect","path","_initTriggersAPI","opts","_debug","name","_qs","options","group","_actionHandle","context","oldRoute","push","parse","querystring","params","afterAllTriggersRan","_invalidateTracker","waitOn","current","data","runTriggers","concat","_exitHandle","next","_triggerRouteRegister","_pathDef","replace","_key","firstRegexpChar","indexOf","key","substring","undefined","match","get","strQueryParams","stringify","go","withValue","setParams","newParams","existingParams","Object","keys","extend","setQueryParams","clone","k","track","reactiveMapper","props","onData","trackerCleanup","handler","nonreactive","autorun","stop","mapper","trackMapper","subsReady","callback","args","Array","from","arguments","pop","globalRoute","values","getAllSubscriptions","map","subName","getSubscription","isReady","ready","every","sub","c","fn","withTrailingSlash","initialize","self","fnName","original","state","dispatch","base","pageOptions","assign","hashbang","decodeURLComponents","tracker","currentContext","clearSubscriptions","callSubscriptions","isRouteChange","oldestRoute","registerRouteChange","callAction","afterFlush","changed","registerRouteClose","invalidate","currentComputation","flush","ex","message","defer","_nextPath","callbacks","exits","catchAll","exit","triggers","enter","_triggers","filter","applyFilters","wait","onRouteRegister","cb","routePublicApi","pick","omit","url","absoluteUrl","apply","RegExp","exportDefault"],"mappings":"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","sourcesContent":["import { FlowRouter, Route, Group, Triggers, BlazeRenderer } from './_init.js';\nimport { EJSON }    from 'meteor/ejson';\nimport { Meteor }   from 'meteor/meteor';\nimport { Tracker }  from 'meteor/tracker';\nimport { _helpers } from './../lib/_helpers.js';\nimport { page, qs } from './modules.js';\n\nclass Router {\n  constructor() {\n    this.pathRegExp = /(:[\\w\\(\\)\\\\\\+\\*\\.\\?\\[\\]\\-]+)+/g;\n    this.globals = [];\n    this.subscriptions = Function.prototype;\n    this.Renderer = new BlazeRenderer();\n\n    this._tracker = this._buildTracker();\n    this._current = {};\n    this._specialChars = ['/', '%', '+'];\n    this._encodeParam = (param) => {\n      const paramArr = param.split('');\n      let _param   = '';\n      for (let i = 0; i < paramArr.length; i++) {\n        if (this._specialChars.includes(paramArr[i])){\n          _param += encodeURIComponent(encodeURIComponent(paramArr[i]));\n        } else {\n          try {\n            _param += encodeURIComponent(paramArr[i]);\n          } catch (e) {\n            _param += paramArr[i];\n          }\n        }\n      }\n      return _param;\n    };\n\n    // tracks the current path change\n    this._onEveryPath = new Tracker.Dependency();\n\n    this._globalRoute = new Route(this);\n\n    // holds onRoute callbacks\n    this._onRouteCallbacks = [];\n\n    // if _askedToWait is true. We don't automatically start the router\n    // in Meteor.startup callback. (see client/_init.js)\n    // Instead user need to call `.initialize()\n    this._askedToWait = false;\n    this._initialized = false;\n    this._triggersEnter = [];\n    this._triggersExit = [];\n    this._routes = [];\n    this._routesMap = {};\n    this._updateCallbacks();\n    this._notFound = null;\n    this.notfound = this.notFound;\n    // indicate it's okay (or not okay) to run the tracker\n    // when doing subscriptions\n    // using a number and increment it help us to support FlowRouter.go()\n    // and legitimate reruns inside tracker on the same event loop.\n    // this is a solution for #145\n    this.safeToRun = 0;\n\n    // Meteor exposes to the client the path prefix that was defined using the\n    // ROOT_URL environement variable on the server using the global runtime\n    // configuration. See #315.\n    this._basePath = window.__meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '';\n\n    // this is a chain contains a list of old routes\n    // most of the time, there is only one old route\n    // but when it's the time for a trigger redirect we've a chain\n    this._oldRouteChain = [];\n\n    this.env = {\n      replaceState: new Meteor.EnvironmentVariable(),\n      reload: new Meteor.EnvironmentVariable(),\n      trailingSlash: new Meteor.EnvironmentVariable()\n    };\n\n    // Implementing Reactive APIs\n    const reactiveApis = [\n      'getParam', 'getQueryParam',\n      'getRouteName', 'watchPathChange'\n    ];\n\n    reactiveApis.forEach((api) => {\n      this[api] = function (arg1) {\n        // when this is calling, there may not be any route initiated\n        // so we need to handle it\n        const currentRoute = this._current.route;\n        if (!currentRoute) {\n          this._onEveryPath.depend();\n          return void 0;\n        }\n\n        // currently, there is only one argument. If we've more let's add more args\n        // this is not clean code, but better in performance\n        return currentRoute[api].call(currentRoute, arg1);\n      };\n    });\n\n    // redirect function used inside triggers\n    this._redirectFn = (pathDef, fields, queryParams) => {\n      if (/^http(s)?:\\/\\//.test(pathDef)) {\n        throw new Error(\"Redirects to URLs outside of the app are not supported in this version of Flow Router. Use 'window.location = yourUrl' instead\");\n      }\n\n      this.withReplaceState(() => {\n        this._page.redirect(FlowRouter.path(pathDef, fields, queryParams));\n      });\n    };\n    this._initTriggersAPI();\n  }\n\n  set notFound(opts) {\n    Meteor._debug('FlowRouter.notFound is deprecated, use FlowRouter.route(\\'*\\', { /*...*/ }) instead!');\n    opts.name = opts.name || '__notFound';\n    this._notFound = this.route('*', opts);\n  }\n\n  get notFound() {\n    return this._notFound;\n  }\n\n  get _page() {\n    return page;\n  }\n\n  get _qs() {\n    return qs;\n  }\n\n  route(pathDef, options = {}, group) {\n    if (!/^\\//.test(pathDef) && pathDef !== '*') {\n      throw new Error(\"route's path must start with '/'\");\n    }\n\n    const route = new Route(this, pathDef, options, group);\n\n    // calls when the page route being activates\n    route._actionHandle = (context) => {\n      const oldRoute = this._current.route;\n      this._oldRouteChain.push(oldRoute);\n\n      // _qs.parse() gives us a object without prototypes,\n      // created with Object.create(null)\n      // Meteor's check doesn't play nice with it.\n      // So, we need to fix it by cloning it.\n      // see more: https://github.com/meteorhacks/flow-router/issues/164\n      const queryParams = this._qs.parse(context.querystring);\n      this._current = {\n        path: context.path,\n        params: context.params,\n        route,\n        context,\n        oldRoute,\n        queryParams\n      };\n\n      // we need to invalidate if all the triggers have been completed\n      // if not that means, we've been redirected to another path\n      // then we don't need to invalidate\n      const afterAllTriggersRan = () => {\n        this._invalidateTracker();\n      };\n\n      route.waitOn(this._current, (current, data) => {\n        Triggers.runTriggers(\n          this._triggersEnter.concat(route._triggersEnter),\n          this._current,\n          this._redirectFn,\n          afterAllTriggersRan,\n          data\n        );\n      });\n    };\n\n    // calls when you exit from the page js route\n    route._exitHandle = (context, next) => {\n      Triggers.runTriggers(\n        this._triggersExit.concat(route._triggersExit),\n        this._current,\n        this._redirectFn,\n        next\n      );\n    };\n\n    this._routes.push(route);\n    if (options.name) {\n      this._routesMap[options.name] = route;\n    }\n\n    this._updateCallbacks();\n    this._triggerRouteRegister(route);\n\n    return route;\n  }\n\n  group(options) {\n    return new Group(this, options);\n  }\n\n  path(_pathDef, fields = {}, queryParams) {\n    let pathDef = _pathDef;\n    if (this._routesMap[pathDef]) {\n      pathDef = this._routesMap[pathDef].pathDef;\n    }\n\n    let path = '';\n\n    // Prefix the path with the router global prefix\n    if (this._basePath) {\n      path += `/${this._basePath}/`;\n    }\n\n    path += pathDef.replace(this.pathRegExp, (_key) => {\n      const firstRegexpChar = _key.indexOf('(');\n      // get the content behind : and (\\\\d+/)\n      let key = _key.substring(1, (firstRegexpChar > 0) ? firstRegexpChar : undefined);\n      // remove +?*\n      key = key.replace(/[\\+\\*\\?]+/g, '');\n\n      // this is to allow page js to keep the custom characters as it is\n      // we need to encode 2 times otherwise \"/\" char does not work properly\n      // So, in that case, when I includes \"/\" it will think it's a part of the\n      // route. encoding 2times fixes it\n      if (fields[key]) {\n        return this._encodeParam(`${fields[key]}`);\n      }\n\n      return '';\n    });\n\n    // Replace multiple slashes with single slash\n    path = path.replace(/\\/\\/+/g, '/');\n\n    // remove trailing slash\n    // but keep the root slash if it's the only one\n    path = path.match(/^\\/{1}$/) ? path : path.replace(/\\/$/, '');\n\n    // explictly asked to add a trailing slash\n    if (this.env.trailingSlash.get() && path[path.length - 1] !== '/') {\n      path += '/';\n    }\n\n    const strQueryParams = this._qs.stringify(queryParams || {});\n    if (strQueryParams) {\n      path += `?${strQueryParams}`;\n    }\n\n    path = path.replace(/\\/\\/+/g, '/');\n    return path;\n  }\n\n  go(pathDef, fields, queryParams) {\n    const path = this.path(pathDef, fields, queryParams);\n    if (!this.env.reload.get() && path === this._current.path) {\n      return;\n    }\n\n    try {\n      if (this.env.replaceState.get()) {\n        this._page.replace(path);\n      } else {\n        this._page(path);\n      }\n    } catch (e) {\n      Meteor._debug('Malformed URI!', path, e);\n    }\n  }\n\n  reload() {\n    this.env.reload.withValue(true, () => {\n      this._page.replace(this._current.path);\n    });\n  }\n\n  redirect(path) {\n    this._page.redirect(path);\n  }\n\n  setParams(newParams) {\n    if (!this._current.route) {return false;}\n\n    const pathDef = this._current.route.pathDef;\n    const existingParams = this._current.params;\n    let params = {};\n    Object.keys(existingParams).forEach((key) => {\n      params[key] = existingParams[key];\n    });\n\n    params = _helpers.extend(params, newParams);\n    const queryParams = this._current.queryParams;\n\n    this.go(pathDef, params, queryParams);\n    return true;\n  }\n\n  setQueryParams(newParams) {\n    if (!this._current.route) {return false;}\n\n    const queryParams = _helpers.extend(_helpers.clone(this._current.queryParams), newParams);\n\n    for (const k in queryParams) {\n      if (queryParams[k] === null || queryParams[k] === undefined) {\n        delete queryParams[k];\n      }\n    }\n\n    const pathDef = this._current.route.pathDef;\n    const params = this._current.params;\n    this.go(pathDef, params, queryParams);\n    return true;\n  }\n\n  // .current is not reactive\n  // This is by design. use .getParam() instead\n  // If you really need to watch the path change, use .watchPathChange()\n  current() {\n    // We can't trust outside, that's why we clone this\n    // Anyway, we can't clone the whole object since it has non-jsonable values\n    // That's why we clone what's really needed.\n    const current = _helpers.clone(this._current);\n    current.queryParams = EJSON.clone(current.queryParams);\n    current.params = EJSON.clone(current.params);\n    return current;\n  }\n\n  track(reactiveMapper) {\n    return (props, onData, env) => {\n      let trackerCleanup = null;\n      const handler = Tracker.nonreactive(() => {\n        return Tracker.autorun(() => {\n          trackerCleanup = reactiveMapper(props, onData, env);\n        });\n      });\n\n      return () => {\n        if (typeof trackerCleanup === 'function') {\n          trackerCleanup();\n        }\n        return handler.stop();\n      };\n    };\n  }\n\n  mapper(props, onData, env) {\n    if (typeof onData === 'function') {\n      onData(null, { route: this.current(), props, env });\n    }\n  }\n\n  trackMapper() {\n    return this.track(this.mapper);\n  }\n\n  subsReady() {\n    let callback = null;\n    const args = Array.from(arguments);\n\n    if (typeof args[args.length - 1] === 'function') {\n      callback = args.pop();\n    }\n\n    const currentRoute = this.current().route;\n    const globalRoute = this._globalRoute;\n\n    // we need to depend for every route change and\n    // rerun subscriptions to check the ready state\n    this._onEveryPath.depend();\n\n    if (!currentRoute) {\n      return false;\n    }\n\n    let subscriptions;\n    if (args.length === 0) {\n      subscriptions = Object.values(globalRoute.getAllSubscriptions());\n      subscriptions = subscriptions.concat(Object.values(currentRoute.getAllSubscriptions()));\n    } else {\n      subscriptions = args.map((subName) => {\n        return globalRoute.getSubscription(subName) || currentRoute.getSubscription(subName);\n      });\n    }\n\n    const isReady = () => {\n      const ready =  subscriptions.every((sub) => {\n        return sub && sub.ready();\n      });\n\n      return ready;\n    };\n\n    if (callback) {\n      Tracker.autorun((c) => {\n        if (isReady()) {\n          callback();\n          c.stop();\n        }\n      });\n      return true;\n    }\n    return isReady();\n  }\n\n  withReplaceState(fn) {\n    return this.env.replaceState.withValue(true, fn);\n  }\n\n  withTrailingSlash(fn) {\n    return this.env.trailingSlash.withValue(true, fn);\n  }\n\n  initialize(options = {}) {\n    if (this._initialized) {\n      throw new Error('FlowRouter is already initialized');\n    }\n\n    const self = this;\n    this._updateCallbacks();\n\n    // Implementing idempotent routing\n    // by overriding page.js`s \"show\" method.\n    // Why?\n    // It is impossible to bypass exit triggers,\n    // because they execute before the handler and\n    // can not know what the next path is, inside exit trigger.\n    //\n    // we need override both show, replace to make this work\n    // since we use redirect when we are talking about withReplaceState\n    ['show', 'replace'].forEach((fnName) => {\n      const original = self._page[fnName];\n      self._page[fnName] = function (path, state, dispatch, push) {\n        if (!path || (!self.env.reload.get() && self._current.path === path)) {\n          return;\n        }\n        original.call(this, path.replace(/\\/\\/+/g, '/'), state, dispatch, push);\n      };\n    });\n\n    // this is very ugly part of pagejs and it does decoding few times\n    // in unpredicatable manner. See #168\n    // this is the default behaviour and we need keep it like that\n    // we are doing a hack. see .path()\n    this._page.base(this._basePath);\n    const pageOptions = Object.assign({\n      hashbang: !!options.hashbang,\n      decodeURLComponents: true\n    }, options.page || {});\n\n    this._page(pageOptions);\n\n    this._initialized = true;\n  }\n\n  _buildTracker() {\n    // main autorun function\n    const tracker = Tracker.autorun(() => {\n      if (!this._current || !this._current.route) {\n        return;\n      }\n\n      // see the definition of `this._processingContexts`\n      const currentContext = this._current;\n      const route = currentContext.route;\n      const path = currentContext.path;\n\n      if (this.safeToRun === 0) {\n        throw new Error(\"You can't use reactive data sources like Session inside the `.subscriptions` method!\");\n      }\n\n      // We need to run subscriptions inside a Tracker\n      // to stop subs when switching between routes\n      // But we don't need to run this tracker with\n      // other reactive changes inside the .subscription method\n      // We tackle this with the `safeToRun` variable\n      this._globalRoute.clearSubscriptions();\n      this.subscriptions.call(this._globalRoute, path);\n      route.callSubscriptions(currentContext);\n\n      // otherwise, computations inside action will trigger to re-run\n      // this computation. which we do not need.\n      Tracker.nonreactive(() => {\n        let isRouteChange = currentContext.oldRoute !== currentContext.route;\n        // first route is not a route change\n        if (!currentContext.oldRoute) {\n          isRouteChange = false;\n        }\n\n        // Clear oldRouteChain just before calling the action\n        // We still need to get a copy of the oldestRoute first\n        // It's very important to get the oldest route and registerRouteClose() it\n        // See: https://github.com/kadirahq/flow-router/issues/314\n        const oldestRoute = this._oldRouteChain[0];\n        this._oldRouteChain = [];\n\n        currentContext.route.registerRouteChange(currentContext, isRouteChange);\n        route.callAction(currentContext);\n\n        Tracker.afterFlush(() => {\n          this._onEveryPath.changed();\n          if (isRouteChange) {\n            // We need to trigger that route (definition itself) has changed.\n            // So, we need to re-run all the register callbacks to current route\n            // This is pretty important, otherwise tracker\n            // can't identify new route's items\n\n            // We also need to afterFlush, otherwise this will re-run\n            // helpers on templates which are marked for destroying\n            if (oldestRoute && oldestRoute.registerRouteClose) {\n              oldestRoute.registerRouteClose();\n            }\n          }\n        });\n      });\n\n      this.safeToRun--;\n    });\n\n    return tracker;\n  }\n\n  _invalidateTracker() {\n    this.safeToRun++;\n    this._tracker.invalidate();\n    // After the invalidation we need to flush to make changes immediately\n    // otherwise, we have face some issues context mix-matches and so on.\n    // But there are some cases we can't flush. So we need to ready for that.\n\n    // we clearly know, we can't flush inside an autorun\n    // this may leads some issues on flow-routing\n    // we may need to do some warning\n    if (!Tracker.currentComputation) {\n      // Still there are some cases where we can't flush\n      //  eg:- when there is a flush currently\n      // But we've no public API or hacks to get that state\n      // So, this is the only solution\n      try {\n        Tracker.flush();\n      } catch(ex) {\n        // only handling \"while flushing\" errors\n        if (!/Tracker\\.flush while flushing/.test(ex.message)) {\n          return;\n        }\n\n        // XXX: fix this with a proper solution by removing subscription mgt.\n        // from the router. Then we don't need to run invalidate using a tracker\n\n        // this happens when we are trying to invoke a route change\n        // with inside a route change. (eg:- Template.onCreated)\n        // Since we use page.js and tracker, we don't have much control\n        // over this process.\n        // only solution is to defer route execution.\n\n        // It's possible to have more than one path want to defer\n        // But, we only need to pick the last one.\n        // self._nextPath = self._current.path;\n        Meteor.defer(() => {\n          const path = this._nextPath;\n          if (!path) {\n            return;\n          }\n\n          delete this._nextPath;\n          this.env.reload.withValue(true, () => {\n            this.go(path);\n          });\n        });\n      }\n    }\n  }\n\n  _updateCallbacks() {\n    this._page.callbacks = [];\n    this._page.exits = [];\n    let catchAll = null;\n\n    this._routes.forEach((route) => {\n      if (route.pathDef === '*') {\n        catchAll = route;\n      } else {\n        this._page(route.pathDef, route._actionHandle);\n        this._page.exit(route.pathDef, route._exitHandle);\n      }\n    });\n\n    // Setting exit triggers on catch all routes leads to weird behavior.\n    // We recommend to avoid enter and exit triggers on catch all (`*`) routes.\n    // Use FlowRouter.triggers.exit([func]) and FlowRouter.triggers.enter([func]) instead\n    if (catchAll) {\n      this._page(catchAll.pathDef, catchAll._actionHandle);\n      // this._page.exit(catchAll.pathDef, catchAll._exitHandle);\n    }\n  }\n\n  _initTriggersAPI() {\n    const self = this;\n    this.triggers = {\n      enter(_triggers, filter) {\n        let triggers = Triggers.applyFilters(_triggers, filter);\n        if (triggers.length) {\n          self._triggersEnter = self._triggersEnter.concat(triggers);\n        }\n      },\n      exit(_triggers, filter) {\n        let triggers = Triggers.applyFilters(_triggers, filter);\n        if (triggers.length) {\n          self._triggersExit = self._triggersExit.concat(triggers);\n        }\n      }\n    };\n  }\n\n  wait() {\n    if (this._initialized) {\n      throw new Error(\"can't wait after FlowRouter has been initialized\");\n    }\n\n    this._askedToWait = true;\n  }\n\n  onRouteRegister(cb) {\n    this._onRouteCallbacks.push(cb);\n  }\n\n  _triggerRouteRegister(currentRoute) {\n    // We should only need to send a safe set of fields on the route\n    // object.\n    // This is not to hide what's inside the route object, but to show\n    // these are the public APIs\n    const routePublicApi = _helpers.pick(currentRoute, ['name', 'pathDef', 'path']);\n    routePublicApi.options = _helpers.omit(currentRoute.options, ['triggersEnter', 'triggersExit', 'action', 'subscriptions', 'name']);\n\n    this._onRouteCallbacks.forEach((cb) => {\n      cb(routePublicApi);\n    });\n  }\n\n  url() {\n    // We need to remove the leading base path, or \"/\", as it will be inserted\n    // automatically by `Meteor.absoluteUrl` as documented in:\n    // http://docs.meteor.com/#/full/meteor_absoluteurl\n    return Meteor.absoluteUrl(this.path.apply(this, arguments).replace(new RegExp('^' + (`/${this._basePath || ''}/`).replace(/\\/\\/+/g, '/')), ''));\n  }\n}\n\nexport default Router;\n"]},"sourceType":"script","hash":"5e81129f09ee7908576fa9b12978fb76a1931e29"}
