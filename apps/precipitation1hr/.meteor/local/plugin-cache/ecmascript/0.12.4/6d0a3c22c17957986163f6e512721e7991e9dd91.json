{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/minimongo/minimongo_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/minimongo/minimongo_server.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/minimongo/minimongo_server.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/minimongo/minimongo_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/minimongo_server.js"}},"code":"module.link(\"./minimongo_common.js\");\nlet hasOwn, isNumericKey, isOperatorObject, pathsToTree, projectionDetails;\nmodule.link(\"./common.js\", {\n  hasOwn(v) {\n    hasOwn = v;\n  },\n\n  isNumericKey(v) {\n    isNumericKey = v;\n  },\n\n  isOperatorObject(v) {\n    isOperatorObject = v;\n  },\n\n  pathsToTree(v) {\n    pathsToTree = v;\n  },\n\n  projectionDetails(v) {\n    projectionDetails = v;\n  }\n\n}, 0);\n\nMinimongo._pathsElidingNumericKeys = paths => paths.map(path => path.split('.').filter(part => !isNumericKey(part)).join('.')); // Returns true if the modifier applied to some document may change the result\n// of matching the document by selector\n// The modifier is always in a form of Object:\n//  - $set\n//    - 'a.b.22.z': value\n//    - 'foo.bar': 42\n//  - $unset\n//    - 'abc.d': 1\n\n\nMinimongo.Matcher.prototype.affectedByModifier = function (modifier) {\n  // safe check for $set/$unset being objects\n  modifier = Object.assign({\n    $set: {},\n    $unset: {}\n  }, modifier);\n\n  const meaningfulPaths = this._getPaths();\n\n  const modifiedPaths = [].concat(Object.keys(modifier.$set), Object.keys(modifier.$unset));\n  return modifiedPaths.some(path => {\n    const mod = path.split('.');\n    return meaningfulPaths.some(meaningfulPath => {\n      const sel = meaningfulPath.split('.');\n      let i = 0,\n          j = 0;\n\n      while (i < sel.length && j < mod.length) {\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n          // foo.4.bar selector affected by foo.4 modifier\n          // foo.3.bar selector unaffected by foo.4 modifier\n          if (sel[i] === mod[j]) {\n            i++;\n            j++;\n          } else {\n            return false;\n          }\n        } else if (isNumericKey(sel[i])) {\n          // foo.4.bar selector unaffected by foo.bar modifier\n          return false;\n        } else if (isNumericKey(mod[j])) {\n          j++;\n        } else if (sel[i] === mod[j]) {\n          i++;\n          j++;\n        } else {\n          return false;\n        }\n      } // One is a prefix of another, taking numeric fields into account\n\n\n      return true;\n    });\n  });\n}; // @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n//                           only. (assumed to come from oplog)\n// @returns - Boolean: if after applying the modifier, selector can start\n//                     accepting the modified value.\n// NOTE: assumes that document affected by modifier didn't match this Matcher\n// before, so if modifier can't convince selector in a positive change it would\n// stay 'false'.\n// Currently doesn't support $-operators and numeric indices precisely.\n\n\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function (modifier) {\n  if (!this.affectedByModifier(modifier)) {\n    return false;\n  }\n\n  if (!this.isSimple()) {\n    return true;\n  }\n\n  modifier = Object.assign({\n    $set: {},\n    $unset: {}\n  }, modifier);\n  const modifierPaths = [].concat(Object.keys(modifier.$set), Object.keys(modifier.$unset));\n\n  if (this._getPaths().some(pathHasNumericKeys) || modifierPaths.some(pathHasNumericKeys)) {\n    return true;\n  } // check if there is a $set or $unset that indicates something is an\n  // object rather than a scalar in the actual object where we saw $-operator\n  // NOTE: it is correct since we allow only scalars in $-operators\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n  // definitely set the result to false as 'a.b' appears to be an object.\n\n\n  const expectedScalarIsObject = Object.keys(this._selector).some(path => {\n    if (!isOperatorObject(this._selector[path])) {\n      return false;\n    }\n\n    return modifierPaths.some(modifierPath => modifierPath.startsWith(`${path}.`));\n  });\n\n  if (expectedScalarIsObject) {\n    return false;\n  } // See if we can apply the modifier on the ideally matching object. If it\n  // still matches the selector, then the modifier could have turned the real\n  // object in the database into something matching.\n\n\n  const matchingDocument = EJSON.clone(this.matchingDocument()); // The selector is too complex, anything can happen.\n\n  if (matchingDocument === null) {\n    return true;\n  }\n\n  try {\n    LocalCollection._modify(matchingDocument, modifier);\n  } catch (error) {\n    // Couldn't set a property on a field which is a scalar or null in the\n    // selector.\n    // Example:\n    // real document: { 'a.b': 3 }\n    // selector: { 'a': 12 }\n    // converted selector (ideal document): { 'a': 12 }\n    // modifier: { $set: { 'a.b': 4 } }\n    // We don't know what real document was like but from the error raised by\n    // $set on a scalar field we can reason that the structure of real document\n    // is completely different.\n    if (error.name === 'MinimongoError' && error.setPropertyError) {\n      return false;\n    }\n\n    throw error;\n  }\n\n  return this.documentMatches(matchingDocument).result;\n}; // Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\n\n\nMinimongo.Matcher.prototype.combineIntoProjection = function (projection) {\n  const selectorPaths = Minimongo._pathsElidingNumericKeys(this._getPaths()); // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n\n\n  if (selectorPaths.includes('')) {\n    return {};\n  }\n\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n}; // Returns an object that would match the selector if possible or null if the\n// selector is too complex for us to analyze\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\n\n\nMinimongo.Matcher.prototype.matchingDocument = function () {\n  // check if it was computed before\n  if (this._matchingDocument !== undefined) {\n    return this._matchingDocument;\n  } // If the analysis of this selector is too hard for our implementation\n  // fallback to \"YES\"\n\n\n  let fallback = false;\n  this._matchingDocument = pathsToTree(this._getPaths(), path => {\n    const valueSelector = this._selector[path];\n\n    if (isOperatorObject(valueSelector)) {\n      // if there is a strict equality, there is a good\n      // chance we can use one of those as \"matching\"\n      // dummy value\n      if (valueSelector.$eq) {\n        return valueSelector.$eq;\n      }\n\n      if (valueSelector.$in) {\n        const matcher = new Minimongo.Matcher({\n          placeholder: valueSelector\n        }); // Return anything from $in that matches the whole selector for this\n        // path. If nothing matches, returns `undefined` as nothing can make\n        // this selector into `true`.\n\n        return valueSelector.$in.find(placeholder => matcher.documentMatches({\n          placeholder\n        }).result);\n      }\n\n      if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n        let lowerBound = -Infinity;\n        let upperBound = Infinity;\n        ['$lte', '$lt'].forEach(op => {\n          if (hasOwn.call(valueSelector, op) && valueSelector[op] < upperBound) {\n            upperBound = valueSelector[op];\n          }\n        });\n        ['$gte', '$gt'].forEach(op => {\n          if (hasOwn.call(valueSelector, op) && valueSelector[op] > lowerBound) {\n            lowerBound = valueSelector[op];\n          }\n        });\n        const middle = (lowerBound + upperBound) / 2;\n        const matcher = new Minimongo.Matcher({\n          placeholder: valueSelector\n        });\n\n        if (!matcher.documentMatches({\n          placeholder: middle\n        }).result && (middle === lowerBound || middle === upperBound)) {\n          fallback = true;\n        }\n\n        return middle;\n      }\n\n      if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n        // Since this._isSimple makes sure $nin and $ne are not combined with\n        // objects or arrays, we can confidently return an empty object as it\n        // never matches any scalar.\n        return {};\n      }\n\n      fallback = true;\n    }\n\n    return this._selector[path];\n  }, x => x);\n\n  if (fallback) {\n    this._matchingDocument = null;\n  }\n\n  return this._matchingDocument;\n}; // Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n// for this exact purpose.\n\n\nMinimongo.Sorter.prototype.affectedByModifier = function (modifier) {\n  return this._selectorForAffectedByModifier.affectedByModifier(modifier);\n};\n\nMinimongo.Sorter.prototype.combineIntoProjection = function (projection) {\n  return combineImportantPathsIntoProjection(Minimongo._pathsElidingNumericKeys(this._getPaths()), projection);\n};\n\nfunction combineImportantPathsIntoProjection(paths, projection) {\n  const details = projectionDetails(projection); // merge the paths to include\n\n  const tree = pathsToTree(paths, path => true, (node, path, fullPath) => true, details.tree);\n  const mergedProjection = treeToPaths(tree);\n\n  if (details.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  } // selector is pointing at fields to include\n  // projection is pointing at fields to exclude\n  // make sure we don't exclude important paths\n\n\n  const mergedExclProjection = {};\n  Object.keys(mergedProjection).forEach(path => {\n    if (!mergedProjection[path]) {\n      mergedExclProjection[path] = false;\n    }\n  });\n  return mergedExclProjection;\n}\n\nfunction getPaths(selector) {\n  return Object.keys(new Minimongo.Matcher(selector)._paths); // XXX remove it?\n  // return Object.keys(selector).map(k => {\n  //   // we don't know how to handle $where because it can be anything\n  //   if (k === '$where') {\n  //     return ''; // matches everything\n  //   }\n  //   // we branch from $or/$and/$nor operator\n  //   if (['$or', '$and', '$nor'].includes(k)) {\n  //     return selector[k].map(getPaths);\n  //   }\n  //   // the value is a literal or some comparison operator\n  //   return k;\n  // })\n  //   .reduce((a, b) => a.concat(b), [])\n  //   .filter((a, b, c) => c.indexOf(a) === b);\n} // A helper to ensure object has only certain keys\n\n\nfunction onlyContainsKeys(obj, keys) {\n  return Object.keys(obj).every(k => keys.includes(k));\n}\n\nfunction pathHasNumericKeys(path) {\n  return path.split('.').some(isNumericKey);\n} // Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\n\n\nfunction treeToPaths(tree, prefix = '') {\n  const result = {};\n  Object.keys(tree).forEach(key => {\n    const value = tree[key];\n\n    if (value === Object(value)) {\n      Object.assign(result, treeToPaths(value, `${prefix + key}.`));\n    } else {\n      result[prefix + key] = value;\n    }\n  });\n  return result;\n}","map":{"version":3,"sources":["packages/minimongo/minimongo_server.js"],"names":["module","link","hasOwn","isNumericKey","isOperatorObject","pathsToTree","projectionDetails","v","Minimongo","_pathsElidingNumericKeys","paths","map","path","split","filter","part","join","Matcher","prototype","affectedByModifier","modifier","Object","assign","$set","$unset","meaningfulPaths","_getPaths","modifiedPaths","concat","keys","some","mod","meaningfulPath","sel","i","j","length","canBecomeTrueByModifier","isSimple","modifierPaths","pathHasNumericKeys","expectedScalarIsObject","_selector","modifierPath","startsWith","matchingDocument","EJSON","clone","LocalCollection","_modify","error","name","setPropertyError","documentMatches","result","combineIntoProjection","projection","selectorPaths","includes","combineImportantPathsIntoProjection","_matchingDocument","undefined","fallback","valueSelector","$eq","$in","matcher","placeholder","find","onlyContainsKeys","lowerBound","Infinity","upperBound","forEach","op","call","middle","x","Sorter","_selectorForAffectedByModifier","details","tree","node","fullPath","mergedProjection","treeToPaths","including","mergedExclProjection","getPaths","selector","_paths","obj","every","k","prefix","key","value"],"mappings":"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","sourcesContent":["import './minimongo_common.js';\nimport {\n  hasOwn,\n  isNumericKey,\n  isOperatorObject,\n  pathsToTree,\n  projectionDetails,\n} from './common.js';\n\nMinimongo._pathsElidingNumericKeys = paths => paths.map(path =>\n  path.split('.').filter(part => !isNumericKey(part)).join('.')\n);\n\n// Returns true if the modifier applied to some document may change the result\n// of matching the document by selector\n// The modifier is always in a form of Object:\n//  - $set\n//    - 'a.b.22.z': value\n//    - 'foo.bar': 42\n//  - $unset\n//    - 'abc.d': 1\nMinimongo.Matcher.prototype.affectedByModifier = function(modifier) {\n  // safe check for $set/$unset being objects\n  modifier = Object.assign({$set: {}, $unset: {}}, modifier);\n\n  const meaningfulPaths = this._getPaths();\n  const modifiedPaths = [].concat(\n    Object.keys(modifier.$set),\n    Object.keys(modifier.$unset)\n  );\n\n  return modifiedPaths.some(path => {\n    const mod = path.split('.');\n\n    return meaningfulPaths.some(meaningfulPath => {\n      const sel = meaningfulPath.split('.');\n\n      let i = 0, j = 0;\n\n      while (i < sel.length && j < mod.length) {\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n          // foo.4.bar selector affected by foo.4 modifier\n          // foo.3.bar selector unaffected by foo.4 modifier\n          if (sel[i] === mod[j]) {\n            i++;\n            j++;\n          } else {\n            return false;\n          }\n        } else if (isNumericKey(sel[i])) {\n          // foo.4.bar selector unaffected by foo.bar modifier\n          return false;\n        } else if (isNumericKey(mod[j])) {\n          j++;\n        } else if (sel[i] === mod[j]) {\n          i++;\n          j++;\n        } else {\n          return false;\n        }\n      }\n\n      // One is a prefix of another, taking numeric fields into account\n      return true;\n    });\n  });\n};\n\n// @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n//                           only. (assumed to come from oplog)\n// @returns - Boolean: if after applying the modifier, selector can start\n//                     accepting the modified value.\n// NOTE: assumes that document affected by modifier didn't match this Matcher\n// before, so if modifier can't convince selector in a positive change it would\n// stay 'false'.\n// Currently doesn't support $-operators and numeric indices precisely.\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function(modifier) {\n  if (!this.affectedByModifier(modifier)) {\n    return false;\n  }\n\n  if (!this.isSimple()) {\n    return true;\n  }\n\n  modifier = Object.assign({$set: {}, $unset: {}}, modifier);\n\n  const modifierPaths = [].concat(\n    Object.keys(modifier.$set),\n    Object.keys(modifier.$unset)\n  );\n\n  if (this._getPaths().some(pathHasNumericKeys) ||\n      modifierPaths.some(pathHasNumericKeys)) {\n    return true;\n  }\n\n  // check if there is a $set or $unset that indicates something is an\n  // object rather than a scalar in the actual object where we saw $-operator\n  // NOTE: it is correct since we allow only scalars in $-operators\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n  // definitely set the result to false as 'a.b' appears to be an object.\n  const expectedScalarIsObject = Object.keys(this._selector).some(path => {\n    if (!isOperatorObject(this._selector[path])) {\n      return false;\n    }\n\n    return modifierPaths.some(modifierPath =>\n      modifierPath.startsWith(`${path}.`)\n    );\n  });\n\n  if (expectedScalarIsObject) {\n    return false;\n  }\n\n  // See if we can apply the modifier on the ideally matching object. If it\n  // still matches the selector, then the modifier could have turned the real\n  // object in the database into something matching.\n  const matchingDocument = EJSON.clone(this.matchingDocument());\n\n  // The selector is too complex, anything can happen.\n  if (matchingDocument === null) {\n    return true;\n  }\n\n  try {\n    LocalCollection._modify(matchingDocument, modifier);\n  } catch (error) {\n    // Couldn't set a property on a field which is a scalar or null in the\n    // selector.\n    // Example:\n    // real document: { 'a.b': 3 }\n    // selector: { 'a': 12 }\n    // converted selector (ideal document): { 'a': 12 }\n    // modifier: { $set: { 'a.b': 4 } }\n    // We don't know what real document was like but from the error raised by\n    // $set on a scalar field we can reason that the structure of real document\n    // is completely different.\n    if (error.name === 'MinimongoError' && error.setPropertyError) {\n      return false;\n    }\n\n    throw error;\n  }\n\n  return this.documentMatches(matchingDocument).result;\n};\n\n// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nMinimongo.Matcher.prototype.combineIntoProjection = function(projection) {\n  const selectorPaths = Minimongo._pathsElidingNumericKeys(this._getPaths());\n\n  // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n  if (selectorPaths.includes('')) {\n    return {};\n  }\n\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n};\n\n// Returns an object that would match the selector if possible or null if the\n// selector is too complex for us to analyze\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\nMinimongo.Matcher.prototype.matchingDocument = function() {\n  // check if it was computed before\n  if (this._matchingDocument !== undefined) {\n    return this._matchingDocument;\n  }\n\n  // If the analysis of this selector is too hard for our implementation\n  // fallback to \"YES\"\n  let fallback = false;\n\n  this._matchingDocument = pathsToTree(\n    this._getPaths(),\n    path => {\n      const valueSelector = this._selector[path];\n\n      if (isOperatorObject(valueSelector)) {\n        // if there is a strict equality, there is a good\n        // chance we can use one of those as \"matching\"\n        // dummy value\n        if (valueSelector.$eq) {\n          return valueSelector.$eq;\n        }\n\n        if (valueSelector.$in) {\n          const matcher = new Minimongo.Matcher({placeholder: valueSelector});\n\n          // Return anything from $in that matches the whole selector for this\n          // path. If nothing matches, returns `undefined` as nothing can make\n          // this selector into `true`.\n          return valueSelector.$in.find(placeholder =>\n            matcher.documentMatches({placeholder}).result\n          );\n        }\n\n        if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n          let lowerBound = -Infinity;\n          let upperBound = Infinity;\n\n          ['$lte', '$lt'].forEach(op => {\n            if (hasOwn.call(valueSelector, op) &&\n                valueSelector[op] < upperBound) {\n              upperBound = valueSelector[op];\n            }\n          });\n\n          ['$gte', '$gt'].forEach(op => {\n            if (hasOwn.call(valueSelector, op) &&\n                valueSelector[op] > lowerBound) {\n              lowerBound = valueSelector[op];\n            }\n          });\n\n          const middle = (lowerBound + upperBound) / 2;\n          const matcher = new Minimongo.Matcher({placeholder: valueSelector});\n\n          if (!matcher.documentMatches({placeholder: middle}).result &&\n              (middle === lowerBound || middle === upperBound)) {\n            fallback = true;\n          }\n\n          return middle;\n        }\n\n        if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n          // Since this._isSimple makes sure $nin and $ne are not combined with\n          // objects or arrays, we can confidently return an empty object as it\n          // never matches any scalar.\n          return {};\n        }\n\n        fallback = true;\n      }\n\n      return this._selector[path];\n    },\n    x => x);\n\n  if (fallback) {\n    this._matchingDocument = null;\n  }\n\n  return this._matchingDocument;\n};\n\n// Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n// for this exact purpose.\nMinimongo.Sorter.prototype.affectedByModifier = function(modifier) {\n  return this._selectorForAffectedByModifier.affectedByModifier(modifier);\n};\n\nMinimongo.Sorter.prototype.combineIntoProjection = function(projection) {\n  return combineImportantPathsIntoProjection(\n    Minimongo._pathsElidingNumericKeys(this._getPaths()),\n    projection\n  );\n};\n\nfunction combineImportantPathsIntoProjection(paths, projection) {\n  const details = projectionDetails(projection);\n\n  // merge the paths to include\n  const tree = pathsToTree(\n    paths,\n    path => true,\n    (node, path, fullPath) => true,\n    details.tree\n  );\n  const mergedProjection = treeToPaths(tree);\n\n  if (details.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  }\n\n  // selector is pointing at fields to include\n  // projection is pointing at fields to exclude\n  // make sure we don't exclude important paths\n  const mergedExclProjection = {};\n\n  Object.keys(mergedProjection).forEach(path => {\n    if (!mergedProjection[path]) {\n      mergedExclProjection[path] = false;\n    }\n  });\n\n  return mergedExclProjection;\n}\n\nfunction getPaths(selector) {\n  return Object.keys(new Minimongo.Matcher(selector)._paths);\n\n  // XXX remove it?\n  // return Object.keys(selector).map(k => {\n  //   // we don't know how to handle $where because it can be anything\n  //   if (k === '$where') {\n  //     return ''; // matches everything\n  //   }\n\n  //   // we branch from $or/$and/$nor operator\n  //   if (['$or', '$and', '$nor'].includes(k)) {\n  //     return selector[k].map(getPaths);\n  //   }\n\n  //   // the value is a literal or some comparison operator\n  //   return k;\n  // })\n  //   .reduce((a, b) => a.concat(b), [])\n  //   .filter((a, b, c) => c.indexOf(a) === b);\n}\n\n// A helper to ensure object has only certain keys\nfunction onlyContainsKeys(obj, keys) {\n  return Object.keys(obj).every(k => keys.includes(k));\n}\n\nfunction pathHasNumericKeys(path) {\n  return path.split('.').some(isNumericKey);\n}\n\n// Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\nfunction treeToPaths(tree, prefix = '') {\n  const result = {};\n\n  Object.keys(tree).forEach(key => {\n    const value = tree[key];\n    if (value === Object(value)) {\n      Object.assign(result, treeToPaths(value, `${prefix + key}.`));\n    } else {\n      result[prefix + key] = value;\n    }\n  });\n\n  return result;\n}\n"]},"sourceType":"script","hash":"6d0a3c22c17957986163f6e512721e7991e9dd91"}
