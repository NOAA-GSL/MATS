{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_diff_util.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_diff_util.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_diff_util.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_diff_util.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_diff_util.js"}},"code":"let matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 0);\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 1);\nlet matsPlotUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsPlotUtils(v) {\n    matsPlotUtils = v;\n  }\n\n}, 2);\n\n// returns the data for whichever curve has the larger interval in its independent variable\nconst getLargeIntervalCurveData = function (dataset, diffFrom, independentVarName) {\n  var dataMaxInterval = Number.MIN_VALUE;\n  var largeIntervalCurveData = dataset[diffFrom[0]]; // set up the indexes and determine the minimum independentVarName value for the dataset\n\n  for (var ci = 0; ci < dataset.length; ci++) {\n    if (dataset[ci][independentVarName] === undefined || dataset[ci][independentVarName].length === 0) {\n      // one of the curves has no data. No match possible. Just use interval from first curve\n      break;\n    }\n\n    if (dataset[ci][independentVarName].length > 1) {\n      var diff;\n\n      for (var di = 0; di < dataset[ci][independentVarName].length - 1; di++) {\n        // don't go all the way to the end - one shy\n        diff = dataset[ci][independentVarName][di + 1] - dataset[ci][independentVarName][di];\n\n        if (diff > dataMaxInterval) {\n          dataMaxInterval = diff;\n          largeIntervalCurveData = dataset[ci];\n        }\n      }\n    }\n  }\n\n  return largeIntervalCurveData;\n}; // generates diff curves for all plot types that have diff curves.\n\n\nconst getDataForDiffCurve = function (dataset, diffFrom, plotType, hasLevels) {\n  /*\n   DATASET ELEMENTS:\n      series: [data,data,data ...... ]   each data is itself an object\n      d = {\n          x: [],\n          y: [],\n          error_x: [],   // curveTime\n          error_y: [],   // values\n          subVals: [],   //subVals\n          subSecs: [],   //subSecs\n          subLevs: [],   //subLevs\n          stats: [],     //pointStats\n          text: [],\n          glob_stats: {},     //curveStats\n          xmin: Number.MAX_VALUE,\n          xmax: Number.MIN_VALUE,\n          ymin: Number.MAX_VALUE,\n          ymax: Number.MIN_VALUE,\n          sum: 0\n      };\n    NOTE -- for profiles, x is the statVarName and y is the independentVarName, because profiles plot the statVarName\n      on the x axis and the independentVarName on the y axis.\n   For histograms:\n  DATASET ELEMENTS:\n      series: [data,data,data ...... ]   each data is itself an array\n      d = {\n          x: [], //placeholder\n          y: [], //placeholder\n          error_x: [], // unused\n          error_y: [], // unused\n          subVals: [],\n          subSecs: [],\n          subLevs: [],\n          glob_stats: [], // placeholder\n          bin_stats: [], // placeholder\n          text: [] //placeholder\n      };\n    */\n  // determine whether data[0] or data[1] is the independent variable, and which is the stat value\n  var independentVarName;\n  var statVarName;\n\n  if (plotType !== matsTypes.PlotTypes.profile) {\n    independentVarName = 'x';\n    statVarName = 'y';\n  } else {\n    independentVarName = 'y';\n    statVarName = 'x';\n  } // initialize variables\n\n\n  var minuendData = dataset[diffFrom[0]];\n  var subtrahendData = dataset[diffFrom[1]];\n  var subtrahendIndex = 0;\n  var minuendIndex = 0;\n  var d;\n\n  if (plotType !== matsTypes.PlotTypes.histogram) {\n    d = {\n      x: [],\n      y: [],\n      error_x: [],\n      // curveTime\n      error_y: [],\n      // values\n      subVals: [],\n      //subVals\n      subSecs: [],\n      //subSecs\n      subLevs: [],\n      //subLevs\n      glob_stats: [],\n      stats: [],\n      //curveStats\n      text: [],\n      xmin: Number.MAX_VALUE,\n      xmax: Number.MIN_VALUE,\n      ymin: Number.MAX_VALUE,\n      ymax: Number.MIN_VALUE,\n      sum: 0\n    };\n  } else {\n    d = {\n      x: [],\n      y: [],\n      error_x: [],\n      error_y: [],\n      subVals: [],\n      subSecs: [],\n      subLevs: [],\n      glob_stats: {\n        'glob_mean': null,\n        'glob_sd': null,\n        'glob_n': null,\n        'glob_max': null,\n        'glob_min': null\n      },\n      bin_stats: [],\n      text: [],\n      xmin: Number.MAX_VALUE,\n      xmax: Number.MIN_VALUE,\n      ymin: Number.MAX_VALUE,\n      ymax: Number.MIN_VALUE\n    };\n  } // make sure neither curve is empty\n\n\n  if (minuendData.x.length === 0 || subtrahendData.x.length === 0) {\n    return {\n      'dataset': d\n    };\n  } // this is a difference curve - we are differencing diffFrom[0] - diffFrom[1] based on the\n  // independentVarName values of whichever has the largest interval\n  // find the largest interval between diffFrom[0] curve and diffFrom[1] curve\n\n\n  var largeIntervalCurveData = getLargeIntervalCurveData(dataset, diffFrom, independentVarName); // calculate the differences\n\n  for (var largeIntervalCurveIndex = 0; largeIntervalCurveIndex < largeIntervalCurveData[independentVarName].length; largeIntervalCurveIndex++) {\n    // make sure that we are actually on the same independentVarName value for each curve\n    var subtrahendIndependentVar = subtrahendData[independentVarName][subtrahendIndex];\n    var minuendIndependentVar = minuendData[independentVarName][minuendIndex];\n    var largeIntervalIndependentVar = largeIntervalCurveData[independentVarName][largeIntervalCurveIndex]; // increment the minuendIndex until it reaches this iteration's largeIntervalIndependentVar\n\n    var minuendChanged = false;\n\n    while (largeIntervalIndependentVar > minuendIndependentVar && minuendIndex < minuendData[independentVarName].length - 1) {\n      minuendIndependentVar = minuendData[independentVarName][++minuendIndex];\n      minuendChanged = true;\n    } // if the end of the curve was reached without finding the largeIntervalIndependentVar, increase the minuendIndex to trigger the end conditions.\n\n\n    if (!minuendChanged && minuendIndex >= minuendData[independentVarName].length - 1) {\n      ++minuendIndex;\n    } // increment the subtrahendIndex until it reaches this iteration's largeIntervalIndependentVar\n\n\n    var subtrahendChanged = false;\n\n    while (largeIntervalIndependentVar > subtrahendIndependentVar && subtrahendIndex < subtrahendData[independentVarName].length - 1) {\n      subtrahendIndependentVar = subtrahendData[independentVarName][++subtrahendIndex];\n      subtrahendChanged = true;\n    } // if the end of the curve was reached without finding the largeIntervalIndependentVar, increase the subtrahendIndex to trigger the end conditions.\n\n\n    if (!subtrahendChanged && subtrahendIndex >= subtrahendData[independentVarName].length - 1) {\n      ++subtrahendIndex;\n    }\n\n    var diffValue = null;\n    var tempSubValsArray;\n    var tempSubSecsArray;\n    var tempSubLevsArray;\n\n    if (minuendData[independentVarName][minuendIndex] !== undefined && subtrahendData[independentVarName][subtrahendIndex] !== undefined) {\n      // make sure both curves actually have data at this index\n      if (minuendData[statVarName][minuendIndex] !== null && subtrahendData[statVarName][subtrahendIndex] !== null && minuendData[independentVarName][minuendIndex] === subtrahendData[independentVarName][subtrahendIndex]) {\n        // make sure data is not null at this point and the independentVars actually match\n        diffValue = minuendData[statVarName][minuendIndex] - subtrahendData[statVarName][subtrahendIndex];\n        d[independentVarName].push(largeIntervalIndependentVar);\n        d[statVarName].push(diffValue);\n        d.error_x.push(null);\n        d.error_y.push(null);\n        tempSubValsArray = [];\n        tempSubSecsArray = [];\n\n        if (hasLevels) {\n          tempSubLevsArray = [];\n        }\n\n        if (plotType !== matsTypes.PlotTypes.histogram) {\n          var minuendDataSubValues = minuendData.subVals[minuendIndex];\n          var minuendDataSubSeconds = minuendData.subSecs[minuendIndex];\n\n          if (hasLevels) {\n            var minuendDataSubLevels = minuendData.subLevs[minuendIndex];\n          }\n\n          var subtrahendDataSubValues = subtrahendData.subVals[subtrahendIndex];\n          var subtrahendDataSubSeconds = subtrahendData.subSecs[subtrahendIndex];\n\n          if (hasLevels) {\n            var subtrahendDataSubLevels = subtrahendData.subLevs[subtrahendIndex];\n          } // find matching sub values and diff those\n\n\n          for (var mvalIdx = 0; mvalIdx < minuendDataSubValues.length; mvalIdx++) {\n            for (var svalIdx = 0; svalIdx < subtrahendDataSubValues.length; svalIdx++) {\n              if (hasLevels && minuendDataSubSeconds[mvalIdx] === subtrahendDataSubSeconds[svalIdx] && minuendDataSubLevels[mvalIdx] === subtrahendDataSubLevels[svalIdx]) {\n                tempSubValsArray.push(minuendDataSubValues[mvalIdx] - subtrahendDataSubValues[svalIdx]);\n                tempSubSecsArray.push(minuendDataSubSeconds[mvalIdx]);\n                tempSubLevsArray.push(minuendDataSubLevels[mvalIdx]);\n              } else if (!hasLevels && minuendDataSubSeconds[mvalIdx] === subtrahendDataSubSeconds[svalIdx]) {\n                tempSubValsArray.push(minuendDataSubValues[mvalIdx] - subtrahendDataSubValues[svalIdx]);\n                tempSubSecsArray.push(minuendDataSubSeconds[mvalIdx]);\n              }\n            }\n          }\n\n          d.subVals.push(tempSubValsArray);\n          d.subSecs.push(tempSubSecsArray);\n\n          if (hasLevels) {\n            d.subLevs.push(tempSubLevsArray);\n          }\n\n          d.sum = d.sum + d[independentVarName][largeIntervalCurveIndex];\n        } else {\n          d.bin_stats.push({\n            'bin_mean': null,\n            'bin_sd': null,\n            'bin_n': diffValue,\n            'bin_rf': minuendData.bin_stats[minuendIndex].bin_rf - subtrahendData.bin_stats[subtrahendIndex].bin_rf,\n            'binLowBound': minuendData.bin_stats[minuendIndex].binLowBound,\n            'binUpBound': minuendData.bin_stats[minuendIndex].binUpBound,\n            'binLabel': minuendData.bin_stats[minuendIndex].binLabel\n          });\n        }\n      } else {\n        // no match for this independentVarName\n        d[independentVarName].push(largeIntervalIndependentVar);\n        d[statVarName].push(null);\n        d.error_x.push(null);\n        d.error_y.push(null);\n        d.subVals.push([]);\n        d.subSecs.push([]);\n\n        if (hasLevels) {\n          d.subLevs.push([]);\n        }\n\n        if (plotType === matsTypes.PlotTypes.histogram) {\n          d.bin_stats.push({\n            'bin_mean': null,\n            'bin_sd': null,\n            'bin_n': null,\n            'bin_rf': null,\n            'binLowBound': minuendData.bin_stats[minuendIndex].binLowBound,\n            'binUpBound': minuendData.bin_stats[minuendIndex].binUpBound,\n            'binLabel': minuendData.bin_stats[minuendIndex].binLabel\n          });\n        }\n      }\n    } else if (!subtrahendChanged && subtrahendIndex >= subtrahendData[independentVarName].length - 1 || !minuendChanged && minuendIndex >= minuendData[independentVarName].length - 1) {\n      // we've reached the end of at least one curve, so end the diffing.\n      break;\n    }\n  }\n\n  const filteredx = d.x.filter(x => x);\n  const filteredy = d.y.filter(y => y);\n  d.xmin = Math.min(...filteredx);\n  d.xmax = Math.max(...filteredx);\n  d.ymin = Math.min(...filteredy);\n  d.ymax = Math.max(...filteredy);\n  return {\n    'dataset': d\n  };\n}; // generates diff of two contours.\n\n\nconst getDataForDiffContour = function (dataset) {\n  /*\n   DATASET ELEMENTS:\n      d[i] = {\n          label: string,\n          curveId: string,\n          name: string,\n          annotateColor: string,\n          annotation: string,             -----\n          x: [],                          *****\n          y: [],                          *****\n          z: [[]],                        *****\n          n: [[]],                        *****\n          text: [],\n          stats: [],\n          glob_stats: object,             -----\n          type: string,\n          autocontour: boolean,\n          ncontours: number,\n          colorbar: object,\n          colorscale: string,\n          reversescale: boolean,\n          contours: object,\n          marker: object,\n          xAxisKey: [],\n          yAxisKey: [],\n          visible: boolean,\n          xTextOutput: [],                *****\n          yTextOutput: [],                *****\n          zTextOutput: [],                *****\n          nTextOutput: [],                *****\n          maxDateTextOutput: [],          *****\n          minDateTextOutput: [],          *****\n          xmax: number,                   -----\n          xmin: number,                   -----\n          ymax: number,                   -----\n          ymin: number,                   -----\n          zmax: number,                   -----\n          zmin: number,                   -----\n          sum: number                     *****\n      };\n       ***** indicates calculation in loops\n      ----- indicates calculation after loops\n   */\n  // initialize output object\n  var diffDataset = {};\n  diffDataset['label'] = dataset[1].label + '-' + dataset[0].label;\n  diffDataset['curveId'] = dataset[1].curveId + '-' + dataset[0].curveId;\n  diffDataset['name'] = dataset[1].name + '-' + dataset[0].name;\n  diffDataset['annotateColor'] = \"rgb(255,165,0)\";\n  diffDataset['annotation'] = \"\";\n  diffDataset['text'] = [];\n  diffDataset['type'] = dataset[0].type;\n  diffDataset['marker'] = dataset[0].marker;\n  diffDataset['xAxisKey'] = dataset[0].xAxisKey;\n  diffDataset['yAxisKey'] = dataset[0].yAxisKey;\n  diffDataset['visible'] = dataset[0].visible;\n  diffDataset['x'] = [];\n  diffDataset['y'] = [];\n  diffDataset['z'] = [];\n  diffDataset['n'] = [];\n  diffDataset['xTextOutput'] = [];\n  diffDataset['yTextOutput'] = [];\n  diffDataset['zTextOutput'] = [];\n  diffDataset['nTextOutput'] = [];\n  diffDataset['maxDateTextOutput'] = [];\n  diffDataset['minDateTextOutput'] = [];\n  diffDataset['stats'] = [];\n  diffDataset['glob_stats'] = {};\n  diffDataset['xmax'] = -1 * Number.MAX_VALUE;\n  diffDataset['xmin'] = Number.MAX_VALUE;\n  diffDataset['ymax'] = -1 * Number.MAX_VALUE;\n  diffDataset['ymin'] = Number.MAX_VALUE;\n  diffDataset['zmax'] = -1 * Number.MAX_VALUE;\n  diffDataset['zmin'] = Number.MAX_VALUE;\n  diffDataset['sum'] = 0; // initialize local variables\n\n  var minuendData = dataset[1];\n  var subtrahendData = dataset[0]; // get common x and y\n\n  diffDataset.x = _.intersection(minuendData.x, subtrahendData.x).sort(function (a, b) {\n    return a - b;\n  });\n  diffDataset.y = _.intersection(minuendData.y, subtrahendData.y).sort(function (a, b) {\n    return a - b;\n  }); // make we actually have matches\n\n  if (diffDataset.x.length === 0 || diffDataset.y.length === 0) {\n    diffDataset.x = [];\n    diffDataset.y = [];\n    return [diffDataset];\n  } // make sure neither dataset is empty\n\n\n  if (minuendData.x.length === 0 || subtrahendData.x.length === 0 || minuendData.y.length === 0 || subtrahendData.y.length === 0) {\n    return [diffDataset];\n  }\n\n  var minuendYIndex = 0;\n  var subtrahendYIndex = 0;\n  var nPoints = 0; // loop through common Ys\n\n  for (var diffDataYIndex = 0; diffDataYIndex < diffDataset.y.length; diffDataYIndex++) {\n    //make sure that we are actually on the same y value for each curve\n    var diffDataY = diffDataset.y[diffDataYIndex];\n    var minuendY = minuendData.y[minuendYIndex];\n    var subtrahendY = subtrahendData.y[subtrahendYIndex]; //increment the minuendYIndex until it reaches this iteration's diffDataY\n\n    while (diffDataY > minuendY && minuendYIndex < minuendData.y.length - 1) {\n      minuendY = minuendData.y[++minuendYIndex];\n    } //increment the subtrahendYIndex until it reaches this iteration's diffDataY\n\n\n    while (diffDataY > subtrahendY && subtrahendYIndex < subtrahendData.y.length - 1) {\n      subtrahendY = subtrahendData.y[++subtrahendYIndex];\n    } // initialize n and z arrays for this Y\n\n\n    diffDataset.z[diffDataYIndex] = [];\n    diffDataset.n[diffDataYIndex] = [];\n    var minuendXIndex = 0;\n    var subtrahendXIndex = 0;\n\n    for (var diffDataXIndex = 0; diffDataXIndex < diffDataset.x.length; diffDataXIndex++) {\n      //make sure that we are actually on the same x value for each curve\n      var diffDataX = diffDataset.x[diffDataXIndex];\n      var minuendX = minuendData.x[minuendXIndex];\n      var subtrahendX = subtrahendData.x[subtrahendXIndex]; //increment the minuendXIndex until it reaches this iteration's diffDataX\n\n      while (diffDataX > minuendX && minuendXIndex < minuendData.x.length - 1) {\n        minuendX = minuendData.x[++minuendXIndex];\n      } //increment the subtrahendXIndex until it reaches this iteration's diffDataX\n\n\n      while (diffDataX > subtrahendX && subtrahendXIndex < subtrahendData.x.length - 1) {\n        subtrahendX = subtrahendData.x[++subtrahendXIndex];\n      }\n\n      var diffValue = null;\n      var diffNumber = 0;\n      var diffMinDate = null;\n      var diffMaxDate = null;\n\n      if (minuendData.z[minuendYIndex][minuendXIndex] !== undefined && subtrahendData.z[subtrahendYIndex][subtrahendXIndex] !== undefined && minuendData.z[minuendYIndex][minuendXIndex] !== null && subtrahendData.z[subtrahendYIndex][subtrahendXIndex] !== null && minuendX === subtrahendX && minuendY === subtrahendY) {\n        // make sure both contours actually have data at these indices, data is not null at this point, and the x and y actually match\n        // calculate the difference values\n        diffValue = minuendData.z[minuendYIndex][minuendXIndex] - subtrahendData.z[subtrahendYIndex][subtrahendXIndex];\n        diffNumber = minuendData.n[minuendYIndex][minuendXIndex] <= subtrahendData.n[subtrahendYIndex][subtrahendXIndex] ? minuendData.n[minuendYIndex][minuendXIndex] : subtrahendData.n[subtrahendYIndex][subtrahendXIndex];\n        diffMinDate = minuendData.minDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] <= subtrahendData.minDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex] ? minuendData.minDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] : subtrahendData.minDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex];\n        diffMaxDate = minuendData.maxDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] >= subtrahendData.maxDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex] ? minuendData.maxDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] : subtrahendData.maxDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex];\n        diffDataset['sum'] += diffValue;\n        nPoints = nPoints + 1;\n      }\n\n      diffDataset.z[diffDataYIndex].push(diffValue);\n      diffDataset.n[diffDataYIndex].push(diffNumber);\n      diffDataset.xTextOutput.push(diffDataX);\n      diffDataset.yTextOutput.push(diffDataY);\n      diffDataset.zTextOutput.push(diffValue);\n      diffDataset.nTextOutput.push(diffNumber);\n      diffDataset.minDateTextOutput.push(diffMinDate);\n      diffDataset.maxDateTextOutput.push(diffMaxDate);\n    }\n  } // calculate statistics\n\n\n  const filteredx = diffDataset.x.filter(x => x);\n  const filteredy = diffDataset.y.filter(y => y);\n  const filteredz = diffDataset.zTextOutput.filter(z => z);\n  diffDataset.xmin = Math.min(...filteredx);\n  diffDataset.xmax = Math.max(...filteredx);\n  diffDataset.ymin = Math.min(...filteredy);\n  diffDataset.ymax = Math.max(...filteredy);\n  diffDataset.zmin = Math.min(...filteredz);\n  diffDataset.zmax = Math.max(...filteredz);\n\n  if (diffDataset.xmin == \"-Infinity\" || diffDataset.x.indexOf(0) !== -1 && 0 < diffDataset.xmin) {\n    diffDataset.xmin = 0;\n  }\n\n  if (diffDataset.ymin == \"-Infinity\" || diffDataset.y.indexOf(0) !== -1 && 0 < diffDataset.ymin) {\n    diffDataset.ymin = 0;\n  }\n\n  if (diffDataset.zmin == \"-Infinity\" || diffDataset.zTextOutput.indexOf(0) !== -1 && 0 < diffDataset.zmin) {\n    diffDataset.zmin = 0;\n  }\n\n  if (diffDataset.xmax == \"-Infinity\") {\n    diffDataset.xmax = 0;\n  }\n\n  if (diffDataset.ymax == \"-Infinity\") {\n    diffDataset.ymax = 0;\n  }\n\n  if (diffDataset.zmax == \"-Infinity\") {\n    diffDataset.zmax = 0;\n  }\n\n  const filteredMinDate = diffDataset.minDateTextOutput.filter(t => t);\n  const filteredMaxDate = diffDataset.maxDateTextOutput.filter(t => t);\n  diffDataset.glob_stats['mean'] = diffDataset.sum / nPoints;\n  diffDataset.glob_stats['minDate'] = Math.min(...filteredMinDate);\n  diffDataset.glob_stats['maxDate'] = Math.max(...filteredMaxDate);\n  diffDataset.glob_stats['n'] = nPoints;\n  diffDataset['annotation'] = diffDataset.glob_stats.mean === undefined ? diffDataset.label + \"- mean = NaN\" : diffDataset.label + \"- mean = \" + diffDataset.glob_stats.mean.toPrecision(4); // make contours symmetrical around 0\n\n  diffDataset['autocontour'] = false;\n  diffDataset['ncontours'] = 15;\n  diffDataset['colorbar'] = dataset[0].colorbar;\n  diffDataset['colorbar']['title'] = dataset[0].colorbar.title === dataset[1].colorbar.title ? dataset[0].colorbar.title : dataset[1].colorbar.title + \" - \" + dataset[0].colorbar.title;\n  diffDataset['colorscale'] = [[0, \"rgb(5,10,172)\"], [0.35, \"rgb(106,137,247)\"], [0.45, \"rgb(255,255,255)\"], [0.55, \"rgb(255,255,255)\"], [0.6, \"rgb(220,170,132)\"], [0.7, \"rgb(230,145,90)\"], [1, \"rgb(178,10,28)\"]];\n  diffDataset['reversescale'] = dataset[0].reversescale;\n  diffDataset['contours'] = dataset[0].contours;\n  const maxZ = Math.abs(diffDataset.zmax) > Math.abs(diffDataset.zmin) ? Math.abs(diffDataset.zmax) : Math.abs(diffDataset.zmin);\n  diffDataset['contours']['start'] = -1 * maxZ + 2 * maxZ / 16;\n  diffDataset['contours']['end'] = maxZ - 2 * maxZ / 16;\n  diffDataset['contours']['size'] = 2 * maxZ / 16;\n  return [diffDataset];\n};\n\nmodule.exportDefault(matsDataDiffUtils = {\n  getDataForDiffCurve: getDataForDiffCurve,\n  getDataForDiffContour: getDataForDiffContour\n});","map":{"version":3,"sources":["packages/randyp:mats-common/imports/startup/server/data_diff_util.js"],"names":["matsTypes","module","link","v","matsCollections","matsPlotUtils","getLargeIntervalCurveData","dataset","diffFrom","independentVarName","dataMaxInterval","Number","MIN_VALUE","largeIntervalCurveData","ci","length","undefined","diff","di","getDataForDiffCurve","plotType","hasLevels","statVarName","PlotTypes","profile","minuendData","subtrahendData","subtrahendIndex","minuendIndex","d","histogram","x","y","error_x","error_y","subVals","subSecs","subLevs","glob_stats","stats","text","xmin","MAX_VALUE","xmax","ymin","ymax","sum","bin_stats","largeIntervalCurveIndex","subtrahendIndependentVar","minuendIndependentVar","largeIntervalIndependentVar","minuendChanged","subtrahendChanged","diffValue","tempSubValsArray","tempSubSecsArray","tempSubLevsArray","push","minuendDataSubValues","minuendDataSubSeconds","minuendDataSubLevels","subtrahendDataSubValues","subtrahendDataSubSeconds","subtrahendDataSubLevels","mvalIdx","svalIdx","bin_rf","binLowBound","binUpBound","binLabel","filteredx","filter","filteredy","Math","min","max","getDataForDiffContour","diffDataset","label","curveId","name","type","marker","xAxisKey","yAxisKey","visible","_","intersection","sort","a","b","minuendYIndex","subtrahendYIndex","nPoints","diffDataYIndex","diffDataY","minuendY","subtrahendY","z","n","minuendXIndex","subtrahendXIndex","diffDataXIndex","diffDataX","minuendX","subtrahendX","diffNumber","diffMinDate","diffMaxDate","minDateTextOutput","maxDateTextOutput","xTextOutput","yTextOutput","zTextOutput","nTextOutput","filteredz","zmin","zmax","indexOf","filteredMinDate","t","filteredMaxDate","mean","toPrecision","colorbar","title","reversescale","contours","maxZ","abs","exportDefault","matsDataDiffUtils"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsPlotUtils} from 'meteor/randyp:mats-common';\n\n// returns the data for whichever curve has the larger interval in its independent variable\nconst getLargeIntervalCurveData = function (dataset, diffFrom, independentVarName) {\n    var dataMaxInterval = Number.MIN_VALUE;\n    var largeIntervalCurveData = dataset[diffFrom[0]];\n    // set up the indexes and determine the minimum independentVarName value for the dataset\n    for (var ci = 0; ci < dataset.length; ci++) {\n        if (dataset[ci][independentVarName] === undefined || dataset[ci][independentVarName].length === 0) {\n            // one of the curves has no data. No match possible. Just use interval from first curve\n            break;\n        }\n        if (dataset[ci][independentVarName].length > 1) {\n            var diff;\n            for (var di = 0; di < dataset[ci][independentVarName].length - 1; di++) {  // don't go all the way to the end - one shy\n                diff = dataset[ci][independentVarName][di + 1] - dataset[ci][independentVarName][di];\n                if (diff > dataMaxInterval) {\n                    dataMaxInterval = diff;\n                    largeIntervalCurveData = dataset[ci];\n                }\n            }\n        }\n    }\n    return largeIntervalCurveData;\n};\n\n// generates diff curves for all plot types that have diff curves.\nconst getDataForDiffCurve = function (dataset, diffFrom, plotType, hasLevels) {\n    /*\n     DATASET ELEMENTS:\n        series: [data,data,data ...... ]   each data is itself an object\n        d = {\n            x: [],\n            y: [],\n            error_x: [],   // curveTime\n            error_y: [],   // values\n            subVals: [],   //subVals\n            subSecs: [],   //subSecs\n            subLevs: [],   //subLevs\n            stats: [],     //pointStats\n            text: [],\n            glob_stats: {},     //curveStats\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            sum: 0\n        };\n\n     NOTE -- for profiles, x is the statVarName and y is the independentVarName, because profiles plot the statVarName\n        on the x axis and the independentVarName on the y axis.\n\n    For histograms:\n    DATASET ELEMENTS:\n        series: [data,data,data ...... ]   each data is itself an array\n        d = {\n            x: [], //placeholder\n            y: [], //placeholder\n            error_x: [], // unused\n            error_y: [], // unused\n            subVals: [],\n            subSecs: [],\n            subLevs: [],\n            glob_stats: [], // placeholder\n            bin_stats: [], // placeholder\n            text: [] //placeholder\n        };\n\n     */\n\n    // determine whether data[0] or data[1] is the independent variable, and which is the stat value\n    var independentVarName;\n    var statVarName;\n    if (plotType !== matsTypes.PlotTypes.profile) {\n        independentVarName = 'x';\n        statVarName = 'y';\n    } else {\n        independentVarName = 'y';\n        statVarName = 'x';\n    }\n\n    // initialize variables\n    var minuendData = dataset[diffFrom[0]];\n    var subtrahendData = dataset[diffFrom[1]];\n    var subtrahendIndex = 0;\n    var minuendIndex = 0;\n\n    var d;\n    if (plotType !== matsTypes.PlotTypes.histogram) {\n        d = {\n            x: [],\n            y: [],\n            error_x: [],   // curveTime\n            error_y: [],   // values\n            subVals: [],   //subVals\n            subSecs: [],   //subSecs\n            subLevs: [],   //subLevs\n            glob_stats: [],\n            stats: [],     //curveStats\n            text: [],\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            sum: 0\n        };\n    } else {\n        d = {\n            x: [],\n            y: [],\n            error_x: [],\n            error_y: [],\n            subVals: [],\n            subSecs: [],\n            subLevs: [],\n            glob_stats: {\n                'glob_mean': null,\n                'glob_sd': null,\n                'glob_n': null,\n                'glob_max': null,\n                'glob_min': null\n            },\n            bin_stats: [],\n            text: [],\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n        };\n    }\n\n    // make sure neither curve is empty\n    if (minuendData.x.length === 0 || subtrahendData.x.length === 0) {\n        return {'dataset': d};\n    }\n\n    // this is a difference curve - we are differencing diffFrom[0] - diffFrom[1] based on the\n    // independentVarName values of whichever has the largest interval\n    // find the largest interval between diffFrom[0] curve and diffFrom[1] curve\n    var largeIntervalCurveData = getLargeIntervalCurveData(dataset, diffFrom, independentVarName);\n\n    // calculate the differences\n    for (var largeIntervalCurveIndex = 0; largeIntervalCurveIndex < largeIntervalCurveData[independentVarName].length; largeIntervalCurveIndex++) {\n\n        // make sure that we are actually on the same independentVarName value for each curve\n        var subtrahendIndependentVar = subtrahendData[independentVarName][subtrahendIndex];\n        var minuendIndependentVar = minuendData[independentVarName][minuendIndex];\n        var largeIntervalIndependentVar = largeIntervalCurveData[independentVarName][largeIntervalCurveIndex];\n\n        // increment the minuendIndex until it reaches this iteration's largeIntervalIndependentVar\n        var minuendChanged = false;\n        while (largeIntervalIndependentVar > minuendIndependentVar && minuendIndex < minuendData[independentVarName].length - 1) {\n            minuendIndependentVar = minuendData[independentVarName][++minuendIndex];\n            minuendChanged = true;\n        }\n        // if the end of the curve was reached without finding the largeIntervalIndependentVar, increase the minuendIndex to trigger the end conditions.\n        if (!minuendChanged && minuendIndex >= minuendData[independentVarName].length - 1) {\n            ++minuendIndex;\n        }\n\n        // increment the subtrahendIndex until it reaches this iteration's largeIntervalIndependentVar\n        var subtrahendChanged = false;\n        while (largeIntervalIndependentVar > subtrahendIndependentVar && subtrahendIndex < subtrahendData[independentVarName].length - 1) {\n            subtrahendIndependentVar = subtrahendData[independentVarName][++subtrahendIndex];\n            subtrahendChanged = true;\n        }\n        // if the end of the curve was reached without finding the largeIntervalIndependentVar, increase the subtrahendIndex to trigger the end conditions.\n        if (!subtrahendChanged && subtrahendIndex >= subtrahendData[independentVarName].length - 1) {\n            ++subtrahendIndex;\n        }\n\n        var diffValue = null;\n        var tempSubValsArray;\n        var tempSubSecsArray;\n        var tempSubLevsArray;\n        if (minuendData[independentVarName][minuendIndex] !== undefined && subtrahendData[independentVarName][subtrahendIndex] !== undefined) {  // make sure both curves actually have data at this index\n            if ((minuendData[statVarName][minuendIndex] !== null && subtrahendData[statVarName][subtrahendIndex] !== null) && minuendData[independentVarName][minuendIndex] === subtrahendData[independentVarName][subtrahendIndex]) { // make sure data is not null at this point and the independentVars actually match\n\n                diffValue = minuendData[statVarName][minuendIndex] - subtrahendData[statVarName][subtrahendIndex];\n                d[independentVarName].push(largeIntervalIndependentVar);\n                d[statVarName].push(diffValue);\n                d.error_x.push(null);\n                d.error_y.push(null);\n                tempSubValsArray = [];\n                tempSubSecsArray = [];\n                if (hasLevels) {\n                    tempSubLevsArray = [];\n                }\n\n                if (plotType !== matsTypes.PlotTypes.histogram) {\n                    var minuendDataSubValues = minuendData.subVals[minuendIndex];\n                    var minuendDataSubSeconds = minuendData.subSecs[minuendIndex];\n                    if (hasLevels) {\n                        var minuendDataSubLevels = minuendData.subLevs[minuendIndex];\n                    }\n                    var subtrahendDataSubValues = subtrahendData.subVals[subtrahendIndex];\n                    var subtrahendDataSubSeconds = subtrahendData.subSecs[subtrahendIndex];\n                    if (hasLevels) {\n                        var subtrahendDataSubLevels = subtrahendData.subLevs[subtrahendIndex];\n                    }\n\n                    // find matching sub values and diff those\n                    for (var mvalIdx = 0; mvalIdx < minuendDataSubValues.length; mvalIdx++) {\n                        for (var svalIdx = 0; svalIdx < subtrahendDataSubValues.length; svalIdx++) {\n                            if (hasLevels && minuendDataSubSeconds[mvalIdx] === subtrahendDataSubSeconds[svalIdx] && minuendDataSubLevels[mvalIdx] === subtrahendDataSubLevels[svalIdx]) {\n                                tempSubValsArray.push(minuendDataSubValues[mvalIdx] - subtrahendDataSubValues[svalIdx]);\n                                tempSubSecsArray.push(minuendDataSubSeconds[mvalIdx]);\n                                tempSubLevsArray.push(minuendDataSubLevels[mvalIdx]);\n                            } else if (!hasLevels && minuendDataSubSeconds[mvalIdx] === subtrahendDataSubSeconds[svalIdx]) {\n                                tempSubValsArray.push(minuendDataSubValues[mvalIdx] - subtrahendDataSubValues[svalIdx]);\n                                tempSubSecsArray.push(minuendDataSubSeconds[mvalIdx]);\n                            }\n                        }\n                    }\n\n                    d.subVals.push(tempSubValsArray);\n                    d.subSecs.push(tempSubSecsArray);\n                    if (hasLevels) {\n                        d.subLevs.push(tempSubLevsArray);\n                    }\n\n                    d.sum = d.sum + d[independentVarName][largeIntervalCurveIndex];\n\n                } else {\n                    d.bin_stats.push({\n                        'bin_mean': null,\n                        'bin_sd': null,\n                        'bin_n': diffValue,\n                        'bin_rf': minuendData.bin_stats[minuendIndex].bin_rf - subtrahendData.bin_stats[subtrahendIndex].bin_rf,\n                        'binLowBound': minuendData.bin_stats[minuendIndex].binLowBound,\n                        'binUpBound': minuendData.bin_stats[minuendIndex].binUpBound,\n                        'binLabel': minuendData.bin_stats[minuendIndex].binLabel\n                    });\n                }\n\n            } else {\n                // no match for this independentVarName\n                d[independentVarName].push(largeIntervalIndependentVar);\n                d[statVarName].push(null);\n                d.error_x.push(null);\n                d.error_y.push(null);\n                d.subVals.push([]);\n                d.subSecs.push([]);\n                if (hasLevels) {\n                    d.subLevs.push([]);\n                }\n                if (plotType === matsTypes.PlotTypes.histogram) {\n                    d.bin_stats.push({\n                        'bin_mean': null,\n                        'bin_sd': null,\n                        'bin_n': null,\n                        'bin_rf': null,\n                        'binLowBound': minuendData.bin_stats[minuendIndex].binLowBound,\n                        'binUpBound': minuendData.bin_stats[minuendIndex].binUpBound,\n                        'binLabel': minuendData.bin_stats[minuendIndex].binLabel\n                    });\n                }\n\n            }\n        } else if ((!subtrahendChanged && subtrahendIndex >= subtrahendData[independentVarName].length - 1) || (!minuendChanged && minuendIndex >= minuendData[independentVarName].length - 1)) {\n            // we've reached the end of at least one curve, so end the diffing.\n            break;\n        }\n    }\n\n    const filteredx = d.x.filter(x => x);\n    const filteredy = d.y.filter(y => y);\n    d.xmin = Math.min(...filteredx);\n    d.xmax = Math.max(...filteredx);\n    d.ymin = Math.min(...filteredy);\n    d.ymax = Math.max(...filteredy);\n\n    return {'dataset': d};\n};\n\n// generates diff of two contours.\nconst getDataForDiffContour = function (dataset) {\n    /*\n     DATASET ELEMENTS:\n        d[i] = {\n            label: string,\n            curveId: string,\n            name: string,\n            annotateColor: string,\n            annotation: string,             -----\n            x: [],                          *****\n            y: [],                          *****\n            z: [[]],                        *****\n            n: [[]],                        *****\n            text: [],\n            stats: [],\n            glob_stats: object,             -----\n            type: string,\n            autocontour: boolean,\n            ncontours: number,\n            colorbar: object,\n            colorscale: string,\n            reversescale: boolean,\n            contours: object,\n            marker: object,\n            xAxisKey: [],\n            yAxisKey: [],\n            visible: boolean,\n            xTextOutput: [],                *****\n            yTextOutput: [],                *****\n            zTextOutput: [],                *****\n            nTextOutput: [],                *****\n            maxDateTextOutput: [],          *****\n            minDateTextOutput: [],          *****\n            xmax: number,                   -----\n            xmin: number,                   -----\n            ymax: number,                   -----\n            ymin: number,                   -----\n            zmax: number,                   -----\n            zmin: number,                   -----\n            sum: number                     *****\n        };\n\n        ***** indicates calculation in loops\n        ----- indicates calculation after loops\n     */\n\n    // initialize output object\n    var diffDataset = {};\n    diffDataset['label'] = dataset[1].label + '-' + dataset[0].label;\n    diffDataset['curveId'] = dataset[1].curveId + '-' + dataset[0].curveId;\n    diffDataset['name'] = dataset[1].name + '-' + dataset[0].name;\n    diffDataset['annotateColor'] = \"rgb(255,165,0)\";\n    diffDataset['annotation'] = \"\";\n    diffDataset['text'] = [];\n    diffDataset['type'] = dataset[0].type;\n    diffDataset['marker'] = dataset[0].marker;\n    diffDataset['xAxisKey'] = dataset[0].xAxisKey;\n    diffDataset['yAxisKey'] = dataset[0].yAxisKey;\n    diffDataset['visible'] = dataset[0].visible;\n    diffDataset['x'] = [];\n    diffDataset['y'] = [];\n    diffDataset['z'] = [];\n    diffDataset['n'] = [];\n    diffDataset['xTextOutput'] = [];\n    diffDataset['yTextOutput'] = [];\n    diffDataset['zTextOutput'] = [];\n    diffDataset['nTextOutput'] = [];\n    diffDataset['maxDateTextOutput'] = [];\n    diffDataset['minDateTextOutput'] = [];\n    diffDataset['stats'] = [];\n    diffDataset['glob_stats'] = {};\n    diffDataset['xmax'] = -1 * Number.MAX_VALUE;\n    diffDataset['xmin'] = Number.MAX_VALUE;\n    diffDataset['ymax'] = -1 * Number.MAX_VALUE;\n    diffDataset['ymin'] = Number.MAX_VALUE;\n    diffDataset['zmax'] = -1 * Number.MAX_VALUE;\n    diffDataset['zmin'] = Number.MAX_VALUE;\n    diffDataset['sum'] = 0;\n\n    // initialize local variables\n    var minuendData = dataset[1];\n    var subtrahendData = dataset[0];\n\n    // get common x and y\n    diffDataset.x = _.intersection(minuendData.x, subtrahendData.x).sort(function (a, b) {\n        return a - b\n    });\n    diffDataset.y = _.intersection(minuendData.y, subtrahendData.y).sort(function (a, b) {\n        return a - b\n    });\n\n    // make we actually have matches\n    if (diffDataset.x.length === 0 || diffDataset.y.length === 0) {\n        diffDataset.x = [];\n        diffDataset.y = [];\n        return [diffDataset];\n    }\n\n    // make sure neither dataset is empty\n    if (minuendData.x.length === 0 || subtrahendData.x.length === 0 || minuendData.y.length === 0 || subtrahendData.y.length === 0) {\n        return [diffDataset];\n    }\n\n    var minuendYIndex = 0;\n    var subtrahendYIndex = 0;\n    var nPoints = 0;\n\n    // loop through common Ys\n    for (var diffDataYIndex = 0; diffDataYIndex < diffDataset.y.length; diffDataYIndex++) {\n        //make sure that we are actually on the same y value for each curve\n        var diffDataY = diffDataset.y[diffDataYIndex];\n        var minuendY = minuendData.y[minuendYIndex];\n        var subtrahendY = subtrahendData.y[subtrahendYIndex];\n\n        //increment the minuendYIndex until it reaches this iteration's diffDataY\n        while (diffDataY > minuendY && minuendYIndex < minuendData.y.length - 1) {\n            minuendY = minuendData.y[++minuendYIndex];\n        }\n\n        //increment the subtrahendYIndex until it reaches this iteration's diffDataY\n        while (diffDataY > subtrahendY && subtrahendYIndex < subtrahendData.y.length - 1) {\n            subtrahendY = subtrahendData.y[++subtrahendYIndex];\n        }\n\n        // initialize n and z arrays for this Y\n        diffDataset.z[diffDataYIndex] = [];\n        diffDataset.n[diffDataYIndex] = [];\n\n        var minuendXIndex = 0;\n        var subtrahendXIndex = 0;\n        for (var diffDataXIndex = 0; diffDataXIndex < diffDataset.x.length; diffDataXIndex++) {\n            //make sure that we are actually on the same x value for each curve\n            var diffDataX = diffDataset.x[diffDataXIndex];\n            var minuendX = minuendData.x[minuendXIndex];\n            var subtrahendX = subtrahendData.x[subtrahendXIndex];\n\n            //increment the minuendXIndex until it reaches this iteration's diffDataX\n            while (diffDataX > minuendX && minuendXIndex < minuendData.x.length - 1) {\n                minuendX = minuendData.x[++minuendXIndex];\n            }\n\n            //increment the subtrahendXIndex until it reaches this iteration's diffDataX\n            while (diffDataX > subtrahendX && subtrahendXIndex < subtrahendData.x.length - 1) {\n                subtrahendX = subtrahendData.x[++subtrahendXIndex];\n            }\n\n            var diffValue = null;\n            var diffNumber = 0;\n            var diffMinDate = null;\n            var diffMaxDate = null;\n            if ((minuendData.z[minuendYIndex][minuendXIndex] !== undefined && subtrahendData.z[subtrahendYIndex][subtrahendXIndex] !== undefined)\n                && (minuendData.z[minuendYIndex][minuendXIndex] !== null && subtrahendData.z[subtrahendYIndex][subtrahendXIndex] !== null)\n                && minuendX === subtrahendX && minuendY === subtrahendY) { // make sure both contours actually have data at these indices, data is not null at this point, and the x and y actually match\n                // calculate the difference values\n                diffValue = minuendData.z[minuendYIndex][minuendXIndex] - subtrahendData.z[subtrahendYIndex][subtrahendXIndex];\n                diffNumber = minuendData.n[minuendYIndex][minuendXIndex] <= subtrahendData.n[subtrahendYIndex][subtrahendXIndex] ? minuendData.n[minuendYIndex][minuendXIndex] : subtrahendData.n[subtrahendYIndex][subtrahendXIndex];\n                diffMinDate = minuendData.minDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] <= subtrahendData.minDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex] ? minuendData.minDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] : subtrahendData.minDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex];\n                diffMaxDate = minuendData.maxDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] >= subtrahendData.maxDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex] ? minuendData.maxDateTextOutput[minuendYIndex * minuendData.x.length + minuendXIndex] : subtrahendData.maxDateTextOutput[subtrahendYIndex * subtrahendData.x.length + subtrahendXIndex];\n                diffDataset['sum'] += diffValue;\n                nPoints = nPoints + 1;\n            }\n            diffDataset.z[diffDataYIndex].push(diffValue);\n            diffDataset.n[diffDataYIndex].push(diffNumber);\n            diffDataset.xTextOutput.push(diffDataX);\n            diffDataset.yTextOutput.push(diffDataY);\n            diffDataset.zTextOutput.push(diffValue);\n            diffDataset.nTextOutput.push(diffNumber);\n            diffDataset.minDateTextOutput.push(diffMinDate);\n            diffDataset.maxDateTextOutput.push(diffMaxDate);\n        }\n    }\n\n    // calculate statistics\n    const filteredx = diffDataset.x.filter(x => x);\n    const filteredy = diffDataset.y.filter(y => y);\n    const filteredz = diffDataset.zTextOutput.filter(z => z);\n    diffDataset.xmin = Math.min(...filteredx);\n    diffDataset.xmax = Math.max(...filteredx);\n    diffDataset.ymin = Math.min(...filteredy);\n    diffDataset.ymax = Math.max(...filteredy);\n    diffDataset.zmin = Math.min(...filteredz);\n    diffDataset.zmax = Math.max(...filteredz);\n\n    if (diffDataset.xmin == \"-Infinity\" || (diffDataset.x.indexOf(0) !== -1 && 0 < diffDataset.xmin)) {\n        diffDataset.xmin = 0;\n    }\n    if (diffDataset.ymin == \"-Infinity\" || (diffDataset.y.indexOf(0) !== -1 && 0 < diffDataset.ymin)) {\n        diffDataset.ymin = 0;\n    }\n    if (diffDataset.zmin == \"-Infinity\" || (diffDataset.zTextOutput.indexOf(0) !== -1 && 0 < diffDataset.zmin)) {\n        diffDataset.zmin = 0;\n    }\n\n    if (diffDataset.xmax == \"-Infinity\") {\n        diffDataset.xmax = 0;\n    }\n    if (diffDataset.ymax == \"-Infinity\") {\n        diffDataset.ymax = 0;\n    }\n    if (diffDataset.zmax == \"-Infinity\") {\n        diffDataset.zmax = 0;\n    }\n\n    const filteredMinDate = diffDataset.minDateTextOutput.filter(t => t);\n    const filteredMaxDate = diffDataset.maxDateTextOutput.filter(t => t);\n    diffDataset.glob_stats['mean'] = diffDataset.sum / nPoints;\n    diffDataset.glob_stats['minDate'] = Math.min(...filteredMinDate);\n    diffDataset.glob_stats['maxDate'] = Math.max(...filteredMaxDate);\n    diffDataset.glob_stats['n'] = nPoints;\n    diffDataset['annotation'] = diffDataset.glob_stats.mean === undefined ? diffDataset.label + \"- mean = NaN\" : diffDataset.label + \"- mean = \" + diffDataset.glob_stats.mean.toPrecision(4);\n\n    // make contours symmetrical around 0\n    diffDataset['autocontour'] = false;\n    diffDataset['ncontours'] = 15;\n    diffDataset['colorbar'] = dataset[0].colorbar;\n    diffDataset['colorbar']['title'] = dataset[0].colorbar.title === dataset[1].colorbar.title ? dataset[0].colorbar.title : dataset[1].colorbar.title + \" - \" + dataset[0].colorbar.title;\n    diffDataset['colorscale'] = [[0,\"rgb(5,10,172)\"],[0.35,\"rgb(106,137,247)\"],[0.45,\"rgb(255,255,255)\"],[0.55,\"rgb(255,255,255)\"],[0.6,\"rgb(220,170,132)\"],[0.7,\"rgb(230,145,90)\"],[1,\"rgb(178,10,28)\"]];\n    diffDataset['reversescale'] = dataset[0].reversescale;\n    diffDataset['contours'] = dataset[0].contours;\n    const maxZ = Math.abs(diffDataset.zmax) > Math.abs(diffDataset.zmin) ? Math.abs(diffDataset.zmax) : Math.abs(diffDataset.zmin);\n    diffDataset['contours']['start'] = -1 * maxZ + (2 * maxZ) / 16;\n    diffDataset['contours']['end'] = maxZ - (2 * maxZ) / 16;\n    diffDataset['contours']['size'] = (2 * maxZ) / 16;\n\n    return [diffDataset];\n};\n\nexport default matsDataDiffUtils = {\n\n    getDataForDiffCurve: getDataForDiffCurve,\n    getDataForDiffContour: getDataForDiffContour\n\n}\n"]},"sourceType":"script","hash":"8b375fed64f4bfc1ccec7e1fb5462a216d103fd5"}
