{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_query_util.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_query_util.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_query_util.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_query_util.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_query_util.js"}},"code":"let matsDataUtils, matsTypes, matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  },\n\n  matsTypes(v) {\n    matsTypes = v;\n  },\n\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\n\n//const Future = require('fibers/future');\n//utility to get the cadence for a particular model, so that the query function\n//knows where to include null points for missing data.\nconst getModelCadence = function (pool, dataSource, startDate, endDate) {\n  var rows = [];\n  var cycles;\n\n  try {\n    //this query should only return data if the model cadence is irregular.\n    //otherwise, the cadence will be calculated later by the query function.\n    rows = simplePoolQueryWrapSynchronous(pool, \"select cycle_seconds \" + \"from mats_common.primary_model_orders \" + \"where model = \" + \"(select new_model as display_text from mats_common.standardized_model_list where old_model = '\" + dataSource + \"');\");\n    var cycles_raw = JSON.parse(rows[0].cycle_seconds);\n    var cycles_keys = Object.keys(cycles_raw).sort(); //there can be difference cadences for different time periods (each time period is a key in cycles_keys,\n    //with the cadences for that period represented as values in cycles_raw), so this section identifies all\n    //time periods relevant to the requested date range, and returns the union of their cadences.\n\n    if (cycles_keys.length !== 0) {\n      var newTime;\n      var chosenStartTime;\n      var chosenEndTime;\n      var chosenStartIdx;\n      var chosenEndIdx;\n      var foundStart = false;\n      var foundEnd = false;\n\n      for (var ti = cycles_keys.length - 1; ti >= 0; ti--) {\n        newTime = cycles_keys[ti];\n\n        if (startDate >= Number(newTime) && !foundStart) {\n          chosenStartTime = newTime;\n          chosenStartIdx = ti;\n          foundStart = true;\n        }\n\n        if (endDate >= Number(newTime) && !foundEnd) {\n          chosenEndTime = newTime;\n          chosenEndIdx = ti;\n          foundEnd = true;\n        }\n\n        if (foundStart && foundEnd) {\n          break;\n        }\n      }\n\n      if (chosenStartTime !== undefined && chosenEndTime !== undefined) {\n        if (Number(chosenStartTime) === Number(chosenEndTime)) {\n          cycles = cycles_raw[chosenStartTime];\n        } else if (chosenEndIdx - chosenStartIdx === 1) {\n          const startCycles = cycles_raw[chosenStartTime];\n          const endCycles = cycles_raw[chosenEndTime];\n          cycles = _.union(startCycles, endCycles);\n        } else {\n          var middleCycles = [];\n          var currCycles;\n\n          for (ti = chosenStartIdx + 1; ti < chosenEndIdx; ti++) {\n            currCycles = cycles_raw[cycles_keys[ti]];\n            middleCycles = _.union(middleCycles, currCycles);\n          }\n\n          const startCycles = cycles_raw[chosenStartTime];\n          const endCycles = cycles_raw[chosenEndTime];\n          cycles = _.union(startCycles, endCycles, middleCycles);\n        }\n      }\n    }\n  } catch (e) {//ignore - just a safety check, don't want to exit if there isn't a cycles_per_model entry\n    //if there isn't a cycles_per_model entry, it just means that the model has a regular cadence\n  }\n\n  if (cycles !== null && cycles !== undefined && cycles.length > 0) {\n    for (var c = 0; c < cycles.length; c++) {\n      cycles[c] = cycles[c] * 1000; // convert to milliseconds\n    }\n  } else {\n    cycles = []; //regular cadence model--cycles will be calculated later by the query function\n  }\n\n  return cycles;\n}; //this function calculates the interval between the current time and the next time for irregular cadence models.\n\n\nconst getTimeInterval = function (avTime, time_interval, foreCastOffset, cycles) {\n  //have to calculate the time_interval\n  var ti;\n  var dayInMilliSeconds = 24 * 3600 * 1000;\n  var minCycleTime = Math.min(...cycles);\n  var thisCadence = avTime % dayInMilliSeconds; //current hour of day (valid time)\n\n  if (Number(thisCadence) - Number(foreCastOffset) * 3600 * 1000 < 0) {\n    //check to see if cycle time was on previous day -- if so, need to wrap around 00Z to get current hour of day (cycle time)\n    thisCadence = Number(thisCadence) - Number(foreCastOffset) * 3600 * 1000 + dayInMilliSeconds; //current hour of day (cycle time)\n  } else {\n    thisCadence = Number(thisCadence) - Number(foreCastOffset) * 3600 * 1000; //current hour of day (cycle time)\n  }\n\n  var thisCadenceIdx = cycles.indexOf(thisCadence); //fnd our where the current hour of day is in the cycles array\n\n  if (thisCadenceIdx !== -1) {\n    var nextCadenceIdx = thisCadenceIdx + 1; //choose the next hour of the day\n\n    if (nextCadenceIdx >= cycles.length) {\n      ti = dayInMilliSeconds - thisCadence + minCycleTime; //if we were at the last cycle cadence, wrap back around to the first cycle cadence\n    } else {\n      ti = cycles[nextCadenceIdx] - cycles[thisCadenceIdx]; //otherwise take the difference between the current and next hours of the day.\n    }\n  } else {\n    ti = time_interval; //if for some reason the current hour of the day isn't in the cycles array, default to the regular cadence interval\n  }\n\n  return ti;\n}; //utility for querying the DB\n\n\nconst simplePoolQueryWrapSynchronous = function (pool, statement) {\n  /*\n   simple synchronous query of statement to the specified pool.\n   params :\n   pool - a predefined db pool (usually defined in main.js). i.e. wfip2Pool = mysql.createPool(wfip2Settings);\n   statement - String - a valid sql statement\n   actions - queries database and will wait until query returns.\n   return: rowset - an array of rows\n   throws: error\n   */\n  if (Meteor.isServer) {\n    const Future = require('fibers/future');\n\n    const queryWrap = Future.wrap(function (pool, statement, callback) {\n      pool.query(statement, function (err, rows) {\n        return callback(err, rows);\n      });\n    });\n    return queryWrap(pool, statement).wait();\n  }\n}; //this method queries the database for timeseries plots\n\n\nconst queryDBTimeSeries = function (pool, statement, dataSource, forecastOffset, startDate, endDate, averageStr, validTimes, hasLevels, forceRegularCadence) {\n  //upper air is only verified at 00Z and 12Z, so you need to force irregular models to verify at that regular cadence\n  const Future = require('fibers/future');\n\n  if (Meteor.isServer) {\n    const plotParams = matsDataUtils.getPlotParamsFromStack();\n    const completenessQCParam = Number(plotParams[\"completeness\"]) / 100;\n    var cycles = getModelCadence(pool, dataSource, startDate, endDate); // if irregular model cadence, get cycle times. If regular, get empty array.\n\n    if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n      var vtCycles = validTimes.map(function (x) {\n        return (Number(x) - forecastOffset) * 3600 * 1000;\n      }); // selecting validTimes makes the cadence irregular\n\n      vtCycles = vtCycles.map(function (x) {\n        return x < 0 ? x + 24 * 3600 * 1000 : x;\n      }); // make sure no cycles are negative\n\n      vtCycles = vtCycles.sort(function (a, b) {\n        return Number(a) - Number(b);\n      }); //sort 'em\n\n      cycles = cycles.length > 0 ? _.intersection(cycles, vtCycles) : vtCycles; // if we already had cycles get the ones that correspond to valid times\n    }\n\n    const regular = forceRegularCadence || averageStr !== \"None\" || !(cycles !== null && cycles.length > 0); // If curves have averaging, the cadence is always regular, i.e. it's the cadence of the average\n\n    var dFuture = new Future();\n    var d = {\n      // d will contain the curve data\n      x: [],\n      y: [],\n      error_x: [],\n      error_y: [],\n      subVals: [],\n      subSecs: [],\n      subLevs: [],\n      stats: [],\n      text: [],\n      xmin: Number.MAX_VALUE,\n      xmax: Number.MIN_VALUE,\n      ymin: Number.MAX_VALUE,\n      ymax: Number.MIN_VALUE,\n      sum: 0\n    };\n    var error = \"\";\n    var N0 = [];\n    var N_times = [];\n    pool.query(statement, function (err, rows) {\n      // query callback - build the curve data from the results - or set an error\n      if (err !== undefined && err !== null) {\n        error = err.message;\n      } else if (rows === undefined || rows === null || rows.length === 0) {\n        error = matsTypes.Messages.NO_DATA_FOUND;\n      } else {\n        const parsedData = parseQueryDataTimeSeries(pool, rows, d, completenessQCParam, hasLevels, averageStr, forecastOffset, cycles, regular);\n        d = parsedData.d;\n        N0 = parsedData.N0;\n        N_times = parsedData.N_times;\n        cycles = parsedData.cycles;\n      } // done waiting - have results\n\n\n      dFuture['return']();\n    }); // wait for future to finish\n\n    dFuture.wait();\n    return {\n      data: d,\n      error: error,\n      N0: N0,\n      N_times: N_times,\n      averageStr: averageStr,\n      cycles: cycles\n    };\n  }\n}; //this method queries the database for specialty curves such as profiles, dieoffs, threshold plots, valid time plots, and histograms\n\n\nconst queryDBSpecialtyCurve = function (pool, statement, plotType, hasLevels) {\n  if (Meteor.isServer) {\n    const Future = require('fibers/future');\n\n    const plotParams = matsDataUtils.getPlotParamsFromStack();\n    const completenessQCParam = Number(plotParams[\"completeness\"]) / 100;\n    const appType = matsCollections.Settings.findOne({}).appType;\n    var dFuture = new Future();\n    var d = {\n      // d will contain the curve data\n      x: [],\n      y: [],\n      error_x: [],\n      error_y: [],\n      subVals: [],\n      subSecs: [],\n      subLevs: [],\n      stats: [],\n      text: [],\n      xmin: Number.MAX_VALUE,\n      xmax: Number.MIN_VALUE,\n      ymin: Number.MAX_VALUE,\n      ymax: Number.MIN_VALUE,\n      sum: 0\n    };\n    var error = \"\";\n    var N0 = [];\n    var N_times = [];\n    pool.query(statement, function (err, rows) {\n      // query callback - build the curve data from the results - or set an error\n      if (err !== undefined && err !== null) {\n        error = err.message;\n      } else if (rows === undefined || rows === null || rows.length === 0) {\n        error = matsTypes.Messages.NO_DATA_FOUND;\n      } else {\n        var parsedData;\n\n        if (plotType !== matsTypes.PlotTypes.histogram) {\n          parsedData = parseQueryDataSpecialtyCurve(rows, d, completenessQCParam, plotType, appType, hasLevels);\n        } else {\n          parsedData = parseQueryDataHistogram(d, rows, hasLevels);\n        }\n\n        d = parsedData.d;\n        N0 = parsedData.N0;\n        N_times = parsedData.N_times;\n      }\n\n      dFuture['return']();\n    }); // wait for future to finish\n\n    dFuture.wait();\n    return {\n      data: d,\n      error: error,\n      N0: N0,\n      N_times: N_times\n    };\n  }\n}; //this method queries the database for map plots\n\n\nconst queryMapDB = function (pool, statement, dataSource, variable, varUnits, siteMap) {\n  if (Meteor.isServer) {\n    // d will contain the curve data\n    var d = {\n      siteName: [],\n      queryVal: [],\n      lat: [],\n      lon: [],\n      color: [],\n      stats: [],\n      text: []\n    }; // for biases <= -1\n\n    var dBlue = {\n      siteName: [],\n      queryVal: [],\n      lat: [],\n      lon: [],\n      stats: [],\n      text: [],\n      color: \"rgb(0,0,255)\"\n    }; // for biases > -1 and < 1\n\n    var dBlack = {\n      siteName: [],\n      queryVal: [],\n      lat: [],\n      lon: [],\n      stats: [],\n      text: [],\n      color: \"rgb(0,0,0)\"\n    }; // for biases >= 1\n\n    var dRed = {\n      siteName: [],\n      queryVal: [],\n      lat: [],\n      lon: [],\n      stats: [],\n      text: [],\n      color: \"rgb(255,0,0)\"\n    };\n    var error = \"\";\n\n    const Future = require('fibers/future');\n\n    var pFuture = new Future();\n    pool.query(statement, function (err, rows) {\n      // query callback - build the curve data from the results - or set an error\n      if (err !== undefined && err !== null) {\n        error = err.message;\n      } else if (rows === undefined || rows === null || rows.length === 0) {\n        error = matsTypes.Messages.NO_DATA_FOUND;\n      } else {\n        var queryVal;\n\n        for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n          const site = rows[rowIndex].sta_name;\n          queryVal = rows[rowIndex].model_ob_diff;\n          d.siteName.push(site);\n          d.queryVal.push(queryVal);\n          d.stats.push({\n            N_times: rows[rowIndex].N_times,\n            min_time: rows[rowIndex].min_time,\n            max_time: rows[rowIndex].max_time\n          });\n          var tooltips = site + \"<br>\" + \"variable: \" + variable + \"<br>\" + \"model: \" + dataSource + \"<br>\" + \"model-obs: \" + queryVal + \" \" + varUnits + \"<br>\" + \"n: \" + rows[rowIndex].N_times;\n          d.text.push(tooltips);\n          var thisSite = siteMap.find(obj => {\n            return obj.name === site;\n          });\n          d.lat.push(thisSite.point[0]);\n          d.lon.push(thisSite.point[1]);\n          var textMarker = queryVal === null ? \"\" : queryVal.toFixed(0);\n\n          if (queryVal <= -1) {\n            d.color.push(\"rgb(0,0,255)\");\n            dBlue.siteName.push(site);\n            dBlue.queryVal.push(queryVal);\n            dBlue.text.push(textMarker);\n            dBlue.lat.push(thisSite.point[0]);\n            dBlue.lon.push(thisSite.point[1]);\n          } else if (queryVal >= 1) {\n            d.color.push(\"rgb(255,0,0)\");\n            dRed.siteName.push(site);\n            dRed.queryVal.push(queryVal);\n            dRed.text.push(textMarker);\n            dRed.lat.push(thisSite.point[0]);\n            dRed.lon.push(thisSite.point[1]);\n          } else {\n            d.color.push(\"rgb(0,0,0)\");\n            dBlack.siteName.push(site);\n            dBlack.queryVal.push(queryVal);\n            dBlack.text.push(textMarker);\n            dBlack.lat.push(thisSite.point[0]);\n            dBlack.lon.push(thisSite.point[1]);\n          }\n        } // end of loop row\n\n      } // done waiting - have results\n\n\n      pFuture['return']();\n    }); // wait for future to finish\n\n    pFuture.wait();\n    return {\n      data: d,\n      // [sub_values,sub_secs] as arrays\n      dataBlue: dBlue,\n      // [sub_values,sub_secs] as arrays\n      dataBlack: dBlack,\n      // [sub_values,sub_secs] as arrays\n      dataRed: dRed,\n      // [sub_values,sub_secs] as arrays\n      error: error\n    };\n  }\n}; //this method queries the database for contour plots\n\n\nconst queryDBContour = function (pool, statement) {\n  if (Meteor.isServer) {\n    const Future = require('fibers/future');\n\n    var dFuture = new Future();\n    var d = {\n      // d will contain the curve data\n      x: [],\n      y: [],\n      z: [],\n      n: [],\n      text: [],\n      xTextOutput: [],\n      yTextOutput: [],\n      zTextOutput: [],\n      nTextOutput: [],\n      minDateTextOutput: [],\n      maxDateTextOutput: [],\n      stats: [],\n      glob_stats: {},\n      xmin: Number.MAX_VALUE,\n      xmax: Number.MIN_VALUE,\n      ymin: Number.MAX_VALUE,\n      ymax: Number.MIN_VALUE,\n      zmin: Number.MAX_VALUE,\n      zmax: Number.MIN_VALUE,\n      sum: 0\n    };\n    var error = \"\";\n    pool.query(statement, function (err, rows) {\n      // query callback - build the curve data from the results - or set an error\n      if (err !== undefined && err !== null) {\n        error = err.message;\n      } else if (rows === undefined || rows === null || rows.length === 0) {\n        error = matsTypes.Messages.NO_DATA_FOUND;\n      } else {\n        const parsedData = parseQueryDataContour(rows, d);\n        d = parsedData.d;\n      }\n\n      dFuture['return']();\n    }); // wait for future to finish\n\n    dFuture.wait();\n    return {\n      data: d,\n      error: error\n    };\n  }\n}; //this method parses the returned query data for timeseries plots\n\n\nconst parseQueryDataTimeSeries = function (pool, rows, d, completenessQCParam, hasLevels, averageStr, foreCastOffset, cycles, regular) {\n  /*\n      var d = {// d will contain the curve data\n          x: [],\n          y: [],\n          error_x: [],   // curveTime\n          error_y: [],   // values\n          subVals: [],   //subVals\n          subSecs: [],   //subSecs\n          subLevs: [],   //subLevs\n          stats: [],     //pointStats\n          text: [],\n          glob_stats: {},     //curveStats\n          xmin: Number.MAX_VALUE,\n          xmax: Number.MIN_VALUE,\n          ymin: Number.MAX_VALUE,\n          ymax: Number.MIN_VALUE,\n          sum: 0\n      };\n  */\n  d.error_x = null; // time series doesn't use x errorbars\n\n  var N0 = [];\n  var N_times = [];\n  var xmax = Number.MIN_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var curveTime = [];\n  var curveStats = [];\n  var subVals = [];\n  var subSecs = [];\n  var subLevs = [];\n  var time_interval = rows.length > 1 ? Number(rows[1].avtime) - Number(rows[0].avtime) : undefined; //calculate a base time interval -- will be used if data is regular\n\n  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n    var avSeconds = Number(rows[rowIndex].avtime);\n    var avTime = avSeconds * 1000;\n    xmin = avTime < xmin ? avTime : xmin;\n    xmax = avTime > xmax ? avTime : xmax;\n    var stat = rows[rowIndex].stat;\n    N0.push(rows[rowIndex].N0); // number of values that go into a time series point\n\n    N_times.push(rows[rowIndex].N_times); // number of times that go into a time series point\n    // find the minimum time_interval. For regular models, this will differ from the previous time_interval\n    // if the interval was artificially large due to missing values. For irregular models, we need the minimum\n    // interval to be sure we don't accidentally go past the next data point.\n\n    if (rowIndex < rows.length - 1) {\n      var time_diff = Number(rows[rowIndex + 1].avtime) - Number(rows[rowIndex].avtime);\n\n      if (time_diff < time_interval) {\n        time_interval = time_diff;\n      }\n    } // store sub values that will later be used for calculating error bar statistics.\n\n\n    var sub_values = [];\n    var sub_secs = [];\n    var sub_levs = [];\n\n    if (stat !== null && stat !== \"NULL\" && rows[rowIndex].sub_data !== undefined) {\n      try {\n        var sub_data = rows[rowIndex].sub_data.toString().split(',');\n        var curr_sub_data;\n\n        for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {\n          curr_sub_data = sub_data[sd_idx].split(';');\n          sub_values.push(Number(curr_sub_data[0]));\n          sub_secs.push(Number(curr_sub_data[1]));\n\n          if (hasLevels) {\n            if (!isNaN(Number(curr_sub_data[2]))) {\n              sub_levs.push(Number(curr_sub_data[2]));\n            } else {\n              sub_levs.push(curr_sub_data[2]);\n            }\n          }\n        }\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in parseQueryDataTimeSeries. The expected fields don't seem to be present in the results cache: \" + e.message;\n        throw new Error(e.message);\n      }\n    } else {\n      sub_values = NaN;\n      sub_secs = NaN;\n\n      if (hasLevels) {\n        sub_levs = NaN;\n      }\n    }\n\n    curveTime.push(avTime);\n    curveStats.push(stat);\n    subVals.push(sub_values);\n    subSecs.push(sub_secs);\n\n    if (hasLevels) {\n      subLevs.push(sub_levs);\n    }\n  }\n\n  var N0_max = Math.max(...N0);\n  var N_times_max = Math.max(...N_times);\n\n  if (xmin < Number(rows[0].avtime) * 1000 || averageStr !== \"None\") {\n    xmin = Number(rows[0].avtime) * 1000;\n  }\n\n  time_interval = time_interval * 1000;\n  var loopTime = xmin;\n  var sum = 0;\n\n  while (loopTime <= xmax) {\n    var d_idx = curveTime.indexOf(loopTime);\n\n    if (d_idx < 0) {\n      if (hasLevels) {\n        //d.push([loopTime, null, -1, NaN, NaN, NaN]);// add a null for missing data\n        d.x.push(loopTime);\n        d.y.push(null); //d.error_x not used\n\n        d.error_y.push(null); //placeholder\n\n        d.subVals.push(NaN);\n        d.subSecs.push(NaN);\n        d.subLevs.push(NaN);\n      } else {\n        //d.push([loopTime, null, -1, NaN, NaN]);     // add a null for missing data\n        d.x.push(loopTime);\n        d.y.push(null); //d.error_x not used\n\n        d.error_y.push(null); //placeholder\n\n        d.subVals.push(NaN);\n        d.subSecs.push(NaN);\n      }\n    } else {\n      var this_N0 = N0[d_idx];\n      var this_N_times = N_times[d_idx]; // Make sure that we don't have any points with far less data than the rest of the graph, and that\n      // we don't have any points with a smaller completeness value than specified by the user.\n\n      if (this_N0 < 0.1 * N0_max || this_N_times < completenessQCParam * N_times_max) {\n        if (hasLevels) {\n          //                    d.push([loopTime, null, -1, NaN, NaN, NaN]);     // add a null if this time doesn't pass QC\n          d.x.push(loopTime);\n          d.y.push(null); //d.error_x not used\n\n          d.error_y.push(null); //placeholder\n\n          d.subVals.push(NaN);\n          d.subSecs.push(NaN);\n          d.subLevs.push(NaN);\n        } else {\n          //                    d.push([loopTime, null, -1, NaN, NaN]);     // add a null if this time doesn't pass QC\n          d.x.push(loopTime);\n          d.y.push(null); //d.error_x not used\n\n          d.error_y.push(null); //placeholder\n\n          d.subVals.push(NaN);\n          d.subSecs.push(NaN);\n        }\n      } else {\n        sum += curveStats[d_idx];\n\n        if (hasLevels) {\n          //d.push([loopTime, curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);   // else add the real data\n          d.x.push(loopTime);\n          d.y.push(curveStats[d_idx]); //d.error_x not used\n\n          d.error_y.push(null);\n          d.subVals.push(subVals[d_idx]);\n          d.subSecs.push(subSecs[d_idx]);\n          d.subLevs.push(subLevs[d_idx]);\n        } else {\n          //d.push([loopTime, curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx]]);   // else add the real data\n          d.x.push(loopTime);\n          d.y.push(curveStats[d_idx]); //d.error_x not used\n\n          d.error_y.push(null);\n          d.subVals.push(subVals[d_idx]);\n          d.subSecs.push(subSecs[d_idx]);\n        }\n      }\n    }\n\n    if (!regular) {\n      // it is a model that has an irregular set of intervals, i.e. an irregular cadence\n      time_interval = getTimeInterval(loopTime, time_interval, foreCastOffset, cycles); // the time interval most likely will not be the one calculated above\n    }\n\n    loopTime = loopTime + time_interval; // advance to the next time.\n  }\n\n  if (regular) {\n    cycles = [time_interval]; // regular models will return one cycle cadence\n  }\n\n  const filteredx = d.x.filter(x => x);\n  const filteredy = d.y.filter(y => y);\n  d.xmin = Math.min(...filteredx);\n  d.xmax = Math.max(...filteredx);\n  d.ymin = Math.min(...filteredy);\n  d.ymax = Math.max(...filteredy);\n  d.sum = sum;\n\n  if (d.xmin == \"-Infinity\" || d.x.indexOf(0) !== -1 && 0 < d.xmin) {\n    d.xmin = 0;\n  }\n\n  if (d.ymin == \"-Infinity\" || d.y.indexOf(0) !== -1 && 0 < d.ymin) {\n    d.ymin = 0;\n  }\n\n  if (d.xmax == \"-Infinity\") {\n    d.xmax = 0;\n  }\n\n  if (d.ymax == \"-Infinity\") {\n    d.ymax = 0;\n  }\n\n  return {\n    d: d,\n    N0: N0,\n    N_times: N_times,\n    cycles: cycles\n  };\n}; //this method parses the returned query data for specialty curves such as profiles, dieoffs, threshold plots, and valid time plots\n\n\nconst parseQueryDataSpecialtyCurve = function (rows, d, completenessQCParam, plotType, appType, hasLevels) {\n  /*\n      var d = {// d will contain the curve data\n          x: [],\n          y: [],\n          error_x: [],   // curveTime\n          error_y: [],   // values\n          subVals: [],   //subVals\n          subSecs: [],   //subSecs\n          subLevs: [],   //subLevs\n          stats: [],     //pointStats\n          text: [],\n          glob_stats: {},     //curveStats\n          xmin:num,\n          ymin:num,\n          xmax:num,\n          ymax:num,\n          sum:num;\n      };\n  */\n  var N0 = [];\n  var N_times = [];\n  var curveIndependentVars = [];\n  var curveStats = [];\n  var subVals = [];\n  var subSecs = [];\n  var subLevs = [];\n\n  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n    var independentVar;\n\n    if (plotType === matsTypes.PlotTypes.validtime) {\n      independentVar = Number(rows[rowIndex].hr_of_day);\n    } else if (plotType === matsTypes.PlotTypes.profile) {\n      independentVar = Number(rows[rowIndex].avVal.toString().replace('P', ''));\n    } else if (plotType === matsTypes.PlotTypes.dailyModelCycle) {\n      independentVar = Number(rows[rowIndex].avtime) * 1000;\n    } else {\n      independentVar = Number(rows[rowIndex].avtime);\n    }\n\n    var stat = rows[rowIndex].stat;\n    N0.push(rows[rowIndex].N0); // number of values that go into a point on the graph\n\n    N_times.push(rows[rowIndex].N_times); // number of times that go into a point on the graph\n\n    var sub_stats = [];\n    var sub_secs = [];\n    var sub_levs = [];\n\n    if (stat !== null && stat !== \"NULL\" && rows[rowIndex].sub_data !== undefined) {\n      try {\n        var sub_data = rows[rowIndex].sub_data.toString().split(',');\n        var curr_sub_data;\n\n        for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {\n          curr_sub_data = sub_data[sd_idx].split(';');\n          sub_stats.push(Number(curr_sub_data[0]));\n          sub_secs.push(Number(curr_sub_data[1]));\n\n          if (hasLevels) {\n            if (!isNaN(Number(curr_sub_data[2]))) {\n              sub_levs.push(Number(curr_sub_data[2]));\n            } else {\n              sub_levs.push(curr_sub_data[2]);\n            }\n          }\n        }\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in parseQueryDataSpecialtyCurve. The expected fields don't seem to be present in the results cache: \" + e.message;\n        throw new Error(e.message);\n      }\n    } else {\n      sub_stats = NaN;\n      sub_secs = NaN;\n\n      if (hasLevels) {\n        sub_levs = NaN;\n      }\n    } // deal with missing forecast cycles for dailyModelCycle plot type\n\n\n    if (plotType === matsTypes.PlotTypes.dailyModelCycle && rowIndex > 0 && Number(independentVar) - Number(rows[rowIndex - 1].avtime * 1000) > 3600 * 24 * 1000) {\n      const cycles_missing = Math.floor((Number(independentVar) - Number(rows[rowIndex - 1].avtime * 1000)) / (3600 * 24 * 1000));\n\n      for (var missingIdx = cycles_missing; missingIdx > 0; missingIdx--) {\n        curveIndependentVars.push(independentVar - 3600 * 24 * 1000 * missingIdx);\n        curveStats.push(null);\n        subVals.push(NaN);\n        subSecs.push(NaN);\n\n        if (hasLevels) {\n          subLevs.push(NaN);\n        }\n      }\n    }\n\n    curveIndependentVars.push(independentVar);\n    curveStats.push(stat);\n    subVals.push(sub_stats);\n    subSecs.push(sub_secs);\n\n    if (hasLevels) {\n      subLevs.push(sub_levs);\n    }\n  }\n\n  var N0_max = Math.max(...N0);\n  var N_times_max = Math.max(...N_times);\n  var sum = 0;\n\n  for (var d_idx = 0; d_idx < curveIndependentVars.length; d_idx++) {\n    var this_N0 = N0[d_idx];\n    var this_N_times = N_times[d_idx]; // Make sure that we don't have any points with far less data than the rest of the graph, and that\n    // we don't have any points with a smaller completeness value than specified by the user.\n\n    if (this_N0 < 0.05 * N0_max || this_N_times < completenessQCParam * N_times_max) {\n      if (plotType === matsTypes.PlotTypes.profile) {\n        // profile has the stat first, and then the independent var. The others have independent var and then stat.\n        // this is in the pattern of x-plotted-variable, y-plotted-variable.\n        //d.push([null, curveIndependentVars[d_idx], -1, NaN, NaN, NaN]);\n        d.x.push(null);\n        d.y.push(curveIndependentVars[d_idx]);\n        d.error_x.push(null); // placeholder\n        //d.error_y not used for profile\n\n        d.subVals.push(NaN);\n        d.subSecs.push(NaN);\n        d.subLevs.push(NaN);\n      } else if (plotType !== matsTypes.PlotTypes.dieoff) {\n        // for dieoffs, we don't want to add a null for missing data. Just don't have a point for that FHR.\n        if (hasLevels) {\n          //d.push([curveIndependentVars[d_idx], null, -1, NaN, NaN, NaN]);\n          d.x.push(curveIndependentVars[d_idx]);\n          d.y.push(null); //d.error_x not used for curves other than profile\n\n          d.error_y.push(null); // placeholder\n\n          d.subVals.push(NaN);\n          d.subSecs.push(NaN);\n          d.subLevs.push(NaN);\n        } else {\n          //d.push([curveIndependentVars[d_idx], null, -1, NaN, NaN]);\n          d.x.push(curveIndependentVars[d_idx]);\n          d.y.push(null); //d.error_x not used for curves other than profile\n\n          d.error_y.push(null); // placeholder\n\n          d.subVals.push(NaN);\n          d.subSecs.push(NaN);\n        }\n      }\n    } else {\n      // else add the real data\n      sum += curveStats[d_idx];\n\n      if (plotType === matsTypes.PlotTypes.profile) {\n        // profile has the stat first, and then the independent var. The others have independent var and then stat.\n        // this is in the pattern of x-plotted-variable, y-plotted-variable.\n        //                d.push([curveStats[d_idx], curveIndependentVars[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);\n        d.x.push(curveStats[d_idx]);\n        d.y.push(curveIndependentVars[d_idx]);\n        d.error_x.push(null); // placeholder\n        //d.error_y not used for curves other than profile\n\n        d.subVals.push(subVals[d_idx]);\n        d.subSecs.push(subSecs[d_idx]);\n        d.subLevs.push(subLevs[d_idx]);\n      } else if (hasLevels) {\n        //                d.push([curveIndependentVars[d_idx], curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);\n        d.x.push(curveIndependentVars[d_idx]);\n        d.y.push(curveStats[d_idx]); //d.error_x not used for curves other than profile\n\n        d.error_y.push(null); // placeholder\n\n        d.subVals.push(subVals[d_idx]);\n        d.subSecs.push(subSecs[d_idx]);\n        d.subLevs.push(subLevs[d_idx]);\n      } else {\n        //                d.push([curveIndependentVars[d_idx], curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx]]);\n        d.x.push(curveIndependentVars[d_idx]);\n        d.y.push(curveStats[d_idx]); //d.error_x not used for curves other than profile\n\n        d.error_y.push(null); // placeholder\n\n        d.subVals.push(subVals[d_idx]);\n        d.subSecs.push(subSecs[d_idx]);\n      }\n    }\n  } // the met levels are ordered as strings, so we need to re-sort them\n\n\n  if (plotType === matsTypes.PlotTypes.profile && appType === matsTypes.AppTypes.metexpress) {\n    var dSorted = [];\n\n    for (var didx = 0; didx < d.y.length; didx++) {\n      dSorted.push({\n        y: d.y[didx],\n        x: d.x[didx],\n        error_x: d.error_x[didx],\n        subVals: d.subVals[didx],\n        subSecs: d.subSecs[didx],\n        subLevs: d.subLevs[didx]\n      });\n    }\n\n    d.y = [];\n    d.x = [];\n    d.error_x = [];\n    d.subVals = [];\n    d.subSecs = [];\n    d.subLevs = [];\n    dSorted.sort(function (a, b) {\n      return a.y - b.y;\n    });\n    dSorted.map(function (elem) {\n      d.y.push(elem.y);\n      d.x.push(elem.x);\n      d.error_x.push(elem.error_x);\n      d.subVals.push(elem.subVals);\n      d.subSecs.push(elem.subSecs);\n      d.subLevs.push(elem.subLevs);\n    });\n  }\n\n  const filteredx = d.x.filter(x => x);\n  const filteredy = d.y.filter(y => y);\n  d.xmin = Math.min(...filteredx);\n  d.xmax = Math.max(...filteredx);\n  d.ymin = Math.min(...filteredy);\n  d.ymax = Math.max(...filteredy);\n  d.sum = sum;\n\n  if (d.xmin == \"-Infinity\" || d.x.indexOf(0) !== -1 && 0 < d.xmin) {\n    d.xmin = 0;\n  }\n\n  if (d.ymin == \"-Infinity\" || d.y.indexOf(0) !== -1 && 0 < d.ymin) {\n    d.ymin = 0;\n  }\n\n  if (d.xmax == \"-Infinity\") {\n    d.xmax = 0;\n  }\n\n  if (d.ymax == \"-Infinity\") {\n    d.ymax = 0;\n  }\n\n  return {\n    d: d,\n    N0: N0,\n    N_times: N_times\n  };\n}; // this method parses the returned query data for histograms\n\n\nconst parseQueryDataHistogram = function (d, rows, hasLevels) {\n  /*\n      var d = {// d will contain the curve data\n          x: [], //placeholder\n          y: [], //placeholder\n          error_x: [], // unused\n          error_y: [], // unused\n          subVals: [],\n          subSecs: [],\n          subLevs: [],\n          glob_stats: [], // placeholder\n          bin_stats: [], // placeholder\n          text: [] //placeholder\n          xmin:num,\n          xmax:num,\n          ymin:num,\n          ymax:num\n      };\n  */\n  // these arrays hold all the sub values and seconds (and levels) until they are sorted into bins\n  var curveSubStatsRaw = [];\n  var curveSubSecsRaw = [];\n  var curveSubLevsRaw = []; // parse the data returned from the query\n\n  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n    var stat = rows[rowIndex].stat;\n    var sub_stats = [];\n    var sub_secs = [];\n    var sub_levs = [];\n\n    if (stat !== null && stat !== \"NULL\" && rows[rowIndex].sub_data !== undefined) {\n      try {\n        var sub_data = rows[rowIndex].sub_data.toString().split(',');\n        var curr_sub_data;\n\n        for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {\n          curr_sub_data = sub_data[sd_idx].split(';');\n          sub_stats.push(Number(curr_sub_data[0]));\n          sub_secs.push(Number(curr_sub_data[1]));\n\n          if (hasLevels) {\n            if (!isNaN(Number(curr_sub_data[2]))) {\n              sub_levs.push(Number(curr_sub_data[2]));\n            } else {\n              sub_levs.push(curr_sub_data[2]);\n            }\n          }\n\n          curveSubLevsRaw.push(sub_levs);\n        }\n\n        curveSubStatsRaw.push(sub_stats);\n        curveSubSecsRaw.push(sub_secs);\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in parseQueryDataHistogram. The expected fields don't seem to be present in the results cache: \" + e.message;\n        throw new Error(e.message);\n      }\n    }\n  } // we don't have bins yet, so we want all of the data in one array\n\n\n  const subVals = [].concat.apply([], curveSubStatsRaw);\n  const subSecs = [].concat.apply([], curveSubSecsRaw);\n  var subLevs;\n\n  if (hasLevels) {\n    subLevs = [].concat.apply([], curveSubLevsRaw);\n  }\n\n  d.subVals = subVals;\n  d.subSecs = subSecs;\n  d.subLevs = subLevs;\n  return {\n    d: d,\n    N0: subVals.length,\n    N_times: subSecs.length\n  };\n}; //this method parses the returned query data for contour plots\n\n\nconst parseQueryDataContour = function (rows, d) {\n  /*\n      var d = {// d will contain the curve data\n          x: [],\n          y: [],\n          z: [],\n          n: [],\n          text: [],\n          xTextOutput: [],\n          yTextOutput: [],\n          zTextOutput: [],\n          nTextOutput: [],\n          minDateTextOutput: [],\n          maxDateTextOutput: [],\n          stats: []],\n          glob_stats: {},\n          xmin:num,\n          ymin:num,\n          zmin:num,\n          xmax:num,\n          ymax:num,\n          zmax:num,\n          sum:num\n      };\n  */\n  var curveStatLookup = {};\n  var curveNLookup = {}; // get all the data out of the query array\n\n  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n    var rowXVal = rows[rowIndex].xVal;\n    var rowYVal = rows[rowIndex].yVal;\n    var statKey = rowXVal.toString() + '_' + rowYVal.toString();\n    var stat = rows[rowIndex].stat;\n    var n = rows[rowIndex].sub_data !== null ? rows[rowIndex].sub_data.toString().split(',').length : 0;\n    var minDate = rows[rowIndex].min_secs;\n    var maxDate = rows[rowIndex].max_secs;\n\n    if (stat === undefined || stat === null || stat === 'NULL') {\n      stat = null;\n      n = 0;\n      minDate = null;\n      maxDate = null;\n    } // store flat arrays of all the parsed data, used by the text output and for some calculations later\n\n\n    d.xTextOutput.push(Number(rowXVal));\n    d.yTextOutput.push(Number(rowYVal));\n    d.zTextOutput.push(stat);\n    d.nTextOutput.push(n);\n    d.minDateTextOutput.push(minDate);\n    d.maxDateTextOutput.push(maxDate);\n    curveStatLookup[statKey] = stat;\n    curveNLookup[statKey] = n;\n  } // get the unique x and y values and sort the stats into the 2D z array accordingly\n\n\n  d.x = matsDataUtils.arrayUnique(d.xTextOutput).sort(function (a, b) {\n    return a - b;\n  });\n  d.y = matsDataUtils.arrayUnique(d.yTextOutput).sort(function (a, b) {\n    return a - b;\n  });\n  var i;\n  var j;\n  var currX;\n  var currY;\n  var currStat;\n  var currN;\n  var currStatKey;\n  var currYStatArray;\n  var currYNArray;\n  var sum = 0;\n  var nPoints = 0;\n\n  for (j = 0; j < d.y.length; j++) {\n    currY = d.y[j];\n    currYStatArray = [];\n    currYNArray = [];\n\n    for (i = 0; i < d.x.length; i++) {\n      currX = d.x[i];\n      currStatKey = currX.toString() + '_' + currY.toString();\n      currStat = curveStatLookup[currStatKey];\n      currN = curveNLookup[currStatKey];\n\n      if (currStat === undefined) {\n        currYStatArray.push(null);\n        currYNArray.push(0);\n      } else {\n        sum += currStat;\n        nPoints = nPoints + 1;\n        currYStatArray.push(currStat);\n        currYNArray.push(currN);\n      }\n    }\n\n    d.z.push(currYStatArray);\n    d.n.push(currYNArray);\n  } // calculate statistics\n\n\n  const filteredx = d.x.filter(x => x);\n  const filteredy = d.y.filter(y => y);\n  const filteredz = d.zTextOutput.filter(z => z);\n  d.xmin = Math.min(...filteredx);\n  d.xmax = Math.max(...filteredx);\n  d.ymin = Math.min(...filteredy);\n  d.ymax = Math.max(...filteredy);\n  d.zmin = Math.min(...filteredz);\n  d.zmax = Math.max(...filteredz);\n  d.sum = sum;\n\n  if (d.xmin == \"-Infinity\" || d.x.indexOf(0) !== -1 && 0 < d.xmin) {\n    d.xmin = 0;\n  }\n\n  if (d.ymin == \"-Infinity\" || d.y.indexOf(0) !== -1 && 0 < d.ymin) {\n    d.ymin = 0;\n  }\n\n  if (d.zmin == \"-Infinity\" || d.zTextOutput.indexOf(0) !== -1 && 0 < d.zmin) {\n    d.zmin = 0;\n  }\n\n  if (d.xmax == \"-Infinity\") {\n    d.xmax = 0;\n  }\n\n  if (d.ymax == \"-Infinity\") {\n    d.ymax = 0;\n  }\n\n  if (d.zmax == \"-Infinity\") {\n    d.zmax = 0;\n  }\n\n  const filteredMinDate = d.minDateTextOutput.filter(t => t);\n  const filteredMaxDate = d.maxDateTextOutput.filter(t => t);\n  d.glob_stats['mean'] = sum / nPoints;\n  d.glob_stats['minDate'] = Math.min(...filteredMinDate);\n  d.glob_stats['maxDate'] = Math.max(...filteredMaxDate);\n  d.glob_stats['n'] = nPoints;\n  return {\n    d: d\n  };\n};\n\nmodule.exportDefault(matsDataQueryUtils = {\n  simplePoolQueryWrapSynchronous: simplePoolQueryWrapSynchronous,\n  queryDBTimeSeries: queryDBTimeSeries,\n  queryDBSpecialtyCurve: queryDBSpecialtyCurve,\n  queryMapDB: queryMapDB,\n  queryDBContour: queryDBContour\n});","map":{"version":3,"sources":["packages/randyp:mats-common/imports/startup/server/data_query_util.js"],"names":["matsDataUtils","matsTypes","matsCollections","module","link","v","Meteor","getModelCadence","pool","dataSource","startDate","endDate","rows","cycles","simplePoolQueryWrapSynchronous","cycles_raw","JSON","parse","cycle_seconds","cycles_keys","Object","keys","sort","length","newTime","chosenStartTime","chosenEndTime","chosenStartIdx","chosenEndIdx","foundStart","foundEnd","ti","Number","undefined","startCycles","endCycles","_","union","middleCycles","currCycles","e","c","getTimeInterval","avTime","time_interval","foreCastOffset","dayInMilliSeconds","minCycleTime","Math","min","thisCadence","thisCadenceIdx","indexOf","nextCadenceIdx","statement","isServer","Future","require","queryWrap","wrap","callback","query","err","wait","queryDBTimeSeries","forecastOffset","averageStr","validTimes","hasLevels","forceRegularCadence","plotParams","getPlotParamsFromStack","completenessQCParam","InputTypes","unused","vtCycles","map","x","a","b","intersection","regular","dFuture","d","y","error_x","error_y","subVals","subSecs","subLevs","stats","text","xmin","MAX_VALUE","xmax","MIN_VALUE","ymin","ymax","sum","error","N0","N_times","message","Messages","NO_DATA_FOUND","parsedData","parseQueryDataTimeSeries","data","queryDBSpecialtyCurve","plotType","appType","Settings","findOne","PlotTypes","histogram","parseQueryDataSpecialtyCurve","parseQueryDataHistogram","queryMapDB","variable","varUnits","siteMap","siteName","queryVal","lat","lon","color","dBlue","dBlack","dRed","pFuture","rowIndex","site","sta_name","model_ob_diff","push","min_time","max_time","tooltips","thisSite","find","obj","name","point","textMarker","toFixed","dataBlue","dataBlack","dataRed","queryDBContour","z","n","xTextOutput","yTextOutput","zTextOutput","nTextOutput","minDateTextOutput","maxDateTextOutput","glob_stats","zmin","zmax","parseQueryDataContour","curveTime","curveStats","avtime","avSeconds","stat","time_diff","sub_values","sub_secs","sub_levs","sub_data","toString","split","curr_sub_data","sd_idx","isNaN","Error","NaN","N0_max","max","N_times_max","loopTime","d_idx","this_N0","this_N_times","filteredx","filter","filteredy","curveIndependentVars","independentVar","validtime","hr_of_day","profile","avVal","replace","dailyModelCycle","sub_stats","cycles_missing","floor","missingIdx","dieoff","AppTypes","metexpress","dSorted","didx","elem","curveSubStatsRaw","curveSubSecsRaw","curveSubLevsRaw","concat","apply","curveStatLookup","curveNLookup","rowXVal","xVal","rowYVal","yVal","statKey","minDate","min_secs","maxDate","max_secs","arrayUnique","i","j","currX","currY","currStat","currN","currStatKey","currYStatArray","currYNArray","nPoints","filteredz","filteredMinDate","t","filteredMaxDate","exportDefault","matsDataQueryUtils"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsDataUtils, matsTypes, matsCollections} from 'meteor/randyp:mats-common';\nimport {Meteor} from \"meteor/meteor\";\n\n//const Future = require('fibers/future');\n\n//utility to get the cadence for a particular model, so that the query function\n//knows where to include null points for missing data.\nconst getModelCadence = function (pool, dataSource, startDate, endDate) {\n    var rows = [];\n    var cycles;\n    try {\n        //this query should only return data if the model cadence is irregular.\n        //otherwise, the cadence will be calculated later by the query function.\n        rows = simplePoolQueryWrapSynchronous(pool, \"select cycle_seconds \" +\n            \"from mats_common.primary_model_orders \" +\n            \"where model = \" +\n            \"(select new_model as display_text from mats_common.standardized_model_list where old_model = '\" + dataSource + \"');\");\n        var cycles_raw = JSON.parse(rows[0].cycle_seconds);\n        var cycles_keys = Object.keys(cycles_raw).sort();\n        //there can be difference cadences for different time periods (each time period is a key in cycles_keys,\n        //with the cadences for that period represented as values in cycles_raw), so this section identifies all\n        //time periods relevant to the requested date range, and returns the union of their cadences.\n        if (cycles_keys.length !== 0) {\n            var newTime;\n            var chosenStartTime;\n            var chosenEndTime;\n            var chosenStartIdx;\n            var chosenEndIdx;\n            var foundStart = false;\n            var foundEnd = false;\n            for (var ti = cycles_keys.length - 1; ti >= 0; ti--) {\n                newTime = cycles_keys[ti];\n                if (startDate >= Number(newTime) && !foundStart) {\n                    chosenStartTime = newTime;\n                    chosenStartIdx = ti;\n                    foundStart = true;\n                }\n                if (endDate >= Number(newTime) && !foundEnd) {\n                    chosenEndTime = newTime;\n                    chosenEndIdx = ti;\n                    foundEnd = true;\n                }\n                if (foundStart && foundEnd) {\n                    break;\n                }\n            }\n            if (chosenStartTime !== undefined && chosenEndTime !== undefined) {\n                if (Number(chosenStartTime) === Number(chosenEndTime)) {\n                    cycles = cycles_raw[chosenStartTime];\n                } else if (chosenEndIdx - chosenStartIdx === 1) {\n                    const startCycles = cycles_raw[chosenStartTime];\n                    const endCycles = cycles_raw[chosenEndTime];\n                    cycles = _.union(startCycles, endCycles);\n                } else {\n                    var middleCycles = [];\n                    var currCycles;\n                    for (ti = chosenStartIdx + 1; ti < chosenEndIdx; ti++) {\n                        currCycles = cycles_raw[cycles_keys[ti]];\n                        middleCycles = _.union(middleCycles, currCycles);\n                    }\n                    const startCycles = cycles_raw[chosenStartTime];\n                    const endCycles = cycles_raw[chosenEndTime];\n                    cycles = _.union(startCycles, endCycles, middleCycles);\n                }\n            }\n        }\n    } catch (e) {\n        //ignore - just a safety check, don't want to exit if there isn't a cycles_per_model entry\n        //if there isn't a cycles_per_model entry, it just means that the model has a regular cadence\n    }\n    if (cycles !== null && cycles !== undefined && cycles.length > 0) {\n        for (var c = 0; c < cycles.length; c++) {\n            cycles[c] = cycles[c] * 1000;         // convert to milliseconds\n        }\n    } else {\n        cycles = []; //regular cadence model--cycles will be calculated later by the query function\n    }\n    return cycles;\n};\n\n//this function calculates the interval between the current time and the next time for irregular cadence models.\nconst getTimeInterval = function (avTime, time_interval, foreCastOffset, cycles) {\n    //have to calculate the time_interval\n    var ti;\n    var dayInMilliSeconds = 24 * 3600 * 1000;\n    var minCycleTime = Math.min(...cycles);\n\n    var thisCadence = (avTime % dayInMilliSeconds); //current hour of day (valid time)\n    if (Number(thisCadence) - (Number(foreCastOffset) * 3600 * 1000) < 0) { //check to see if cycle time was on previous day -- if so, need to wrap around 00Z to get current hour of day (cycle time)\n        thisCadence = (Number(thisCadence) - (Number(foreCastOffset) * 3600 * 1000) + dayInMilliSeconds); //current hour of day (cycle time)\n    } else {\n        thisCadence = (Number(thisCadence) - (Number(foreCastOffset) * 3600 * 1000)); //current hour of day (cycle time)\n    }\n\n    var thisCadenceIdx = cycles.indexOf(thisCadence); //fnd our where the current hour of day is in the cycles array\n    if (thisCadenceIdx !== -1) {\n        var nextCadenceIdx = thisCadenceIdx + 1; //choose the next hour of the day\n        if (nextCadenceIdx >= cycles.length) {\n            ti = (dayInMilliSeconds - thisCadence) + minCycleTime; //if we were at the last cycle cadence, wrap back around to the first cycle cadence\n        } else {\n            ti = cycles[nextCadenceIdx] - cycles[thisCadenceIdx]; //otherwise take the difference between the current and next hours of the day.\n        }\n    } else {\n        ti = time_interval; //if for some reason the current hour of the day isn't in the cycles array, default to the regular cadence interval\n    }\n\n    return ti;\n};\n\n//utility for querying the DB\nconst simplePoolQueryWrapSynchronous = function (pool, statement) {\n    /*\n     simple synchronous query of statement to the specified pool.\n     params :\n     pool - a predefined db pool (usually defined in main.js). i.e. wfip2Pool = mysql.createPool(wfip2Settings);\n     statement - String - a valid sql statement\n     actions - queries database and will wait until query returns.\n     return: rowset - an array of rows\n     throws: error\n     */\n    if (Meteor.isServer) {\n        const Future = require('fibers/future');\n        const queryWrap = Future.wrap(function (pool, statement, callback) {\n            pool.query(statement, function (err, rows) {\n                return callback(err, rows);\n            });\n        });\n        return queryWrap(pool, statement).wait();\n    }\n};\n\n//this method queries the database for timeseries plots\nconst queryDBTimeSeries = function (pool, statement, dataSource, forecastOffset, startDate, endDate, averageStr, validTimes, hasLevels, forceRegularCadence) {\n    //upper air is only verified at 00Z and 12Z, so you need to force irregular models to verify at that regular cadence\n    const Future = require('fibers/future');\n    if (Meteor.isServer) {\n        const plotParams = matsDataUtils.getPlotParamsFromStack();\n        const completenessQCParam = Number(plotParams[\"completeness\"]) / 100;\n\n        var cycles = getModelCadence(pool, dataSource, startDate, endDate); // if irregular model cadence, get cycle times. If regular, get empty array.\n        if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n            var vtCycles = validTimes.map(function (x) {\n                return (Number(x) - forecastOffset) * 3600 * 1000;\n            }); // selecting validTimes makes the cadence irregular\n            vtCycles = vtCycles.map(function (x) {\n                return x < 0 ? (x + 24 * 3600 * 1000) : x;\n            }); // make sure no cycles are negative\n            vtCycles = vtCycles.sort(function (a, b) {\n                return Number(a) - Number(b);\n            }); //sort 'em\n            cycles = cycles.length > 0 ? _.intersection(cycles, vtCycles) : vtCycles; // if we already had cycles get the ones that correspond to valid times\n        }\n        const regular = (forceRegularCadence || averageStr !== \"None\" || !(cycles !== null && cycles.length > 0)); // If curves have averaging, the cadence is always regular, i.e. it's the cadence of the average\n\n        var dFuture = new Future();\n        var d = {// d will contain the curve data\n            x: [],\n            y: [],\n            error_x: [],\n            error_y: [],\n            subVals: [],\n            subSecs: [],\n            subLevs: [],\n            stats: [],\n            text: [],\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            sum: 0\n        };\n        var error = \"\";\n        var N0 = [];\n        var N_times = [];\n\n        pool.query(statement, function (err, rows) {\n            // query callback - build the curve data from the results - or set an error\n            if (err !== undefined && err !== null) {\n                error = err.message;\n            } else if (rows === undefined || rows === null || rows.length === 0) {\n                error = matsTypes.Messages.NO_DATA_FOUND;\n            } else {\n                const parsedData = parseQueryDataTimeSeries(pool, rows, d, completenessQCParam, hasLevels, averageStr, forecastOffset, cycles, regular);\n                d = parsedData.d;\n                N0 = parsedData.N0;\n                N_times = parsedData.N_times;\n                cycles = parsedData.cycles;\n            }\n            // done waiting - have results\n            dFuture['return']();\n        });\n\n        // wait for future to finish\n        dFuture.wait();\n        return {\n            data: d,\n            error: error,\n            N0: N0,\n            N_times: N_times,\n            averageStr: averageStr,\n            cycles: cycles,\n        };\n    }\n};\n\n//this method queries the database for specialty curves such as profiles, dieoffs, threshold plots, valid time plots, and histograms\nconst queryDBSpecialtyCurve = function (pool, statement, plotType, hasLevels) {\n    if (Meteor.isServer) {\n        const Future = require('fibers/future');\n        const plotParams = matsDataUtils.getPlotParamsFromStack();\n        const completenessQCParam = Number(plotParams[\"completeness\"]) / 100;\n        const appType = matsCollections.Settings.findOne({}).appType;\n\n        var dFuture = new Future();\n        var d = {// d will contain the curve data\n            x: [],\n            y: [],\n            error_x: [],\n            error_y: [],\n            subVals: [],\n            subSecs: [],\n            subLevs: [],\n            stats: [],\n            text: [],\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            sum: 0\n        };\n\n        var error = \"\";\n        var N0 = [];\n        var N_times = [];\n\n        pool.query(statement, function (err, rows) {\n            // query callback - build the curve data from the results - or set an error\n            if (err !== undefined && err !== null) {\n                error = err.message;\n            } else if (rows === undefined || rows === null || rows.length === 0) {\n                error = matsTypes.Messages.NO_DATA_FOUND;\n            } else {\n                var parsedData;\n                if (plotType !== matsTypes.PlotTypes.histogram) {\n                    parsedData = parseQueryDataSpecialtyCurve(rows, d, completenessQCParam, plotType, appType, hasLevels);\n                } else {\n                    parsedData = parseQueryDataHistogram(d, rows, hasLevels);\n                }\n                d = parsedData.d;\n                N0 = parsedData.N0;\n                N_times = parsedData.N_times;\n            }\n            dFuture['return']();\n        });\n\n        // wait for future to finish\n        dFuture.wait();\n        return {\n            data: d,\n            error: error,\n            N0: N0,\n            N_times: N_times,\n        };\n    }\n};\n\n//this method queries the database for map plots\nconst queryMapDB = function (pool, statement, dataSource, variable, varUnits, siteMap) {\n    if (Meteor.isServer) {\n        // d will contain the curve data\n        var d = {\n            siteName: [],\n            queryVal: [],\n            lat: [],\n            lon: [],\n            color: [],\n            stats: [],\n            text: []\n        };\n        // for biases <= -1\n        var dBlue = {\n            siteName: [],\n            queryVal: [],\n            lat: [],\n            lon: [],\n            stats: [],\n            text: [],\n            color: \"rgb(0,0,255)\"\n        };\n        // for biases > -1 and < 1\n        var dBlack = {\n            siteName: [],\n            queryVal: [],\n            lat: [],\n            lon: [],\n            stats: [],\n            text: [],\n            color: \"rgb(0,0,0)\"\n        };\n        // for biases >= 1\n        var dRed = {\n            siteName: [],\n            queryVal: [],\n            lat: [],\n            lon: [],\n            stats: [],\n            text: [],\n            color: \"rgb(255,0,0)\"\n        };\n\n        var error = \"\";\n        const Future = require('fibers/future');\n        var pFuture = new Future();\n        pool.query(statement, function (err, rows) {\n            // query callback - build the curve data from the results - or set an error\n            if (err !== undefined && err !== null) {\n                error = err.message;\n            } else if (rows === undefined || rows === null || rows.length === 0) {\n                error = matsTypes.Messages.NO_DATA_FOUND;\n            } else {\n                var queryVal;\n                for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n                    const site = rows[rowIndex].sta_name;\n                    queryVal = rows[rowIndex].model_ob_diff;\n                    d.siteName.push(site);\n                    d.queryVal.push(queryVal);\n                    d.stats.push({\n                        N_times: rows[rowIndex].N_times,\n                        min_time: rows[rowIndex].min_time,\n                        max_time: rows[rowIndex].max_time\n                    });\n                    var tooltips = site +\n                        \"<br>\" + \"variable: \" + variable +\n                        \"<br>\" + \"model: \" + dataSource +\n                        \"<br>\" + \"model-obs: \" + queryVal + \" \" + varUnits +\n                        \"<br>\" + \"n: \" + rows[rowIndex].N_times;\n                    d.text.push(tooltips);\n\n                    var thisSite = siteMap.find(obj => {\n                        return obj.name === site;\n                    });\n                    d.lat.push(thisSite.point[0]);\n                    d.lon.push(thisSite.point[1]);\n\n                    var textMarker = queryVal === null ? \"\" : queryVal.toFixed(0);\n                    if (queryVal <= -1) {\n                        d.color.push(\"rgb(0,0,255)\");\n                        dBlue.siteName.push(site);\n                        dBlue.queryVal.push(queryVal);\n                        dBlue.text.push(textMarker);\n                        dBlue.lat.push(thisSite.point[0]);\n                        dBlue.lon.push(thisSite.point[1]);\n                    } else if (queryVal >= 1) {\n                        d.color.push(\"rgb(255,0,0)\");\n                        dRed.siteName.push(site);\n                        dRed.queryVal.push(queryVal);\n                        dRed.text.push(textMarker);\n                        dRed.lat.push(thisSite.point[0]);\n                        dRed.lon.push(thisSite.point[1]);\n                    } else {\n                        d.color.push(\"rgb(0,0,0)\");\n                        dBlack.siteName.push(site);\n                        dBlack.queryVal.push(queryVal);\n                        dBlack.text.push(textMarker);\n                        dBlack.lat.push(thisSite.point[0]);\n                        dBlack.lon.push(thisSite.point[1]);\n                    }\n                }// end of loop row\n            }\n            // done waiting - have results\n            pFuture['return']();\n        });\n\n        // wait for future to finish\n        pFuture.wait();\n        return {\n            data: d,    // [sub_values,sub_secs] as arrays\n            dataBlue: dBlue,    // [sub_values,sub_secs] as arrays\n            dataBlack: dBlack,    // [sub_values,sub_secs] as arrays\n            dataRed: dRed,    // [sub_values,sub_secs] as arrays\n            error: error,\n        };\n    }\n};\n\n//this method queries the database for contour plots\nconst queryDBContour = function (pool, statement) {\n    if (Meteor.isServer) {\n        const Future = require('fibers/future');\n\n        var dFuture = new Future();\n        var d = {// d will contain the curve data\n            x: [],\n            y: [],\n            z: [],\n            n: [],\n            text: [],\n            xTextOutput: [],\n            yTextOutput: [],\n            zTextOutput: [],\n            nTextOutput: [],\n            minDateTextOutput: [],\n            maxDateTextOutput: [],\n            stats: [],\n            glob_stats: {},\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            zmin: Number.MAX_VALUE,\n            zmax: Number.MIN_VALUE,\n            sum: 0\n        };\n\n        var error = \"\";\n        pool.query(statement, function (err, rows) {\n            // query callback - build the curve data from the results - or set an error\n            if (err !== undefined && err !== null) {\n                error = err.message;\n            } else if (rows === undefined || rows === null || rows.length === 0) {\n                error = matsTypes.Messages.NO_DATA_FOUND;\n            } else {\n                const parsedData = parseQueryDataContour(rows, d);\n                d = parsedData.d;\n            }\n            dFuture['return']();\n        });\n\n        // wait for future to finish\n        dFuture.wait();\n        return {\n            data: d,\n            error: error\n        };\n    }\n};\n\n//this method parses the returned query data for timeseries plots\nconst parseQueryDataTimeSeries = function (pool, rows, d, completenessQCParam, hasLevels, averageStr, foreCastOffset, cycles, regular) {\n    /*\n        var d = {// d will contain the curve data\n            x: [],\n            y: [],\n            error_x: [],   // curveTime\n            error_y: [],   // values\n            subVals: [],   //subVals\n            subSecs: [],   //subSecs\n            subLevs: [],   //subLevs\n            stats: [],     //pointStats\n            text: [],\n            glob_stats: {},     //curveStats\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            sum: 0\n        };\n    */\n    d.error_x = null;  // time series doesn't use x errorbars\n    var N0 = [];\n    var N_times = [];\n    var xmax = Number.MIN_VALUE;\n    var xmin = Number.MAX_VALUE;\n\n    var curveTime = [];\n    var curveStats = [];\n    var subVals = [];\n    var subSecs = [];\n    var subLevs = [];\n\n    var time_interval = rows.length > 1 ? Number(rows[1].avtime) - Number(rows[0].avtime) : undefined; //calculate a base time interval -- will be used if data is regular\n    for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n\n        var avSeconds = Number(rows[rowIndex].avtime);\n        var avTime = avSeconds * 1000;\n        xmin = avTime < xmin ? avTime : xmin;\n        xmax = avTime > xmax ? avTime : xmax;\n        var stat = rows[rowIndex].stat;\n        N0.push(rows[rowIndex].N0);             // number of values that go into a time series point\n        N_times.push(rows[rowIndex].N_times);   // number of times that go into a time series point\n\n        // find the minimum time_interval. For regular models, this will differ from the previous time_interval\n        // if the interval was artificially large due to missing values. For irregular models, we need the minimum\n        // interval to be sure we don't accidentally go past the next data point.\n        if (rowIndex < rows.length - 1) {\n            var time_diff = Number(rows[rowIndex + 1].avtime) - Number(rows[rowIndex].avtime);\n            if (time_diff < time_interval) {\n                time_interval = time_diff;\n            }\n        }\n\n        // store sub values that will later be used for calculating error bar statistics.\n        var sub_values = [];\n        var sub_secs = [];\n        var sub_levs = [];\n        if (stat !== null && stat !== \"NULL\" && rows[rowIndex].sub_data !== undefined) {\n            try {\n                var sub_data = rows[rowIndex].sub_data.toString().split(',');\n                var curr_sub_data;\n                for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {\n                    curr_sub_data = sub_data[sd_idx].split(';');\n                    sub_values.push(Number(curr_sub_data[0]));\n                    sub_secs.push(Number(curr_sub_data[1]));\n                    if (hasLevels) {\n                        if (!isNaN(Number(curr_sub_data[2]))) {\n                            sub_levs.push(Number(curr_sub_data[2]));\n                        } else {\n                            sub_levs.push(curr_sub_data[2]);\n                        }\n                    }\n                }\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in parseQueryDataTimeSeries. The expected fields don't seem to be present in the results cache: \" + e.message;\n                throw new Error(e.message);\n            }\n        } else {\n            sub_values = NaN;\n            sub_secs = NaN;\n            if (hasLevels) {\n                sub_levs = NaN;\n            }\n        }\n        curveTime.push(avTime);\n        curveStats.push(stat);\n        subVals.push(sub_values);\n        subSecs.push(sub_secs);\n        if (hasLevels) {\n            subLevs.push(sub_levs);\n        }\n    }\n\n    var N0_max = Math.max(...N0);\n    var N_times_max = Math.max(...N_times);\n\n    if (xmin < Number(rows[0].avtime) * 1000 || averageStr !== \"None\") {\n        xmin = Number(rows[0].avtime) * 1000;\n    }\n\n    time_interval = time_interval * 1000;\n    var loopTime = xmin;\n    var sum = 0;\n    while (loopTime <= xmax) {\n        var d_idx = curveTime.indexOf(loopTime);\n        if (d_idx < 0) {\n            if (hasLevels) {\n                //d.push([loopTime, null, -1, NaN, NaN, NaN]);// add a null for missing data\n                d.x.push(loopTime);\n                d.y.push(null);\n                //d.error_x not used\n                d.error_y.push(null);   //placeholder\n                d.subVals.push(NaN);\n                d.subSecs.push(NaN);\n                d.subLevs.push(NaN);\n            } else {\n                //d.push([loopTime, null, -1, NaN, NaN]);     // add a null for missing data\n                d.x.push(loopTime);\n                d.y.push(null);\n                //d.error_x not used\n                d.error_y.push(null); //placeholder\n                d.subVals.push(NaN);\n                d.subSecs.push(NaN);\n            }\n        } else {\n            var this_N0 = N0[d_idx];\n            var this_N_times = N_times[d_idx];\n            // Make sure that we don't have any points with far less data than the rest of the graph, and that\n            // we don't have any points with a smaller completeness value than specified by the user.\n            if (this_N0 < 0.1 * N0_max || this_N_times < completenessQCParam * N_times_max) {\n                if (hasLevels) {\n//                    d.push([loopTime, null, -1, NaN, NaN, NaN]);     // add a null if this time doesn't pass QC\n                    d.x.push(loopTime);\n                    d.y.push(null);\n                    //d.error_x not used\n                    d.error_y.push(null); //placeholder\n                    d.subVals.push(NaN);\n                    d.subSecs.push(NaN);\n                    d.subLevs.push(NaN);\n                } else {\n//                    d.push([loopTime, null, -1, NaN, NaN]);     // add a null if this time doesn't pass QC\n                    d.x.push(loopTime);\n                    d.y.push(null);\n                    //d.error_x not used\n                    d.error_y.push(null); //placeholder\n                    d.subVals.push(NaN);\n                    d.subSecs.push(NaN);\n                }\n            } else {\n                sum += curveStats[d_idx];\n                if (hasLevels) {\n                    //d.push([loopTime, curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);   // else add the real data\n                    d.x.push(loopTime);\n                    d.y.push(curveStats[d_idx]);\n                    //d.error_x not used\n                    d.error_y.push(null);\n                    d.subVals.push(subVals[d_idx]);\n                    d.subSecs.push(subSecs[d_idx]);\n                    d.subLevs.push(subLevs[d_idx]);\n                } else {\n                    //d.push([loopTime, curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx]]);   // else add the real data\n                    d.x.push(loopTime);\n                    d.y.push(curveStats[d_idx]);\n                    //d.error_x not used\n                    d.error_y.push(null);\n                    d.subVals.push(subVals[d_idx]);\n                    d.subSecs.push(subSecs[d_idx]);\n                }\n            }\n        }\n        if (!regular) {  // it is a model that has an irregular set of intervals, i.e. an irregular cadence\n            time_interval = getTimeInterval(loopTime, time_interval, foreCastOffset, cycles);   // the time interval most likely will not be the one calculated above\n        }\n        loopTime = loopTime + time_interval;    // advance to the next time.\n    }\n    if (regular) {\n        cycles = [time_interval];   // regular models will return one cycle cadence\n    }\n    const filteredx = d.x.filter(x => x);\n    const filteredy = d.y.filter(y => y);\n    d.xmin = Math.min(...filteredx);\n    d.xmax = Math.max(...filteredx);\n    d.ymin = Math.min(...filteredy);\n    d.ymax = Math.max(...filteredy);\n    d.sum = sum;\n\n    if (d.xmin == \"-Infinity\" || (d.x.indexOf(0) !== -1 && 0 < d.xmin)) {\n        d.xmin = 0;\n    }\n    if (d.ymin == \"-Infinity\" || (d.y.indexOf(0) !== -1 && 0 < d.ymin)) {\n        d.ymin = 0;\n    }\n\n    if (d.xmax == \"-Infinity\") {\n        d.xmax = 0;\n    }\n    if (d.ymax == \"-Infinity\") {\n        d.ymax = 0;\n    }\n    return {\n        d: d,\n        N0: N0,\n        N_times: N_times,\n        cycles: cycles\n    };\n};\n\n//this method parses the returned query data for specialty curves such as profiles, dieoffs, threshold plots, and valid time plots\nconst parseQueryDataSpecialtyCurve = function (rows, d, completenessQCParam, plotType, appType, hasLevels) {\n    /*\n        var d = {// d will contain the curve data\n            x: [],\n            y: [],\n            error_x: [],   // curveTime\n            error_y: [],   // values\n            subVals: [],   //subVals\n            subSecs: [],   //subSecs\n            subLevs: [],   //subLevs\n            stats: [],     //pointStats\n            text: [],\n            glob_stats: {},     //curveStats\n            xmin:num,\n            ymin:num,\n            xmax:num,\n            ymax:num,\n            sum:num;\n        };\n    */\n    var N0 = [];\n    var N_times = [];\n    var curveIndependentVars = [];\n    var curveStats = [];\n    var subVals = [];\n    var subSecs = [];\n    var subLevs = [];\n    for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n        var independentVar;\n        if (plotType === matsTypes.PlotTypes.validtime) {\n            independentVar = Number(rows[rowIndex].hr_of_day);\n        } else if (plotType === matsTypes.PlotTypes.profile) {\n            independentVar = Number((rows[rowIndex].avVal).toString().replace('P', ''));\n        } else if (plotType === matsTypes.PlotTypes.dailyModelCycle) {\n            independentVar = Number(rows[rowIndex].avtime) * 1000;\n        } else {\n            independentVar = Number(rows[rowIndex].avtime);\n        }\n\n        var stat = rows[rowIndex].stat;\n        N0.push(rows[rowIndex].N0);             // number of values that go into a point on the graph\n        N_times.push(rows[rowIndex].N_times);   // number of times that go into a point on the graph\n\n        var sub_stats = [];\n        var sub_secs = [];\n        var sub_levs = [];\n        if (stat !== null && stat !== \"NULL\" && rows[rowIndex].sub_data !== undefined) {\n            try {\n                var sub_data = rows[rowIndex].sub_data.toString().split(',');\n                var curr_sub_data;\n                for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {\n                    curr_sub_data = sub_data[sd_idx].split(';');\n                    sub_stats.push(Number(curr_sub_data[0]));\n                    sub_secs.push(Number(curr_sub_data[1]));\n                    if (hasLevels) {\n                        if (!isNaN(Number(curr_sub_data[2]))) {\n                            sub_levs.push(Number(curr_sub_data[2]));\n                        } else {\n                            sub_levs.push(curr_sub_data[2]);\n                        }\n                    }\n                }\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in parseQueryDataSpecialtyCurve. The expected fields don't seem to be present in the results cache: \" + e.message;\n                throw new Error(e.message);\n            }\n        } else {\n            sub_stats = NaN;\n            sub_secs = NaN;\n            if (hasLevels) {\n                sub_levs = NaN;\n            }\n        }\n\n        // deal with missing forecast cycles for dailyModelCycle plot type\n        if (plotType === matsTypes.PlotTypes.dailyModelCycle && rowIndex > 0 && (Number(independentVar) - Number(rows[rowIndex - 1].avtime * 1000)) > 3600 * 24 * 1000) {\n            const cycles_missing = Math.floor((Number(independentVar) - Number(rows[rowIndex - 1].avtime * 1000)) / (3600 * 24 * 1000));\n            for (var missingIdx = cycles_missing; missingIdx > 0; missingIdx--) {\n                curveIndependentVars.push(independentVar - 3600 * 24 * 1000 * missingIdx);\n                curveStats.push(null);\n                subVals.push(NaN);\n                subSecs.push(NaN);\n                if (hasLevels) {\n                    subLevs.push(NaN);\n                }\n            }\n        }\n        curveIndependentVars.push(independentVar);\n        curveStats.push(stat);\n        subVals.push(sub_stats);\n        subSecs.push(sub_secs);\n        if (hasLevels) {\n            subLevs.push(sub_levs);\n        }\n    }\n    var N0_max = Math.max(...N0);\n    var N_times_max = Math.max(...N_times);\n    var sum = 0;\n    for (var d_idx = 0; d_idx < curveIndependentVars.length; d_idx++) {\n        var this_N0 = N0[d_idx];\n        var this_N_times = N_times[d_idx];\n        // Make sure that we don't have any points with far less data than the rest of the graph, and that\n        // we don't have any points with a smaller completeness value than specified by the user.\n        if (this_N0 < 0.05 * N0_max || this_N_times < completenessQCParam * N_times_max) {\n            if (plotType === matsTypes.PlotTypes.profile) {\n                // profile has the stat first, and then the independent var. The others have independent var and then stat.\n                // this is in the pattern of x-plotted-variable, y-plotted-variable.\n                //d.push([null, curveIndependentVars[d_idx], -1, NaN, NaN, NaN]);\n                d.x.push(null);\n                d.y.push(curveIndependentVars[d_idx]);\n                d.error_x.push(null);  // placeholder\n                //d.error_y not used for profile\n                d.subVals.push(NaN);\n                d.subSecs.push(NaN);\n                d.subLevs.push(NaN);\n            } else if (plotType !== matsTypes.PlotTypes.dieoff) {\n                // for dieoffs, we don't want to add a null for missing data. Just don't have a point for that FHR.\n                if (hasLevels) {\n                    //d.push([curveIndependentVars[d_idx], null, -1, NaN, NaN, NaN]);\n                    d.x.push(curveIndependentVars[d_idx]);\n                    d.y.push(null);\n                    //d.error_x not used for curves other than profile\n                    d.error_y.push(null);  // placeholder\n                    d.subVals.push(NaN);\n                    d.subSecs.push(NaN);\n                    d.subLevs.push(NaN);\n                } else {\n                    //d.push([curveIndependentVars[d_idx], null, -1, NaN, NaN]);\n                    d.x.push(curveIndependentVars[d_idx]);\n                    d.y.push(null);\n                    //d.error_x not used for curves other than profile\n                    d.error_y.push(null);  // placeholder\n                    d.subVals.push(NaN);\n                    d.subSecs.push(NaN);\n                }\n            }\n        } else {\n            // else add the real data\n            sum += curveStats[d_idx];\n            if (plotType === matsTypes.PlotTypes.profile) {\n                // profile has the stat first, and then the independent var. The others have independent var and then stat.\n                // this is in the pattern of x-plotted-variable, y-plotted-variable.\n//                d.push([curveStats[d_idx], curveIndependentVars[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);\n                d.x.push(curveStats[d_idx]);\n                d.y.push(curveIndependentVars[d_idx]);\n                d.error_x.push(null); // placeholder\n                //d.error_y not used for curves other than profile\n                d.subVals.push(subVals[d_idx]);\n                d.subSecs.push(subSecs[d_idx]);\n                d.subLevs.push(subLevs[d_idx]);\n            } else if (hasLevels) {\n//                d.push([curveIndependentVars[d_idx], curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx], subLevs[d_idx]]);\n                d.x.push(curveIndependentVars[d_idx]);\n                d.y.push(curveStats[d_idx]);\n                //d.error_x not used for curves other than profile\n                d.error_y.push(null);  // placeholder\n                d.subVals.push(subVals[d_idx]);\n                d.subSecs.push(subSecs[d_idx]);\n                d.subLevs.push(subLevs[d_idx]);\n            } else {\n//                d.push([curveIndependentVars[d_idx], curveStats[d_idx], -1, subVals[d_idx], subSecs[d_idx]]);\n                d.x.push(curveIndependentVars[d_idx]);\n                d.y.push(curveStats[d_idx]);\n                //d.error_x not used for curves other than profile\n                d.error_y.push(null);  // placeholder\n                d.subVals.push(subVals[d_idx]);\n                d.subSecs.push(subSecs[d_idx]);\n            }\n        }\n    }\n\n    // the met levels are ordered as strings, so we need to re-sort them\n    if (plotType === matsTypes.PlotTypes.profile && appType === matsTypes.AppTypes.metexpress) {\n        var dSorted = [];\n        for (var didx = 0; didx < d.y.length; didx++) {\n            dSorted.push({\n                y: d.y[didx],\n                x: d.x[didx],\n                error_x: d.error_x[didx],\n                subVals: d.subVals[didx],\n                subSecs: d.subSecs[didx],\n                subLevs: d.subLevs[didx]\n            });\n        }\n        d.y = [];\n        d.x = [];\n        d.error_x = [];\n        d.subVals = [];\n        d.subSecs = [];\n        d.subLevs = [];\n        dSorted.sort(function(a,b) { return a.y - b.y; });\n        dSorted.map(function (elem) {\n            d.y.push(elem.y);\n            d.x.push(elem.x);\n            d.error_x.push(elem.error_x);\n            d.subVals.push(elem.subVals);\n            d.subSecs.push(elem.subSecs);\n            d.subLevs.push(elem.subLevs);\n        });\n    }\n\n    const filteredx = d.x.filter(x => x);\n    const filteredy = d.y.filter(y => y);\n    d.xmin = Math.min(...filteredx);\n    d.xmax = Math.max(...filteredx);\n    d.ymin = Math.min(...filteredy);\n    d.ymax = Math.max(...filteredy);\n    d.sum = sum;\n\n    if (d.xmin == \"-Infinity\" || (d.x.indexOf(0) !== -1 && 0 < d.xmin)) {\n        d.xmin = 0;\n    }\n    if (d.ymin == \"-Infinity\" || (d.y.indexOf(0) !== -1 && 0 < d.ymin)) {\n        d.ymin = 0;\n    }\n\n    if (d.xmax == \"-Infinity\") {\n        d.xmax = 0;\n    }\n    if (d.ymax == \"-Infinity\") {\n        d.ymax = 0;\n    }\n\n    return {\n        d: d,\n        N0: N0,\n        N_times: N_times\n    };\n};\n\n// this method parses the returned query data for histograms\nconst parseQueryDataHistogram = function (d, rows, hasLevels) {\n    /*\n        var d = {// d will contain the curve data\n            x: [], //placeholder\n            y: [], //placeholder\n            error_x: [], // unused\n            error_y: [], // unused\n            subVals: [],\n            subSecs: [],\n            subLevs: [],\n            glob_stats: [], // placeholder\n            bin_stats: [], // placeholder\n            text: [] //placeholder\n            xmin:num,\n            xmax:num,\n            ymin:num,\n            ymax:num\n        };\n    */\n\n    // these arrays hold all the sub values and seconds (and levels) until they are sorted into bins\n    var curveSubStatsRaw = [];\n    var curveSubSecsRaw = [];\n    var curveSubLevsRaw = [];\n\n    // parse the data returned from the query\n    for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n\n        var stat = rows[rowIndex].stat;\n        var sub_stats = [];\n        var sub_secs = [];\n        var sub_levs = [];\n        if (stat !== null && stat !== \"NULL\" && rows[rowIndex].sub_data !== undefined) {\n            try {\n                var sub_data = rows[rowIndex].sub_data.toString().split(',');\n                var curr_sub_data;\n                for (var sd_idx = 0; sd_idx < sub_data.length; sd_idx++) {\n                    curr_sub_data = sub_data[sd_idx].split(';');\n                    sub_stats.push(Number(curr_sub_data[0]));\n                    sub_secs.push(Number(curr_sub_data[1]));\n                    if (hasLevels) {\n                            if (!isNaN(Number(curr_sub_data[2]))) {\n                                sub_levs.push(Number(curr_sub_data[2]));\n                            } else {\n                                sub_levs.push(curr_sub_data[2]);\n                            }\n                        }\n                        curveSubLevsRaw.push(sub_levs);\n                    }\n                curveSubStatsRaw.push(sub_stats);\n                curveSubSecsRaw.push(sub_secs);\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in parseQueryDataHistogram. The expected fields don't seem to be present in the results cache: \" + e.message;\n                throw new Error(e.message);\n            }\n        }\n    }\n\n    // we don't have bins yet, so we want all of the data in one array\n    const subVals = [].concat.apply([], curveSubStatsRaw);\n    const subSecs = [].concat.apply([], curveSubSecsRaw);\n    var subLevs;\n    if (hasLevels) {\n        subLevs = [].concat.apply([], curveSubLevsRaw);\n    }\n\n    d.subVals = subVals;\n    d.subSecs = subSecs;\n    d.subLevs = subLevs;\n\n    return {\n        d: d,\n        N0: subVals.length,\n        N_times: subSecs.length\n    };\n};\n\n//this method parses the returned query data for contour plots\nconst parseQueryDataContour = function (rows, d) {\n    /*\n        var d = {// d will contain the curve data\n            x: [],\n            y: [],\n            z: [],\n            n: [],\n            text: [],\n            xTextOutput: [],\n            yTextOutput: [],\n            zTextOutput: [],\n            nTextOutput: [],\n            minDateTextOutput: [],\n            maxDateTextOutput: [],\n            stats: []],\n            glob_stats: {},\n            xmin:num,\n            ymin:num,\n            zmin:num,\n            xmax:num,\n            ymax:num,\n            zmax:num,\n            sum:num\n        };\n    */\n    var curveStatLookup = {};\n    var curveNLookup = {};\n    // get all the data out of the query array\n    for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n        var rowXVal = rows[rowIndex].xVal;\n        var rowYVal = rows[rowIndex].yVal;\n        var statKey = rowXVal.toString() + '_' + rowYVal.toString();\n        var stat = rows[rowIndex].stat;\n        var n = rows[rowIndex].sub_data !== null ? rows[rowIndex].sub_data.toString().split(',').length : 0;\n        var minDate = rows[rowIndex].min_secs;\n        var maxDate = rows[rowIndex].max_secs;\n        if (stat === undefined || stat === null || stat === 'NULL') {\n            stat = null;\n            n = 0;\n            minDate = null;\n            maxDate = null;\n        }\n        // store flat arrays of all the parsed data, used by the text output and for some calculations later\n        d.xTextOutput.push(Number(rowXVal));\n        d.yTextOutput.push(Number(rowYVal));\n        d.zTextOutput.push(stat);\n        d.nTextOutput.push(n);\n        d.minDateTextOutput.push(minDate);\n        d.maxDateTextOutput.push(maxDate);\n        curveStatLookup[statKey] = stat;\n        curveNLookup[statKey] = n;\n    }\n    // get the unique x and y values and sort the stats into the 2D z array accordingly\n    d.x = matsDataUtils.arrayUnique(d.xTextOutput).sort(function (a, b) {\n        return a - b\n    });\n    d.y = matsDataUtils.arrayUnique(d.yTextOutput).sort(function (a, b) {\n        return a - b\n    });\n    var i;\n    var j;\n    var currX;\n    var currY;\n    var currStat;\n    var currN;\n    var currStatKey;\n    var currYStatArray;\n    var currYNArray;\n    var sum = 0;\n    var nPoints = 0;\n    for (j = 0; j < d.y.length; j++) {\n        currY = d.y[j];\n        currYStatArray = [];\n        currYNArray = [];\n        for (i = 0; i < d.x.length; i++) {\n            currX = d.x[i];\n            currStatKey = currX.toString() + '_' + currY.toString();\n            currStat = curveStatLookup[currStatKey];\n            currN = curveNLookup[currStatKey];\n            if (currStat === undefined) {\n                currYStatArray.push(null);\n                currYNArray.push(0);\n            } else {\n                sum += currStat;\n                nPoints = nPoints + 1;\n                currYStatArray.push(currStat);\n                currYNArray.push(currN);\n            }\n        }\n        d.z.push(currYStatArray);\n        d.n.push(currYNArray);\n    }\n\n    // calculate statistics\n    const filteredx = d.x.filter(x => x);\n    const filteredy = d.y.filter(y => y);\n    const filteredz = d.zTextOutput.filter(z => z);\n    d.xmin = Math.min(...filteredx);\n    d.xmax = Math.max(...filteredx);\n    d.ymin = Math.min(...filteredy);\n    d.ymax = Math.max(...filteredy);\n    d.zmin = Math.min(...filteredz);\n    d.zmax = Math.max(...filteredz);\n    d.sum = sum;\n\n    if (d.xmin == \"-Infinity\" || (d.x.indexOf(0) !== -1 && 0 < d.xmin)) {\n        d.xmin = 0;\n    }\n    if (d.ymin == \"-Infinity\" || (d.y.indexOf(0) !== -1 && 0 < d.ymin)) {\n        d.ymin = 0;\n    }\n    if (d.zmin == \"-Infinity\" || (d.zTextOutput.indexOf(0) !== -1 && 0 < d.zmin)) {\n        d.zmin = 0;\n    }\n\n    if (d.xmax == \"-Infinity\") {\n        d.xmax = 0;\n    }\n    if (d.ymax == \"-Infinity\") {\n        d.ymax = 0;\n    }\n    if (d.zmax == \"-Infinity\") {\n        d.zmax = 0;\n    }\n\n    const filteredMinDate = d.minDateTextOutput.filter(t => t);\n    const filteredMaxDate = d.maxDateTextOutput.filter(t => t);\n    d.glob_stats['mean'] = sum / nPoints;\n    d.glob_stats['minDate'] = Math.min(...filteredMinDate);\n    d.glob_stats['maxDate'] = Math.max(...filteredMaxDate);\n    d.glob_stats['n'] = nPoints;\n\n    return {\n        d: d\n    };\n};\n\nexport default matsDataQueryUtils = {\n\n    simplePoolQueryWrapSynchronous: simplePoolQueryWrapSynchronous,\n    queryDBTimeSeries: queryDBTimeSeries,\n    queryDBSpecialtyCurve: queryDBSpecialtyCurve,\n    queryMapDB: queryMapDB,\n    queryDBContour: queryDBContour\n\n}\n\n\n"]},"sourceType":"script","hash":"66453a18837e059cc49be9842286f6d3226fbf56"}
