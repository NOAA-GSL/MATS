{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_dieoff.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"server/dataFunctions/data_dieoff.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_dieoff.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_dieoff.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/dataFunctions/data_dieoff.js"}},"code":"let matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataDieOff = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.dieoff;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var forecastLengthStr = curve['dieoff-type'];\n    var forecastLengthOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'dieoff-type'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var forecastLength = forecastLengthOptionsMap[forecastLengthStr][0];\n    var validTimes;\n    var validTimeClause = \"\";\n    var utcCycleStart;\n    var utcCycleStartClause = \"\";\n    var dateRangeClause = \"and m0.time >= \" + fromSecs + \" and m0.time <= \" + toSecs;\n\n    if (forecastLength === matsTypes.ForecastTypes.dieoff) {\n      validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n\n      if (validTimes.length !== 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \"and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n    } else if (forecastLength === matsTypes.ForecastTypes.utcCycle) {\n      utcCycleStart = Number(curve['utc-cycle-start']);\n      utcCycleStartClause = \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN(\" + utcCycleStart + \")\";\n    } else {\n      dateRangeClause = \"and (m0.time - m0.fcst_len*3600) = \" + fromSecs;\n    } // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"SELECT m0.fcst_len AS avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"{{dateRangeClause}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = {{threshold}} \" + \"{{validTimeClause}} \" + \"{{utcCycleStartClause}} \" + \"group by avtime \" + \"order by avtime;\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{dateRangeClause}}', dateRangeClause);\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      statement = statement.replace('{{utcCycleStartClause}}', utcCycleStartClause);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};","map":{"version":3,"sources":["server/dataFunctions/data_dieoff.js"],"names":["matsCollections","module","link","v","matsTypes","matsDataUtils","matsDataQueryUtils","matsDataDiffUtils","matsDataCurveOpsUtils","matsDataProcessUtils","moment","dataDieOff","plotParams","plotFunction","matching","PlotActions","matched","plotType","PlotTypes","dieoff","hasLevels","dataRequests","dataFoundForCurve","totalProcessingStart","error","curves","JSON","parse","stringify","curvesLength","length","dataset","utcCycleStarts","axisMap","Object","create","xmax","Number","MAX_VALUE","ymax","xmin","ymin","idealValues","curveIndex","curve","diffFrom","label","data_source","CurveParams","findOne","name","optionsMap","regionStr","region","keys","valuesMap","find","key","source","sourceStr","thresholdStr","threshold","statisticSelect","statisticOptionsMap","statistic","scaleStr","scale","dateRange","getDateRange","fromSecs","fromSeconds","toSecs","toSeconds","forecastLengthStr","forecastLengthOptionsMap","forecastLength","validTimes","validTimeClause","utcCycleStart","utcCycleStartClause","dateRangeClause","ForecastTypes","undefined","InputTypes","unused","utcCycle","axisKey","idealVal","indexOf","push","d","statement","replace","queryResult","startMoment","finishMoment","queryDBSpecialtyCurve","sumPool","begin","format","finish","duration","diff","asSeconds","recordCount","data","x","e","message","Error","Messages","NO_DATA_FOUND","postQueryStartMoment","diffResult","getDataForDiffCurve","mean","sum","annotation","toPrecision","cOptions","generateSeriesCurveOptions","postQueryFinishMoment","appParams","curveInfoParams","bookkeepingParams","result","processDataXYCurve"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataDieOff = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.dieoff;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var forecastLengthStr = curve['dieoff-type'];\n        var forecastLengthOptionsMap = matsCollections.CurveParams.findOne({name: 'dieoff-type'}, {optionsMap: 1})['optionsMap'];\n        var forecastLength = forecastLengthOptionsMap[forecastLengthStr][0];\n        var validTimes;\n        var validTimeClause = \"\";\n        var utcCycleStart;\n        var utcCycleStartClause = \"\";\n        var dateRangeClause = \"and m0.time >= \" + fromSecs + \" and m0.time <= \" + toSecs;\n        if (forecastLength === matsTypes.ForecastTypes.dieoff) {\n            validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n            if (validTimes.length !== 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \"and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n            }\n        } else if (forecastLength === matsTypes.ForecastTypes.utcCycle) {\n            utcCycleStart = Number(curve['utc-cycle-start']);\n            utcCycleStartClause = \"and (m0.time - m0.fcst_len*3600)%(24*3600)/3600 IN(\" + utcCycleStart + \")\";\n        } else {\n            dateRangeClause = \"and (m0.time - m0.fcst_len*3600) = \" + fromSecs;\n        }\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"SELECT m0.fcst_len AS avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"{{dateRangeClause}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = {{threshold}} \" +\n                \"{{validTimeClause}} \" +\n                \"{{utcCycleStartClause}} \" +\n                \"group by avtime \" +\n                \"order by avtime;\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{dateRangeClause}}', dateRangeClause);\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n            statement = statement.replace('{{utcCycleStartClause}}', utcCycleStartClause);\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};"]},"sourceType":"script","hash":"5d94acb5e238b011816749e7e9707f0917a79cf7"}
