{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_histogram.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"server/dataFunctions/data_histogram.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_histogram.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_histogram.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/dataFunctions/data_histogram.js"}},"code":"let matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 4);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 5);\n\ndataHistogram = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const plotType = matsTypes.PlotTypes.histogram;\n  const hasLevels = false;\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  var alreadyMatched = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = [];\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var allReturnedSubStats = [];\n  var allReturnedSubSecs = [];\n  var axisMap = Object.create(null); // process user bin customizations\n\n  const binParams = matsDataUtils.setHistogramParameters(plotParams);\n  const yAxisFormat = binParams.yAxisFormat;\n  const binNum = binParams.binNum;\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    dataFoundForCurve[curveIndex] = true;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = yAxisFormat;\n\n    if (yAxisFormat === 'Relative frequency') {\n      axisKey = axisKey + \" (x100)\";\n    }\n\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    curves[curveIndex].binNum = binNum; // stash the binNum to use it later for bar chart options\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select m0.time as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"{{validTimeClause}} \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = '{{threshold}}' \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      var validTimeClause = \" \";\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n        allReturnedSubStats.push(d.subVals); // save returned data so that we can calculate histogram stats once all the queries are done\n\n        allReturnedSubSecs.push(d.subSecs);\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve[curveIndex] = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      }\n    }\n  }\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"dataFoundForCurve\": dataFoundForCurve,\n    \"axisMap\": axisMap,\n    \"yAxisFormat\": yAxisFormat\n  };\n  const bookkeepingParams = {\n    \"alreadyMatched\": alreadyMatched,\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataHistogram(allReturnedSubStats, allReturnedSubSecs, [], dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams);\n  plotFunction(result);\n};","map":{"version":3,"sources":["server/dataFunctions/data_histogram.js"],"names":["matsCollections","module","link","v","matsTypes","matsDataUtils","matsDataQueryUtils","matsDataProcessUtils","moment","dataHistogram","plotParams","plotFunction","plotType","PlotTypes","histogram","hasLevels","matching","PlotActions","matched","alreadyMatched","dataRequests","dataFoundForCurve","totalProcessingStart","error","curves","JSON","parse","stringify","curvesLength","length","dataset","allReturnedSubStats","allReturnedSubSecs","axisMap","Object","create","binParams","setHistogramParameters","yAxisFormat","binNum","curveIndex","curve","diffFrom","label","dataSourceStr","data_source","CurveParams","findOne","name","optionsMap","regionStr","region","keys","valuesMap","find","key","source","sourceStr","scaleStr","scale","thresholdStr","threshold","statisticSelect","statisticOptionsMap","statistic","validTimes","undefined","dateRange","getDateRange","fromSecs","fromSeconds","toSecs","toSeconds","forecastLength","axisKey","d","statement","replace","validTimeClause","InputTypes","unused","queryResult","startMoment","finishMoment","queryDBSpecialtyCurve","sumPool","begin","format","finish","duration","diff","asSeconds","recordCount","data","x","push","subVals","subSecs","e","message","Error","Messages","NO_DATA_FOUND","appParams","curveInfoParams","bookkeepingParams","result","processDataHistogram"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataHistogram = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const plotType = matsTypes.PlotTypes.histogram;\n    const hasLevels = false;\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    var alreadyMatched = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = [];\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var allReturnedSubStats = [];\n    var allReturnedSubSecs = [];\n    var axisMap = Object.create(null);\n\n    // process user bin customizations\n    const binParams = matsDataUtils.setHistogramParameters(plotParams);\n    const yAxisFormat = binParams.yAxisFormat;\n    const binNum = binParams.binNum;\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        dataFoundForCurve[curveIndex] = true;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = yAxisFormat;\n        if (yAxisFormat === 'Relative frequency') {\n            axisKey = axisKey + \" (x100)\"\n        }\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        curves[curveIndex].binNum = binNum; // stash the binNum to use it later for bar chart options\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select m0.time as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"{{validTimeClause}} \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = '{{threshold}}' \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            var validTimeClause = \" \";\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n            }\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n                allReturnedSubStats.push(d.subVals); // save returned data so that we can calculate histogram stats once all the queries are done\n                allReturnedSubSecs.push(d.subSecs);\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve[curveIndex] = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n        }\n    }\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"dataFoundForCurve\": dataFoundForCurve,\n        \"axisMap\": axisMap,\n        \"yAxisFormat\": yAxisFormat\n    };\n    const bookkeepingParams = {\n        \"alreadyMatched\": alreadyMatched,\n        \"dataRequests\": dataRequests,\n        \"totalProcessingStart\": totalProcessingStart\n    };\n    var result = matsDataProcessUtils.processDataHistogram(allReturnedSubStats, allReturnedSubSecs, [], dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams);\n    plotFunction(result);\n};"]},"sourceType":"script","hash":"79520936802c1baa2deb2695bdabe9517077dd90"}
