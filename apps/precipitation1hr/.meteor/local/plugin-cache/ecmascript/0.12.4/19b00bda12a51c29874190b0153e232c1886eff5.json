{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/client/select_util.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/randyp:mats-common/imports/startup/client/select_util.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/client/select_util.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/client/select_util.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/randyp:mats-common/imports/startup/client/select_util.js"}},"code":"let matsCollections, matsMethods, matsParamUtils, matsPlotUtils, matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  },\n\n  matsMethods(v) {\n    matsMethods = v;\n  },\n\n  matsParamUtils(v) {\n    matsParamUtils = v;\n  },\n\n  matsPlotUtils(v) {\n    matsPlotUtils = v;\n  },\n\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 0);\n\n// method to refresh the peers of the current selector\nconst refreshPeer = function (event, param) {\n  try {\n    const peerName = param.peerName;\n\n    if (peerName !== undefined) {\n      // refresh the peer\n      const targetParam = matsParamUtils.getParameterForName(peerName);\n      const targetId = targetParam.name + '-' + targetParam.type;\n      const targetElem = document.getElementById(targetId);\n      const refreshMapEvent = new CustomEvent(\"refresh\", {\n        detail: {\n          refElement: null\n        }\n      });\n      targetElem.dispatchEvent(refreshMapEvent);\n    }\n\n    refreshDependents(event, param);\n  } catch (e) {\n    e.message = \"INFO: Error in select.js refreshPeer: \" + e.message;\n    setInfo(e.message);\n  }\n}; // method to refresh the dependents of the current selector\n\n\nconst refreshDependents = function (event, param) {\n  try {\n    const dependentNames = param.dependentNames;\n\n    if (dependentNames && Object.prototype.toString.call(dependentNames) === '[object Array]' && dependentNames.length > 0) {\n      // refresh the dependents\n      var selectAllbool = false;\n\n      for (var i = 0; i < dependentNames.length; i++) {\n        const name = dependentNames[i];\n        const targetParam = matsParamUtils.getParameterForName(name);\n        var targetId;\n\n        if (targetParam.type === matsTypes.InputTypes.dateRange) {\n          targetId = \"element-\" + targetParam.name;\n        } else {\n          targetId = targetParam.name + '-' + targetParam.type;\n        }\n\n        const targetElem = document.getElementById(targetId);\n\n        if (document.getElementById('selectAll')) {\n          selectAllbool = document.getElementById('selectAll').checked;\n        }\n\n        try {\n          targetElem.dispatchEvent(new CustomEvent(\"refresh\"));\n        } catch (re) {\n          re.message = \"INFO: refreshDependents of: \" + param.name + \" dependent: \" + targetParam.name + \" - error: \" + re.message;\n          setInfo(re.message);\n        }\n\n        const elements = targetElem.options;\n        const select = true;\n\n        if (targetElem.multiple && elements !== undefined && elements.length > 0) {\n          if (selectAllbool) {\n            for (var i1 = 0; i1 < elements.length; i1++) {\n              elements[i1].selected = select;\n            }\n\n            matsParamUtils.setValueTextForParamName(name, \"\");\n          } else {\n            const previously_selected = Session.get('selected');\n\n            for (var i2 = 0; i2 < elements.length; i2++) {\n              if (_.indexOf(previously_selected, elements[i2].text) != -1) {\n                elements[i2].selected = select;\n              }\n            }\n          }\n        }\n      }\n    }\n  } catch (e) {\n    e.message = \"INFO: Error in select.js refreshDependents: \" + e.message;\n    setInfo(e.message);\n  }\n}; // check for enable controlled - This select might have control of another selector\n\n\nconst checkDisableOther = function (param, firstRender) {\n  try {\n    if (param.disableOtherFor !== undefined) {\n      // this param controls the enable/disable properties of at least one other param.\n      // Use the options to enable disable that param.\n      const controlledSelectors = Object.keys(param.disableOtherFor);\n\n      for (var i = 0; i < controlledSelectors.length; i++) {\n        const elem = matsParamUtils.getInputElementForParamName(param.name);\n\n        if (!elem) {\n          return;\n        }\n\n        const selectedOptions = elem.selectedOptions;\n        const selectedText = selectedOptions && selectedOptions.length > 0 ? selectedOptions[0].text : \"\";\n\n        if (firstRender == true && param.default == param.hideOtherFor[controlledSelectors[i]] || param.disableOtherFor[controlledSelectors[i]] === matsTypes.InputTypes.unused && selectedText === \"\" || $.inArray(selectedText, param.disableOtherFor[controlledSelectors[i]]) !== -1) {\n          matsParamUtils.getInputElementForParamName(controlledSelectors[i]).disabled = true;\n          matsParamUtils.setValueTextForParamName(controlledSelectors[i], matsTypes.InputTypes.unused);\n        } else {\n          matsParamUtils.getInputElementForParamName(controlledSelectors[i]).disabled = false;\n        }\n      }\n    }\n  } catch (e) {\n    e.message = \"INFO: Error in select.js checkDisableOther: \" + e.message;\n    setInfo(e.message);\n  }\n}; // check for hide controlled - This select might have control of another selector's visibility\n\n\nconst checkHideOther = function (param, firstRender) {\n  try {\n    if (param.hideOtherFor !== undefined) {\n      // this param controls the visibility of at least one other param.\n      const controlledSelectors = Object.keys(param.hideOtherFor);\n\n      for (var i = 0; i < controlledSelectors.length; i++) {\n        const elem = matsParamUtils.getInputElementForParamName(param.name);\n\n        if (!elem) {\n          return;\n        }\n\n        const selectedOptions = elem.selectedOptions;\n        const selectedText = selectedOptions && selectedOptions.length > 0 ? selectedOptions[0].text : \"\";\n        var otherInputElement = matsParamUtils.getInputElementForParamName(controlledSelectors[i]);\n        var selectorControlElem;\n\n        if (firstRender == true && param.default == param.hideOtherFor[controlledSelectors[i]] || param.hideOtherFor[controlledSelectors[i]] === matsTypes.InputTypes.unused && selectedText === \"\" || $.inArray(selectedText, param.hideOtherFor[controlledSelectors[i]]) !== -1) {\n          selectorControlElem = document.getElementById(controlledSelectors[i] + '-item');\n\n          if (selectorControlElem && selectorControlElem.style) {\n            selectorControlElem.style.display = \"none\";\n          }\n\n          matsParamUtils.setValueTextForParamName(controlledSelectors[i], matsTypes.InputTypes.unused);\n        } else {\n          selectorControlElem = document.getElementById(controlledSelectors[i] + '-item');\n\n          if (selectorControlElem && selectorControlElem.style) {\n            selectorControlElem.style.display = \"block\";\n          }\n\n          otherInputElement && otherInputElement.options && otherInputElement.selectedIndex >= 0 && otherInputElement.options[otherInputElement.selectedIndex].scrollIntoView();\n        }\n      }\n\n      matsSelectUtils.checkDisableOther(param), firstRender;\n    }\n  } catch (e) {\n    e.message = \"INFO: Error in select.js checkHideOther: \" + e.message;\n    setInfo(e.message);\n  }\n}; // refresh the selector in question to the appropriate options indicated by the values of any superior selectors\n\n\nconst refresh = function (event, paramName) {\n  if (paramName.search('axis') === 1) {\n    // this is a \"brother\" (hidden) scatterplot param. There is no need to refresh it or add event listeners etc.\n    return;\n  }\n\n  const param = matsParamUtils.getParameterForName(paramName);\n  const elem = matsParamUtils.getInputElementForParamName(paramName);\n  /*\n  OptionsGroups are a mechanism for displaying the select options in groups.\n  A disabled option is used for the group header. Disabled options simply show up\n  in the selector list in bold font and act as group titles. They are disabled so that\n  they cannot be clicked. DisabledOptions are the headers that the options are to be grouped under.\n  disabledOptions are optional so if there are disabledOptions they are the keys in the optionsGroups\n  and they are the sort order of those keys.\n  */\n\n  const disabledOptions = matsParamUtils.getDisabledOptionsForParamName(paramName);\n  const optionsGroups = param.optionsGroups;\n  const optionsMap = param.optionsMap;\n  const superiorNames = param.superiorNames;\n  const superiorDimensionality = superiorNames !== undefined && superiorNames !== null && superiorNames.length > 0 && Array.isArray(superiorNames[0]) ? superiorNames.length : 1;\n  var superiors = []; // get a list of the current superior selected values - in order of superiority i.e. [databaseValue,dataSourceValue]\n\n  var sNames;\n\n  if (superiorNames !== undefined) {\n    if (superiorDimensionality === 1) {\n      sNames = superiorNames;\n    } else {\n      sNames = superiorNames[0];\n    }\n\n    for (var sn = 0; sn < sNames.length; sn++) {\n      var superiorElement = matsParamUtils.getInputElementForParamName(sNames[sn]);\n      var selectedSuperiorValue = superiorElement.options[superiorElement.selectedIndex] === undefined ? matsParamUtils.getParameterForName(sNames[sn]).default : superiorElement.options[superiorElement.selectedIndex].text;\n      superiors[0] = superiors[0] === undefined ? [] : superiors[0];\n      superiors[0].push({\n        element: superiorElement,\n        value: selectedSuperiorValue\n      });\n    }\n\n    for (var sNameIndex = 1; sNameIndex < superiorDimensionality; sNameIndex++) {\n      sNames = superiorNames[sNameIndex];\n\n      for (var sn = 0; sn < sNames.length; sn++) {\n        var superiorElement = matsParamUtils.getInputElementForParamName(sNames[sn]);\n        var selectedSuperiorValue = superiorElement.options[superiorElement.selectedIndex] === undefined ? matsParamUtils.getParameterForName(sNames[sn]).default : superiorElement.options[superiorElement.selectedIndex].text;\n        superiors[sNameIndex] = superiors[sNameIndex] === undefined ? [] : superiors[sNameIndex];\n        superiors[sNameIndex].push({\n          element: superiorElement,\n          value: selectedSuperiorValue\n        });\n      }\n    }\n  }\n  /*\n  So what are superiors now.....\n  superiors = [[{element:anElement,value:aValue},{element:anElement,value:aValue}...]]\n  or they might be [[{element:anElement,value:aValue},{element:anElement,value:aValue}...],[{element:anElement,value:aValue},{element:anElement,value:aValue}...],...]\n     Axis-brothers:\n   Axis-brothers are for scatter plots. They are a second hidden set of parameters that apply to a different axis.\n   Because there may be axis \"brothers\" This refresh must go and\n   see if there are any brother elements that are essentially hidden copies\n   of this one, and also refresh their options lists\n    Superior Heirarchy:\n   There can be a heirarchy of superiors and dependents. The superiorNames are a list of paramNames. The most superior has the 0th index and\n   the least superior has the highest index.\n   The Refresh uses the superiors to get the appropriate options for a given options map.\n   The way it works is that superiors are always refreshed first. The superior heirarchy selections are then used by a\n   dependent to retrieve its appropriate optionsMap from the superiorOptionsMap.\n   superiorsOptionsMap = {\n      mostSuperiorValue0: {  // optionsMap for the most superior first value\n          nextSuperiorValue0: [value0,value1,value2,value3,...],\n          nextSuperiorValue1: [value0,value1,value2,value3,...],\n          nextSuperiorValue2: [value0,value1,value2,value3,...],\n          ...\n      },\n      mostSuperiorValue1:{  // optionsMap for the most superior second value\n          nextSuperiorValue0: [value0,value1,value2,value3,...],\n          nextSuperiorValue1: [value0,value1,value2,value3,...],\n          nextSuperiorValue2: [value0,value1,value2,value3,...],\n          ...\n      },\n      ...,\n      mostSuperiorValue2:{  // optionsMap for the most superior third value\n          nextSuperiorValue0: [value0,value1,value2,value3,...],\n          nextSuperiorValue1: [value0,value1,value2,value3,...],\n          nextSuperiorValue2: [value0,value1,value2,value3,...],\n          ...\n      },\n   }\n   */\n  // find all the elements that have ids like .... \"x|y|z\" + \"axis-\" + this.name\n\n\n  const name = param.name;\n  const elems = document.getElementsByClassName(\"data-input\") === undefined ? [] : document.getElementsByClassName(\"data-input\");\n  Session.set('selected', $(elem).val());\n\n  if (elem && elem.options) {\n    if (elem.selectedIndex === undefined || elem.selectedIndex === -1) {\n      if (param.default !== matsTypes.InputTypes.unused) {\n        elem.selectedIndex = 0;\n      }\n    }\n\n    const selectedText = elem.selectedIndex >= 0 ? elem.options[elem.selectedIndex].text : matsTypes.InputTypes.unused;\n    var brothers = [];\n\n    for (var i = 0; i < elems.length; i++) {\n      if (elems[i].id.indexOf(name) >= 0 && elems[i].id !== elem.id) brothers.push(elems[i]);\n    }\n\n    var myOptions = [];\n    var selectedSuperiorValues = [];\n\n    try {\n      // index down through the options for the list of superiors\n      // starting with the most superior down through the least superior\n      // and get the options list for the first set of superiors.\n      // These are the ancestral options.\n      if (param.optionsMap) {\n        var firstSuperiorOptions = optionsMap;\n        var theseSuperiors = superiors === undefined || superiors.length === 0 ? [] : superiors[0];\n\n        for (var theseSuperiorsIndex = 0; theseSuperiorsIndex < theseSuperiors.length; theseSuperiorsIndex++) {\n          var superior = theseSuperiors[theseSuperiorsIndex];\n          var selectedSuperiorValue = superior.value;\n          firstSuperiorOptions = firstSuperiorOptions[selectedSuperiorValue];\n        }\n\n        myOptions = Array.isArray(firstSuperiorOptions) ? firstSuperiorOptions : Object.keys(firstSuperiorOptions);\n      } else {\n        myOptions = param.options;\n      } // need to get the ancestral truth options because we may need to intersect the options\n\n      /* tricky little bit here:\n      SuperiorDimensionality:\n       It is possible to have two superior options maps.. i.e. datasource and truth.\n       In that case the superiorNames won't look like [\"something\",\"somethingelse\"],\n       instead it will look like [[\"something\",\"somethingelse\"],[\"someotherthing\",\"someotherthingelse\"]]\n       i.e. it will be a multidimensional array.\n        If the controlButton for one of these multi-dimensional superior elements is hidden ....\n       matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent !== null\n       it has been hidden because it has a visibility dependency on another param\n       i.e. truth-data-source and truth-variable (for mean there would be no truth, but for bias\n       there must always be truth...).\n       In this case these are dependent upon statistic such that if the statistic is \"mean\" the truth-data-source and truth-variable\n       are hidden. See the wfip2 main.js statistic param as an example....\n       \"disableOtherFor:{'truth-data-source':[statisticOptionsMap.mean][0]},\"\n       and\n       \"hideOtherFor:{'truth-data-source':[statisticOptionsMap.mean][0]},\"\n       are the fields that cause the truth-data-source to be hidden when statistic is set to \"mean\".\n       In that condition (the controlButton is hidden) the superior should not be used as an intersection in the selected sites.\n       matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent will be null if the controlButton\n       for this element (this superior) is hidden. That is the tricky part ... it will be null.\n        Also the unused superior is tested against the superior according to the truth table...\n       used && unused  -> use the used\n       unused and used -> use the used\n       used and used -> use the intersection\n       unused and unused - set the options to []\n        A select may have a list of disabledOptions. These are used as optionGroup markers.\n       */\n      // need to get the actual options here\n\n\n      for (var sNameIndex = 1; sNameIndex < superiorDimensionality; sNameIndex++) {\n        // index down through the options for the list of superiors\n        // starting with the most superior down through the least superior\n        // and get the options list for the first set of superiors.\n        // These are the ancestral options.\n        var nextSuperiorOptions = optionsMap;\n        var theseSuperiors = superiors === undefined || superiors.length === 0 ? [] : superiors[sNameIndex];\n\n        for (var theseSuperiorsIndex = 0; theseSuperiorsIndex < theseSuperiors.length; theseSuperiorsIndex++) {\n          var superior = theseSuperiors[theseSuperiorsIndex];\n          var selectedSuperiorValue = superior.value;\n          nextSuperiorOptions = nextSuperiorOptions[selectedSuperiorValue];\n        } // since we now have multiple options we have to intersect them\n\n\n        myOptions = _.intersection(myOptions, nextSuperiorOptions);\n      }\n\n      if (myOptions === []) {\n        // none used - set to []\n        matsParamUtils.setValueTextForParamName(name, matsTypes.InputTypes.unused);\n      }\n    } catch (e) {\n      e.message = \"INFO: Error in select.js refresh: determining options from superiors: \" + e.message;\n      setInfo(e.message);\n    }\n\n    try {\n      // reset the options of the select\n      // if the options are null it might be that this is the initial setup.\n      // so use the optionsmap and the default options for the map\n      // it might also mean that there are no superiors for this param\n      if (myOptions == null) {\n        // get the default options\n        if (optionsGroups) {\n          // optionGroups are an ordered map. It probably has options that are in the disabledOption list\n          // which are used as markers in the select options pulldown. This is typical for models\n          const optionsGroupsKeys = Object.keys(optionsGroups);\n\n          for (var k = 0; k < optionsGroupsKeys.length; k++) {\n            if (myOptions === null) {\n              myOptions = [];\n              myOptions.push(optionsGroupsKeys[k]);\n              myOptions = myOptions.concat(optionsGroups[optionsGroupsKeys[k]]); // the primary group does not get sorted\n            } else {\n              myOptions.push(optionsGroupsKeys[k]);\n              myOptions = myOptions.concat(optionsGroups[optionsGroupsKeys[k]].sort()); // non primary  groups get sorted\n            }\n          }\n        } else {\n          myOptions = param.options;\n        }\n      }\n\n      var optionsAsString = \"\";\n\n      if (myOptions === undefined || myOptions == null) {\n        return;\n      }\n\n      var firstGroup = true;\n\n      for (var i = 0; i < myOptions.length; i++) {\n        var dIndex = disabledOptions === undefined ? -1 : disabledOptions.indexOf(myOptions[i]);\n\n        if (dIndex >= 0) {\n          // the option was found in the disabled options so it needs to be an optgroup label\n          // disabled option\n          if (firstGroup === true) {\n            // first in group\n            optionsAsString += \"<optgroup label=\" + myOptions[i] + \">\";\n            firstGroup = false;\n          } else {\n            optionsAsString += \"</optgroup>\";\n            optionsAsString += \"<optgroup label=\" + myOptions[i] + \">\";\n          }\n        } else {\n          //regular option - the option was not found in the disabled options\n          optionsAsString += \"<option value='\" + myOptions[i] + \"'>\" + myOptions[i] + \"</option>\";\n        }\n      }\n\n      if (disabledOptions !== undefined) {\n        optionsAsString += \"</optgroup>\";\n      }\n\n      $('select[name=\"' + name + '\"]').empty().append(optionsAsString); //reset the selected index if it had been set prior (the list may have changed so the index may have changed)\n\n      var selectedOptionIndex;\n\n      if (selectedText === 'initial') {\n        selectedOptionIndex = myOptions.indexOf(param.default);\n      } else {\n        selectedOptionIndex = myOptions.indexOf(selectedText);\n      }\n\n      var sviText = \"\";\n\n      if (selectedOptionIndex == -1 && elem.selectedIndex >= 0) {\n        for (var svi = 0; svi < selectedSuperiorValues.length; svi++) {\n          superior = superiors[svi];\n\n          if (matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent !== null) {\n            if (svi > 0) {\n              sviText += \" and \";\n            }\n\n            sviText += selectedSuperiorValues[svi];\n          }\n        }\n\n        setInfo(\"I changed your selected \" + name + \": '\" + selectedText + \"' to '\" + myOptions[0] + \"' because '\" + selectedText + \"' is no longer an option for \" + sviText);\n      } // if the selectedText existed in the new options list then the selectedOptionIndex won't be -1 and we have to choose the default option\n\n\n      if (selectedOptionIndex === -1) {\n        // if the param default is unused set it to unused\n        // else just choose the 0th element in the element options. default?\n        if (param.default === matsTypes.InputTypes.unused) {\n          matsParamUtils.setValueTextForParamName(name, matsTypes.InputTypes.unused);\n        } else {\n          elem.selectedIndex = 0;\n          elem && elem.options && elem.selectedIndex >= 0 && elem.options[elem.selectedIndex].scrollIntoView();\n          elem && elem.options && elem.selectedIndex >= 0 && matsParamUtils.setValueTextForParamName(name, elem.options[elem.selectedIndex].text);\n        }\n      } else {\n        elem.selectedIndex = selectedOptionIndex;\n        elem && elem.options && elem.selectedIndex >= 0 && elem.options[elem.selectedIndex].scrollIntoView();\n        elem && elem.options && elem.selectedIndex >= 0 && matsParamUtils.setValueTextForParamName(name, elem.options[elem.selectedIndex].text);\n      }\n\n      for (var i = 0; i < brothers.length; i++) {\n        const belem = brothers[i];\n        const belemSelectedOptions = $(belem.selectedOptions).map(function () {\n          return this.value;\n        }).get();\n\n        if (belemSelectedOptions === undefined || belemSelectedOptions.length === 0) {\n          belem.options = [];\n\n          for (var i1 = 0; i1 < myOptions.length; i1++) {\n            belem.options[belem.options.length] = new Option(myOptions[i1], myOptions[i1], i1 == 0, i1 == 0);\n          }\n        }\n      }\n    } catch (e) {\n      e.message = \"INFO: Error in select.js refresh: resetting selected options: \" + e.message;\n      setInfo(e.message);\n    }\n  }\n\n  refreshPeer(event, param);\n}; // refresh function\n\n\nmodule.exportDefault(matsSelectUtils = {\n  refresh: refresh,\n  refreshPeer: refreshPeer,\n  refreshDependents: refreshDependents,\n  checkDisableOther: checkDisableOther,\n  checkHideOther: checkHideOther\n});","map":{"version":3,"sources":["packages/randyp:mats-common/imports/startup/client/select_util.js"],"names":["matsCollections","matsMethods","matsParamUtils","matsPlotUtils","matsTypes","module","link","v","refreshPeer","event","param","peerName","undefined","targetParam","getParameterForName","targetId","name","type","targetElem","document","getElementById","refreshMapEvent","CustomEvent","detail","refElement","dispatchEvent","refreshDependents","e","message","setInfo","dependentNames","Object","prototype","toString","call","length","selectAllbool","i","InputTypes","dateRange","checked","re","elements","options","select","multiple","i1","selected","setValueTextForParamName","previously_selected","Session","get","i2","_","indexOf","text","checkDisableOther","firstRender","disableOtherFor","controlledSelectors","keys","elem","getInputElementForParamName","selectedOptions","selectedText","default","hideOtherFor","unused","$","inArray","disabled","checkHideOther","otherInputElement","selectorControlElem","style","display","selectedIndex","scrollIntoView","matsSelectUtils","refresh","paramName","search","disabledOptions","getDisabledOptionsForParamName","optionsGroups","optionsMap","superiorNames","superiorDimensionality","Array","isArray","superiors","sNames","sn","superiorElement","selectedSuperiorValue","push","element","value","sNameIndex","elems","getElementsByClassName","set","val","brothers","id","myOptions","selectedSuperiorValues","firstSuperiorOptions","theseSuperiors","theseSuperiorsIndex","superior","nextSuperiorOptions","intersection","optionsGroupsKeys","k","concat","sort","optionsAsString","firstGroup","dIndex","empty","append","selectedOptionIndex","sviText","svi","getControlElementForParamName","offsetParent","belem","belemSelectedOptions","map","Option","exportDefault"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections, matsMethods, matsParamUtils, matsPlotUtils, matsTypes} from 'meteor/randyp:mats-common';\n\n// method to refresh the peers of the current selector\nconst refreshPeer = function (event, param) {\n    try {\n        const peerName = param.peerName;\n        if (peerName !== undefined) {\n            // refresh the peer\n            const targetParam = matsParamUtils.getParameterForName(peerName);\n            const targetId = targetParam.name + '-' + targetParam.type;\n            const targetElem = document.getElementById(targetId);\n            const refreshMapEvent = new CustomEvent(\"refresh\", {\n                detail: {\n                    refElement: null\n                }\n            });\n            targetElem.dispatchEvent(refreshMapEvent);\n        }\n        refreshDependents(event, param);\n    } catch (e) {\n        e.message = \"INFO: Error in select.js refreshPeer: \" + e.message;\n        setInfo(e.message);\n    }\n};\n\n// method to refresh the dependents of the current selector\nconst refreshDependents = function (event, param) {\n    try {\n        const dependentNames = param.dependentNames;\n        if (dependentNames && Object.prototype.toString.call(dependentNames) === '[object Array]' && dependentNames.length > 0) {\n            // refresh the dependents\n            var selectAllbool = false;\n            for (var i = 0; i < dependentNames.length; i++) {\n                const name = dependentNames[i];\n                const targetParam = matsParamUtils.getParameterForName(name);\n                var targetId;\n                if (targetParam.type === matsTypes.InputTypes.dateRange) {\n                    targetId = \"element-\" + targetParam.name;\n                } else {\n                    targetId = targetParam.name + '-' + targetParam.type;\n                }\n                const targetElem = document.getElementById(targetId);\n\n                if (document.getElementById('selectAll')) {\n                    selectAllbool = document.getElementById('selectAll').checked;\n                }\n                try {\n                    targetElem.dispatchEvent(new CustomEvent(\"refresh\"))\n                } catch (re) {\n                    re.message = \"INFO: refreshDependents of: \" + param.name + \" dependent: \" + targetParam.name + \" - error: \" + re.message;\n                    setInfo(re.message);\n                }\n                const elements = targetElem.options;\n                const select = true;\n                if (targetElem.multiple && elements !== undefined && elements.length > 0) {\n                    if (selectAllbool) {\n                        for (var i1 = 0; i1 < elements.length; i1++) {\n                            elements[i1].selected = select;\n                        }\n                        matsParamUtils.setValueTextForParamName(name, \"\");\n                    } else {\n                        const previously_selected = Session.get('selected');\n                        for (var i2 = 0; i2 < elements.length; i2++) {\n                            if (_.indexOf(previously_selected, elements[i2].text) != -1) {\n                                elements[i2].selected = select;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } catch (e) {\n        e.message = \"INFO: Error in select.js refreshDependents: \" + e.message;\n        setInfo(e.message);\n    }\n};\n\n// check for enable controlled - This select might have control of another selector\nconst checkDisableOther = function (param, firstRender) {\n    try {\n        if (param.disableOtherFor !== undefined) {\n            // this param controls the enable/disable properties of at least one other param.\n            // Use the options to enable disable that param.\n            const controlledSelectors = Object.keys(param.disableOtherFor);\n            for (var i = 0; i < controlledSelectors.length; i++) {\n                const elem = matsParamUtils.getInputElementForParamName(param.name);\n                if (!elem) {\n                    return;\n                }\n                const selectedOptions = elem.selectedOptions;\n                const selectedText = selectedOptions && selectedOptions.length > 0 ? selectedOptions[0].text : \"\";\n                if ((firstRender == true && param.default == param.hideOtherFor[controlledSelectors[i]]) ||\n                    (param.disableOtherFor[controlledSelectors[i]] === matsTypes.InputTypes.unused && selectedText === \"\") ||\n                    $.inArray(selectedText, param.disableOtherFor[controlledSelectors[i]]) !== -1) {\n                    matsParamUtils.getInputElementForParamName(controlledSelectors[i]).disabled = true;\n                    matsParamUtils.setValueTextForParamName(controlledSelectors[i], matsTypes.InputTypes.unused);\n                } else {\n                    matsParamUtils.getInputElementForParamName(controlledSelectors[i]).disabled = false;\n                }\n            }\n        }\n    } catch (e) {\n        e.message = \"INFO: Error in select.js checkDisableOther: \" + e.message;\n        setInfo(e.message);\n    }\n};\n\n// check for hide controlled - This select might have control of another selector's visibility\nconst checkHideOther = function (param, firstRender) {\n    try {\n        if (param.hideOtherFor !== undefined) {\n            // this param controls the visibility of at least one other param.\n            const controlledSelectors = Object.keys(param.hideOtherFor);\n            for (var i = 0; i < controlledSelectors.length; i++) {\n                const elem = matsParamUtils.getInputElementForParamName(param.name);\n                if (!elem) {\n                    return;\n                }\n                const selectedOptions = elem.selectedOptions;\n                const selectedText = selectedOptions && selectedOptions.length > 0 ? selectedOptions[0].text : \"\";\n\n                var otherInputElement = matsParamUtils.getInputElementForParamName(controlledSelectors[i]);\n\n                var selectorControlElem;\n                if ((firstRender == true && param.default == param.hideOtherFor[controlledSelectors[i]]) ||\n                    (param.hideOtherFor[controlledSelectors[i]] === matsTypes.InputTypes.unused && selectedText === \"\") ||\n                    $.inArray(selectedText, param.hideOtherFor[controlledSelectors[i]]) !== -1) {\n                    selectorControlElem = document.getElementById(controlledSelectors[i] + '-item');\n                    if (selectorControlElem && selectorControlElem.style) {\n                        selectorControlElem.style.display = \"none\";\n                    }\n                    matsParamUtils.setValueTextForParamName(controlledSelectors[i], matsTypes.InputTypes.unused);\n                } else {\n                    selectorControlElem = document.getElementById(controlledSelectors[i] + '-item');\n                    if (selectorControlElem && selectorControlElem.style) {\n                        selectorControlElem.style.display = \"block\";\n                    }\n                    otherInputElement && otherInputElement.options && otherInputElement.selectedIndex >= 0 &&\n                    otherInputElement.options[otherInputElement.selectedIndex].scrollIntoView();\n                }\n            }\n            matsSelectUtils.checkDisableOther(param), firstRender;\n        }\n    } catch (e) {\n        e.message = \"INFO: Error in select.js checkHideOther: \" + e.message;\n        setInfo(e.message);\n    }\n};\n\n// refresh the selector in question to the appropriate options indicated by the values of any superior selectors\nconst refresh = function (event, paramName) {\n    if (paramName.search('axis') === 1) {\n        // this is a \"brother\" (hidden) scatterplot param. There is no need to refresh it or add event listeners etc.\n        return;\n    }\n    const param = matsParamUtils.getParameterForName(paramName);\n    const elem = matsParamUtils.getInputElementForParamName(paramName);\n\n    /*\n    OptionsGroups are a mechanism for displaying the select options in groups.\n    A disabled option is used for the group header. Disabled options simply show up\n    in the selector list in bold font and act as group titles. They are disabled so that\n    they cannot be clicked. DisabledOptions are the headers that the options are to be grouped under.\n    disabledOptions are optional so if there are disabledOptions they are the keys in the optionsGroups\n    and they are the sort order of those keys.\n    */\n    const disabledOptions = matsParamUtils.getDisabledOptionsForParamName(paramName);\n    const optionsGroups = param.optionsGroups;\n    const optionsMap = param.optionsMap;\n\n    const superiorNames = param.superiorNames;\n    const superiorDimensionality = superiorNames !== undefined && superiorNames !== null && superiorNames.length > 0 && Array.isArray(superiorNames[0]) ? superiorNames.length : 1;\n    var superiors = [];\n    // get a list of the current superior selected values - in order of superiority i.e. [databaseValue,dataSourceValue]\n    var sNames;\n    if (superiorNames !== undefined) {\n        if (superiorDimensionality === 1) {\n            sNames = superiorNames;\n        } else {\n            sNames = superiorNames[0];\n        }\n        for (var sn = 0; sn < sNames.length; sn++) {\n            var superiorElement = matsParamUtils.getInputElementForParamName(sNames[sn]);\n            var selectedSuperiorValue = superiorElement.options[superiorElement.selectedIndex] === undefined ? matsParamUtils.getParameterForName(sNames[sn]).default : superiorElement.options[superiorElement.selectedIndex].text;\n            superiors[0] = superiors[0] === undefined ? [] : superiors[0];\n            superiors[0].push({element: superiorElement, value: selectedSuperiorValue});\n        }\n        for (var sNameIndex = 1; sNameIndex < superiorDimensionality; sNameIndex++) {\n            sNames = superiorNames[sNameIndex];\n            for (var sn = 0; sn < sNames.length; sn++) {\n                var superiorElement = matsParamUtils.getInputElementForParamName(sNames[sn]);\n                var selectedSuperiorValue = superiorElement.options[superiorElement.selectedIndex] === undefined ? matsParamUtils.getParameterForName(sNames[sn]).default : superiorElement.options[superiorElement.selectedIndex].text;\n                superiors[sNameIndex] = superiors[sNameIndex] === undefined ? [] : superiors[sNameIndex];\n                superiors[sNameIndex].push({element: superiorElement, value: selectedSuperiorValue});\n            }\n        }\n    }\n    /*\n    So what are superiors now.....\n    superiors = [[{element:anElement,value:aValue},{element:anElement,value:aValue}...]]\n    or they might be [[{element:anElement,value:aValue},{element:anElement,value:aValue}...],[{element:anElement,value:aValue},{element:anElement,value:aValue}...],...]\n\n\n     Axis-brothers:\n     Axis-brothers are for scatter plots. They are a second hidden set of parameters that apply to a different axis.\n     Because there may be axis \"brothers\" This refresh must go and\n     see if there are any brother elements that are essentially hidden copies\n     of this one, and also refresh their options lists\n\n     Superior Heirarchy:\n     There can be a heirarchy of superiors and dependents. The superiorNames are a list of paramNames. The most superior has the 0th index and\n     the least superior has the highest index.\n     The Refresh uses the superiors to get the appropriate options for a given options map.\n     The way it works is that superiors are always refreshed first. The superior heirarchy selections are then used by a\n     dependent to retrieve its appropriate optionsMap from the superiorOptionsMap.\n     superiorsOptionsMap = {\n        mostSuperiorValue0: {  // optionsMap for the most superior first value\n            nextSuperiorValue0: [value0,value1,value2,value3,...],\n            nextSuperiorValue1: [value0,value1,value2,value3,...],\n            nextSuperiorValue2: [value0,value1,value2,value3,...],\n            ...\n        },\n        mostSuperiorValue1:{  // optionsMap for the most superior second value\n            nextSuperiorValue0: [value0,value1,value2,value3,...],\n            nextSuperiorValue1: [value0,value1,value2,value3,...],\n            nextSuperiorValue2: [value0,value1,value2,value3,...],\n            ...\n        },\n        ...,\n        mostSuperiorValue2:{  // optionsMap for the most superior third value\n            nextSuperiorValue0: [value0,value1,value2,value3,...],\n            nextSuperiorValue1: [value0,value1,value2,value3,...],\n            nextSuperiorValue2: [value0,value1,value2,value3,...],\n            ...\n        },\n     }\n     */\n\n    // find all the elements that have ids like .... \"x|y|z\" + \"axis-\" + this.name\n    const name = param.name;\n    const elems = document.getElementsByClassName(\"data-input\") === undefined ? [] : document.getElementsByClassName(\"data-input\");\n    Session.set('selected', $(elem).val());\n\n    if (elem && elem.options) {\n        if (elem.selectedIndex === undefined || elem.selectedIndex === -1) {\n            if (param.default !== matsTypes.InputTypes.unused) {\n                elem.selectedIndex = 0;\n            }\n        }\n        const selectedText = elem.selectedIndex >= 0 ? elem.options[elem.selectedIndex].text : matsTypes.InputTypes.unused;\n        var brothers = [];\n        for (var i = 0; i < elems.length; i++) {\n            if (elems[i].id.indexOf(name) >= 0 && elems[i].id !== elem.id)\n                brothers.push(elems[i]);\n        }\n\n        var myOptions = [];\n        var selectedSuperiorValues = [];\n\n        try {\n            // index down through the options for the list of superiors\n            // starting with the most superior down through the least superior\n            // and get the options list for the first set of superiors.\n            // These are the ancestral options.\n            if (param.optionsMap) {\n                var firstSuperiorOptions = optionsMap;\n                var theseSuperiors = superiors === undefined || superiors.length === 0 ? [] : superiors[0];\n                for (var theseSuperiorsIndex = 0; theseSuperiorsIndex < theseSuperiors.length; theseSuperiorsIndex++) {\n                    var superior = theseSuperiors[theseSuperiorsIndex];\n                    var selectedSuperiorValue = superior.value;\n                    firstSuperiorOptions = firstSuperiorOptions[selectedSuperiorValue];\n                }\n                myOptions = Array.isArray(firstSuperiorOptions) ? firstSuperiorOptions : Object.keys(firstSuperiorOptions);\n            } else {\n                myOptions = param.options;\n            }\n\n            // need to get the ancestral truth options because we may need to intersect the options\n\n\n            /* tricky little bit here:\n            SuperiorDimensionality:\n             It is possible to have two superior options maps.. i.e. datasource and truth.\n             In that case the superiorNames won't look like [\"something\",\"somethingelse\"],\n             instead it will look like [[\"something\",\"somethingelse\"],[\"someotherthing\",\"someotherthingelse\"]]\n             i.e. it will be a multidimensional array.\n\n             If the controlButton for one of these multi-dimensional superior elements is hidden ....\n             matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent !== null\n             it has been hidden because it has a visibility dependency on another param\n             i.e. truth-data-source and truth-variable (for mean there would be no truth, but for bias\n             there must always be truth...).\n             In this case these are dependent upon statistic such that if the statistic is \"mean\" the truth-data-source and truth-variable\n             are hidden. See the wfip2 main.js statistic param as an example....\n             \"disableOtherFor:{'truth-data-source':[statisticOptionsMap.mean][0]},\"\n             and\n             \"hideOtherFor:{'truth-data-source':[statisticOptionsMap.mean][0]},\"\n             are the fields that cause the truth-data-source to be hidden when statistic is set to \"mean\".\n             In that condition (the controlButton is hidden) the superior should not be used as an intersection in the selected sites.\n             matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent will be null if the controlButton\n             for this element (this superior) is hidden. That is the tricky part ... it will be null.\n\n             Also the unused superior is tested against the superior according to the truth table...\n             used && unused  -> use the used\n             unused and used -> use the used\n             used and used -> use the intersection\n             unused and unused - set the options to []\n\n             A select may have a list of disabledOptions. These are used as optionGroup markers.\n             */\n\n            // need to get the actual options here\n            for (var sNameIndex = 1; sNameIndex < superiorDimensionality; sNameIndex++) {\n                // index down through the options for the list of superiors\n                // starting with the most superior down through the least superior\n                // and get the options list for the first set of superiors.\n                // These are the ancestral options.\n                var nextSuperiorOptions = optionsMap;\n                var theseSuperiors = superiors === undefined || superiors.length === 0 ? [] : superiors[sNameIndex];\n                for (var theseSuperiorsIndex = 0; theseSuperiorsIndex < theseSuperiors.length; theseSuperiorsIndex++) {\n                    var superior = theseSuperiors[theseSuperiorsIndex];\n                    var selectedSuperiorValue = superior.value;\n                    nextSuperiorOptions = nextSuperiorOptions[selectedSuperiorValue];\n                }\n                // since we now have multiple options we have to intersect them\n                myOptions = _.intersection(myOptions, nextSuperiorOptions);\n            }\n            if (myOptions === []) {  // none used - set to []\n                matsParamUtils.setValueTextForParamName(name, matsTypes.InputTypes.unused);\n            }\n        } catch (e) {\n            e.message = \"INFO: Error in select.js refresh: determining options from superiors: \" + e.message;\n            setInfo(e.message);\n        }\n\n        try {\n            // reset the options of the select\n            // if the options are null it might be that this is the initial setup.\n            // so use the optionsmap and the default options for the map\n            // it might also mean that there are no superiors for this param\n            if (myOptions == null) {\n                // get the default options\n                if (optionsGroups) {\n                    // optionGroups are an ordered map. It probably has options that are in the disabledOption list\n                    // which are used as markers in the select options pulldown. This is typical for models\n                    const optionsGroupsKeys = Object.keys(optionsGroups);\n                    for (var k = 0; k < optionsGroupsKeys.length; k++) {\n                        if (myOptions === null) {\n                            myOptions = [];\n                            myOptions.push(optionsGroupsKeys[k]);\n                            myOptions = myOptions.concat(optionsGroups[optionsGroupsKeys[k]]); // the primary group does not get sorted\n                        } else {\n                            myOptions.push(optionsGroupsKeys[k]);\n                            myOptions = myOptions.concat(optionsGroups[optionsGroupsKeys[k]].sort()); // non primary  groups get sorted\n                        }\n                    }\n                } else {\n                    myOptions = param.options;\n                }\n            }\n            var optionsAsString = \"\";\n            if (myOptions === undefined || myOptions == null) {\n                return;\n            }\n            var firstGroup = true;\n            for (var i = 0; i < myOptions.length; i++) {\n                var dIndex = disabledOptions === undefined ? -1 : disabledOptions.indexOf(myOptions[i]);\n                if (dIndex >= 0) {   // the option was found in the disabled options so it needs to be an optgroup label\n                    // disabled option\n                    if (firstGroup === true) {\n                        // first in group\n                        optionsAsString += \"<optgroup label=\" + myOptions[i] + \">\";\n                        firstGroup = false;\n                    } else {\n                        optionsAsString += \"</optgroup>\";\n                        optionsAsString += \"<optgroup label=\" + myOptions[i] + \">\";\n                    }\n                } else {\n                    //regular option - the option was not found in the disabled options\n                    optionsAsString += \"<option value='\" + myOptions[i] + \"'>\" + myOptions[i] + \"</option>\";\n                }\n            }\n            if (disabledOptions !== undefined) {\n                optionsAsString += \"</optgroup>\";\n            }\n            $('select[name=\"' + name + '\"]').empty().append(optionsAsString);\n            //reset the selected index if it had been set prior (the list may have changed so the index may have changed)\n            var selectedOptionIndex;\n            if (selectedText === 'initial') {\n                selectedOptionIndex = myOptions.indexOf(param.default);\n            } else {\n                selectedOptionIndex = myOptions.indexOf(selectedText);\n            }\n            var sviText = \"\";\n            if (selectedOptionIndex == -1 && elem.selectedIndex >= 0) {\n                for (var svi = 0; svi < selectedSuperiorValues.length; svi++) {\n                    superior = superiors[svi];\n                    if (matsParamUtils.getControlElementForParamName(superior.element.name).offsetParent !== null) {\n                        if (svi > 0) {\n                            sviText += \" and \";\n                        }\n                        sviText += selectedSuperiorValues[svi]\n                    }\n                }\n                setInfo(\"I changed your selected \" + name + \": '\" + selectedText + \"' to '\" + myOptions[0] + \"' because '\" + selectedText + \"' is no longer an option for \" + sviText);\n            }\n            // if the selectedText existed in the new options list then the selectedOptionIndex won't be -1 and we have to choose the default option\n            if (selectedOptionIndex === -1) {\n                // if the param default is unused set it to unused\n                // else just choose the 0th element in the element options. default?\n                if (param.default === matsTypes.InputTypes.unused) {\n                    matsParamUtils.setValueTextForParamName(name, matsTypes.InputTypes.unused);\n                } else {\n                    elem.selectedIndex = 0;\n                    elem && elem.options && elem.selectedIndex >= 0 && elem.options[elem.selectedIndex].scrollIntoView();\n                    elem && elem.options && elem.selectedIndex >= 0 && matsParamUtils.setValueTextForParamName(name, elem.options[elem.selectedIndex].text);\n                }\n            } else {\n                elem.selectedIndex = selectedOptionIndex;\n                elem && elem.options && elem.selectedIndex >= 0 && elem.options[elem.selectedIndex].scrollIntoView();\n                elem && elem.options && elem.selectedIndex >= 0 && matsParamUtils.setValueTextForParamName(name, elem.options[elem.selectedIndex].text);\n            }\n            for (var i = 0; i < brothers.length; i++) {\n                const belem = brothers[i];\n                const belemSelectedOptions = $(belem.selectedOptions).map(function () {\n                    return (this.value)\n                }).get();\n                if (belemSelectedOptions === undefined || belemSelectedOptions.length === 0) {\n                    belem.options = [];\n                    for (var i1 = 0; i1 < myOptions.length; i1++) {\n                        belem.options[belem.options.length] = new Option(myOptions[i1], myOptions[i1], i1 == 0, i1 == 0);\n                    }\n                }\n            }\n        } catch (e) {\n            e.message = \"INFO: Error in select.js refresh: resetting selected options: \" + e.message;\n            setInfo(e.message);\n        }\n    }\n    refreshPeer(event, param);\n};  // refresh function\n\nexport default matsSelectUtils = {\n    refresh: refresh,\n    refreshPeer: refreshPeer,\n    refreshDependents: refreshDependents,\n    checkDisableOther: checkDisableOther,\n    checkHideOther: checkHideOther\n};\n\n            "]},"sourceType":"script","hash":"19b00bda12a51c29874190b0153e232c1886eff5"}
