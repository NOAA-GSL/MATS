{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/routepolicy/routepolicy.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/routepolicy/routepolicy.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/routepolicy/routepolicy.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/routepolicy/routepolicy.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/routepolicy/routepolicy.js"}},"code":"module.export({\n  default: () => RoutePolicy\n});\n\nclass RoutePolicy {\n  constructor() {\n    // maps prefix to a type\n    this.urlPrefixTypes = {};\n  }\n\n  urlPrefixMatches(urlPrefix, url) {\n    return url.startsWith(urlPrefix);\n  }\n\n  checkType(type) {\n    if (!['network', 'static-online'].includes(type)) {\n      return 'the route type must be \"network\" or \"static-online\"';\n    }\n\n    return null;\n  }\n\n  checkUrlPrefix(urlPrefix, type) {\n    if (!urlPrefix.startsWith('/')) {\n      return 'a route URL prefix must begin with a slash';\n    }\n\n    if (urlPrefix === '/') {\n      return 'a route URL prefix cannot be /';\n    }\n\n    const existingType = this.urlPrefixTypes[urlPrefix];\n\n    if (existingType && existingType !== type) {\n      return `the route URL prefix ${urlPrefix} has already been declared ` + `to be of type ${existingType}`;\n    }\n\n    return null;\n  }\n\n  checkForConflictWithStatic(urlPrefix, type, _testManifest) {\n    if (type === 'static-online') {\n      return null;\n    }\n\n    const policy = this;\n\n    function check(manifest) {\n      const conflict = manifest.find(resource => resource.type === 'static' && resource.where === 'client' && policy.urlPrefixMatches(urlPrefix, resource.url));\n\n      if (conflict) {\n        return `static resource ${conflict.url} conflicts with ${type} ` + `route ${urlPrefix}`;\n      }\n\n      return null;\n    }\n\n    ;\n\n    if (_testManifest) {\n      return check(_testManifest);\n    }\n\n    const {\n      WebApp\n    } = require(\"meteor/webapp\");\n\n    let errorMessage = null;\n    Object.keys(WebApp.clientPrograms).some(arch => {\n      const {\n        manifest\n      } = WebApp.clientPrograms[arch];\n      return errorMessage = check(manifest);\n    });\n    return errorMessage;\n  }\n\n  declare(urlPrefix, type) {\n    const problem = this.checkType(type) || this.checkUrlPrefix(urlPrefix, type) || this.checkForConflictWithStatic(urlPrefix, type);\n\n    if (problem) {\n      throw new Error(problem);\n    } // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/\n\n\n    this.urlPrefixTypes[urlPrefix] = type;\n  }\n\n  isValidUrl(url) {\n    return url.startsWith('/');\n  }\n\n  classify(url) {\n    if (!this.isValidUrl(url)) {\n      throw new Error(`url must be a relative URL: ${url}`);\n    }\n\n    const prefix = Object.keys(this.urlPrefixTypes).find(prefix => this.urlPrefixMatches(prefix, url));\n    return prefix ? this.urlPrefixTypes[prefix] : null;\n  }\n\n  urlPrefixesFor(type) {\n    return Object.entries(this.urlPrefixTypes).filter(([_prefix, _type]) => _type === type).map(([_prefix]) => _prefix).sort();\n  }\n\n}","map":{"version":3,"sources":["packages/routepolicy/routepolicy.js"],"names":["module","export","default","RoutePolicy","constructor","urlPrefixTypes","urlPrefixMatches","urlPrefix","url","startsWith","checkType","type","includes","checkUrlPrefix","existingType","checkForConflictWithStatic","_testManifest","policy","check","manifest","conflict","find","resource","where","WebApp","require","errorMessage","Object","keys","clientPrograms","some","arch","declare","problem","Error","isValidUrl","classify","prefix","urlPrefixesFor","entries","filter","_prefix","_type","map","sort"],"mappings":"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","sourcesContent":["// In addition to listing specific files to be cached, the browser\n// application cache manifest allows URLs to be designated as NETWORK\n// (always fetched from the Internet) and FALLBACK (which we use to\n// serve app HTML on arbitrary URLs).\n//\n// The limitation of the manifest file format is that the designations\n// are by prefix only: if \"/foo\" is declared NETWORK then \"/foobar\"\n// will also be treated as a network route.\n//\n// RoutePolicy is a low-level API for declaring the route type of URL prefixes:\n//\n// \"network\": for network routes that should not conflict with static\n// resources.  (For example, if \"/sockjs/\" is a network route, we\n// shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).\n//\n// \"static-online\": for static resources which should not be cached in\n// the app cache.  This is implemented by also adding them to the\n// NETWORK section (as otherwise the browser would receive app HTML\n// for them because of the FALLBACK section), but static-online routes\n// don't need to be checked for conflict with static resources.\n\n\nexport default class RoutePolicy {\n  constructor() {\n    // maps prefix to a type\n    this.urlPrefixTypes = {};\n  }\n\n  urlPrefixMatches(urlPrefix, url) {\n    return url.startsWith(urlPrefix);\n  }\n\n  checkType(type) {\n    if (!['network', 'static-online'].includes(type)) {\n      return 'the route type must be \"network\" or \"static-online\"';\n    }\n    return null;\n  }\n\n  checkUrlPrefix(urlPrefix, type) {\n    if (!urlPrefix.startsWith('/')) {\n      return 'a route URL prefix must begin with a slash';\n    }\n\n    if (urlPrefix === '/') {\n      return 'a route URL prefix cannot be /';\n    }\n\n    const existingType = this.urlPrefixTypes[urlPrefix];\n    if (existingType && existingType !== type) {\n      return `the route URL prefix ${urlPrefix} has already been declared ` +\n        `to be of type ${existingType}`;\n    }\n\n    return null;\n  }\n\n  checkForConflictWithStatic(urlPrefix, type, _testManifest) {\n    if (type === 'static-online') {\n      return null;\n    }\n\n    const policy = this;\n\n    function check(manifest) {\n      const conflict = manifest.find(resource => (\n        resource.type === 'static' &&\n        resource.where === 'client' &&\n        policy.urlPrefixMatches(urlPrefix, resource.url)\n      ));\n\n      if (conflict) {\n        return `static resource ${conflict.url} conflicts with ${type} ` +\n          `route ${urlPrefix}`;\n      }\n\n      return null;\n    };\n\n    if (_testManifest) {\n      return check(_testManifest);\n    }\n\n    const { WebApp } = require(\"meteor/webapp\");\n    let errorMessage = null;\n\n    Object.keys(WebApp.clientPrograms).some(arch => {\n      const { manifest } = WebApp.clientPrograms[arch];\n      return errorMessage = check(manifest);\n    });\n\n    return errorMessage;\n  }\n\n  declare(urlPrefix, type) {\n    const problem =\n      this.checkType(type) ||\n      this.checkUrlPrefix(urlPrefix, type) ||\n      this.checkForConflictWithStatic(urlPrefix, type);\n    if (problem) {\n      throw new Error(problem);\n    }\n    // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/\n    this.urlPrefixTypes[urlPrefix] = type;\n  }\n\n  isValidUrl(url) {\n    return url.startsWith('/');\n  }\n\n  classify(url) {\n    if (!this.isValidUrl(url)) {\n      throw new Error(`url must be a relative URL: ${url}`);\n    }\n\n    const prefix = Object.keys(this.urlPrefixTypes).find(prefix =>\n      this.urlPrefixMatches(prefix, url)\n    );\n\n    return prefix ? this.urlPrefixTypes[prefix] : null;\n  }\n\n  urlPrefixesFor(type) {\n    return Object.entries(this.urlPrefixTypes)\n      .filter(([_prefix, _type]) => _type === type)\n      .map(([_prefix]) => _prefix)\n      .sort();\n  }\n}\n"]},"sourceType":"script","hash":"252aaf0477a39cb02daea9542a3b239da7f0f915"}
