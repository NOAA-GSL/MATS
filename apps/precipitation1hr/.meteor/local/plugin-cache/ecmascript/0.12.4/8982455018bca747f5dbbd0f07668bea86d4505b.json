{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_process_util.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_process_util.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_process_util.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_process_util.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_process_util.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes: function (v) {\n    matsTypes = v;\n  }\n}, 0);\nvar matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections: function (v) {\n    matsCollections = v;\n  }\n}, 1);\nvar matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils: function (v) {\n    matsDataUtils = v;\n  }\n}, 2);\nvar matsDataMatchUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataMatchUtils: function (v) {\n    matsDataMatchUtils = v;\n  }\n}, 3);\nvar matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils: function (v) {\n    matsDataDiffUtils = v;\n  }\n}, 4);\nvar matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils: function (v) {\n    matsDataCurveOpsUtils = v;\n  }\n}, 5);\nvar matsDataPlotOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataPlotOpsUtils: function (v) {\n    matsDataPlotOpsUtils = v;\n  }\n}, 6);\nvar moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment: function (v) {\n    moment = v;\n  }\n}, 7);\n\nvar processDataXYCurve = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {\n  // variable to store maximum error bar length\n  var errorMax = Number.MIN_VALUE;\n  var error = \"\";\n  var appName = matsCollections.appName.findOne({}).app; // if matching, pare down dataset to only matching data\n\n  if (curveInfoParams.curvesLength > 1 && appParams.matching) {\n    if (appParams.hasLevels) {\n      dataset = matsDataMatchUtils.getMatchedDataSetWithLevels(dataset, curveInfoParams.curvesLength, appParams.plotType);\n    } else {\n      dataset = matsDataMatchUtils.getMatchedDataSet(dataset, curveInfoParams.curvesLength);\n    }\n  } // we may need to recalculate the axis limits after unmatched data and outliers are removed\n\n\n  var axisLimitReprocessed = {}; // calculate data statistics (including error bars) for each curve\n\n  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n    if (appName !== \"surfrad\") {\n      axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] = axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] !== undefined;\n    }\n\n    var diffFrom = curveInfoParams.curves[curveIndex].diffFrom;\n    var statisticSelect = appName.indexOf(\"anomalycor\") !== -1 ? \"ACC\" : curveInfoParams.curves[curveIndex]['statistic'];\n    var data = dataset[curveIndex];\n    var _label = dataset[curveIndex].label;\n    var di = 0;\n    var values = [];\n    var indVars = [];\n    var means = [];\n    var rawStat;\n    /*\n    dataset[curveIndex] is the dataset.\n    it looks like:\n     d = {\n        x: [],\n        y: [],\n        error_x: [],   // curveTime\n        error_y: [],   // values\n        subVals: [],   //subVals\n        subSecs: [],   //subSecs\n        subLevs: [],   //subLevs\n        stats: [],     //pointStats\n        text: [],\n        glob_stats: {},     //curveStats\n        xmin: Number.MAX_VALUE,\n        xmax: Number.MIN_VALUE,\n        ymin: Number.MAX_VALUE,\n        ymax: Number.MIN_VALUE,\n        sum: 0\n    };\n    */\n\n    while (di < data.x.length) {\n      // errorResult holds all the calculated curve stats like mean, sd, etc.\n      var errorResult;\n\n      if (appParams.hasLevels) {\n        errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], data.subLevs[di]);\n      } else {\n        errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], []);\n      } // store raw statistic from query before recalculating that statistic to account for data removed due to matching, QC, etc.\n\n\n      rawStat = data.y[di]; // this ungainly if statement is because the surfrad3 database doesn't support recalculating some stats.\n\n      if (appName !== \"surfrad\" || !(appName === \"surfrad\" && (statisticSelect === 'Std deviation (do not plot matched)' || statisticSelect === 'RMS (do not plot matched)') && !appParams.matching)) {\n        if (diffFrom === null || diffFrom === undefined || !appParams.matching) {\n          // assign recalculated statistic to data[di][1], which is the value to be plotted\n          data.y[di] = errorResult.d_mean;\n        } else {\n          if (dataset[diffFrom[0]].y[di] !== null && dataset[diffFrom[1]].y[di] !== null) {\n            // make sure that the diff curve actually shows the difference when matching. Otherwise outlier filtering etc. can make it slightly off.\n            data.y[di] = dataset[diffFrom[0]].y[di] - dataset[diffFrom[1]].y[di];\n          } else {\n            // keep the null for no data at this point\n            data.y[di] = null;\n          }\n        }\n      }\n\n      values.push(data.y[di]);\n      indVars.push(data.x[di]);\n      means.push(errorResult.d_mean); // store error bars if matching\n\n      var errorBar = errorResult.stde_betsy * 1.96;\n\n      if (appParams.matching) {\n        errorMax = errorMax > errorBar ? errorMax : errorBar;\n        data.error_y.array[di] = errorBar;\n      } else {\n        data.error_y.array[di] = null;\n      } // remove sub values and times to save space\n\n\n      data.subVals[di] = [];\n      data.subSecs[di] = [];\n      data.subLevs[di] = []; // store statistics for this di datapoint\n\n      data.stats[di] = {\n        raw_stat: rawStat,\n        d_mean: errorResult.d_mean,\n        sd: errorResult.sd,\n        n_good: errorResult.n_good,\n        lag1: errorResult.lag1,\n        stde_betsy: errorResult.stde_betsy\n      }; // this is the tooltip, it is the last element of each dataseries element.\n      // also change the x array from epoch to date for timeseries and DMC, as we are now done with it for calculations.\n\n      data.text[di] = _label;\n\n      switch (appParams.plotType) {\n        case matsTypes.PlotTypes.timeSeries:\n          data.text[di] = data.text[di] + \"<br>time: \" + moment.utc(data.x[di]).format(\"YYYY-MM-DD HH:mm\");\n          break;\n\n        case matsTypes.PlotTypes.dailyModelCycle:\n          var fhr = data.x[di] / 1000 % (24 * 3600) / 3600 - curveInfoParams.utcCycleStarts[curveIndex];\n          fhr = fhr < 0 ? fhr + 24 : fhr;\n          data.text[di] = data.text[di] + \"<br>time: \" + moment.utc(data.x[di]).format(\"YYYY-MM-DD HH:mm\");\n          data.text[di] = data.text[di] + \"<br>forecast hour: \" + fhr;\n          break;\n\n        case matsTypes.PlotTypes.dieoff:\n          data.text[di] = data.text[di] + \"<br>fhr: \" + data.x[di];\n          break;\n\n        case matsTypes.PlotTypes.threshold:\n          data.text[di] = data.text[di] + \"<br>threshold: \" + data.x[di];\n          break;\n\n        case matsTypes.PlotTypes.validtime:\n          data.text[di] = data.text[di] + \"<br>hour of day: \" + data.x[di];\n          break;\n\n        default:\n          data.text[di] = data.text[di] + \"<br>\" + data.x[di];\n          break;\n      }\n\n      data.text[di] = data.text[di] + \"<br>\" + statisticSelect + \": \" + (data.y[di] === null ? null : data.y[di].toPrecision(4)) + \"<br>sd: \" + (errorResult.sd === null ? null : errorResult.sd.toPrecision(4)) + \"<br>mean: \" + (errorResult.d_mean === null ? null : errorResult.d_mean.toPrecision(4)) + \"<br>n: \" + errorResult.n_good + // \"<br>lag1: \" + (errorResult.lag1 === null ? null : errorResult.lag1.toPrecision(4)) +\n      // \"<br>stde: \" + errorResult.stde_betsy +\n      \"<br>errorbars: \" + Number(data.y[di] - errorResult.stde_betsy * 1.96).toPrecision(4) + \" to \" + Number(data.y[di] + errorResult.stde_betsy * 1.96).toPrecision(4);\n      di++;\n    } // enable error bars if matching and they aren't null\n\n\n    if (appParams.matching && data.error_y.array.filter(function (x) {\n      return x;\n    }).length > 0) {\n      data.error_y.visible = true;\n    } // get the overall stats for the text output - this uses the means not the stats.\n\n\n    var stats = matsDataUtils.get_err(values, indVars, []);\n    var filteredMeans = means.filter(function (x) {\n      return x;\n    });\n    var miny = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredMeans));\n    var maxy = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredMeans));\n\n    if (means.indexOf(0) !== -1 && 0 < miny) {\n      miny = 0;\n    }\n\n    if (means.indexOf(0) !== -1 && 0 > maxy) {\n      maxy = 0;\n    }\n\n    stats.miny = miny;\n    stats.maxy = maxy;\n    dataset[curveIndex]['glob_stats'] = stats; // recalculate axis options after QC and matching\n\n    if (appName !== \"surfrad\") {\n      var minx = Math.min.apply(Math, indVars);\n      var maxx = Math.max.apply(Math, indVars);\n      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'] < maxy || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? maxy : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'];\n      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'] > miny || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? miny : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'];\n      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] < maxx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? maxx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'];\n      curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] > minx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? minx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'];\n    } // recalculate curve annotation after QC and matching\n\n\n    if (stats.d_mean !== undefined && stats.d_mean !== null) {\n      dataset[curveIndex]['annotation'] = _label + \"- mean = \" + stats.d_mean.toPrecision(4);\n    }\n\n    if (appParams.plotType === matsTypes.PlotTypes.timeSeries || appParams.plotType === matsTypes.PlotTypes.dailyModelCycle) {\n      data['x_epoch'] = data.x;\n      data.x = data.x.map(function (val) {\n        return moment.utc(val).format(\"YYYY-MM-DD HH:mm\");\n      });\n    }\n  } // add black 0 line curve\n  // need to define the minimum and maximum x value for making the zero curve\n\n\n  var zeroLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, 0, matsTypes.ReservedWords.zero);\n  dataset.push(zeroLine); //add ideal value lines, if any\n\n  var idealValueLine;\n  var idealLabel;\n\n  for (var ivIdx = 0; ivIdx < curveInfoParams.idealValues.length; ivIdx++) {\n    idealLabel = \"ideal\" + ivIdx.toString();\n    idealValueLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, curveInfoParams.idealValues[ivIdx], matsTypes.ReservedWords[idealLabel]);\n    dataset.push(idealValueLine);\n  } // generate plot options\n\n\n  var resultOptions;\n\n  switch (appParams.plotType) {\n    case matsTypes.PlotTypes.timeSeries:\n    case matsTypes.PlotTypes.dailyModelCycle:\n      resultOptions = matsDataPlotOpsUtils.generateSeriesPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n      break;\n\n    case matsTypes.PlotTypes.dieoff:\n      resultOptions = matsDataPlotOpsUtils.generateDieoffPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n      break;\n\n    case matsTypes.PlotTypes.validtime:\n      resultOptions = matsDataPlotOpsUtils.generateValidTimePlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n      break;\n\n    case matsTypes.PlotTypes.threshold:\n      resultOptions = matsDataPlotOpsUtils.generateThresholdPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n      break;\n\n    default:\n      break;\n  }\n\n  var totalProcessingFinish = moment();\n  bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n    begin: bookkeepingParams.totalProcessingStart.format(),\n    finish: totalProcessingFinish.format(),\n    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n  }; // pass result to client-side plotting functions\n\n  return {\n    error: error,\n    data: dataset,\n    options: resultOptions,\n    basis: {\n      plotParams: plotParams,\n      queries: bookkeepingParams.dataRequests\n    }\n  };\n};\n\nvar processDataProfile = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {\n  // variable to store maximum error bar length\n  var errorMax = Number.MIN_VALUE;\n  var error = \"\";\n  var appName = matsCollections.appName.findOne({}).app; // if matching, pare down dataset to only matching data\n\n  if (curveInfoParams.curvesLength > 1 && appParams.matching) {\n    dataset = matsDataMatchUtils.getMatchedDataSetWithLevels(dataset, curveInfoParams.curvesLength, appParams.plotType);\n  } // we may need to recalculate the axis limits after unmatched data and outliers are removed\n\n\n  var axisLimitReprocessed = {}; // calculate data statistics (including error bars) for each curve\n\n  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n    axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] = axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] !== undefined;\n    var diffFrom = curveInfoParams.curves[curveIndex].diffFrom;\n    var statisticSelect = appName.indexOf(\"anomalycor\") !== -1 ? \"ACC\" : curveInfoParams.curves[curveIndex]['statistic'];\n    var data = dataset[curveIndex];\n    var _label2 = dataset[curveIndex].label;\n    var di = 0;\n    var values = [];\n    var levels = [];\n    var means = [];\n    var rawStat;\n    /*\n    dataset[curveIndex] is the dataset.\n    it looks like:\n     d = {\n        x: [],\n        y: [],\n        error_x: [],   // curveTime\n        error_y: [],   // values\n        subVals: [],   //subVals\n        subSecs: [],   //subSecs\n        subLevs: [],   //subLevs\n        stats: [],     //pointStats\n        text: [],\n        glob_stats: {},     //curveStats\n        xmin: Number.MAX_VALUE,\n        xmax: Number.MIN_VALUE,\n        ymin: Number.MAX_VALUE,\n        ymax: Number.MIN_VALUE,\n        sum: 0\n    };\n    */\n\n    while (di < data.y.length) {\n      // errorResult holds all the calculated curve stats like mean, sd, etc.\n      var errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], data.subLevs[di]); // store raw statistic from query before recalculating that statistic to account for data removed due to matching, QC, etc.\n\n      rawStat = data.x[di];\n\n      if (diffFrom === null || diffFrom === undefined || !appParams.matching) {\n        // assign recalculated statistic to data[di][1], which is the value to be plotted\n        data.x[di] = errorResult.d_mean;\n      } else {\n        if (dataset[diffFrom[0]].x[di] !== null && dataset[diffFrom[1]].x[di] !== null) {\n          // make sure that the diff curve actually shows the difference when matching. Otherwise outlier filtering etc. can make it slightly off.\n          data.x[di] = dataset[diffFrom[0]].x[di] - dataset[diffFrom[1]].x[di];\n        } else {\n          // keep the null for no data at this point\n          data.x[di] = null;\n        }\n      }\n\n      values.push(data.x[di]);\n      levels.push(data.y[di]);\n      means.push(errorResult.d_mean); // store error bars if matching\n\n      var errorBar = errorResult.stde_betsy * 1.96;\n\n      if (appParams.matching) {\n        errorMax = errorMax > errorBar ? errorMax : errorBar;\n        data.error_x.array[di] = errorBar;\n      } else {\n        data.error_x.array[di] = null;\n      } // remove sub values and times to save space\n\n\n      data.subVals[di] = [];\n      data.subSecs[di] = [];\n      data.subLevs[di] = []; // store statistics\n\n      data.stats[di] = {\n        raw_stat: rawStat,\n        d_mean: errorResult.d_mean,\n        sd: errorResult.sd,\n        n_good: errorResult.n_good,\n        lag1: errorResult.lag1,\n        stde_betsy: errorResult.stde_betsy\n      }; // this is the tooltip, it is the last element of each dataseries element\n\n      data.text[di] = _label2 + \"<br>\" + data.y[di] + \"mb\" + \"<br>\" + statisticSelect + \": \" + (data.x[di] === null ? null : data.x[di].toPrecision(4)) + \"<br>sd: \" + (errorResult.sd === null ? null : errorResult.sd.toPrecision(4)) + \"<br>mean: \" + (errorResult.d_mean === null ? null : errorResult.d_mean.toPrecision(4)) + \"<br>n: \" + errorResult.n_good + // \"<br>lag1: \" + (errorResult.lag1 === null ? null : errorResult.lag1.toPrecision(4)) +\n      // \"<br>stde: \" + errorResult.stde_betsy +\n      \"<br>errorbars: \" + Number(data.x[di] - errorResult.stde_betsy * 1.96).toPrecision(4) + \" to \" + Number(data.x[di] + errorResult.stde_betsy * 1.96).toPrecision(4);\n      di++;\n    } // enable error bars if matching and they aren't null\n\n\n    if (appParams.matching && data.error_x.array.filter(function (x) {\n      return x;\n    }).length > 0) {\n      data.error_x.visible = true;\n    } // get the overall stats for the text output - this uses the means not the stats.\n\n\n    var stats = matsDataUtils.get_err(values.reverse(), levels.reverse(), []); // have to reverse because of data inversion\n\n    var filteredMeans = means.filter(function (x) {\n      return x;\n    });\n    var minx = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredMeans));\n    var maxx = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredMeans));\n\n    if (means.indexOf(0) !== -1 && 0 < minx) {\n      minx = 0;\n    }\n\n    if (means.indexOf(0) !== -1 && 0 > maxx) {\n      maxx = 0;\n    }\n\n    stats.minx = minx;\n    stats.maxx = maxx;\n    dataset[curveIndex]['glob_stats'] = stats; // recalculate axis options after QC and matching\n\n    curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] < maxx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? maxx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'];\n    curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] = curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] > minx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] ? minx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin']; // recalculate curve annotation after QC and matching\n\n    if (stats.d_mean !== undefined && stats.d_mean !== null) {\n      dataset[curveIndex]['annotation'] = _label2 + \"- mean = \" + stats.d_mean.toPrecision(4);\n    }\n  } // add black 0 line curve\n  // need to define the minimum and maximum x value for making the zero curve\n\n\n  var zeroLine = matsDataCurveOpsUtils.getVerticalValueLine(1100, 0, 0, matsTypes.ReservedWords.zero);\n  dataset.push(zeroLine); //add ideal value lines, if any\n\n  var idealValueLine;\n  var idealLabel;\n\n  for (var ivIdx = 0; ivIdx < curveInfoParams.idealValues.length; ivIdx++) {\n    idealLabel = \"ideal\" + ivIdx.toString();\n    idealValueLine = matsDataCurveOpsUtils.getVerticalValueLine(1100, 0, curveInfoParams.idealValues[ivIdx], matsTypes.ReservedWords[idealLabel]);\n    dataset.push(idealValueLine);\n  } // generate plot options\n\n\n  var resultOptions = matsDataPlotOpsUtils.generateProfilePlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n  var totalProcessingFinish = moment();\n  bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n    begin: bookkeepingParams.totalProcessingStart.format(),\n    finish: totalProcessingFinish.format(),\n    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n  }; // pass result to client-side plotting functions\n\n  return {\n    error: error,\n    data: dataset,\n    options: resultOptions,\n    basis: {\n      plotParams: plotParams,\n      queries: bookkeepingParams.dataRequests\n    }\n  };\n};\n\nvar processDataReliability = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {\n  var error = \"\"; // calculate data statistics (including error bars) for each curve\n\n  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n    var data = dataset[curveIndex];\n    var _label3 = dataset[curveIndex].label;\n    var sample_climo = data.subVals;\n    var di = 0;\n    /*\n    dataset[curveIndex] is the dataset.\n    it looks like:\n     d = {\n        x: [],\n        y: [],\n        error_x: [],   // curveTime\n        error_y: [],   // values\n        subVals: [],   //subVals\n        subSecs: [],   //subSecs\n        subLevs: [],   //subLevs\n        stats: [],     //pointStats\n        text: [],\n        glob_stats: {},     //curveStats\n        xmin: Number.MAX_VALUE,\n        xmax: Number.MIN_VALUE,\n        ymin: Number.MAX_VALUE,\n        ymax: Number.MIN_VALUE,\n        sum: 0\n    };\n    */\n\n    while (di < data.x.length) {\n      // store statistics for this di datapoint\n      data.stats[di] = {\n        prob_bin: data.x[di],\n        hit_rate: data.y[di],\n        obs_y: data.error_x[di],\n        obs_n: data.subLevs[di]\n      }; // this is the tooltip, it is the last element of each dataseries element.\n      // also change the x array from epoch to date for timeseries and DMC, as we are now done with it for calculations.\n\n      data.text[di] = _label3;\n      data.text[di] = data.text[di] + \"<br>probability bin: \" + data.x[di];\n      data.text[di] = data.text[di] + \"<br>hit rate: \" + data.y[di];\n      data.text[di] = data.text[di] + \"<br>oy: \" + data.error_x[di];\n      data.text[di] = data.text[di] + \"<br>on: \" + data.subLevs[di]; // remove sub values and times to save space\n\n      data.subVals[di] = [];\n      data.subSecs[di] = [];\n      data.subLevs[di] = [];\n      di++;\n    }\n\n    dataset[curveIndex]['glob_stats'] = {\n      sample_climo: sample_climo\n    };\n  } // add black perfect reliability line curve\n\n\n  var perfectLine = matsDataCurveOpsUtils.getLinearValueLine(curveInfoParams.xmax, curveInfoParams.xmin, data.ymax, data.ymin, matsTypes.ReservedWords.perfectReliability);\n  dataset.push(perfectLine);\n\n  if (sample_climo >= data.ymin) {\n    var skillmin = sample_climo - (sample_climo - data.xmin) / 2;\n  } else {\n    var skillmin = data.xmin - (data.xmin - sample_climo) / 2;\n  }\n\n  if (sample_climo >= data.ymax) {\n    var skillmax = sample_climo - (sample_climo - data.xmax) / 2;\n  } else {\n    var skillmax = data.xmax - (data.xmax - sample_climo) / 2;\n  } // add black no skill line curve\n\n\n  var noSkillLine = matsDataCurveOpsUtils.getLinearValueLine(curveInfoParams.xmax, curveInfoParams.xmin, skillmax, skillmin, matsTypes.ReservedWords.noSkill);\n  dataset.push(noSkillLine); // add sample climo lines\n  // need to define the minimum and maximum x value for making the curves\n\n  var xClimoLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, sample_climo, matsTypes.ReservedWords.zero);\n  dataset.push(xClimoLine);\n  var yClimoLine = matsDataCurveOpsUtils.getVerticalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, sample_climo, matsTypes.ReservedWords.zero);\n  dataset.push(yClimoLine); // generate plot options\n\n  var resultOptions = matsDataPlotOpsUtils.generateReliabilityPlotOptions();\n  var totalProcessingFinish = moment();\n  bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n    begin: bookkeepingParams.totalProcessingStart.format(),\n    finish: totalProcessingFinish.format(),\n    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n  }; // pass result to client-side plotting functions\n\n  return {\n    error: error,\n    data: dataset,\n    options: resultOptions,\n    basis: {\n      plotParams: plotParams,\n      queries: bookkeepingParams.dataRequests\n    }\n  };\n};\n\nvar processDataHistogram = function (allReturnedSubStats, allReturnedSubSecs, allReturnedSubLevs, dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams) {\n  var error = \"\";\n  var curvesLengthSoFar = 0; // flatten all the returned data into one stats array and one secs array in order to calculate histogram bins over the whole range.\n\n  var curveSubStats = [].concat.apply([], allReturnedSubStats);\n  var curveSubSecs = [].concat.apply([], allReturnedSubSecs);\n  var binStats;\n\n  if (binParams.binBounds.length === 0) {\n    binStats = matsDataUtils.calculateHistogramBins(curveSubStats, curveSubSecs, binParams).binStats;\n  } else {\n    binStats = matsDataUtils.prescribeHistogramBins(curveSubStats, curveSubSecs, binParams).binStats;\n  } // store bin labels and x-axis positions of those labels for later when we set up the plot options\n\n\n  var plotBins = {};\n  plotBins['binMeans'] = [];\n  plotBins['binLabels'] = [];\n\n  for (var b_idx = 0; b_idx < binStats.binMeans.length; b_idx++) {\n    plotBins['binMeans'].push(binStats.binMeans[b_idx]);\n    plotBins['binLabels'].push(binStats.binLabels[b_idx]);\n  } // post process curves\n\n\n  var sortedData;\n  var curve;\n  var diffFrom;\n  var label;\n\n  for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n    curve = curveInfoParams.curves[curveIndex];\n    diffFrom = curve.diffFrom;\n    label = curve.label;\n    var d = {\n      // d will contain the curve data\n      x: [],\n      //placeholder\n      y: [],\n      //placeholder\n      error_x: [],\n      // unused\n      error_y: [],\n      // unused\n      subVals: [],\n      subSecs: [],\n      subLevs: [],\n      glob_stats: {},\n      // placeholder\n      bin_stats: [],\n      // placeholder\n      text: [],\n      //placeholder\n      xmin: Number.MAX_VALUE,\n      xmax: Number.MIN_VALUE,\n      ymin: Number.MAX_VALUE,\n      ymax: Number.MIN_VALUE\n    };\n\n    if (diffFrom == null) {\n      var postQueryStartMoment = moment();\n\n      if (curveInfoParams.dataFoundForCurve[curveIndex]) {\n        // sort queried data into the full set of histogram bins\n        sortedData = matsDataUtils.sortHistogramBins(allReturnedSubStats[curveIndex], allReturnedSubSecs[curveIndex], allReturnedSubLevs[curveIndex], binParams.binNum, binStats, appParams.hasLevels, d);\n        d = sortedData.d;\n      }\n    } else {\n      // this is a difference curve, so we're done with regular curves.\n      // do any matching that needs to be done.\n      if (appParams.matching && !bookkeepingParams.alreadyMatched) {\n        if (appParams.hasLevels) {\n          dataset = matsDataMatchUtils.getMatchedDataSetHistogramWithLevels(dataset, curvesLengthSoFar, binStats);\n        } else {\n          dataset = matsDataMatchUtils.getMatchedDataSetHistogram(dataset, curvesLengthSoFar, binStats);\n        }\n\n        bookkeepingParams.alreadyMatched = true;\n      } // then take diffs\n\n\n      var diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, matsTypes.PlotTypes.histogram, appParams.hasLevels); // adjust axis stats based on new data from diff curve\n\n      d = diffResult.dataset;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    curve['annotation'] = \"\";\n    curve['axisKey'] = curveInfoParams.curves[curveIndex].axisKey;\n    var cOptions = matsDataCurveOpsUtils.generateBarChartCurveOptions(curve, curveIndex, curveInfoParams.axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    curvesLengthSoFar++;\n    var postQueryFinishMoment = moment();\n    bookkeepingParams.dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // if matching, pare down dataset to only matching data. Only do this if we didn't already do it while calculating diffs.\n\n\n  if (curveInfoParams.curvesLength > 1 && appParams.matching && !bookkeepingParams.alreadyMatched) {\n    if (appParams.hasLevels) {\n      dataset = matsDataMatchUtils.getMatchedDataSetHistogramWithLevels(dataset, curveInfoParams.curvesLength, binStats);\n    } else {\n      dataset = matsDataMatchUtils.getMatchedDataSetHistogram(dataset, curveInfoParams.curvesLength, binStats);\n    }\n  } // calculate data statistics (including error bars) for each curve\n\n\n  for (curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n    var statisticSelect = curveInfoParams.curves[curveIndex]['statistic'];\n    diffFrom = curveInfoParams.curves[curveIndex].diffFrom;\n    var data = dataset[curveIndex];\n    label = dataset[curveIndex].label;\n    var di = 0;\n\n    while (di < data.x.length) {\n      if (curveInfoParams.yAxisFormat === 'Relative frequency') {\n        // replace the bin number with the bin relative frequency for the plotted statistic\n        data.y[di] = data.bin_stats[di].bin_rf * 100;\n      } // remove sub values and times to save space\n\n\n      data.subVals[di] = [];\n      data.subSecs[di] = [];\n      data.subLevs[di] = []; // this is the tooltip, it is the last element of each dataseries element\n\n      data.text[di] = label + \"<br>\" + \"bin: \" + di + \" (\" + statisticSelect + \" values between \" + (data.bin_stats[di].binLowBound === null ? null : data.bin_stats[di].binLowBound.toPrecision(4)) + \" and \" + (data.bin_stats[di].binUpBound === null ? null : data.bin_stats[di].binUpBound.toPrecision(4)) + \")\" + \"<br>\" + \"number in bin for this curve: \" + (data.y[di] === null ? null : data.y[di]) + \"<br>bin mean for this curve: \" + statisticSelect + \" = \" + (data.bin_stats[di].bin_mean === null ? null : data.bin_stats[di].bin_mean.toPrecision(4)) + \"<br>bin sd  for this curve: \" + statisticSelect + \" = \" + (data.bin_stats[di].bin_sd === null ? null : data.bin_stats[di].bin_sd.toPrecision(4));\n      di++;\n    }\n  } // end curves\n  // generate plot options\n\n\n  var resultOptions = matsDataPlotOpsUtils.generateHistogramPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, plotBins);\n  var totalProcessingFinish = moment();\n  bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n    begin: bookkeepingParams.totalProcessingStart.format(),\n    finish: totalProcessingFinish.format(),\n    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n  }; // pass result to client-side plotting functions\n\n  return {\n    error: error,\n    data: dataset,\n    options: resultOptions,\n    basis: {\n      plotParams: plotParams,\n      queries: bookkeepingParams.dataRequests\n    }\n  };\n};\n\nvar processDataContour = function (dataset, curveInfoParams, plotParams, bookkeepingParams) {\n  var error = \"\";\n  var appName = matsCollections.appName.findOne({}).app;\n  var statisticSelect = appName.indexOf(\"anomalycor\") !== -1 ? \"ACC\" : curveInfoParams.curve[0]['statistic'];\n  var data = dataset[0];\n  var label = dataset[0].label;\n\n  if (data.xAxisKey.indexOf(\"Date\") !== -1) {\n    data.x = data.x.map(function (val) {\n      return moment.utc(val * 1000).format(\"YYYY-MM-DD HH:mm\");\n    });\n  } else if (data.yAxisKey.indexOf(\"Date\") !== -1) {\n    data.y = data.y.map(function (val) {\n      return moment.utc(val * 1000).format(\"YYYY-MM-DD HH:mm\");\n    });\n  }\n\n  var i;\n  var j;\n  var currX;\n  var currY;\n  var currText;\n  var currYTextArray;\n\n  for (j = 0; j < data.y.length; j++) {\n    currY = data.y[j];\n    currYTextArray = [];\n\n    for (i = 0; i < data.x.length; i++) {\n      currX = data.x[i];\n      currText = label + \"<br>\" + data['xAxisKey'] + \": \" + data.x[i] + \"<br>\" + data['yAxisKey'] + \": \" + data.y[j] + \"<br>\" + statisticSelect + \": \" + (data.z[j][i] === undefined || data.z[j][i] === null || data.z[j][i] === 'null' ? null : data.z[j][i].toPrecision(4)) + \"<br>n: \" + data['n'][j][i];\n      currYTextArray.push(currText);\n    }\n\n    data.text.push(currYTextArray);\n  } // generate plot options\n\n\n  var resultOptions = matsDataPlotOpsUtils.generateContourPlotOptions(dataset, curveInfoParams.axisMap);\n  var totalProcessingFinish = moment();\n  bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n    begin: bookkeepingParams.totalProcessingStart.format(),\n    finish: totalProcessingFinish.format(),\n    duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n  }; // pass result to client-side plotting functions\n\n  return {\n    error: error,\n    data: dataset,\n    options: resultOptions,\n    basis: {\n      plotParams: plotParams,\n      queries: bookkeepingParams.dataRequests\n    }\n  };\n};\n\nmodule.exportDefault(matsDataProcessUtils = {\n  processDataXYCurve: processDataXYCurve,\n  processDataProfile: processDataProfile,\n  processDataReliability: processDataReliability,\n  processDataHistogram: processDataHistogram,\n  processDataContour: processDataContour\n});","map":{"version":3,"sources":["packages/randyp:mats-common/imports/startup/server/data_process_util.js"],"names":["matsTypes","module","link","v","matsCollections","matsDataUtils","matsDataMatchUtils","matsDataDiffUtils","matsDataCurveOpsUtils","matsDataPlotOpsUtils","moment","processDataXYCurve","dataset","appParams","curveInfoParams","plotParams","bookkeepingParams","errorMax","Number","MIN_VALUE","error","appName","findOne","app","curvesLength","matching","hasLevels","getMatchedDataSetWithLevels","plotType","getMatchedDataSet","axisLimitReprocessed","curveIndex","curves","axisKey","undefined","diffFrom","statisticSelect","indexOf","data","label","di","values","indVars","means","rawStat","x","length","errorResult","get_err","subVals","subSecs","subLevs","y","d_mean","push","errorBar","stde_betsy","error_y","array","stats","raw_stat","sd","n_good","lag1","text","PlotTypes","timeSeries","utc","format","dailyModelCycle","fhr","utcCycleStarts","dieoff","threshold","validtime","toPrecision","filter","visible","filteredMeans","miny","Math","min","maxy","max","minx","maxx","axisMap","map","val","zeroLine","getHorizontalValueLine","xmax","xmin","ReservedWords","zero","idealValueLine","idealLabel","ivIdx","idealValues","toString","resultOptions","generateSeriesPlotOptions","generateDieoffPlotOptions","generateValidTimePlotOptions","generateThresholdPlotOptions","totalProcessingFinish","dataRequests","begin","totalProcessingStart","finish","duration","diff","asSeconds","options","basis","queries","processDataProfile","levels","error_x","reverse","getVerticalValueLine","generateProfilePlotOptions","processDataReliability","sample_climo","prob_bin","hit_rate","obs_y","obs_n","perfectLine","getLinearValueLine","ymax","ymin","perfectReliability","skillmin","skillmax","noSkillLine","noSkill","xClimoLine","yClimoLine","generateReliabilityPlotOptions","processDataHistogram","allReturnedSubStats","allReturnedSubSecs","allReturnedSubLevs","binParams","curvesLengthSoFar","curveSubStats","concat","apply","curveSubSecs","binStats","binBounds","calculateHistogramBins","prescribeHistogramBins","plotBins","b_idx","binMeans","binLabels","sortedData","curve","d","glob_stats","bin_stats","MAX_VALUE","postQueryStartMoment","dataFoundForCurve","sortHistogramBins","binNum","alreadyMatched","getMatchedDataSetHistogramWithLevels","getMatchedDataSetHistogram","diffResult","getDataForDiffCurve","histogram","cOptions","generateBarChartCurveOptions","postQueryFinishMoment","yAxisFormat","bin_rf","binLowBound","binUpBound","bin_mean","bin_sd","generateHistogramPlotOptions","processDataContour","xAxisKey","yAxisKey","i","j","currX","currY","currText","currYTextArray","z","generateContourPlotOptions","exportDefault","matsDataProcessUtils"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataMatchUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataPlotOpsUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\nconst processDataXYCurve = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {\n    // variable to store maximum error bar length\n    var errorMax = Number.MIN_VALUE;\n    var error = \"\";\n\n    const appName = matsCollections.appName.findOne({}).app;\n\n    // if matching, pare down dataset to only matching data\n    if (curveInfoParams.curvesLength > 1 && appParams.matching) {\n        if (appParams.hasLevels) {\n            dataset = matsDataMatchUtils.getMatchedDataSetWithLevels(dataset, curveInfoParams.curvesLength, appParams.plotType);\n        } else {\n            dataset = matsDataMatchUtils.getMatchedDataSet(dataset, curveInfoParams.curvesLength);\n        }\n    }\n\n    // we may need to recalculate the axis limits after unmatched data and outliers are removed\n    var axisLimitReprocessed = {};\n\n    // calculate data statistics (including error bars) for each curve\n    for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n        if (appName !== \"surfrad\") {\n            axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] = axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] !== undefined;\n        }\n        var diffFrom = curveInfoParams.curves[curveIndex].diffFrom;\n        var statisticSelect = appName.indexOf(\"anomalycor\") !== -1 ? \"ACC\" : curveInfoParams.curves[curveIndex]['statistic'];\n        var data = dataset[curveIndex];\n        const label = dataset[curveIndex].label;\n\n        var di = 0;\n        var values = [];\n        var indVars = [];\n        var means = [];\n        var rawStat;\n\n        /*\n        dataset[curveIndex] is the dataset.\n        it looks like:\n\n        d = {\n            x: [],\n            y: [],\n            error_x: [],   // curveTime\n            error_y: [],   // values\n            subVals: [],   //subVals\n            subSecs: [],   //subSecs\n            subLevs: [],   //subLevs\n            stats: [],     //pointStats\n            text: [],\n            glob_stats: {},     //curveStats\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            sum: 0\n        };\n        */\n\n        while (di < data.x.length) {\n\n            // errorResult holds all the calculated curve stats like mean, sd, etc.\n            var errorResult;\n            if (appParams.hasLevels) {\n                errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], data.subLevs[di]);\n            } else {\n                errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], []);\n            }\n\n            // store raw statistic from query before recalculating that statistic to account for data removed due to matching, QC, etc.\n            rawStat = data.y[di];\n            // this ungainly if statement is because the surfrad3 database doesn't support recalculating some stats.\n            if (appName !== \"surfrad\" ||\n                !(appName === \"surfrad\" &&\n                    (statisticSelect === 'Std deviation (do not plot matched)' || statisticSelect === 'RMS (do not plot matched)') &&\n                    !appParams.matching)) {\n                if ((diffFrom === null || diffFrom === undefined) || !appParams.matching) {\n                    // assign recalculated statistic to data[di][1], which is the value to be plotted\n                    data.y[di] = errorResult.d_mean;\n                } else {\n                    if (dataset[diffFrom[0]].y[di] !== null && dataset[diffFrom[1]].y[di] !== null) {\n                        // make sure that the diff curve actually shows the difference when matching. Otherwise outlier filtering etc. can make it slightly off.\n                        data.y[di] = dataset[diffFrom[0]].y[di] - dataset[diffFrom[1]].y[di];\n                    } else {\n                        // keep the null for no data at this point\n                        data.y[di] = null;\n                    }\n                }\n            }\n            values.push(data.y[di]);\n            indVars.push(data.x[di]);\n            means.push(errorResult.d_mean);\n\n            // store error bars if matching\n            const errorBar = errorResult.stde_betsy * 1.96;\n            if (appParams.matching) {\n                errorMax = errorMax > errorBar ? errorMax : errorBar;\n                data.error_y.array[di] = errorBar;\n            } else {\n                data.error_y.array[di] = null;\n            }\n\n            // remove sub values and times to save space\n            data.subVals[di] = [];\n            data.subSecs[di] = [];\n            data.subLevs[di] = [];\n\n            // store statistics for this di datapoint\n            data.stats[di] = {\n                raw_stat: rawStat,\n                d_mean: errorResult.d_mean,\n                sd: errorResult.sd,\n                n_good: errorResult.n_good,\n                lag1: errorResult.lag1,\n                stde_betsy: errorResult.stde_betsy\n            };\n\n            // this is the tooltip, it is the last element of each dataseries element.\n            // also change the x array from epoch to date for timeseries and DMC, as we are now done with it for calculations.\n            data.text[di] = label;\n            switch (appParams.plotType) {\n                case matsTypes.PlotTypes.timeSeries:\n                    data.text[di] = data.text[di] + \"<br>time: \" + moment.utc(data.x[di]).format(\"YYYY-MM-DD HH:mm\");\n                    break;\n                case matsTypes.PlotTypes.dailyModelCycle:\n                    var fhr = ((data.x[di] / 1000) % (24 * 3600)) / 3600 - curveInfoParams.utcCycleStarts[curveIndex];\n                    fhr = fhr < 0 ? fhr + 24 : fhr;\n                    data.text[di] = data.text[di] + \"<br>time: \" + moment.utc(data.x[di]).format(\"YYYY-MM-DD HH:mm\");\n                    data.text[di] = data.text[di] + \"<br>forecast hour: \" + fhr;\n                    break;\n                case matsTypes.PlotTypes.dieoff:\n                    data.text[di] = data.text[di] + \"<br>fhr: \" + data.x[di];\n                    break;\n                case matsTypes.PlotTypes.threshold:\n                    data.text[di] = data.text[di] + \"<br>threshold: \" + data.x[di];\n                    break;\n                case matsTypes.PlotTypes.validtime:\n                    data.text[di] = data.text[di] + \"<br>hour of day: \" + data.x[di];\n                    break;\n                default:\n                    data.text[di] = data.text[di] + \"<br>\" + data.x[di];\n                    break;\n            }\n            data.text[di] = data.text[di] +\n                \"<br>\" + statisticSelect + \": \" + (data.y[di] === null ? null : data.y[di].toPrecision(4)) +\n                \"<br>sd: \" + (errorResult.sd === null ? null : errorResult.sd.toPrecision(4)) +\n                \"<br>mean: \" + (errorResult.d_mean === null ? null : errorResult.d_mean.toPrecision(4)) +\n                \"<br>n: \" + errorResult.n_good +\n                // \"<br>lag1: \" + (errorResult.lag1 === null ? null : errorResult.lag1.toPrecision(4)) +\n                // \"<br>stde: \" + errorResult.stde_betsy +\n                \"<br>errorbars: \" + Number((data.y[di]) - (errorResult.stde_betsy * 1.96)).toPrecision(4) + \" to \" + Number((data.y[di]) + (errorResult.stde_betsy * 1.96)).toPrecision(4);\n\n            di++;\n        }\n\n        // enable error bars if matching and they aren't null\n        if (appParams.matching && data.error_y.array.filter(x => x).length > 0) {\n            data.error_y.visible = true;\n        }\n\n        // get the overall stats for the text output - this uses the means not the stats.\n        const stats = matsDataUtils.get_err(values, indVars, []);\n        const filteredMeans = means.filter(x => x);\n        var miny = Math.min(...filteredMeans);\n        var maxy = Math.max(...filteredMeans);\n        if (means.indexOf(0) !== -1 && 0 < miny) {\n            miny = 0;\n        }\n        if (means.indexOf(0) !== -1 && 0 > maxy) {\n            maxy = 0;\n        }\n        stats.miny = miny;\n        stats.maxy = maxy;\n        dataset[curveIndex]['glob_stats'] = stats;\n\n        // recalculate axis options after QC and matching\n        if (appName !== \"surfrad\") {\n            const minx = Math.min(...indVars);\n            const maxx = Math.max(...indVars);\n            curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'] = (curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'] < maxy || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey]) ? maxy : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymax'];\n            curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'] = (curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'] > miny || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey]) ? miny : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['ymin'];\n            curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] = (curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] < maxx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey]) ? maxx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'];\n            curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] = (curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] > minx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey]) ? minx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'];\n        }\n\n        // recalculate curve annotation after QC and matching\n        if (stats.d_mean !== undefined && stats.d_mean !== null) {\n            dataset[curveIndex]['annotation'] = label + \"- mean = \" + stats.d_mean.toPrecision(4);\n        }\n\n        if (appParams.plotType === matsTypes.PlotTypes.timeSeries || appParams.plotType === matsTypes.PlotTypes.dailyModelCycle) {\n            data['x_epoch'] = data.x;\n            data.x = data.x.map(function (val) {\n                return moment.utc(val).format(\"YYYY-MM-DD HH:mm\");\n            });\n        }\n\n    }\n\n    // add black 0 line curve\n    // need to define the minimum and maximum x value for making the zero curve\n    const zeroLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, 0, matsTypes.ReservedWords.zero);\n    dataset.push(zeroLine);\n\n    //add ideal value lines, if any\n    var idealValueLine;\n    var idealLabel;\n    for (var ivIdx = 0; ivIdx < curveInfoParams.idealValues.length; ivIdx++) {\n        idealLabel = \"ideal\" + ivIdx.toString();\n        idealValueLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, curveInfoParams.idealValues[ivIdx], matsTypes.ReservedWords[idealLabel]);\n        dataset.push(idealValueLine);\n    }\n\n    // generate plot options\n    var resultOptions;\n    switch (appParams.plotType) {\n        case matsTypes.PlotTypes.timeSeries:\n        case matsTypes.PlotTypes.dailyModelCycle:\n            resultOptions = matsDataPlotOpsUtils.generateSeriesPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n            break;\n        case matsTypes.PlotTypes.dieoff:\n            resultOptions = matsDataPlotOpsUtils.generateDieoffPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n            break;\n        case matsTypes.PlotTypes.validtime:\n            resultOptions = matsDataPlotOpsUtils.generateValidTimePlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n            break;\n        case matsTypes.PlotTypes.threshold:\n            resultOptions = matsDataPlotOpsUtils.generateThresholdPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n            break;\n        default:\n            break;\n    }\n\n    var totalProcessingFinish = moment();\n    bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n        begin: bookkeepingParams.totalProcessingStart.format(),\n        finish: totalProcessingFinish.format(),\n        duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n    };\n\n    // pass result to client-side plotting functions\n    return {\n        error: error,\n        data: dataset,\n        options: resultOptions,\n        basis: {\n            plotParams: plotParams,\n            queries: bookkeepingParams.dataRequests\n        }\n    };\n};\n\nconst processDataProfile = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {\n    // variable to store maximum error bar length\n    var errorMax = Number.MIN_VALUE;\n    var error = \"\";\n\n    const appName = matsCollections.appName.findOne({}).app;\n\n    // if matching, pare down dataset to only matching data\n    if (curveInfoParams.curvesLength > 1 && appParams.matching) {\n        dataset = matsDataMatchUtils.getMatchedDataSetWithLevels(dataset, curveInfoParams.curvesLength, appParams.plotType);\n    }\n\n    // we may need to recalculate the axis limits after unmatched data and outliers are removed\n    var axisLimitReprocessed = {};\n\n    // calculate data statistics (including error bars) for each curve\n    for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n        axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] = axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey] !== undefined;\n        var diffFrom = curveInfoParams.curves[curveIndex].diffFrom;\n        var statisticSelect = appName.indexOf(\"anomalycor\") !== -1 ? \"ACC\" : curveInfoParams.curves[curveIndex]['statistic'];\n        var data = dataset[curveIndex];\n        const label = dataset[curveIndex].label;\n\n        var di = 0;\n        var values = [];\n        var levels = [];\n        var means = [];\n        var rawStat;\n\n        /*\n        dataset[curveIndex] is the dataset.\n        it looks like:\n\n        d = {\n            x: [],\n            y: [],\n            error_x: [],   // curveTime\n            error_y: [],   // values\n            subVals: [],   //subVals\n            subSecs: [],   //subSecs\n            subLevs: [],   //subLevs\n            stats: [],     //pointStats\n            text: [],\n            glob_stats: {},     //curveStats\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            sum: 0\n        };\n        */\n\n        while (di < data.y.length) {\n\n            // errorResult holds all the calculated curve stats like mean, sd, etc.\n            var errorResult = matsDataUtils.get_err(data.subVals[di], data.subSecs[di], data.subLevs[di]);\n\n            // store raw statistic from query before recalculating that statistic to account for data removed due to matching, QC, etc.\n            rawStat = data.x[di];\n            if ((diffFrom === null || diffFrom === undefined) || !appParams.matching) {\n                // assign recalculated statistic to data[di][1], which is the value to be plotted\n                data.x[di] = errorResult.d_mean;\n            } else {\n                if (dataset[diffFrom[0]].x[di] !== null && dataset[diffFrom[1]].x[di] !== null) {\n                    // make sure that the diff curve actually shows the difference when matching. Otherwise outlier filtering etc. can make it slightly off.\n                    data.x[di] = dataset[diffFrom[0]].x[di] - dataset[diffFrom[1]].x[di];\n                } else {\n                    // keep the null for no data at this point\n                    data.x[di] = null;\n                }\n            }\n            values.push(data.x[di]);\n            levels.push(data.y[di]);\n            means.push(errorResult.d_mean);\n\n            // store error bars if matching\n            const errorBar = errorResult.stde_betsy * 1.96;\n            if (appParams.matching) {\n                errorMax = errorMax > errorBar ? errorMax : errorBar;\n                data.error_x.array[di] = errorBar;\n            } else {\n                data.error_x.array[di] = null;\n            }\n\n            // remove sub values and times to save space\n            data.subVals[di] = [];\n            data.subSecs[di] = [];\n            data.subLevs[di] = [];\n\n            // store statistics\n            data.stats[di] = {\n                raw_stat: rawStat,\n                d_mean: errorResult.d_mean,\n                sd: errorResult.sd,\n                n_good: errorResult.n_good,\n                lag1: errorResult.lag1,\n                stde_betsy: errorResult.stde_betsy\n            };\n\n            // this is the tooltip, it is the last element of each dataseries element\n            data.text[di] = label +\n                \"<br>\" + data.y[di] + \"mb\" +\n                \"<br>\" + statisticSelect + \": \" + (data.x[di] === null ? null : data.x[di].toPrecision(4)) +\n                \"<br>sd: \" + (errorResult.sd === null ? null : errorResult.sd.toPrecision(4)) +\n                \"<br>mean: \" + (errorResult.d_mean === null ? null : errorResult.d_mean.toPrecision(4)) +\n                \"<br>n: \" + errorResult.n_good +\n                // \"<br>lag1: \" + (errorResult.lag1 === null ? null : errorResult.lag1.toPrecision(4)) +\n                // \"<br>stde: \" + errorResult.stde_betsy +\n                \"<br>errorbars: \" + Number((data.x[di]) - (errorResult.stde_betsy * 1.96)).toPrecision(4) + \" to \" + Number((data.x[di]) + (errorResult.stde_betsy * 1.96)).toPrecision(4);\n\n            di++;\n        }\n\n        // enable error bars if matching and they aren't null\n        if (appParams.matching && data.error_x.array.filter(x => x).length > 0) {\n            data.error_x.visible = true;\n        }\n\n        // get the overall stats for the text output - this uses the means not the stats.\n        const stats = matsDataUtils.get_err(values.reverse(), levels.reverse(), []); // have to reverse because of data inversion\n        const filteredMeans = means.filter(x => x);\n        var minx = Math.min(...filteredMeans);\n        var maxx = Math.max(...filteredMeans);\n        if (means.indexOf(0) !== -1 && 0 < minx) {\n            minx = 0;\n        }\n        if (means.indexOf(0) !== -1 && 0 > maxx) {\n            maxx = 0;\n        }\n        stats.minx = minx;\n        stats.maxx = maxx;\n        dataset[curveIndex]['glob_stats'] = stats;\n\n        // recalculate axis options after QC and matching\n        curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] = (curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'] < maxx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey]) ? maxx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmax'];\n        curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] = (curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'] > minx || !axisLimitReprocessed[curveInfoParams.curves[curveIndex].axisKey]) ? minx : curveInfoParams.axisMap[curveInfoParams.curves[curveIndex].axisKey]['xmin'];\n\n        // recalculate curve annotation after QC and matching\n        if (stats.d_mean !== undefined && stats.d_mean !== null) {\n            dataset[curveIndex]['annotation'] = label + \"- mean = \" + stats.d_mean.toPrecision(4);\n        }\n    }\n\n    // add black 0 line curve\n    // need to define the minimum and maximum x value for making the zero curve\n    const zeroLine = matsDataCurveOpsUtils.getVerticalValueLine(1100, 0, 0, matsTypes.ReservedWords.zero);\n    dataset.push(zeroLine);\n\n    //add ideal value lines, if any\n    var idealValueLine;\n    var idealLabel;\n    for (var ivIdx = 0; ivIdx < curveInfoParams.idealValues.length; ivIdx++) {\n        idealLabel = \"ideal\" + ivIdx.toString();\n        idealValueLine = matsDataCurveOpsUtils.getVerticalValueLine(1100, 0, curveInfoParams.idealValues[ivIdx], matsTypes.ReservedWords[idealLabel]);\n        dataset.push(idealValueLine);\n    }\n\n    // generate plot options\n    const resultOptions = matsDataPlotOpsUtils.generateProfilePlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, errorMax);\n    var totalProcessingFinish = moment();\n    bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n        begin: bookkeepingParams.totalProcessingStart.format(),\n        finish: totalProcessingFinish.format(),\n        duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n    };\n\n    // pass result to client-side plotting functions\n    return {\n        error: error,\n        data: dataset,\n        options: resultOptions,\n        basis: {\n            plotParams: plotParams,\n            queries: bookkeepingParams.dataRequests\n        }\n    };\n};\n\nconst processDataReliability = function (dataset, appParams, curveInfoParams, plotParams, bookkeepingParams) {\n    var error = \"\";\n\n    // calculate data statistics (including error bars) for each curve\n    for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n\n        var data = dataset[curveIndex];\n        const label = dataset[curveIndex].label;\n\n        var sample_climo = data.subVals;\n        var di = 0;\n\n        /*\n        dataset[curveIndex] is the dataset.\n        it looks like:\n\n        d = {\n            x: [],\n            y: [],\n            error_x: [],   // curveTime\n            error_y: [],   // values\n            subVals: [],   //subVals\n            subSecs: [],   //subSecs\n            subLevs: [],   //subLevs\n            stats: [],     //pointStats\n            text: [],\n            glob_stats: {},     //curveStats\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            sum: 0\n        };\n        */\n\n        while (di < data.x.length) {\n\n            // store statistics for this di datapoint\n            data.stats[di] = {\n                prob_bin: data.x[di],\n                hit_rate: data.y[di],\n                obs_y: data.error_x[di],\n                obs_n: data.subLevs[di]\n            };\n\n            // this is the tooltip, it is the last element of each dataseries element.\n            // also change the x array from epoch to date for timeseries and DMC, as we are now done with it for calculations.\n            data.text[di] = label;\n            data.text[di] = data.text[di] + \"<br>probability bin: \" + data.x[di];\n            data.text[di] = data.text[di] + \"<br>hit rate: \" + data.y[di];\n            data.text[di] = data.text[di] + \"<br>oy: \" + data.error_x[di];\n            data.text[di] = data.text[di] + \"<br>on: \" + data.subLevs[di];\n\n            // remove sub values and times to save space\n            data.subVals[di] = [];\n            data.subSecs[di] = [];\n            data.subLevs[di] = [];\n\n            di++;\n        }\n\n        dataset[curveIndex]['glob_stats'] = {\n            sample_climo: sample_climo\n        };\n    }\n\n    // add black perfect reliability line curve\n    const perfectLine = matsDataCurveOpsUtils.getLinearValueLine(curveInfoParams.xmax, curveInfoParams.xmin, data.ymax, data.ymin, matsTypes.ReservedWords.perfectReliability);\n    dataset.push(perfectLine);\n\n    if (sample_climo >= data.ymin) {\n        var skillmin = sample_climo - ((sample_climo - data.xmin) / 2);\n    } else {\n        var skillmin = data.xmin - ((data.xmin - sample_climo) / 2);\n    }\n    if (sample_climo >= data.ymax) {\n        var skillmax = sample_climo - ((sample_climo - data.xmax) / 2);\n    } else {\n        var skillmax = data.xmax - ((data.xmax - sample_climo) / 2);\n    }\n\n\n    // add black no skill line curve\n    const noSkillLine = matsDataCurveOpsUtils.getLinearValueLine(curveInfoParams.xmax, curveInfoParams.xmin, skillmax, skillmin, matsTypes.ReservedWords.noSkill);\n    dataset.push(noSkillLine);\n\n    // add sample climo lines\n    // need to define the minimum and maximum x value for making the curves\n    const xClimoLine = matsDataCurveOpsUtils.getHorizontalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, sample_climo, matsTypes.ReservedWords.zero);\n    dataset.push(xClimoLine);\n\n    const yClimoLine = matsDataCurveOpsUtils.getVerticalValueLine(curveInfoParams.xmax, curveInfoParams.xmin, sample_climo, matsTypes.ReservedWords.zero);\n    dataset.push(yClimoLine);\n\n    // generate plot options\n    var resultOptions = matsDataPlotOpsUtils.generateReliabilityPlotOptions();\n\n    var totalProcessingFinish = moment();\n    bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n        begin: bookkeepingParams.totalProcessingStart.format(),\n        finish: totalProcessingFinish.format(),\n        duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n    };\n\n    // pass result to client-side plotting functions\n    return {\n        error: error,\n        data: dataset,\n        options: resultOptions,\n        basis: {\n            plotParams: plotParams,\n            queries: bookkeepingParams.dataRequests\n        }\n    };\n};\n\nconst processDataHistogram = function (allReturnedSubStats, allReturnedSubSecs, allReturnedSubLevs, dataset, appParams, curveInfoParams, plotParams, binParams, bookkeepingParams) {\n    var error = \"\";\n    var curvesLengthSoFar = 0;\n\n    // flatten all the returned data into one stats array and one secs array in order to calculate histogram bins over the whole range.\n    const curveSubStats = [].concat.apply([], allReturnedSubStats);\n    const curveSubSecs = [].concat.apply([], allReturnedSubSecs);\n\n    var binStats;\n    if (binParams.binBounds.length === 0) {\n        binStats = matsDataUtils.calculateHistogramBins(curveSubStats, curveSubSecs, binParams).binStats;\n    } else {\n        binStats = matsDataUtils.prescribeHistogramBins(curveSubStats, curveSubSecs, binParams).binStats;\n    }\n\n    // store bin labels and x-axis positions of those labels for later when we set up the plot options\n    var plotBins = {};\n    plotBins['binMeans'] = [];\n    plotBins['binLabels'] = [];\n    for (var b_idx = 0; b_idx < binStats.binMeans.length; b_idx++) {\n        plotBins['binMeans'].push(binStats.binMeans[b_idx]);\n        plotBins['binLabels'].push(binStats.binLabels[b_idx]);\n    }\n\n    // post process curves\n    var sortedData;\n    var curve;\n    var diffFrom;\n    var label;\n    for (var curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n        curve = curveInfoParams.curves[curveIndex];\n        diffFrom = curve.diffFrom;\n        label = curve.label;\n\n        var d = {// d will contain the curve data\n            x: [], //placeholder\n            y: [], //placeholder\n            error_x: [], // unused\n            error_y: [], // unused\n            subVals: [],\n            subSecs: [],\n            subLevs: [],\n            glob_stats: {}, // placeholder\n            bin_stats: [], // placeholder\n            text: [], //placeholder\n            xmin: Number.MAX_VALUE,\n            xmax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n        };\n\n        if (diffFrom == null) {\n            var postQueryStartMoment = moment();\n            if (curveInfoParams.dataFoundForCurve[curveIndex]) {\n                // sort queried data into the full set of histogram bins\n                sortedData = matsDataUtils.sortHistogramBins(allReturnedSubStats[curveIndex], allReturnedSubSecs[curveIndex], allReturnedSubLevs[curveIndex], binParams.binNum, binStats, appParams.hasLevels, d);\n                d = sortedData.d;\n            }\n        } else {\n            // this is a difference curve, so we're done with regular curves.\n            // do any matching that needs to be done.\n            if (appParams.matching && !bookkeepingParams.alreadyMatched) {\n                if (appParams.hasLevels) {\n                    dataset = matsDataMatchUtils.getMatchedDataSetHistogramWithLevels(dataset, curvesLengthSoFar, binStats);\n                } else {\n                    dataset = matsDataMatchUtils.getMatchedDataSetHistogram(dataset, curvesLengthSoFar, binStats);\n                }\n                bookkeepingParams.alreadyMatched = true;\n            }\n\n            // then take diffs\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, matsTypes.PlotTypes.histogram, appParams.hasLevels);\n\n            // adjust axis stats based on new data from diff curve\n            d = diffResult.dataset;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        curve['annotation'] = \"\";\n        curve['axisKey'] = curveInfoParams.curves[curveIndex].axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateBarChartCurveOptions(curve, curveIndex, curveInfoParams.axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        curvesLengthSoFar++;\n        var postQueryFinishMoment = moment();\n        bookkeepingParams.dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // if matching, pare down dataset to only matching data. Only do this if we didn't already do it while calculating diffs.\n    if (curveInfoParams.curvesLength > 1 && (appParams.matching && !bookkeepingParams.alreadyMatched)) {\n        if (appParams.hasLevels) {\n            dataset = matsDataMatchUtils.getMatchedDataSetHistogramWithLevels(dataset, curveInfoParams.curvesLength, binStats);\n        } else {\n            dataset = matsDataMatchUtils.getMatchedDataSetHistogram(dataset, curveInfoParams.curvesLength, binStats);\n        }\n    }\n\n    // calculate data statistics (including error bars) for each curve\n    for (curveIndex = 0; curveIndex < curveInfoParams.curvesLength; curveIndex++) {\n        var statisticSelect = curveInfoParams.curves[curveIndex]['statistic'];\n        diffFrom = curveInfoParams.curves[curveIndex].diffFrom;\n        var data = dataset[curveIndex];\n        label = dataset[curveIndex].label;\n\n        var di = 0;\n\n        while (di < data.x.length) {\n\n            if (curveInfoParams.yAxisFormat === 'Relative frequency') {\n                // replace the bin number with the bin relative frequency for the plotted statistic\n                data.y[di] = data.bin_stats[di].bin_rf * 100;\n            }\n\n            // remove sub values and times to save space\n            data.subVals[di] = [];\n            data.subSecs[di] = [];\n            data.subLevs[di] = [];\n\n            // this is the tooltip, it is the last element of each dataseries element\n            data.text[di] = label +\n                \"<br>\" + \"bin: \" + di + \" (\" + statisticSelect + \" values between \" + (data.bin_stats[di].binLowBound === null ? null : data.bin_stats[di].binLowBound.toPrecision(4)) + \" and \" + (data.bin_stats[di].binUpBound === null ? null : data.bin_stats[di].binUpBound.toPrecision(4)) + \")\" +\n                \"<br>\" + \"number in bin for this curve: \" + (data.y[di] === null ? null : data.y[di]) +\n                \"<br>bin mean for this curve: \" + statisticSelect + \" = \" + (data.bin_stats[di].bin_mean === null ? null : data.bin_stats[di].bin_mean.toPrecision(4)) +\n                \"<br>bin sd  for this curve: \" + statisticSelect + \" = \" + (data.bin_stats[di].bin_sd === null ? null : data.bin_stats[di].bin_sd.toPrecision(4));\n\n            di++;\n        }\n    } // end curves\n\n    // generate plot options\n    const resultOptions = matsDataPlotOpsUtils.generateHistogramPlotOptions(dataset, curveInfoParams.curves, curveInfoParams.axisMap, plotBins);\n    var totalProcessingFinish = moment();\n    bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n        begin: bookkeepingParams.totalProcessingStart.format(),\n        finish: totalProcessingFinish.format(),\n        duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n    };\n\n    // pass result to client-side plotting functions\n    return {\n        error: error,\n        data: dataset,\n        options: resultOptions,\n        basis: {\n            plotParams: plotParams,\n            queries: bookkeepingParams.dataRequests\n        }\n    };\n\n};\n\nconst processDataContour = function (dataset, curveInfoParams, plotParams, bookkeepingParams) {\n    var error = \"\";\n    const appName = matsCollections.appName.findOne({}).app;\n    var statisticSelect = appName.indexOf(\"anomalycor\") !== -1 ? \"ACC\" : curveInfoParams.curve[0]['statistic'];\n    var data = dataset[0];\n    const label = dataset[0].label;\n\n    if (data.xAxisKey.indexOf(\"Date\") !== -1) {\n        data.x = data.x.map(function (val) {\n            return moment.utc(val * 1000).format(\"YYYY-MM-DD HH:mm\");\n        });\n    } else if (data.yAxisKey.indexOf(\"Date\") !== -1) {\n        data.y = data.y.map(function (val) {\n            return moment.utc(val * 1000).format(\"YYYY-MM-DD HH:mm\");\n        });\n    }\n\n    var i;\n    var j;\n    var currX;\n    var currY;\n    var currText;\n    var currYTextArray;\n    for (j = 0; j < data.y.length; j++) {\n        currY = data.y[j];\n        currYTextArray = [];\n        for (i = 0; i < data.x.length; i++) {\n            currX = data.x[i];\n            currText = label +\n                \"<br>\" + data['xAxisKey'] + \": \" + data.x[i] +\n                \"<br>\" + data['yAxisKey'] + \": \" + data.y[j] +\n                \"<br>\" + statisticSelect + \": \" + (data.z[j][i] === undefined || data.z[j][i] === null || data.z[j][i] === 'null' ? null : data.z[j][i].toPrecision(4)) +\n                \"<br>n: \" + data['n'][j][i];\n            currYTextArray.push(currText);\n        }\n        data.text.push(currYTextArray);\n    }\n\n    // generate plot options\n    const resultOptions = matsDataPlotOpsUtils.generateContourPlotOptions(dataset, curveInfoParams.axisMap);\n\n    var totalProcessingFinish = moment();\n    bookkeepingParams.dataRequests[\"total retrieval and processing time for curve set\"] = {\n        begin: bookkeepingParams.totalProcessingStart.format(),\n        finish: totalProcessingFinish.format(),\n        duration: moment.duration(totalProcessingFinish.diff(bookkeepingParams.totalProcessingStart)).asSeconds() + ' seconds'\n    };\n\n    // pass result to client-side plotting functions\n    return {\n        error: error,\n        data: dataset,\n        options: resultOptions,\n        basis: {\n            plotParams: plotParams,\n            queries: bookkeepingParams.dataRequests\n        }\n    };\n};\n\nexport default matsDataProcessUtils = {\n\n    processDataXYCurve: processDataXYCurve,\n    processDataProfile: processDataProfile,\n    processDataReliability: processDataReliability,\n    processDataHistogram: processDataHistogram,\n    processDataContour: processDataContour\n\n}"]},"sourceType":"script","hash":"8982455018bca747f5dbbd0f07668bea86d4505b"}
