{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_util.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_util.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_util.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_util.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_util.js"}},"code":"let matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 0);\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 1);\nlet matsPlotUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsPlotUtils(v) {\n    matsPlotUtils = v;\n  }\n\n}, 2);\n\n//this function checks if two JSON objects are identical\nconst areObjectsEqual = function (o, p) {\n  if (o && !p || p && !o) {\n    return false;\n  }\n\n  if (JSON.stringify(o) === JSON.stringify(p)) {\n    return true;\n  } else {\n    return false;\n  }\n}; //this function checks if values of subArray are also in superArray\n\n\nconst arrayContainsArray = function (superArray, subArray) {\n  superArray.sort(function (a, b) {\n    return Number(a) - Number(b);\n  });\n  subArray.sort(function (a, b) {\n    return Number(a) - Number(b);\n  });\n  var i, j;\n\n  for (i = 0, j = 0; i < superArray.length && j < subArray.length;) {\n    if (superArray[i] < subArray[j]) {\n      ++i;\n    } else if (superArray[i] === subArray[j]) {\n      ++i;\n      ++j;\n    } else {\n      // subArray[j] not in superArray, so superArray does not contain all elements of subArray\n      return false;\n    }\n  } // make sure there are no elements left in sub\n\n\n  return j === subArray.length;\n}; //this function checks if the entire array subArray is contained in superArray\n\n\nconst arrayContainsSubArray = function (superArray, subArray) {\n  var i, j, current;\n\n  for (i = 0; i < superArray.length; ++i) {\n    if (subArray.length === superArray[i].length) {\n      current = superArray[i];\n\n      for (j = 0; j < subArray.length && subArray[j] === current[j]; ++j);\n\n      if (j === subArray.length) return true;\n    }\n  }\n\n  return false;\n}; //this function checks if two arrays are identical\n\n\nconst arraysEqual = function (a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n};\n\nconst arrayUnique = function (a) {\n  var arr = [];\n\n  for (var i = 0; i < a.length; i++) {\n    if (!arr.includes(a[i])) {\n      arr.push(a[i]);\n    }\n  }\n\n  return arr;\n}; //this function finds the position of the array subArray in superArray\n\n\nconst findArrayInSubArray = function (superArray, subArray) {\n  var i, j, current;\n\n  for (i = 0; i < superArray.length; ++i) {\n    if (subArray.length === superArray[i].length) {\n      current = superArray[i];\n\n      for (j = 0; j < subArray.length && subArray[j] === current[j]; ++j);\n\n      if (j === subArray.length) return i;\n    }\n  }\n\n  return -1;\n}; //this function checks if an object is a value in another object\n\n\nconst objectContainsObject = function (superObject, subObject) {\n  const superObjectKeys = Object.keys(superObject);\n  var currentObject;\n\n  for (var i = 0; i < superObjectKeys.length; i++) {\n    currentObject = superObject[superObjectKeys[i]];\n\n    if (areObjectsEqual(subObject, currentObject)) {\n      return true;\n    }\n  } // if the loop completes, the subObject was not found\n\n\n  return false;\n}; //utility for calculating the average of an array\n\n\nconst average = function (data) {\n  var sum = data.reduce(function (sum, value) {\n    return value == null ? sum : sum + value;\n  }, 0);\n  var avg = sum / data.length;\n  return avg;\n}; //utility for calculating the stdev of an array\n\n\nconst stdev = function (data) {\n  var avg = average(data);\n  var squareDiffs = data.map(function (value) {\n    var diff = value - avg;\n    return diff * diff;\n  });\n  var avgSquareDiff = average(squareDiffs);\n  var stdDev = Math.sqrt(avgSquareDiff);\n  return stdDev;\n}; //this function makes sure date strings are in the correct format\n\n\nconst dateConvert = function (dStr) {\n  if (dStr === undefined || dStr === \" \") {\n    var now = new Date();\n    var date = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());\n    var yr = date.getUTCFullYear();\n    var day = date.getUTCDate();\n    var month = date.getUTCMonth();\n    var hour = date.getUTCHours();\n    var minute = date.getUTCMinutes();\n    return month + \"/\" + day + '/' + yr + ' ' + hour + \":\" + minute;\n  }\n\n  var dateParts = dStr.split(' ');\n  var dateArray = dateParts[0].split(/[\\-\\/]/); // split on - or /    01-01-2017 OR 01/01/2017\n\n  var month = dateArray[0];\n  var day = dateArray[1];\n  var yr = dateArray[2];\n  var hour = 0;\n  var minute = 0;\n\n  if (dateParts[1]) {\n    var timeArray = dateParts[1].split(\":\");\n    hour = timeArray[0];\n    minute = timeArray[1];\n  }\n\n  return month + \"/\" + day + '/' + yr + ' ' + hour + \":\" + minute;\n}; //splits the date range string from the date selector into standardized fromDate/toDate strings,\n// plus the epochs for the fromDate and toDate\n\n\nconst getDateRange = function (dateRange) {\n  var dates = dateRange.split(' - ');\n  var fromDateStr = dates[0];\n  var fromDate = dateConvert(fromDateStr);\n  var toDateStr = dates[1];\n  var toDate = dateConvert(toDateStr);\n  var fromSecs = secsConvert(fromDateStr);\n  var toSecs = secsConvert(toDateStr);\n  return {\n    fromDate: fromDate,\n    toDate: toDate,\n    fromSeconds: fromSecs,\n    toSeconds: toSecs\n  };\n}; //this function converts a date string into an epoch\n\n\nconst secsConvert = function (dStr) {\n  if (dStr === undefined || dStr === \" \") {\n    var now = new Date();\n    return now.getTime() / 1000;\n  } else {\n    var dateParts = dStr.split(' ');\n    var dateArray = dateParts[0].split(/[\\-\\/]/); // split on - or /    01-01-2017 OR 01/01/2017\n\n    var month = dateArray[0];\n    var day = dateArray[1];\n    var yr = dateArray[2];\n    var hour = 0;\n    var minute = 0;\n\n    if (dateParts[1]) {\n      var timeArray = dateParts[1].split(\":\");\n      hour = timeArray[0];\n      minute = timeArray[1];\n    }\n\n    var my_date = new Date(Date.UTC(yr, month - 1, day, hour, minute, 0)); // to UTC time, not local time\n\n    var date_in_secs = my_date.getTime();\n  } // to UTC time, not local time\n  //return date_in_secs/1000 -3600*6;\n\n\n  return date_in_secs / 1000;\n}; //function to manage authorized logins for MATS\n\n\nconst doAuthorization = function () {\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.Authorization.remove({});\n  }\n\n  if (matsCollections.Authorization.find().count() == 0) {\n    matsCollections.Authorization.insert({\n      email: \"randy.pierce@noaa.gov\",\n      roles: [\"administrator\"]\n    });\n    matsCollections.Authorization.insert({\n      email: \"kirk.l.holub@noaa.gov\",\n      roles: [\"administrator\"]\n    });\n    matsCollections.Authorization.insert({\n      email: \"jeffrey.a.hamilton@noaa.gov\",\n      roles: [\"administrator\"]\n    });\n    matsCollections.Authorization.insert({\n      email: \"bonny.strong@noaa.gov\",\n      roles: [\"administrator\"]\n    });\n    matsCollections.Authorization.insert({\n      email: \"molly.b.smith@noaa.gov\",\n      roles: [\"administrator\"]\n    });\n    matsCollections.Authorization.insert({\n      email: \"mats.gsd@noaa.gov\",\n      roles: [\"administrator\"]\n    });\n  }\n}; //master list of colors for MATS curves\n\n\nconst doColorScheme = function () {\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.ColorScheme.remove({});\n  }\n\n  if (matsCollections.ColorScheme.find().count() == 0) {\n    matsCollections.ColorScheme.insert({\n      colors: [\"rgb(255,0,0)\", \"rgb(0,0,255)\", \"rgb(255,165,0)\", \"rgb(128,128,128)\", \"rgb(238,130,238)\", \"rgb(238,130,238)\", \"rgb(0,0,139)\", \"rgb(148,0,211)\", \"rgb(105,105,105)\", \"rgb(255,140,0)\", \"rgb(235,92,92)\", \"rgb(82,92,245)\", \"rgb(133,143,143)\", \"rgb(235,143,92)\", \"rgb(190,120,120)\", \"rgb(225,82,92)\", \"rgb(72,82,245)\", \"rgb(123,133,143)\", \"rgb(225,133,92)\", \"rgb(180,120,120)\"]\n    });\n  }\n}; //utility for google login capabilities in MATS -- broken for esrl.noaa.gov/gsd/mats?\n\n\nconst doCredentials = function () {\n  // the gmail account for the credentials is mats.mail.daemon@gmail.com - pwd mats2015!\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.Credentials.remove({});\n  }\n\n  if (matsCollections.Credentials.find().count() == 0) {\n    matsCollections.Credentials.insert({\n      name: \"oauth_google\",\n      clientId: \"499180266722-aai2tddo8s9edv4km1pst88vebpf9hec.apps.googleusercontent.com\",\n      clientSecret: \"xdU0sc7SbdOOEzSyID_PTIRE\",\n      refresh_token: \"1/3bhWyvCMMfwwDdd4F3ftlJs3-vksgg7G8POtiOBwYnhIgOrJDtdun6zK6XiATCKT\"\n    });\n  }\n}; //another utility to assist at logging into MATS\n\n\nconst doRoles = function () {\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.Roles.remove({});\n  }\n\n  if (matsCollections.Roles.find().count() == 0) {\n    matsCollections.Roles.insert({\n      name: \"administrator\",\n      description: \"administrator privileges\"\n    });\n  }\n}; //for use in matsMethods.resetApp() to establish default settings\n\n\nconst doSettings = function (title, version, buildDate, appType) {\n  if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n    matsCollections.Settings.remove({});\n  }\n\n  if (matsCollections.Settings.find().count() == 0) {\n    matsCollections.Settings.insert({\n      LabelPrefix: \"Curve\",\n      Title: title,\n      appVersion: version,\n      buildDate: buildDate,\n      appType: appType,\n      LineWidth: 3.5,\n      NullFillString: \"---\",\n      resetFromCode: false\n    });\n  } // always update the version, roles, and the hostname, not just if it doesn't exist...\n\n\n  var settings = matsCollections.Settings.findOne({});\n  const deploymentRoles = {\n    \"mats-dev\": \"development\",\n    \"mats-int\": \"integration\",\n    \"mats\": \"production\"\n  };\n  var settingsId = settings._id;\n\n  var os = Npm.require('os');\n\n  var hostname = os.hostname().split('.')[0];\n  settings['appVersion'] = version;\n  settings['hostname'] = hostname;\n  settings['deploymentRoles'] = JSON.stringify(deploymentRoles);\n  matsCollections.Settings.update(settingsId, {\n    $set: settings\n  });\n}; //Utility for transferring client-side parameters to the server-side methods via the \"PlotParams\" object in the stack.\n//Add values to this object in the 'click .submit-params' event handler in plot_list.js\n\n\nconst getPlotParamsFromStack = function () {\n  var params = {};\n  const err = new Error();\n  Error.captureStackTrace(err, arguments.callee.arguments.callee);\n  const stack = err.stack;\n  const stackElems = stack.split(\"\\n\");\n\n  for (si = 0; si < stackElems.length; si++) {\n    const sElem = stackElems[si].trim();\n\n    if (sElem.indexOf('dataFunctions') !== -1 && sElem.startsWith(\"at data\")) {\n      const dataFunctionName = sElem.split('at ')[1];\n\n      try {\n        params = global[sElem.split('at ')[1].split(' ')[0]].arguments[0];\n      } catch (noJoy) {}\n\n      break;\n    }\n  }\n\n  return params;\n}; //calculates mean, stdev, and other statistics for curve data points in all apps and plot types\n\n\nconst get_err = function (sVals, sSecs, sLevs) {\n  /* refer to perl error_library.pl sub  get_stats\n   to see the perl implementation of these statics calculations.\n   These should match exactly those, except that they are processed in reverse order.\n   */\n  const autocorr_limit = 0.95;\n  const hasLevels = sLevs.length > 0;\n  const plotParams = getPlotParamsFromStack();\n  var outlierQCParam;\n\n  if (plotParams[\"outliers\"] !== \"all\") {\n    outlierQCParam = Number(plotParams[\"outliers\"]);\n  } else {\n    outlierQCParam = 100;\n  }\n\n  var subVals = [];\n  var subSecs = [];\n  var subLevs = [];\n  var n = sVals.length;\n  var n_good = 0;\n  var sum_d = 0;\n  var sum2_d = 0;\n  var error = \"\";\n  var i;\n\n  for (i = 0; i < n; i++) {\n    if (sVals[i] !== null && !isNaN(sVals[i])) {\n      n_good = n_good + 1;\n      sum_d = sum_d + sVals[i];\n      sum2_d = sum2_d + sVals[i] * sVals[i];\n      subVals.push(sVals[i]);\n      subSecs.push(sSecs[i]);\n\n      if (hasLevels) {\n        subLevs.push(sLevs[i]);\n      }\n    }\n  }\n\n  var d_mean = sum_d / n_good;\n  var sd2 = sum2_d / n_good - d_mean * d_mean;\n  var sd = sd2 > 0 ? Math.sqrt(sd2) : sd2;\n  var sd_limit = outlierQCParam * sd; //console.log(\"see error_library.pl l208 These are processed in reverse order to the perl code -  \\nmean is \" + d_mean + \" sd_limit is +/- \" + sd_limit + \" n_good is \" + n_good + \" sum_d is\" + sum_d + \" sum2_d is \" + sum2_d);\n  // find minimum delta_time, if any value missing, set null\n\n  var last_secs = 0;\n  var minDelta = Number.MAX_VALUE;\n  var minSecs = Number.MAX_VALUE;\n  var max_secs = Number.MIN_VALUE;\n  var minVal = Number.MAX_VALUE;\n  var maxVal = -1 * Number.MAX_VALUE;\n  var secs;\n  var delta;\n\n  for (i = 0; i < subSecs.length; i++) {\n    secs = subSecs[i];\n    delta = Math.abs(secs - last_secs);\n\n    if (delta > 0 && delta < minDelta) {\n      minDelta = delta;\n    }\n\n    if (secs < minSecs) {\n      minSecs = secs;\n    }\n\n    if (secs > max_secs) {\n      max_secs = secs;\n    }\n\n    last_secs = secs;\n  }\n\n  var data_wg = [];\n  var n_gaps = 0;\n  n_good = 0;\n  var sum = 0;\n  var sum2 = 0;\n\n  if (minDelta < 0) {\n    error = \"Invalid time interval - minDelta: \" + minDelta;\n    console.log(\"matsDataUtil.getErr: Invalid time interval - minDelta: \" + minDelta);\n  } // remove data more than $sd_limit from mean\n\n\n  var qaCorrected = [];\n\n  for (i = 0; i < subVals.length; i++) {\n    if (Math.abs(subVals[i] - d_mean) > sd_limit) {\n      qaCorrected.push(\"removing datum \" + i + \" with value \" + subVals[i] + \" because it exceeds \" + outlierQCParam + \" standard deviations from the mean - mean: \" + d_mean + \" \" + outlierQCParam + \" * sd: \" + sd_limit + \" delta: \" + (subVals[i] - d_mean)); // console.log(qaCorrected.join('\\n'));\n\n      subVals[i] = null;\n    } else {\n      minVal = minVal < subVals[i] ? minVal : subVals[i];\n      maxVal = maxVal > subVals[i] ? maxVal : subVals[i];\n      sum += subVals[i];\n      sum2 += subVals[i] * subVals[i];\n      n_good++;\n    }\n  }\n\n  if (n_good < 1) {\n    return {\n      d_mean: null,\n      stde_betsy: null,\n      sd: null,\n      n_good: n_good,\n      lag1: null,\n      min: null,\n      max: null,\n      sum: null\n    };\n  } // recalculate if we threw anything away.\n\n\n  d_mean = sum / n_good;\n  sd2 = sum2 / n_good - d_mean * d_mean;\n  sd = 0;\n\n  if (sd2 > 0) {\n    sd = Math.sqrt(sd2);\n  } //console.log(\"new mean after throwing away outliers is \" + sd + \" n_good is \" + n_good + \" sum is \" + sum  + \" sum2 is \" + sum2 + \" d_mean is \" + d_mean);\n  // look for gaps\n\n\n  var lastSecond = -1 * Number.MAX_VALUE;\n  var lastPressure = -1 * Number.MAX_VALUE;\n  var n_pressures;\n\n  if (hasLevels) {\n    n_pressures = arrayUnique(subLevs).length;\n  } else {\n    n_pressures = 1;\n  } // set lag1_t to the first time the time changes from its initial value + 1 (data zero based)\n  // set lag1_p to the first time the pressure changes from its initial value + 1 (data zero based)\n\n\n  var lag1_t = 0;\n  var lag1_p = 0;\n  var r1_t = 0; // autocorrelation for time\n\n  var r1_p = 0; // autocorrelation for pressure\n\n  var j = 0; // i is loop index without gaps; j is loop index with gaps\n\n  var n_deltas = 0;\n\n  for (i = 0; i < subSecs.length; i++) {\n    var sec = subSecs[i];\n    var lev;\n\n    if (hasLevels) {\n      lev = subLevs[i]; // find first time the pressure changes\n\n      if (lag1_p === 0 && lastPressure > 0) {\n        if (lev !== lastPressure) {\n          lag1_p = j;\n        }\n      }\n    }\n\n    if (lastSecond >= 0) {\n      if (lag1_t === 0 && sec !== lastSecond) {\n        lag1_t = j;\n      }\n\n      if (Math.abs(sec - lastSecond) > minDelta) {\n        n_deltas = (Math.abs(sec - lastSecond) / minDelta - 1) * n_pressures; // for the Autocorrelation at lag 1, it doesn't matter how many missing\n        // data we put in within gaps! (But for the other AC's it does.)\n        // since we're using only the AC at lag 1 for calculating std err, let's\n        // save cpu time and only put in one missing datum per gap, no matter\n        // how long. WRM 2/22/2019\n        // but if we're using a different lag, which could happen, we'll need\n        // to insert all the missing data in each gap. WRM 2/22/2019\n        // $n_deltas=1;\n\n        for (var count = 0; count < n_deltas; count++) {\n          data_wg.push(null);\n          n_gaps++;\n          j++;\n        }\n      }\n    }\n\n    lastSecond = sec;\n\n    if (hasLevels) {\n      lastPressure = lev;\n    }\n\n    data_wg.push(subVals[i]);\n    j++;\n  } //from http://www.itl.nist.gov/div898/handbook/eda/section3/eda35c.htm\n\n\n  var r = [];\n  var lag_by_r = {};\n  var lag1_max = lag1_p > lag1_t ? lag1_p : lag1_t;\n  var r_sum = 0;\n  var n_r = 0;\n  var n_in_lag;\n  var lag;\n  var t;\n\n  for (lag = 0; lag <= lag1_max; lag++) {\n    r[lag] = 0;\n    n_in_lag = 0;\n\n    for (t = 0; t < n + n_gaps - lag; t++) {\n      if (data_wg[t] != null && data_wg[t + lag] != null) {\n        r[lag] += +(data_wg[t] - d_mean) * (data_wg[t + lag] - d_mean);\n        n_in_lag++;\n      }\n    }\n\n    if (n_in_lag > 0 && sd > 0) {\n      r[lag] /= n_in_lag * sd * sd;\n      r_sum += r[lag];\n      n_r++;\n    } else {\n      r[lag] = null;\n    }\n\n    if (lag >= 1 && lag < (n + n_gaps) / 2) {\n      lag_by_r[r[lag]] = lag;\n    }\n  }\n\n  if (lag1_t > 0) {\n    r1_t = r[lag1_t] !== undefined ? r[lag1_t] : 0;\n  }\n\n  if (lag1_p > 0) {\n    r1_p = r[lag1_p] !== undefined ? r[lag1_p] : 0;\n  } // Betsy Weatherhead's correction, based on lag 1, augmented by the highest\n  // lag > 1 and < n/2\n\n\n  if (r1_p >= autocorr_limit) {\n    r1_p = autocorr_limit;\n  }\n\n  if (r1_t >= autocorr_limit) {\n    r1_t = autocorr_limit;\n  }\n\n  const betsy = Math.sqrt((n_good - 1) * (1. - r1_p) * (1. - r1_t));\n  var stde_betsy;\n\n  if (betsy !== 0) {\n    stde_betsy = sd / betsy;\n  } else {\n    stde_betsy = null;\n  }\n\n  const stats = {\n    d_mean: d_mean,\n    stde_betsy: stde_betsy,\n    sd: sd,\n    n_good: n_good,\n    lag1: r[1],\n    min: minSecs,\n    max: max_secs,\n    minVal: minVal,\n    maxVal: maxVal,\n    sum: sum_d,\n    qaCorrected: qaCorrected\n  }; //console.log(\"stats are \" + JSON.stringify(stats));\n  // stde_betsy is standard error with auto correlation\n  //console.log(\"---------\\n\\n\");\n\n  return stats;\n}; // utility to process the user-input histogram customization controls\n\n\nconst setHistogramParameters = function (plotParams) {\n  var yAxisFormat = plotParams['histogram-yaxis-controls'];\n  var binType = plotParams['histogram-bin-controls'];\n  var binNum = 12; // default bin number\n\n  var binStart = undefined; // default is no mandated bin start\n\n  var binStride = undefined; // default is no mandated stride\n\n  var pivotVal = undefined; // default is not to shift the bins over to a pivot\n\n  var binBounds = []; // default is no specified bin bounds -- our algorithm will figure them out if this array stays empty\n\n  switch (binType) {\n    case \"Set number of bins\":\n      // get the user's chosen number of bins\n      binNum = Number(plotParams['bin-number']);\n\n      if (isNaN(binNum)) {\n        throw new Error(\"Error parsing bin number: please enter the desired number of bins.\");\n      }\n\n      break;\n\n    case \"Make zero a bin bound\":\n      // let the histogram routine know that we want the bins shifted over to zero\n      pivotVal = 0;\n      break;\n\n    case \"Choose a bin bound\":\n      // let the histogram routine know that we want the bins shifted over to whatever was input\n      pivotVal = Number(plotParams['bin-pivot']);\n\n      if (isNaN(pivotVal)) {\n        throw new Error(\"Error parsing bin pivot: please enter the desired bin pivot.\");\n      }\n\n      break;\n\n    case \"Set number of bins and make zero a bin bound\":\n      // get the user's chosen number of bins and let the histogram routine know that we want the bins shifted over to zero\n      binNum = Number(plotParams['bin-number']);\n\n      if (isNaN(binNum)) {\n        throw new Error(\"Error parsing bin number: please enter the desired number of bins.\");\n      }\n\n      pivotVal = 0;\n      break;\n\n    case \"Set number of bins and choose a bin bound\":\n      // get the user's chosen number of bins and let the histogram routine know that we want the bins shifted over to whatever was input\n      binNum = Number(plotParams['bin-number']);\n\n      if (isNaN(binNum)) {\n        throw new Error(\"Error parsing bin number: please enter the desired number of bins.\");\n      }\n\n      pivotVal = Number(plotParams['bin-pivot']);\n\n      if (isNaN(pivotVal)) {\n        throw new Error(\"Error parsing bin pivot: please enter the desired bin pivot.\");\n      }\n\n      break;\n\n    case \"Manual bins\":\n      // try to parse whatever we've been given for bin bounds. Throw an error if they didn't follow directions to enter a comma-separated list of numbers.\n      try {\n        binBounds = plotParams['bin-bounds'].split(\",\").map(function (item) {\n          item.trim();\n          item = Number(item);\n\n          if (!isNaN(item)) {\n            return item;\n          } else {\n            throw new Error(\"Error parsing bin bounds: please enter  at least two numbers delimited by commas.\");\n          }\n        });\n        binNum = binBounds.length + 1; // add 1 because these are inner bin bounds\n      } catch (e) {\n        throw new Error(\"Error parsing bin bounds: please enter  at least two numbers delimited by commas.\");\n      } // make sure that we've been given at least two good bin bounds (enough to make one bin).\n\n\n      if (binNum < 3) {\n        throw new Error(\"Error parsing bin bounds: please enter at least two numbers delimited by commas.\");\n      }\n\n      break;\n\n    case \"Manual bin start, number, and stride\":\n      // get the bin start, number, and stride.\n      binNum = Number(plotParams['bin-number']);\n\n      if (isNaN(binNum)) {\n        throw new Error(\"Error parsing bin number: please enter the desired number of bins.\");\n      }\n\n      binStart = Number(plotParams['bin-start']);\n\n      if (isNaN(binStart)) {\n        throw new Error(\"Error parsing bin start: please enter the desired bin start.\");\n      }\n\n      binStride = Number(plotParams['bin-stride']);\n\n      if (isNaN(binStride)) {\n        throw new Error(\"Error parsing bin stride: please enter the desired bin stride.\");\n      }\n\n      break;\n\n    case \"Default bins\":\n    default:\n      break;\n  }\n\n  return {\n    yAxisFormat: yAxisFormat,\n    binNum: binNum,\n    binStart: binStart,\n    binStride: binStride,\n    pivotVal: pivotVal,\n    binBounds: binBounds\n  };\n}; // utility that takes arrays of seconds and values and produces a data structure containing bin information for histogram plotting\n\n\nconst calculateHistogramBins = function (curveSubStats, curveSubSecs, binParams) {\n  // binStart and binStride will only be defined if the user wants to specify the bin spacing.\n  // otherwise, we'll use the mean and standard deviation of the data to space the bins.\n  // pivotVal will only be defined if the user wants to shift the bin limits to align with a certain value.\n  // otherwise, we'll keep everything aligned with the data mean.\n  var binStats = {};\n  var binUpBounds = [];\n  var binLowBounds = [];\n  var binMeans = []; // calculate the global stats across all of the data\n\n  const globalStats = get_err(curveSubStats, curveSubSecs, []); // we don't need levels for the mean or sd calculations, so just pass in an empty array\n\n  const glob_mean = globalStats.d_mean;\n  const glob_sd = globalStats.sd;\n  var fullLowBound;\n  var fullUpBound;\n  var fullRange;\n  var binInterval;\n\n  if (binParams.binStart === undefined || binParams.binStride === undefined) {\n    // use the global stats to determine the bin bounds -- should be based on dividing up +/- 3*sd from the mean into requested number of bins\n    fullLowBound = glob_mean - 3 * glob_sd;\n    fullUpBound = glob_mean + 3 * glob_sd;\n    fullRange = 6 * glob_sd;\n    binInterval = fullRange / (binParams.binNum - 2); // take off two bins from the total number of requested bins to represent values either less than - 3*sd from the mean or greater than 3*sd from the mean\n  } else {\n    // use the user-defined start, number, and stride to determine the bin bounds\n    fullLowBound = binParams.binStart;\n    fullUpBound = binParams.binStart + (binParams.binNum - 2) * binParams.binStride; // take off two bins from the total number of requested bins to represent values that fall outside of the prescribed range\n\n    fullRange = (binParams.binNum - 2) * binParams.binStride;\n    binInterval = binParams.binStride;\n  } // store an array of the upper and lower bounding values for each bin.\n\n\n  binUpBounds[0] = fullLowBound; // the first upper bound should be exactly - 3*sd from the mean, or the previously calculated fullLowBound\n\n  binLowBounds[0] = -1 * Number.MAX_VALUE;\n  binMeans[0] = fullLowBound - binInterval / 2;\n\n  for (var b_idx = 1; b_idx < binParams.binNum - 1; b_idx++) {\n    binUpBounds[b_idx] = binUpBounds[b_idx - 1] + binInterval; // increment from fullLowBound to get the rest of the bin upper limits\n\n    binLowBounds[b_idx] = binUpBounds[b_idx - 1];\n    binMeans[b_idx] = binUpBounds[b_idx - 1] + binInterval / 2;\n  }\n\n  binUpBounds[binParams.binNum - 1] = Number.MAX_VALUE; // the last bin should have everything too large to fit into the previous bins, so make its upper bound the max number value\n\n  binLowBounds[binParams.binNum - 1] = fullUpBound;\n  binMeans[binParams.binNum - 1] = fullUpBound + binInterval / 2;\n\n  if (binParams.pivotVal !== undefined && !isNaN(binParams.pivotVal)) {\n    // need to shift the bounds and means over so that one of the bounds is on the chosen pivot\n    var closestBoundToPivot = binLowBounds.reduce(function (prev, curr) {\n      return Math.abs(curr - binParams.pivotVal) < Math.abs(prev - binParams.pivotVal) ? curr : prev;\n    });\n    binUpBounds = binUpBounds.map(function (val) {\n      return val - (closestBoundToPivot - binParams.pivotVal);\n    });\n    binLowBounds = binLowBounds.map(function (val) {\n      return val - (closestBoundToPivot - binParams.pivotVal);\n    });\n    binMeans = binMeans.map(function (val) {\n      return val - (closestBoundToPivot - binParams.pivotVal);\n    });\n  } // calculate the labels for each bin, based on the data bounding range, for the graph x-axis later\n\n\n  var binLabels = [];\n  var lowSdFromMean;\n  var upSdFromMean;\n\n  for (b_idx = 0; b_idx < binParams.binNum; b_idx++) {\n    lowSdFromMean = binLowBounds[b_idx].toFixed(2);\n    upSdFromMean = binUpBounds[b_idx].toFixed(2);\n\n    if (b_idx === 0) {\n      binLabels[b_idx] = \"< \" + upSdFromMean;\n    } else if (b_idx === binParams.binNum - 1) {\n      binLabels[b_idx] = \"> \" + lowSdFromMean;\n    } else {\n      binLabels[b_idx] = lowSdFromMean + \"-\" + upSdFromMean;\n    }\n  }\n\n  binStats['glob_mean'] = glob_mean;\n  binStats['glob_sd'] = glob_sd;\n  binStats['binUpBounds'] = binUpBounds;\n  binStats['binLowBounds'] = binLowBounds;\n  binStats['binMeans'] = binMeans;\n  binStats['binLabels'] = binLabels;\n  return {\n    'binStats': binStats\n  };\n}; // utility that takes an array of user-defined bin bounds and produces a data structure containing bin information for histogram plotting\n\n\nconst prescribeHistogramBins = function (curveSubStats, curveSubSecs, binParams) {\n  var binStats = {}; // calculate the global stats across all of the data\n\n  const globalStats = get_err(curveSubStats, curveSubSecs, []); // we don't need levels for the mean or sd calculations, so just pass in an empty array\n\n  const glob_mean = globalStats.d_mean;\n  const glob_sd = globalStats.sd; // make sure the user-defined bins are in order from least to greatest\n\n  binParams.binBounds = binParams.binBounds.sort(function (a, b) {\n    return Number(a) - Number(b);\n  }); // store an array of the upper and lower bounding values for each bin.\n\n  var binUpBounds = [];\n  var binLowBounds = [];\n  var binMeans = [];\n  var binIntervalSum = 0;\n\n  for (var b_idx = 1; b_idx < binParams.binNum - 1; b_idx++) {\n    binUpBounds[b_idx] = binParams.binBounds[b_idx];\n    binLowBounds[b_idx] = binParams.binBounds[b_idx - 1];\n    binMeans[b_idx] = (binUpBounds[b_idx] + binLowBounds[b_idx]) / 2;\n    binIntervalSum = binIntervalSum + (binUpBounds[b_idx] - binLowBounds[b_idx]);\n  }\n\n  const binIntervalAverage = binIntervalSum / (binParams.binNum - 2);\n  binUpBounds[0] = binLowBounds[1];\n  binLowBounds[0] = -1 * Number.MAX_VALUE; // the first bin should have everything too small to fit into the other bins, so make its lower bound -1 * the max number value\n\n  binMeans[0] = binLowBounds[1] - binIntervalAverage / 2; // the bin means for the edge bins is a little arbitrary, so base it on the average bin width\n\n  binUpBounds[binParams.binNum - 1] = Number.MAX_VALUE; // the last bin should have everything too large to fit into the previous bins, so make its upper bound the max number value\n\n  binLowBounds[binParams.binNum - 1] = binUpBounds[binParams.binNum - 2];\n  binMeans[binParams.binNum - 1] = binUpBounds[binParams.binNum - 2] + binIntervalAverage / 2; // the bin means for the edge bins is a little arbitrary, so base it on the average bin width\n  // calculate the labels for each bin, based on the data bounding range, for the graph x-axis later\n\n  var binLabels = [];\n  var lowSdFromMean;\n  var upSdFromMean;\n\n  for (b_idx = 0; b_idx < binParams.binNum; b_idx++) {\n    lowSdFromMean = binLowBounds[b_idx].toFixed(2);\n    upSdFromMean = binUpBounds[b_idx].toFixed(2);\n\n    if (b_idx === 0) {\n      binLabels[b_idx] = \"< \" + upSdFromMean;\n    } else if (b_idx === binParams.binNum - 1) {\n      binLabels[b_idx] = \"> \" + lowSdFromMean;\n    } else {\n      binLabels[b_idx] = lowSdFromMean + \"-\" + upSdFromMean;\n    }\n  }\n\n  binStats['glob_mean'] = glob_mean;\n  binStats['glob_sd'] = glob_sd;\n  binStats['binUpBounds'] = binUpBounds;\n  binStats['binLowBounds'] = binLowBounds;\n  binStats['binMeans'] = binMeans;\n  binStats['binLabels'] = binLabels;\n  return {\n    'binStats': binStats\n  };\n}; // utility that takes arrays of seconds, values, and optionally levels, and produces a data structure for histogram data\n// processing. Used in the initial histogram DB query and in matching.\n\n\nconst sortHistogramBins = function (curveSubStats, curveSubSecs, curveSubLevs, binNum, masterBinStats, hasLevels, d) {\n  // need maps to hold the sub values and seconds (and levels) for each bin, after the bin bounds are calculated.\n  var binSubStats = {};\n  var binSubSecs = {};\n  var binSubLevs = {};\n\n  for (var b_idx = 0; b_idx < binNum; b_idx++) {\n    binSubStats[b_idx] = [];\n    binSubSecs[b_idx] = [];\n    binSubLevs[b_idx] = [];\n  } // calculate the global stats across all of the data\n\n\n  var globalStats;\n\n  if (hasLevels) {\n    globalStats = get_err(curveSubStats, curveSubSecs, curveSubLevs);\n  } else {\n    globalStats = get_err(curveSubStats, curveSubSecs, []);\n  }\n\n  const glob_mean = globalStats.d_mean;\n  const glob_sd = globalStats.sd;\n  const glob_n = globalStats.n_good;\n  const glob_max = globalStats.maxVal;\n  const glob_min = globalStats.minVal; // sort data into bins\n\n  const binUpBounds = masterBinStats.binUpBounds;\n  const binLowBounds = masterBinStats.binLowBounds;\n  const binMeans = masterBinStats.binMeans;\n  const binLabels = masterBinStats.binLabels;\n\n  for (var d_idx = 0; d_idx < curveSubStats.length; d_idx++) {\n    // iterate through all of the bins until we find one where the upper limit is greater than our datum.\n    for (b_idx = 0; b_idx < binNum; b_idx++) {\n      if (curveSubStats[d_idx] <= binUpBounds[b_idx]) {\n        binSubStats[b_idx].push(curveSubStats[d_idx]);\n        binSubSecs[b_idx].push(curveSubSecs[d_idx]);\n\n        if (hasLevels) {\n          binSubLevs[b_idx].push(curveSubLevs[d_idx]);\n        }\n\n        break;\n      }\n    }\n  } // calculate the statistics for each bin\n  // we are especially interested in the number of values in each bin, as that is the plotted stat in a histogram\n\n\n  var binStats;\n  var bin_mean;\n  var bin_sd;\n  var bin_n;\n  var bin_rf;\n  var sum = 0;\n  var count = 0;\n\n  for (b_idx = 0; b_idx < binNum; b_idx++) {\n    if (hasLevels) {\n      binStats = get_err(binSubStats[b_idx], binSubSecs[b_idx], binSubLevs[b_idx]);\n    } else {\n      binStats = get_err(binSubStats[b_idx], binSubSecs[b_idx], []);\n    }\n\n    bin_mean = binStats.d_mean;\n    bin_sd = binStats.sd;\n    bin_n = binStats.n_good;\n    bin_rf = bin_n / glob_n;\n    /*\n    var d = {// d will contain the curve data\n        x: [], //placeholder\n        y: [], //placeholder\n        error_x: [], // unused\n        error_y: [], // unused\n        subVals: [],\n        subSecs: [],\n        subLevs: [],\n        glob_stats: {}, // placeholder\n        bin_stats: [], // placeholder\n        text: [], //placeholder\n        xmax: Number.MIN_VALUE,\n        xmin: Number.MAX_VALUE,\n        ymax: Number.MIN_VALUE,\n        ymin: Number.MAX_VALUE\n    };\n    */\n\n    d.x.push(binMeans[b_idx]);\n    d.y.push(bin_n);\n    d.subVals.push(binSubStats[b_idx]);\n    d.subSecs.push(binSubSecs[b_idx]);\n    d.bin_stats.push({\n      'bin_mean': bin_mean,\n      'bin_sd': bin_sd,\n      'bin_n': bin_n,\n      'bin_rf': bin_rf,\n      'binLowBound': binLowBounds[b_idx],\n      'binUpBound': binUpBounds[b_idx],\n      'binLabel': binLabels[b_idx]\n    });\n    d.text.push(null);\n\n    if (hasLevels) {\n      d.subLevs.push(binSubLevs[b_idx]);\n    } // set axis limits based on returned data\n\n\n    if (d.y[b_idx] !== null) {\n      sum = sum + d.y[b_idx];\n      count++;\n      d.ymin = d.ymin < d.y[b_idx] ? d.ymin : d.y[b_idx];\n      d.ymax = d.ymax > d.y[b_idx] ? d.ymax : d.y[b_idx];\n    }\n  }\n\n  d.glob_stats = {\n    'glob_mean': glob_mean,\n    'glob_sd': glob_sd,\n    'glob_n': glob_n,\n    'glob_max': glob_max,\n    'glob_min': glob_min\n  };\n  d.xmin = d.x[0];\n  d.xmax = d.x[binNum - 1];\n  return {\n    d: d\n  };\n}; // utility that takes the curve params for two contour plots and collapses them into the curve params for one diff contour.\n\n\nconst getDiffContourCurveParams = function (curves) {\n  var newCurve = {};\n  const curveKeys = Object.keys(curves[0]);\n  var currKey;\n\n  for (var ckidx = 0; ckidx < curveKeys.length; ckidx++) {\n    currKey = curveKeys[ckidx];\n\n    if (currKey === 'color') {\n      newCurve['color'] = \"rgb(255,165,0)\";\n    } else if (curves[0][currKey] === curves[1][currKey]) {\n      newCurve[currKey] = curves[0][currKey];\n    } else {\n      newCurve[currKey] = curves[1][currKey] + \"-\" + curves[0][currKey];\n    }\n  }\n\n  return [newCurve];\n}; //used for sorting arrays\n\n\nconst sortFunction = function (a, b) {\n  if (a[0] === b[0]) {\n    return 0;\n  } else {\n    return a[0] < b[0] ? -1 : 1;\n  }\n};\n\nmodule.exportDefault(matsDataUtils = {\n  areObjectsEqual: areObjectsEqual,\n  arrayContainsArray: arrayContainsArray,\n  arrayContainsSubArray: arrayContainsSubArray,\n  arraysEqual: arraysEqual,\n  arrayUnique: arrayUnique,\n  findArrayInSubArray: findArrayInSubArray,\n  objectContainsObject: objectContainsObject,\n  average: average,\n  stdev: stdev,\n  dateConvert: dateConvert,\n  getDateRange: getDateRange,\n  secsConvert: secsConvert,\n  doAuthorization: doAuthorization,\n  doColorScheme: doColorScheme,\n  doCredentials: doCredentials,\n  doRoles: doRoles,\n  doSettings: doSettings,\n  getPlotParamsFromStack: getPlotParamsFromStack,\n  get_err: get_err,\n  setHistogramParameters: setHistogramParameters,\n  calculateHistogramBins: calculateHistogramBins,\n  prescribeHistogramBins: prescribeHistogramBins,\n  sortHistogramBins: sortHistogramBins,\n  getDiffContourCurveParams: getDiffContourCurveParams,\n  sortFunction: sortFunction\n});","map":{"version":3,"sources":["packages/randyp:mats-common/imports/startup/server/data_util.js"],"names":["matsTypes","module","link","v","matsCollections","matsPlotUtils","areObjectsEqual","o","p","JSON","stringify","arrayContainsArray","superArray","subArray","sort","a","b","Number","i","j","length","arrayContainsSubArray","current","arraysEqual","arrayUnique","arr","includes","push","findArrayInSubArray","objectContainsObject","superObject","subObject","superObjectKeys","Object","keys","currentObject","average","data","sum","reduce","value","avg","stdev","squareDiffs","map","diff","avgSquareDiff","stdDev","Math","sqrt","dateConvert","dStr","undefined","now","Date","date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","yr","day","month","hour","minute","dateParts","split","dateArray","timeArray","getDateRange","dateRange","dates","fromDateStr","fromDate","toDateStr","toDate","fromSecs","secsConvert","toSecs","fromSeconds","toSeconds","getTime","my_date","UTC","date_in_secs","doAuthorization","Settings","findOne","resetFromCode","Authorization","remove","find","count","insert","email","roles","doColorScheme","ColorScheme","colors","doCredentials","Credentials","name","clientId","clientSecret","refresh_token","doRoles","Roles","description","doSettings","title","version","buildDate","appType","LabelPrefix","Title","appVersion","LineWidth","NullFillString","settings","deploymentRoles","settingsId","_id","os","Npm","require","hostname","update","$set","getPlotParamsFromStack","params","err","Error","captureStackTrace","arguments","callee","stack","stackElems","si","sElem","trim","indexOf","startsWith","dataFunctionName","global","noJoy","get_err","sVals","sSecs","sLevs","autocorr_limit","hasLevels","plotParams","outlierQCParam","subVals","subSecs","subLevs","n","n_good","sum_d","sum2_d","error","isNaN","d_mean","sd2","sd","sd_limit","last_secs","minDelta","MAX_VALUE","minSecs","max_secs","MIN_VALUE","minVal","maxVal","secs","delta","abs","data_wg","n_gaps","sum2","console","log","qaCorrected","stde_betsy","lag1","min","max","lastSecond","lastPressure","n_pressures","lag1_t","lag1_p","r1_t","r1_p","n_deltas","sec","lev","r","lag_by_r","lag1_max","r_sum","n_r","n_in_lag","lag","t","betsy","stats","setHistogramParameters","yAxisFormat","binType","binNum","binStart","binStride","pivotVal","binBounds","item","e","calculateHistogramBins","curveSubStats","curveSubSecs","binParams","binStats","binUpBounds","binLowBounds","binMeans","globalStats","glob_mean","glob_sd","fullLowBound","fullUpBound","fullRange","binInterval","b_idx","closestBoundToPivot","prev","curr","val","binLabels","lowSdFromMean","upSdFromMean","toFixed","prescribeHistogramBins","binIntervalSum","binIntervalAverage","sortHistogramBins","curveSubLevs","masterBinStats","d","binSubStats","binSubSecs","binSubLevs","glob_n","glob_max","glob_min","d_idx","bin_mean","bin_sd","bin_n","bin_rf","x","y","bin_stats","text","ymin","ymax","glob_stats","xmin","xmax","getDiffContourCurveParams","curves","newCurve","curveKeys","currKey","ckidx","sortFunction","exportDefault","matsDataUtils"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsPlotUtils} from 'meteor/randyp:mats-common';\n\n//this function checks if two JSON objects are identical\nconst areObjectsEqual = function (o, p) {\n    if ((o && !p) || (p && !o)) {\n        return false;\n    }\n    if (JSON.stringify(o) === JSON.stringify(p)) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\n//this function checks if values of subArray are also in superArray\nconst arrayContainsArray = function (superArray, subArray) {\n    superArray.sort(function (a, b) {\n        return Number(a) - Number(b);\n    });\n    subArray.sort(function (a, b) {\n        return Number(a) - Number(b);\n    });\n    var i, j;\n    for (i = 0, j = 0; i < superArray.length && j < subArray.length;) {\n        if (superArray[i] < subArray[j]) {\n            ++i;\n        } else if (superArray[i] === subArray[j]) {\n            ++i;\n            ++j;\n        } else {\n            // subArray[j] not in superArray, so superArray does not contain all elements of subArray\n            return false;\n        }\n    }\n    // make sure there are no elements left in sub\n    return j === subArray.length;\n};\n\n//this function checks if the entire array subArray is contained in superArray\nconst arrayContainsSubArray = function (superArray, subArray) {\n    var i, j, current;\n    for (i = 0; i < superArray.length; ++i) {\n        if (subArray.length === superArray[i].length) {\n            current = superArray[i];\n            for (j = 0; j < subArray.length && subArray[j] === current[j]; ++j) ;\n            if (j === subArray.length)\n                return true;\n        }\n    }\n    return false;\n};\n\n//this function checks if two arrays are identical\nconst arraysEqual = function (a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n};\n\nconst arrayUnique = function(a) {\n    var arr = [];\n    for(var i = 0; i < a.length; i++) {\n        if(!arr.includes(a[i])) {\n            arr.push(a[i]);\n        }\n    }\n    return arr;\n};\n\n//this function finds the position of the array subArray in superArray\nconst findArrayInSubArray = function (superArray, subArray) {\n    var i, j, current;\n    for (i = 0; i < superArray.length; ++i) {\n        if (subArray.length === superArray[i].length) {\n            current = superArray[i];\n            for (j = 0; j < subArray.length && subArray[j] === current[j]; ++j) ;\n            if (j === subArray.length)\n                return i;\n        }\n    }\n    return -1;\n};\n\n//this function checks if an object is a value in another object\nconst objectContainsObject = function (superObject, subObject) {\n    const superObjectKeys = Object.keys(superObject);\n    var currentObject;\n    for (var i = 0; i < superObjectKeys.length; i++) {\n        currentObject = superObject[superObjectKeys[i]];\n        if (areObjectsEqual(subObject,currentObject)) {\n            return true;\n        }\n    }\n    // if the loop completes, the subObject was not found\n    return false;\n};\n\n//utility for calculating the average of an array\nconst average = function (data) {\n    var sum = data.reduce(function (sum, value) {\n        return value == null ? sum : sum + value;\n    }, 0);\n    var avg = sum / data.length;\n    return avg;\n};\n\n//utility for calculating the stdev of an array\nconst stdev = function (data) {\n    var avg = average(data);\n    var squareDiffs = data.map(function(value){\n        var diff = value - avg;\n        return diff * diff;\n    });\n    var avgSquareDiff = average(squareDiffs);\n    var stdDev = Math.sqrt(avgSquareDiff);\n    return stdDev;\n};\n\n//this function makes sure date strings are in the correct format\nconst dateConvert = function (dStr) {\n    if (dStr === undefined || dStr === \" \") {\n        var now = new Date();\n        var date = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());\n        var yr = date.getUTCFullYear();\n        var day = date.getUTCDate();\n        var month = date.getUTCMonth();\n        var hour = date.getUTCHours();\n        var minute = date.getUTCMinutes();\n        return month + \"/\" + day + '/' + yr + ' ' + hour + \":\" + minute;\n    }\n    var dateParts = dStr.split(' ');\n    var dateArray = dateParts[0].split(/[\\-\\/]/);  // split on - or /    01-01-2017 OR 01/01/2017\n    var month = dateArray[0];\n    var day = dateArray[1];\n    var yr = dateArray[2];\n    var hour = 0;\n    var minute = 0;\n    if (dateParts[1]) {\n        var timeArray = dateParts[1].split(\":\");\n        hour = timeArray[0];\n        minute = timeArray[1];\n    }\n    return month + \"/\" + day + '/' + yr + ' ' + hour + \":\" + minute;\n};\n\n//splits the date range string from the date selector into standardized fromDate/toDate strings,\n// plus the epochs for the fromDate and toDate\nconst getDateRange = function (dateRange) {\n    var dates = dateRange.split(' - ');\n    var fromDateStr = dates[0];\n    var fromDate = dateConvert(fromDateStr);\n    var toDateStr = dates[1];\n    var toDate = dateConvert(toDateStr);\n    var fromSecs = secsConvert(fromDateStr);\n    var toSecs = secsConvert(toDateStr);\n    return {\n        fromDate: fromDate,\n        toDate: toDate,\n        fromSeconds: fromSecs,\n        toSeconds: toSecs\n    }\n};\n\n//this function converts a date string into an epoch\nconst secsConvert = function (dStr) {\n    if (dStr === undefined || dStr === \" \") {\n        var now = new Date();\n        return now.getTime() / 1000;\n    }\n    else {\n        var dateParts = dStr.split(' ');\n        var dateArray = dateParts[0].split(/[\\-\\/]/);  // split on - or /    01-01-2017 OR 01/01/2017\n        var month = dateArray[0];\n        var day = dateArray[1];\n        var yr = dateArray[2];\n        var hour = 0;\n        var minute = 0;\n        if (dateParts[1]) {\n            var timeArray = dateParts[1].split(\":\");\n            hour = timeArray[0];\n            minute = timeArray[1];\n        }\n        var my_date = new Date(Date.UTC(yr, month - 1, day, hour, minute, 0));\n        // to UTC time, not local time\n        var date_in_secs = my_date.getTime();\n    }\n    // to UTC time, not local time\n    //return date_in_secs/1000 -3600*6;\n    return date_in_secs / 1000;\n};\n\n//function to manage authorized logins for MATS\nconst doAuthorization = function () {\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.Authorization.remove({});\n    }\n    if (matsCollections.Authorization.find().count() == 0) {\n        matsCollections.Authorization.insert({email: \"randy.pierce@noaa.gov\", roles: [\"administrator\"]});\n        matsCollections.Authorization.insert({email: \"kirk.l.holub@noaa.gov\", roles: [\"administrator\"]});\n        matsCollections.Authorization.insert({email: \"jeffrey.a.hamilton@noaa.gov\", roles: [\"administrator\"]});\n        matsCollections.Authorization.insert({email: \"bonny.strong@noaa.gov\", roles: [\"administrator\"]});\n        matsCollections.Authorization.insert({email: \"molly.b.smith@noaa.gov\", roles: [\"administrator\"]});\n        matsCollections.Authorization.insert({email: \"mats.gsd@noaa.gov\", roles: [\"administrator\"]});\n    }\n};\n\n//master list of colors for MATS curves\nconst doColorScheme = function () {\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.ColorScheme.remove({});\n    }\n    if (matsCollections.ColorScheme.find().count() == 0) {\n        matsCollections.ColorScheme.insert({\n            colors: [\n                \"rgb(255,0,0)\",\n                \"rgb(0,0,255)\",\n                \"rgb(255,165,0)\",\n                \"rgb(128,128,128)\",\n                \"rgb(238,130,238)\",\n\n                \"rgb(238,130,238)\",\n                \"rgb(0,0,139)\",\n                \"rgb(148,0,211)\",\n                \"rgb(105,105,105)\",\n                \"rgb(255,140,0)\",\n\n                \"rgb(235,92,92)\",\n                \"rgb(82,92,245)\",\n                \"rgb(133,143,143)\",\n                \"rgb(235,143,92)\",\n                \"rgb(190,120,120)\",\n\n                \"rgb(225,82,92)\",\n                \"rgb(72,82,245)\",\n                \"rgb(123,133,143)\",\n                \"rgb(225,133,92)\",\n                \"rgb(180,120,120)\"\n            ]\n        });\n    }\n};\n\n//utility for google login capabilities in MATS -- broken for esrl.noaa.gov/gsd/mats?\nconst doCredentials = function () {\n// the gmail account for the credentials is mats.mail.daemon@gmail.com - pwd mats2015!\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.Credentials.remove({});\n    }\n    if (matsCollections.Credentials.find().count() == 0) {\n        matsCollections.Credentials.insert({\n            name: \"oauth_google\",\n            clientId: \"499180266722-aai2tddo8s9edv4km1pst88vebpf9hec.apps.googleusercontent.com\",\n            clientSecret: \"xdU0sc7SbdOOEzSyID_PTIRE\",\n            refresh_token: \"1/3bhWyvCMMfwwDdd4F3ftlJs3-vksgg7G8POtiOBwYnhIgOrJDtdun6zK6XiATCKT\"\n        });\n    }\n};\n\n//another utility to assist at logging into MATS\nconst doRoles = function () {\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.Roles.remove({});\n    }\n    if (matsCollections.Roles.find().count() == 0) {\n        matsCollections.Roles.insert({name: \"administrator\", description: \"administrator privileges\"});\n    }\n};\n\n//for use in matsMethods.resetApp() to establish default settings\nconst doSettings = function (title, version, buildDate, appType) {\n    if (matsCollections.Settings.findOne({}) === undefined || matsCollections.Settings.findOne({}).resetFromCode === undefined || matsCollections.Settings.findOne({}).resetFromCode == true) {\n        matsCollections.Settings.remove({});\n    }\n    if (matsCollections.Settings.find().count() == 0) {\n        matsCollections.Settings.insert({\n            LabelPrefix: \"Curve\",\n            Title: title,\n            appVersion: version,\n            buildDate: buildDate,\n            appType: appType,\n            LineWidth: 3.5,\n            NullFillString: \"---\",\n            resetFromCode: false\n        });\n    }\n    // always update the version, roles, and the hostname, not just if it doesn't exist...\n    var settings = matsCollections.Settings.findOne({});\n    const deploymentRoles = {\n        \"mats-dev\": \"development\",\n        \"mats-int\": \"integration\",\n        \"mats\": \"production\"\n    };\n    var settingsId = settings._id;\n    var os = Npm.require('os');\n    var hostname = os.hostname().split('.')[0];\n    settings['appVersion'] = version;\n    settings['hostname'] = hostname;\n    settings['deploymentRoles'] = JSON.stringify(deploymentRoles);\n    matsCollections.Settings.update(settingsId, {$set: settings});\n};\n\n//Utility for transferring client-side parameters to the server-side methods via the \"PlotParams\" object in the stack.\n//Add values to this object in the 'click .submit-params' event handler in plot_list.js\nconst getPlotParamsFromStack = function () {\n    var params = {};\n    const err = new Error;\n    Error.captureStackTrace(err, arguments.callee.arguments.callee);\n    const stack = err.stack;\n    const stackElems = stack.split(\"\\n\");\n    for (si = 0; si < stackElems.length; si++) {\n        const sElem = stackElems[si].trim();\n        if (sElem.indexOf('dataFunctions') !== -1 && sElem.startsWith(\"at data\")) {\n            const dataFunctionName = sElem.split('at ')[1];\n            try {\n                params = global[sElem.split('at ')[1].split(' ')[0]].arguments[0]\n            } catch (noJoy) {\n            }\n            break;\n        }\n    }\n    return params;\n};\n\n//calculates mean, stdev, and other statistics for curve data points in all apps and plot types\nconst get_err = function (sVals, sSecs, sLevs) {\n    /* refer to perl error_library.pl sub  get_stats\n     to see the perl implementation of these statics calculations.\n     These should match exactly those, except that they are processed in reverse order.\n     */\n    const autocorr_limit = 0.95;\n    const hasLevels = sLevs.length > 0;\n    const plotParams = getPlotParamsFromStack();\n    var outlierQCParam;\n    if (plotParams[\"outliers\"] !== \"all\") {\n        outlierQCParam = Number(plotParams[\"outliers\"]);\n    } else {\n        outlierQCParam = 100;\n    }\n\n    var subVals = [];\n    var subSecs = [];\n    var subLevs = [];\n    var n = sVals.length;\n    var n_good = 0;\n    var sum_d = 0;\n    var sum2_d = 0;\n    var error = \"\";\n    var i;\n    for (i = 0; i < n; i++) {\n        if (sVals[i] !== null && !isNaN(sVals[i])) {\n            n_good = n_good + 1;\n            sum_d = sum_d + sVals[i];\n            sum2_d = sum2_d + sVals[i] * sVals[i];\n            subVals.push(sVals[i]);\n            subSecs.push(sSecs[i]);\n            if (hasLevels) {\n                subLevs.push(sLevs[i]);\n            }\n        }\n    }\n    var d_mean = sum_d / n_good;\n    var sd2 = sum2_d / n_good - d_mean * d_mean;\n    var sd = sd2 > 0 ? Math.sqrt(sd2) : sd2;\n    var sd_limit = outlierQCParam * sd;\n    //console.log(\"see error_library.pl l208 These are processed in reverse order to the perl code -  \\nmean is \" + d_mean + \" sd_limit is +/- \" + sd_limit + \" n_good is \" + n_good + \" sum_d is\" + sum_d + \" sum2_d is \" + sum2_d);\n\n    // find minimum delta_time, if any value missing, set null\n    var last_secs = 0;\n    var minDelta = Number.MAX_VALUE;\n    var minSecs = Number.MAX_VALUE;\n    var max_secs = Number.MIN_VALUE;\n    var minVal = Number.MAX_VALUE;\n    var maxVal = -1 * Number.MAX_VALUE;\n    var secs;\n    var delta;\n    for (i = 0; i < subSecs.length; i++) {\n        secs = (subSecs[i]);\n        delta = Math.abs(secs - last_secs);\n        if (delta > 0 && delta < minDelta) {\n            minDelta = delta;\n        }\n        if (secs < minSecs) {\n            minSecs = secs;\n        }\n        if (secs > max_secs) {\n            max_secs = secs;\n        }\n        last_secs = secs;\n    }\n\n    var data_wg = [];\n    var n_gaps = 0;\n    n_good = 0;\n    var sum = 0;\n    var sum2 = 0;\n    if (minDelta < 0) {\n        error = (\"Invalid time interval - minDelta: \" + minDelta);\n        console.log(\"matsDataUtil.getErr: Invalid time interval - minDelta: \" + minDelta)\n    }\n    // remove data more than $sd_limit from mean\n    var qaCorrected = [];\n    for (i = 0; i < subVals.length; i++) {\n        if (Math.abs(subVals[i] - d_mean) > sd_limit) {\n            qaCorrected.push(\"removing datum \" + i + \" with value \" + subVals[i] + \" because it exceeds \" + outlierQCParam + \" standard deviations from the mean - mean: \" + d_mean + \" \" + outlierQCParam + \" * sd: \" + sd_limit + \" delta: \" + (subVals[i] - d_mean));\n            // console.log(qaCorrected.join('\\n'));\n            subVals[i] = null;\n        } else {\n            minVal = minVal < subVals[i] ? minVal : subVals[i];\n            maxVal = maxVal > subVals[i] ? maxVal : subVals[i];\n            sum += subVals[i];\n            sum2 += subVals[i] * subVals[i];\n            n_good++;\n        }\n    }\n    if (n_good < 1) {\n        return {d_mean: null, stde_betsy: null, sd: null, n_good: n_good, lag1: null, min: null, max: null, sum: null};\n    }\n\n    // recalculate if we threw anything away.\n    d_mean = sum / n_good;\n    sd2 = sum2 / n_good - d_mean * d_mean;\n    sd = 0;\n    if (sd2 > 0) {\n        sd = Math.sqrt(sd2);\n    }\n    //console.log(\"new mean after throwing away outliers is \" + sd + \" n_good is \" + n_good + \" sum is \" + sum  + \" sum2 is \" + sum2 + \" d_mean is \" + d_mean);\n\n    // look for gaps\n    var lastSecond = -1 * Number.MAX_VALUE;\n    var lastPressure = -1 * Number.MAX_VALUE;\n    var n_pressures;\n    if (hasLevels) {\n        n_pressures = arrayUnique(subLevs).length;\n    } else {\n        n_pressures = 1;\n    }\n    // set lag1_t to the first time the time changes from its initial value + 1 (data zero based)\n    // set lag1_p to the first time the pressure changes from its initial value + 1 (data zero based)\n    var lag1_t = 0;\n    var lag1_p = 0;\n    var r1_t = 0;\t\t\t// autocorrelation for time\n    var r1_p = 0;\t\t\t// autocorrelation for pressure\n    var j = 0;              // i is loop index without gaps; j is loop index with gaps\n    var n_deltas = 0;\n\n    for (i = 0; i < subSecs.length; i++) {\n        var sec = subSecs[i];\n        var lev;\n        if (hasLevels) {\n            lev = subLevs[i];\n            // find first time the pressure changes\n            if (lag1_p === 0 && lastPressure > 0) {\n                if (lev !== lastPressure) {\n                    lag1_p = j;\n                }\n            }\n        }\n        if (lastSecond >= 0) {\n            if(lag1_t === 0 && sec !== lastSecond) {\n                lag1_t = j;\n            }\n            if (Math.abs(sec - lastSecond) > minDelta) {\n                n_deltas = (Math.abs(sec - lastSecond)/minDelta - 1) * n_pressures;\n                // for the Autocorrelation at lag 1, it doesn't matter how many missing\n                // data we put in within gaps! (But for the other AC's it does.)\n                // since we're using only the AC at lag 1 for calculating std err, let's\n                // save cpu time and only put in one missing datum per gap, no matter\n                // how long. WRM 2/22/2019\n                // but if we're using a different lag, which could happen, we'll need\n                // to insert all the missing data in each gap. WRM 2/22/2019\n                // $n_deltas=1;\n                for(var count = 0; count < n_deltas; count++) {\n                    data_wg.push(null);\n                    n_gaps++;\n                    j++;\n                }\n            }\n        }\n        lastSecond = sec;\n        if (hasLevels) {\n            lastPressure = lev;\n        }\n        data_wg.push(subVals[i]);\n        j++;\n    }\n\n    //from http://www.itl.nist.gov/div898/handbook/eda/section3/eda35c.htm\n    var r = [];\n    var lag_by_r = {};\n    var lag1_max = lag1_p > lag1_t ? lag1_p : lag1_t;\n    var r_sum = 0;\n    var n_r = 0;\n    var n_in_lag;\n    var lag;\n    var t;\n    for (lag = 0; lag <= lag1_max; lag++) {\n        r[lag] = 0;\n        n_in_lag = 0;\n        for (t = 0; t < ((n + n_gaps) - lag); t++) {\n            if (data_wg[t] != null && data_wg[t + lag] != null) {\n                r[lag] += +(data_wg[t] - d_mean) * (data_wg[t + lag] - d_mean);\n                n_in_lag++;\n            }\n        }\n        if (n_in_lag > 0 && sd > 0) {\n            r[lag] /= (n_in_lag * sd * sd);\n            r_sum += r[lag];\n            n_r++;\n        } else {\n            r[lag] = null;\n        }\n        if(lag >= 1 && lag < (n + n_gaps) / 2) {\n            lag_by_r[r[lag]] = lag;\n        }\n    }\n    if (lag1_t > 0) {\n        r1_t = r[lag1_t] !== undefined ? r[lag1_t] : 0;\n    }\n    if (lag1_p > 0) {\n        r1_p = r[lag1_p] !== undefined ? r[lag1_p] : 0;\n    }\n\n    // Betsy Weatherhead's correction, based on lag 1, augmented by the highest\n    // lag > 1 and < n/2\n    if (r1_p >= autocorr_limit) {\n        r1_p = autocorr_limit;\n    }\n    if(r1_t >= autocorr_limit) {\n        r1_t = autocorr_limit;\n    }\n\n    const betsy = Math.sqrt((n_good-1)*(1. - r1_p)*(1. - r1_t));\n    var stde_betsy;\n    if (betsy !== 0) {\n        stde_betsy = sd / betsy;\n    } else {\n        stde_betsy = null;\n    }\n    const stats = {\n        d_mean: d_mean,\n        stde_betsy: stde_betsy,\n        sd: sd,\n        n_good: n_good,\n        lag1: r[1],\n        min: minSecs,\n        max: max_secs,\n        minVal: minVal,\n        maxVal: maxVal,\n        sum: sum_d,\n        qaCorrected: qaCorrected\n    };\n    //console.log(\"stats are \" + JSON.stringify(stats));\n    // stde_betsy is standard error with auto correlation\n    //console.log(\"---------\\n\\n\");\n    return stats;\n};\n\n// utility to process the user-input histogram customization controls\nconst setHistogramParameters = function (plotParams) {\n    var yAxisFormat = plotParams['histogram-yaxis-controls'];\n    var binType = plotParams['histogram-bin-controls'];\n    var binNum = 12;    // default bin number\n    var binStart = undefined;    // default is no mandated bin start\n    var binStride = undefined;         // default is no mandated stride\n    var pivotVal = undefined;      // default is not to shift the bins over to a pivot\n    var binBounds = []; // default is no specified bin bounds -- our algorithm will figure them out if this array stays empty\n\n    switch (binType) {\n        case \"Set number of bins\":\n            // get the user's chosen number of bins\n            binNum = Number(plotParams['bin-number']);\n            if (isNaN(binNum)) {\n                throw new Error(\"Error parsing bin number: please enter the desired number of bins.\");\n            }\n            break;\n\n        case \"Make zero a bin bound\":\n            // let the histogram routine know that we want the bins shifted over to zero\n            pivotVal = 0;\n            break;\n\n        case \"Choose a bin bound\":\n            // let the histogram routine know that we want the bins shifted over to whatever was input\n            pivotVal = Number(plotParams['bin-pivot']);\n            if (isNaN(pivotVal)) {\n                throw new Error(\"Error parsing bin pivot: please enter the desired bin pivot.\");\n            }\n            break;\n\n        case \"Set number of bins and make zero a bin bound\":\n            // get the user's chosen number of bins and let the histogram routine know that we want the bins shifted over to zero\n            binNum = Number(plotParams['bin-number']);\n            if (isNaN(binNum)) {\n                throw new Error(\"Error parsing bin number: please enter the desired number of bins.\");\n            }\n            pivotVal = 0;\n            break;\n\n        case \"Set number of bins and choose a bin bound\":\n            // get the user's chosen number of bins and let the histogram routine know that we want the bins shifted over to whatever was input\n            binNum = Number(plotParams['bin-number']);\n            if (isNaN(binNum)) {\n                throw new Error(\"Error parsing bin number: please enter the desired number of bins.\");\n            }\n            pivotVal = Number(plotParams['bin-pivot']);\n            if (isNaN(pivotVal)) {\n                throw new Error(\"Error parsing bin pivot: please enter the desired bin pivot.\");\n            }\n            break;\n\n        case \"Manual bins\":\n            // try to parse whatever we've been given for bin bounds. Throw an error if they didn't follow directions to enter a comma-separated list of numbers.\n            try {\n                binBounds = plotParams['bin-bounds'].split(\",\").map(function (item) {\n                    item.trim();\n                    item = Number(item);\n                    if (!isNaN(item)) {\n                        return item\n                    } else {\n                        throw new Error(\"Error parsing bin bounds: please enter  at least two numbers delimited by commas.\");\n                    }\n                });\n                binNum = binBounds.length + 1; // add 1 because these are inner bin bounds\n            } catch (e) {\n                throw new Error(\"Error parsing bin bounds: please enter  at least two numbers delimited by commas.\");\n            }\n            // make sure that we've been given at least two good bin bounds (enough to make one bin).\n            if (binNum < 3) {\n                throw new Error(\"Error parsing bin bounds: please enter at least two numbers delimited by commas.\");\n            }\n            break;\n\n        case \"Manual bin start, number, and stride\":\n            // get the bin start, number, and stride.\n            binNum = Number(plotParams['bin-number']);\n            if (isNaN(binNum)) {\n                throw new Error(\"Error parsing bin number: please enter the desired number of bins.\");\n            }\n            binStart = Number(plotParams['bin-start']);\n            if (isNaN(binStart)) {\n                throw new Error(\"Error parsing bin start: please enter the desired bin start.\");\n            }\n            binStride = Number(plotParams['bin-stride']);\n            if (isNaN(binStride)) {\n                throw new Error(\"Error parsing bin stride: please enter the desired bin stride.\");\n            }\n            break;\n\n        case \"Default bins\":\n        default:\n            break;\n    }\n    return {\n        yAxisFormat: yAxisFormat,\n        binNum: binNum,\n        binStart: binStart,\n        binStride: binStride,\n        pivotVal: pivotVal,\n        binBounds: binBounds\n    };\n};\n\n// utility that takes arrays of seconds and values and produces a data structure containing bin information for histogram plotting\nconst calculateHistogramBins = function (curveSubStats, curveSubSecs, binParams) {\n\n    // binStart and binStride will only be defined if the user wants to specify the bin spacing.\n    // otherwise, we'll use the mean and standard deviation of the data to space the bins.\n\n    // pivotVal will only be defined if the user wants to shift the bin limits to align with a certain value.\n    // otherwise, we'll keep everything aligned with the data mean.\n\n    var binStats = {};\n    var binUpBounds = [];\n    var binLowBounds = [];\n    var binMeans = [];\n\n    // calculate the global stats across all of the data\n    const globalStats = get_err(curveSubStats, curveSubSecs, []);   // we don't need levels for the mean or sd calculations, so just pass in an empty array\n    const glob_mean = globalStats.d_mean;\n    const glob_sd = globalStats.sd;\n\n    var fullLowBound;\n    var fullUpBound;\n    var fullRange;\n    var binInterval;\n\n    if (binParams.binStart === undefined || binParams.binStride === undefined) {\n        // use the global stats to determine the bin bounds -- should be based on dividing up +/- 3*sd from the mean into requested number of bins\n        fullLowBound = glob_mean - 3 * glob_sd;\n        fullUpBound = glob_mean + 3 * glob_sd;\n        fullRange = 6 * glob_sd;\n        binInterval = fullRange / (binParams.binNum - 2);   // take off two bins from the total number of requested bins to represent values either less than - 3*sd from the mean or greater than 3*sd from the mean\n    } else {\n        // use the user-defined start, number, and stride to determine the bin bounds\n        fullLowBound = binParams.binStart;\n        fullUpBound = binParams.binStart + (binParams.binNum - 2) * binParams.binStride;  // take off two bins from the total number of requested bins to represent values that fall outside of the prescribed range\n        fullRange = (binParams.binNum - 2) * binParams.binStride;\n        binInterval = binParams.binStride;\n    }\n\n    // store an array of the upper and lower bounding values for each bin.\n    binUpBounds[0] = fullLowBound; // the first upper bound should be exactly - 3*sd from the mean, or the previously calculated fullLowBound\n    binLowBounds[0] = -1 * Number.MAX_VALUE;\n    binMeans[0] = fullLowBound - binInterval / 2;\n    for (var b_idx = 1; b_idx < binParams.binNum - 1; b_idx++) {\n        binUpBounds[b_idx] = binUpBounds[b_idx - 1] + binInterval; // increment from fullLowBound to get the rest of the bin upper limits\n        binLowBounds[b_idx] = binUpBounds[b_idx - 1];\n        binMeans[b_idx] = binUpBounds[b_idx - 1] + binInterval / 2;\n    }\n    binUpBounds[binParams.binNum - 1] = Number.MAX_VALUE; // the last bin should have everything too large to fit into the previous bins, so make its upper bound the max number value\n    binLowBounds[binParams.binNum - 1] = fullUpBound;\n    binMeans[binParams.binNum - 1] = fullUpBound + binInterval / 2;\n\n    if (binParams.pivotVal !== undefined && !isNaN(binParams.pivotVal)) {\n        // need to shift the bounds and means over so that one of the bounds is on the chosen pivot\n        var closestBoundToPivot = binLowBounds.reduce(function (prev, curr) {\n            return (Math.abs(curr - binParams.pivotVal) < Math.abs(prev - binParams.pivotVal) ? curr : prev);\n        });\n        binUpBounds = binUpBounds.map(function (val) {\n            return val - (closestBoundToPivot - binParams.pivotVal);\n        });\n        binLowBounds = binLowBounds.map(function (val) {\n            return val - (closestBoundToPivot - binParams.pivotVal);\n        });\n        binMeans = binMeans.map(function (val) {\n            return val - (closestBoundToPivot - binParams.pivotVal);\n        });\n    }\n\n    // calculate the labels for each bin, based on the data bounding range, for the graph x-axis later\n    var binLabels = [];\n    var lowSdFromMean;\n    var upSdFromMean;\n    for (b_idx = 0; b_idx < binParams.binNum; b_idx++) {\n        lowSdFromMean = (binLowBounds[b_idx]).toFixed(2);\n        upSdFromMean = (binUpBounds[b_idx]).toFixed(2);\n        if (b_idx === 0) {\n            binLabels[b_idx] = \"< \" + upSdFromMean;\n        } else if (b_idx === binParams.binNum - 1) {\n            binLabels[b_idx] = \"> \" + lowSdFromMean;\n        } else {\n            binLabels[b_idx] = lowSdFromMean + \"-\" + upSdFromMean;\n        }\n    }\n\n    binStats['glob_mean'] = glob_mean;\n    binStats['glob_sd'] = glob_sd;\n    binStats['binUpBounds'] = binUpBounds;\n    binStats['binLowBounds'] = binLowBounds;\n    binStats['binMeans'] = binMeans;\n    binStats['binLabels'] = binLabels;\n\n    return {'binStats': binStats};\n};\n\n// utility that takes an array of user-defined bin bounds and produces a data structure containing bin information for histogram plotting\nconst prescribeHistogramBins = function (curveSubStats, curveSubSecs, binParams) {\n\n    var binStats = {};\n\n    // calculate the global stats across all of the data\n    const globalStats = get_err(curveSubStats, curveSubSecs, []);   // we don't need levels for the mean or sd calculations, so just pass in an empty array\n    const glob_mean = globalStats.d_mean;\n    const glob_sd = globalStats.sd;\n\n    // make sure the user-defined bins are in order from least to greatest\n    binParams.binBounds = binParams.binBounds.sort(function (a, b) {\n        return Number(a) - Number(b);\n    });\n\n    // store an array of the upper and lower bounding values for each bin.\n    var binUpBounds = [];\n    var binLowBounds = [];\n    var binMeans = [];\n    var binIntervalSum = 0;\n    for (var b_idx = 1; b_idx < binParams.binNum - 1; b_idx++) {\n        binUpBounds[b_idx] = binParams.binBounds[b_idx];\n        binLowBounds[b_idx] = binParams.binBounds[b_idx - 1];\n        binMeans[b_idx] = (binUpBounds[b_idx] + binLowBounds[b_idx]) / 2;\n        binIntervalSum = binIntervalSum + (binUpBounds[b_idx] - binLowBounds[b_idx]);\n    }\n    const binIntervalAverage = binIntervalSum / (binParams.binNum - 2);\n    binUpBounds[0] = binLowBounds[1];\n    binLowBounds[0] = -1 * Number.MAX_VALUE; // the first bin should have everything too small to fit into the other bins, so make its lower bound -1 * the max number value\n    binMeans[0] = binLowBounds[1] - binIntervalAverage / 2; // the bin means for the edge bins is a little arbitrary, so base it on the average bin width\n    binUpBounds[binParams.binNum - 1] = Number.MAX_VALUE; // the last bin should have everything too large to fit into the previous bins, so make its upper bound the max number value\n    binLowBounds[binParams.binNum - 1] = binUpBounds[binParams.binNum - 2];\n    binMeans[binParams.binNum - 1] = binUpBounds[binParams.binNum - 2] + binIntervalAverage / 2; // the bin means for the edge bins is a little arbitrary, so base it on the average bin width\n\n    // calculate the labels for each bin, based on the data bounding range, for the graph x-axis later\n    var binLabels = [];\n    var lowSdFromMean;\n    var upSdFromMean;\n    for (b_idx = 0; b_idx < binParams.binNum; b_idx++) {\n        lowSdFromMean = (binLowBounds[b_idx]).toFixed(2);\n        upSdFromMean = (binUpBounds[b_idx]).toFixed(2);\n        if (b_idx === 0) {\n            binLabels[b_idx] = \"< \" + upSdFromMean;\n        } else if (b_idx === binParams.binNum - 1) {\n            binLabels[b_idx] = \"> \" + lowSdFromMean;\n        } else {\n            binLabels[b_idx] = lowSdFromMean + \"-\" + upSdFromMean;\n        }\n    }\n\n    binStats['glob_mean'] = glob_mean;\n    binStats['glob_sd'] = glob_sd;\n    binStats['binUpBounds'] = binUpBounds;\n    binStats['binLowBounds'] = binLowBounds;\n    binStats['binMeans'] = binMeans;\n    binStats['binLabels'] = binLabels;\n\n    return {'binStats': binStats};\n};\n\n// utility that takes arrays of seconds, values, and optionally levels, and produces a data structure for histogram data\n// processing. Used in the initial histogram DB query and in matching.\nconst sortHistogramBins = function (curveSubStats, curveSubSecs, curveSubLevs, binNum, masterBinStats, hasLevels, d) {\n\n    // need maps to hold the sub values and seconds (and levels) for each bin, after the bin bounds are calculated.\n    var binSubStats = {};\n    var binSubSecs = {};\n    var binSubLevs = {};\n\n    for (var b_idx = 0; b_idx < binNum; b_idx++) {\n        binSubStats[b_idx] = [];\n        binSubSecs[b_idx] = [];\n        binSubLevs[b_idx] = [];\n    }\n\n    // calculate the global stats across all of the data\n    var globalStats;\n    if (hasLevels) {\n        globalStats = get_err(curveSubStats, curveSubSecs, curveSubLevs);\n    } else {\n        globalStats = get_err(curveSubStats, curveSubSecs, []);\n    }\n    const glob_mean = globalStats.d_mean;\n    const glob_sd = globalStats.sd;\n    const glob_n = globalStats.n_good;\n    const glob_max = globalStats.maxVal;\n    const glob_min = globalStats.minVal;\n\n    // sort data into bins\n    const binUpBounds = masterBinStats.binUpBounds;\n    const binLowBounds = masterBinStats.binLowBounds;\n    const binMeans = masterBinStats.binMeans;\n    const binLabels = masterBinStats.binLabels;\n\n    for (var d_idx = 0; d_idx < curveSubStats.length; d_idx++) {\n        // iterate through all of the bins until we find one where the upper limit is greater than our datum.\n        for (b_idx = 0; b_idx < binNum; b_idx++) {\n            if (curveSubStats[d_idx] <= binUpBounds[b_idx]) {\n                binSubStats[b_idx].push(curveSubStats[d_idx]);\n                binSubSecs[b_idx].push(curveSubSecs[d_idx]);\n                if (hasLevels) {\n                    binSubLevs[b_idx].push(curveSubLevs[d_idx]);\n                }\n                break;\n            }\n        }\n    }\n\n    // calculate the statistics for each bin\n    // we are especially interested in the number of values in each bin, as that is the plotted stat in a histogram\n    var binStats;\n    var bin_mean;\n    var bin_sd;\n    var bin_n;\n    var bin_rf;\n\n    var sum = 0;\n    var count = 0;\n    for (b_idx = 0; b_idx < binNum; b_idx++) {\n        if (hasLevels) {\n            binStats = get_err(binSubStats[b_idx], binSubSecs[b_idx], binSubLevs[b_idx]);\n        } else {\n            binStats = get_err(binSubStats[b_idx], binSubSecs[b_idx], []);\n        }\n        bin_mean = binStats.d_mean;\n        bin_sd = binStats.sd;\n        bin_n = binStats.n_good;\n        bin_rf = bin_n / glob_n;\n\n        /*\n        var d = {// d will contain the curve data\n            x: [], //placeholder\n            y: [], //placeholder\n            error_x: [], // unused\n            error_y: [], // unused\n            subVals: [],\n            subSecs: [],\n            subLevs: [],\n            glob_stats: {}, // placeholder\n            bin_stats: [], // placeholder\n            text: [], //placeholder\n            xmax: Number.MIN_VALUE,\n            xmin: Number.MAX_VALUE,\n            ymax: Number.MIN_VALUE,\n            ymin: Number.MAX_VALUE\n        };\n        */\n\n        d.x.push(binMeans[b_idx]);\n        d.y.push(bin_n);\n        d.subVals.push(binSubStats[b_idx]);\n        d.subSecs.push(binSubSecs[b_idx]);\n        d.bin_stats.push({\n            'bin_mean': bin_mean,\n            'bin_sd': bin_sd,\n            'bin_n': bin_n,\n            'bin_rf': bin_rf,\n            'binLowBound': binLowBounds[b_idx],\n            'binUpBound': binUpBounds[b_idx],\n            'binLabel': binLabels[b_idx]\n        });\n        d.text.push(null);\n\n        if (hasLevels) {\n            d.subLevs.push(binSubLevs[b_idx]);\n        }\n\n        // set axis limits based on returned data\n        if (d.y[b_idx] !== null) {\n            sum = sum + d.y[b_idx];\n            count++;\n            d.ymin = d.ymin < d.y[b_idx] ? d.ymin : d.y[b_idx];\n            d.ymax = d.ymax > d.y[b_idx] ? d.ymax : d.y[b_idx];\n        }\n\n    }\n    d.glob_stats = {\n        'glob_mean': glob_mean,\n        'glob_sd': glob_sd,\n        'glob_n': glob_n,\n        'glob_max': glob_max,\n        'glob_min': glob_min\n    };\n    d.xmin = d.x[0];\n    d.xmax = d.x[binNum - 1];\n\n    return {d: d};\n};\n\n// utility that takes the curve params for two contour plots and collapses them into the curve params for one diff contour.\nconst getDiffContourCurveParams = function (curves) {\n\n    var newCurve = {};\n    const curveKeys = Object.keys(curves[0]);\n    var currKey;\n    for (var ckidx = 0; ckidx < curveKeys.length; ckidx++) {\n        currKey = curveKeys[ckidx];\n        if (currKey === 'color') {\n            newCurve['color'] = \"rgb(255,165,0)\";\n        } else if (curves[0][currKey] === curves[1][currKey]) {\n            newCurve[currKey] = curves[0][currKey];\n        } else {\n            newCurve[currKey] = curves[1][currKey] + \"-\" + curves[0][currKey];\n        }\n    }\n    return [newCurve];\n};\n\n//used for sorting arrays\nconst sortFunction = function (a, b) {\n    if (a[0] === b[0]) {\n        return 0;\n    }\n    else {\n        return (a[0] < b[0]) ? -1 : 1;\n    }\n};\n\nexport default matsDataUtils = {\n\n    areObjectsEqual: areObjectsEqual,\n    arrayContainsArray: arrayContainsArray,\n    arrayContainsSubArray: arrayContainsSubArray,\n    arraysEqual: arraysEqual,\n    arrayUnique: arrayUnique,\n    findArrayInSubArray: findArrayInSubArray,\n    objectContainsObject: objectContainsObject,\n    average: average,\n    stdev: stdev,\n    dateConvert: dateConvert,\n    getDateRange: getDateRange,\n    secsConvert: secsConvert,\n    doAuthorization: doAuthorization,\n    doColorScheme: doColorScheme,\n    doCredentials: doCredentials,\n    doRoles: doRoles,\n    doSettings: doSettings,\n    getPlotParamsFromStack: getPlotParamsFromStack,\n    get_err: get_err,\n    setHistogramParameters: setHistogramParameters,\n    calculateHistogramBins: calculateHistogramBins,\n    prescribeHistogramBins: prescribeHistogramBins,\n    sortHistogramBins: sortHistogramBins,\n    getDiffContourCurveParams: getDiffContourCurveParams,\n    sortFunction: sortFunction,\n\n}"]},"sourceType":"script","hash":"2d7278ed85b97b903f1268bdb4649d3ba6daf83b"}
