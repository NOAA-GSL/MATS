{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_threshold.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"server/dataFunctions/data_threshold.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_threshold.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_threshold.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/dataFunctions/data_threshold.js"}},"code":"let matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataThreshold = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.threshold;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"SELECT m0.thresh/100 as avtime, \" + \"count(distinct m0.valid_time) as N_times, \" + \"min(m0.valid_time) as min_secs, \" + \"max(m0.valid_time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.valid_time >= '{{fromSecs}}' \" + \"and m0.valid_time <= '{{toSecs}}' \" + \"{{validTimeClause}} \" + \"and m0.yy+m0.ny+m0.yn+m0.nn > 0 \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + region + sourceStr);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      var validTimeClause = \" \";\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and floor((m0.valid_time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      dataRequests[curve.label] = statement;\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};","map":{"version":3,"sources":["server/dataFunctions/data_threshold.js"],"names":["matsCollections","module","link","v","matsTypes","matsDataUtils","matsDataQueryUtils","matsDataDiffUtils","matsDataCurveOpsUtils","matsDataProcessUtils","moment","dataThreshold","plotParams","plotFunction","matching","PlotActions","matched","plotType","PlotTypes","threshold","hasLevels","dataRequests","dataFoundForCurve","totalProcessingStart","error","curves","JSON","parse","stringify","curvesLength","length","dataset","utcCycleStarts","axisMap","Object","create","xmax","Number","MAX_VALUE","ymax","xmin","ymin","idealValues","curveIndex","curve","diffFrom","label","dataSourceStr","data_source","CurveParams","findOne","name","optionsMap","regionStr","region","keys","valuesMap","find","key","source","sourceStr","statisticSelect","statisticOptionsMap","statistic","dateRange","getDateRange","fromSecs","fromSeconds","toSecs","toSeconds","validTimes","undefined","forecastLength","axisKey","idealVal","indexOf","push","d","statement","replace","validTimeClause","InputTypes","unused","queryResult","startMoment","finishMoment","queryDBSpecialtyCurve","sumPool","begin","format","finish","duration","diff","asSeconds","recordCount","data","x","e","message","Error","Messages","NO_DATA_FOUND","postQueryStartMoment","diffResult","getDataForDiffCurve","mean","sum","annotation","toPrecision","cOptions","generateSeriesCurveOptions","postQueryFinishMoment","appParams","curveInfoParams","bookkeepingParams","result","processDataXYCurve"],"mappings":"AAAA,IAAIA,eAAJ;AAAoBC,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACF,EAAAA,eAAe,CAACG,CAAD,EAAG;AAACH,IAAAA,eAAe,GAACG,CAAhB;AAAkB;;AAAtC,CAAxC,EAAgF,CAAhF;AAAmF,IAAIC,SAAJ;AAAcH,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACE,EAAAA,SAAS,CAACD,CAAD,EAAG;AAACC,IAAAA,SAAS,GAACD,CAAV;AAAY;;AAA1B,CAAxC,EAAoE,CAApE;AAAuE,IAAIE,aAAJ;AAAkBJ,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACG,EAAAA,aAAa,CAACF,CAAD,EAAG;AAACE,IAAAA,aAAa,GAACF,CAAd;AAAgB;;AAAlC,CAAxC,EAA4E,CAA5E;AAA+E,IAAIG,kBAAJ;AAAuBL,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACI,EAAAA,kBAAkB,CAACH,CAAD,EAAG;AAACG,IAAAA,kBAAkB,GAACH,CAAnB;AAAqB;;AAA5C,CAAxC,EAAsF,CAAtF;AAAyF,IAAII,iBAAJ;AAAsBN,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACK,EAAAA,iBAAiB,CAACJ,CAAD,EAAG;AAACI,IAAAA,iBAAiB,GAACJ,CAAlB;AAAoB;;AAA1C,CAAxC,EAAoF,CAApF;AAAuF,IAAIK,qBAAJ;AAA0BP,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACM,EAAAA,qBAAqB,CAACL,CAAD,EAAG;AAACK,IAAAA,qBAAqB,GAACL,CAAtB;AAAwB;;AAAlD,CAAxC,EAA4F,CAA5F;AAA+F,IAAIM,oBAAJ;AAAyBR,MAAM,CAACC,IAAP,CAAY,2BAAZ,EAAwC;AAACO,EAAAA,oBAAoB,CAACN,CAAD,EAAG;AAACM,IAAAA,oBAAoB,GAACN,CAArB;AAAuB;;AAAhD,CAAxC,EAA0F,CAA1F;AAA6F,IAAIO,MAAJ;AAAWT,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACQ,EAAAA,MAAM,CAACP,CAAD,EAAG;AAACO,IAAAA,MAAM,GAACP,CAAP;AAAS;;AAApB,CAArC,EAA2D,CAA3D;;AAapvBQ,aAAa,GAAG,UAAUC,UAAV,EAAsBC,YAAtB,EAAoC;AAChD;AACA,QAAMC,QAAQ,GAAGF,UAAU,CAAC,YAAD,CAAV,KAA6BR,SAAS,CAACW,WAAV,CAAsBC,OAApE;AACA,QAAMC,QAAQ,GAAGb,SAAS,CAACc,SAAV,CAAoBC,SAArC;AACA,QAAMC,SAAS,GAAG,KAAlB;AACA,MAAIC,YAAY,GAAG,EAAnB,CALgD,CAKzB;;AACvB,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,oBAAoB,GAAGb,MAAM,EAAjC;AACA,MAAIc,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAehB,UAAU,CAACa,MAA1B,CAAX,CAAb;AACA,MAAII,YAAY,GAAGJ,MAAM,CAACK,MAA1B;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,cAAc,GAAG,EAArB;AACA,MAAIC,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;AACA,MAAIC,IAAI,GAAG,CAAC,CAAD,GAAKC,MAAM,CAACC,SAAvB;AACA,MAAIC,IAAI,GAAG,CAAC,CAAD,GAAKF,MAAM,CAACC,SAAvB;AACA,MAAIE,IAAI,GAAGH,MAAM,CAACC,SAAlB;AACA,MAAIG,IAAI,GAAGJ,MAAM,CAACC,SAAlB;AACA,MAAII,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAIC,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGd,YAAtC,EAAoDc,UAAU,EAA9D,EAAkE;AAC9D;AACA,QAAIC,KAAK,GAAGnB,MAAM,CAACkB,UAAD,CAAlB;AACA,QAAIE,QAAQ,GAAGD,KAAK,CAACC,QAArB;AACA,QAAIC,KAAK,GAAGF,KAAK,CAAC,OAAD,CAAjB;AACA,QAAIG,aAAa,GAAGH,KAAK,CAAC,aAAD,CAAzB;AACA,QAAII,WAAW,GAAGhD,eAAe,CAACiD,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,MAAAA,IAAI,EAAE;AAAP,KAApC,EAA2DC,UAA3D,CAAsER,KAAK,CAAC,aAAD,CAA3E,EAA4F,CAA5F,CAAlB;AACA,QAAIS,SAAS,GAAGT,KAAK,CAAC,QAAD,CAArB;AACA,QAAIU,MAAM,GAAGpB,MAAM,CAACqB,IAAP,CAAYvD,eAAe,CAACiD,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,MAAAA,IAAI,EAAE;AAAP,KAApC,EAAsDK,SAAlE,EAA6EC,IAA7E,CAAkFC,GAAG,IAAI1D,eAAe,CAACiD,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,MAAAA,IAAI,EAAE;AAAP,KAApC,EAAsDK,SAAtD,CAAgEE,GAAhE,MAAyEL,SAAlK,CAAb;AACA,QAAIM,MAAM,GAAGf,KAAK,CAAC,OAAD,CAAlB;AACA,QAAIgB,SAAS,GAAG,EAAhB;;AACA,QAAID,MAAM,KAAK,KAAf,EAAsB;AAClBC,MAAAA,SAAS,GAAG,MAAMD,MAAlB;AACH;;AACD,QAAIE,eAAe,GAAGjB,KAAK,CAAC,WAAD,CAA3B;AACA,QAAIkB,mBAAmB,GAAG9D,eAAe,CAACiD,WAAhB,CAA4BC,OAA5B,CAAoC;AAACC,MAAAA,IAAI,EAAE;AAAP,KAApC,EAAyD;AAACC,MAAAA,UAAU,EAAE;AAAb,KAAzD,EAA0E,YAA1E,CAA1B;AACA,QAAIW,SAAS,GAAGD,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAhB;AACA,QAAIG,SAAS,GAAG3D,aAAa,CAAC4D,YAAd,CAA2BrB,KAAK,CAAC,aAAD,CAAhC,CAAhB;AACA,QAAIsB,QAAQ,GAAGF,SAAS,CAACG,WAAzB;AACA,QAAIC,MAAM,GAAGJ,SAAS,CAACK,SAAvB;AACA,QAAIC,UAAU,GAAG1B,KAAK,CAAC,YAAD,CAAL,KAAwB2B,SAAxB,GAAoC,EAApC,GAAyC3B,KAAK,CAAC,YAAD,CAA/D;AACA,QAAI4B,cAAc,GAAG5B,KAAK,CAAC,iBAAD,CAA1B,CArB8D,CAsB9D;AACA;AACA;AACA;;AACA,QAAI6B,OAAO,GAAGX,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAd;AACApC,IAAAA,MAAM,CAACkB,UAAD,CAAN,CAAmB8B,OAAnB,GAA6BA,OAA7B,CA3B8D,CA2BxB;;AACtC,QAAIC,QAAQ,GAAGZ,mBAAmB,CAACD,eAAD,CAAnB,CAAqC,CAArC,CAAf;;AACA,QAAIa,QAAQ,KAAK,IAAb,IAAqBhC,WAAW,CAACiC,OAAZ,CAAoBD,QAApB,MAAkC,CAAC,CAA5D,EAA+D;AAC3DhC,MAAAA,WAAW,CAACkC,IAAZ,CAAiBF,QAAjB;AACH;;AAED,QAAIG,CAAJ;;AACA,QAAIhC,QAAQ,IAAI,IAAhB,EAAsB;AAClB;AACA;AACA,UAAIiC,SAAS,GAAG,qCACZ,4CADY,GAEZ,kCAFY,GAGZ,kCAHY,GAIZ,gBAJY,GAKZ,6BALY,GAMZ,YANY,GAOZ,sCAPY,GAQZ,oCARY,GASZ,sBATY,GAUZ,kCAVY,GAWZ,yCAXY,GAYZ,kBAZY,GAaZ,iBAbY,GAcZ,GAdJ;AAgBAA,MAAAA,SAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,cAAlB,EAAkCb,QAAlC,CAAZ;AACAY,MAAAA,SAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,YAAlB,EAAgCX,MAAhC,CAAZ;AACAU,MAAAA,SAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,iBAAlB,EAAqC/B,WAAW,GAAG,GAAd,GAAoBM,MAApB,GAA6BM,SAAlE,CAAZ;AACAkB,MAAAA,SAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,eAAlB,EAAmChB,SAAnC,CAAZ;AACAe,MAAAA,SAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,oBAAlB,EAAwCP,cAAxC,CAAZ;AACA,UAAIQ,eAAe,GAAG,GAAtB;;AACA,UAAIV,UAAU,CAACxC,MAAX,GAAoB,CAApB,IAAyBwC,UAAU,KAAKlE,SAAS,CAAC6E,UAAV,CAAqBC,MAAjE,EAAyE;AACrEF,QAAAA,eAAe,GAAG,mDAAmDV,UAAnD,GAAgE,GAAlF;AACH;;AACDQ,MAAAA,SAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,qBAAlB,EAAyCC,eAAzC,CAAZ;AAEA3D,MAAAA,YAAY,CAACuB,KAAK,CAACE,KAAP,CAAZ,GAA4BgC,SAA5B;AAEA,UAAIK,WAAJ;AACA,UAAIC,WAAW,GAAG1E,MAAM,EAAxB;AACA,UAAI2E,YAAJ;;AACA,UAAI;AACA;AACAF,QAAAA,WAAW,GAAG7E,kBAAkB,CAACgF,qBAAnB,CAAyCC,OAAzC,EAAkDT,SAAlD,EAA6D7D,QAA7D,EAAuEG,SAAvE,CAAd;AACAiE,QAAAA,YAAY,GAAG3E,MAAM,EAArB;AACAW,QAAAA,YAAY,CAAC,mCAAmCuB,KAAK,CAACE,KAA1C,CAAZ,GAA+D;AAC3D0C,UAAAA,KAAK,EAAEJ,WAAW,CAACK,MAAZ,EADoD;AAE3DC,UAAAA,MAAM,EAAEL,YAAY,CAACI,MAAb,EAFmD;AAG3DE,UAAAA,QAAQ,EAAEjF,MAAM,CAACiF,QAAP,CAAgBN,YAAY,CAACO,IAAb,CAAkBR,WAAlB,CAAhB,EAAgDS,SAAhD,KAA8D,UAHb;AAI3DC,UAAAA,WAAW,EAAEX,WAAW,CAACY,IAAZ,CAAiBC,CAAjB,CAAmBlE;AAJ2B,SAA/D,CAJA,CAUA;;AACA+C,QAAAA,CAAC,GAAGM,WAAW,CAACY,IAAhB;AACH,OAZD,CAYE,OAAOE,CAAP,EAAU;AACR;AACAA,QAAAA,CAAC,CAACC,OAAF,GAAY,uBAAuBD,CAAC,CAACC,OAAzB,GAAmC,kBAAnC,GAAwDpB,SAApE;AACA,cAAM,IAAIqB,KAAJ,CAAUF,CAAC,CAACC,OAAZ,CAAN;AACH;;AACD,UAAIf,WAAW,CAAC3D,KAAZ,KAAsB+C,SAAtB,IAAmCY,WAAW,CAAC3D,KAAZ,KAAsB,EAA7D,EAAiE;AAC7D,YAAI2D,WAAW,CAAC3D,KAAZ,KAAsBpB,SAAS,CAACgG,QAAV,CAAmBC,aAA7C,EAA4D;AACxD;AACA/E,UAAAA,iBAAiB,GAAG,KAApB;AACH,SAHD,MAGO;AACH;AACAE,UAAAA,KAAK,IAAI,wCAAwC2D,WAAW,CAAC3D,KAApD,GAA4D,kBAA5D,GAAiFsD,SAAjF,GAA6F,MAAtG;AACA,gBAAO,IAAIqB,KAAJ,CAAU3E,KAAV,CAAP;AACH;AACJ,OA7DiB,CA+DlB;;;AACA,UAAI8E,oBAAoB,GAAG5F,MAAM,EAAjC;;AACA,UAAIY,iBAAJ,EAAuB;AACnBkB,QAAAA,IAAI,GAAGA,IAAI,GAAGqC,CAAC,CAACrC,IAAT,GAAgBA,IAAhB,GAAuBqC,CAAC,CAACrC,IAAhC;AACAJ,QAAAA,IAAI,GAAGA,IAAI,GAAGyC,CAAC,CAACzC,IAAT,GAAgBA,IAAhB,GAAuByC,CAAC,CAACzC,IAAhC;AACAK,QAAAA,IAAI,GAAGA,IAAI,GAAGoC,CAAC,CAACpC,IAAT,GAAgBA,IAAhB,GAAuBoC,CAAC,CAACpC,IAAhC;AACAF,QAAAA,IAAI,GAAGA,IAAI,GAAGsC,CAAC,CAACtC,IAAT,GAAgBA,IAAhB,GAAuBsC,CAAC,CAACtC,IAAhC;AACH;AACJ,KAvED,MAuEO;AACH;AACA,YAAMgE,UAAU,GAAGhG,iBAAiB,CAACiG,mBAAlB,CAAsCzE,OAAtC,EAA+Cc,QAA/C,EAAyD5B,QAAzD,EAAmEG,SAAnE,CAAnB;AACAyD,MAAAA,CAAC,GAAG0B,UAAU,CAACxE,OAAf;AACAS,MAAAA,IAAI,GAAGA,IAAI,GAAGqC,CAAC,CAACrC,IAAT,GAAgBA,IAAhB,GAAuBqC,CAAC,CAACrC,IAAhC;AACAJ,MAAAA,IAAI,GAAGA,IAAI,GAAGyC,CAAC,CAACzC,IAAT,GAAgBA,IAAhB,GAAuByC,CAAC,CAACzC,IAAhC;AACAK,MAAAA,IAAI,GAAGA,IAAI,GAAGoC,CAAC,CAACpC,IAAT,GAAgBA,IAAhB,GAAuBoC,CAAC,CAACpC,IAAhC;AACAF,MAAAA,IAAI,GAAGA,IAAI,GAAGsC,CAAC,CAACtC,IAAT,GAAgBA,IAAhB,GAAuBsC,CAAC,CAACtC,IAAhC;AACH,KAjH6D,CAmH9D;AACA;;;AACA,UAAMkE,IAAI,GAAG5B,CAAC,CAAC6B,GAAF,GAAQ7B,CAAC,CAACmB,CAAF,CAAIlE,MAAzB;AACA,UAAM6E,UAAU,GAAGF,IAAI,KAAKlC,SAAT,GAAqBzB,KAAK,GAAG,cAA7B,GAA8CA,KAAK,GAAG,WAAR,GAAsB2D,IAAI,CAACG,WAAL,CAAiB,CAAjB,CAAvF;AACAhE,IAAAA,KAAK,CAAC,YAAD,CAAL,GAAsB+D,UAAtB;AACA/D,IAAAA,KAAK,CAAC,MAAD,CAAL,GAAgBiC,CAAC,CAACrC,IAAlB;AACAI,IAAAA,KAAK,CAAC,MAAD,CAAL,GAAgBiC,CAAC,CAACzC,IAAlB;AACAQ,IAAAA,KAAK,CAAC,MAAD,CAAL,GAAgBiC,CAAC,CAACpC,IAAlB;AACAG,IAAAA,KAAK,CAAC,MAAD,CAAL,GAAgBiC,CAAC,CAACtC,IAAlB;AACAK,IAAAA,KAAK,CAAC,SAAD,CAAL,GAAmB6B,OAAnB;AACA,UAAMoC,QAAQ,GAAGrG,qBAAqB,CAACsG,0BAAtB,CAAiDlE,KAAjD,EAAwDD,UAAxD,EAAoEV,OAApE,EAA6E4C,CAA7E,CAAjB,CA7H8D,CA6HqC;;AACnG9C,IAAAA,OAAO,CAAC6C,IAAR,CAAaiC,QAAb;AACA,QAAIE,qBAAqB,GAAGrG,MAAM,EAAlC;AACAW,IAAAA,YAAY,CAAC,gDAAgDuB,KAAK,CAACE,KAAvD,CAAZ,GAA4E;AACxE0C,MAAAA,KAAK,EAAEc,oBAAoB,CAACb,MAArB,EADiE;AAExEC,MAAAA,MAAM,EAAEqB,qBAAqB,CAACtB,MAAtB,EAFgE;AAGxEE,MAAAA,QAAQ,EAAEjF,MAAM,CAACiF,QAAP,CAAgBoB,qBAAqB,CAACnB,IAAtB,CAA2BU,oBAA3B,CAAhB,EAAkET,SAAlE,KAAgF;AAHlB,KAA5E;AAKH,GAzJ+C,CAyJ7C;AAEH;;;AACA,QAAMmB,SAAS,GAAG;AAAC,gBAAY/F,QAAb;AAAuB,iBAAaG,SAApC;AAA+C,gBAAYN;AAA3D,GAAlB;AACA,QAAMmG,eAAe,GAAG;AACpB,cAAUxF,MADU;AAEpB,oBAAgBI,YAFI;AAGpB,mBAAea,WAHK;AAIpB,sBAAkBV,cAJE;AAKpB,eAAWC,OALS;AAMpB,YAAQG,IANY;AAOpB,YAAQI;AAPY,GAAxB;AASA,QAAM0E,iBAAiB,GAAG;AAAC,oBAAgB7F,YAAjB;AAA+B,4BAAwBE;AAAvD,GAA1B;AACA,MAAI4F,MAAM,GAAG1G,oBAAoB,CAAC2G,kBAArB,CAAwCrF,OAAxC,EAAiDiF,SAAjD,EAA4DC,eAA5D,EAA6ErG,UAA7E,EAAyFsG,iBAAzF,CAAb;AACArG,EAAAA,YAAY,CAACsG,MAAD,CAAZ;AACH,CAzKD","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataThreshold = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.threshold;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var dateRange = matsDataUtils.getDateRange(curve['curve-dates']);\n        var fromSecs = dateRange.fromSeconds;\n        var toSecs = dateRange.toSeconds;\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"SELECT m0.thresh/100 as avtime, \" +\n                \"count(distinct m0.valid_time) as N_times, \" +\n                \"min(m0.valid_time) as min_secs, \" +\n                \"max(m0.valid_time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.valid_time >= '{{fromSecs}}' \" +\n                \"and m0.valid_time <= '{{toSecs}}' \" +\n                \"{{validTimeClause}} \" +\n                \"and m0.yy+m0.ny+m0.yn+m0.nn > 0 \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + region + sourceStr);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            var validTimeClause = \" \";\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and floor((m0.valid_time)%(24*3600)/3600) IN(\" + validTimes + \")\"\n            }\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n\n            dataRequests[curve.label] = statement;\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBSpecialtyCurve(sumPool, statement, plotType, hasLevels);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};"]},"sourceType":"script","hash":"8ab7d20c7f165c2ee6cb2dcbc8d1767ecb9cbcad"}
