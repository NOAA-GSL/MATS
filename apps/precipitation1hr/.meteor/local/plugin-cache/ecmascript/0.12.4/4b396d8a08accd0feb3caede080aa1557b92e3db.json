{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/minimongo/local_collection.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/minimongo/local_collection.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/minimongo/local_collection.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/minimongo/local_collection.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/local_collection.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nmodule.export({\n  \"default\": function () {\n    return LocalCollection;\n  }\n});\nvar Cursor;\nmodule.link(\"./cursor.js\", {\n  \"default\": function (v) {\n    Cursor = v;\n  }\n}, 0);\nvar ObserveHandle;\nmodule.link(\"./observe_handle.js\", {\n  \"default\": function (v) {\n    ObserveHandle = v;\n  }\n}, 1);\nvar hasOwn, isIndexable, isNumericKey, isOperatorObject, populateDocumentWithQueryFields, projectionDetails;\nmodule.link(\"./common.js\", {\n  hasOwn: function (v) {\n    hasOwn = v;\n  },\n  isIndexable: function (v) {\n    isIndexable = v;\n  },\n  isNumericKey: function (v) {\n    isNumericKey = v;\n  },\n  isOperatorObject: function (v) {\n    isOperatorObject = v;\n  },\n  populateDocumentWithQueryFields: function (v) {\n    populateDocumentWithQueryFields = v;\n  },\n  projectionDetails: function (v) {\n    projectionDetails = v;\n  }\n}, 2);\n\nvar LocalCollection =\n/*#__PURE__*/\nfunction () {\n  function LocalCollection(name) {\n    this.name = name; // _id -> document (also containing id)\n\n    this._docs = new LocalCollection._IdMap();\n    this._observeQueue = new Meteor._SynchronousQueue();\n    this.next_qid = 1; // live query id generator\n    // qid -> live query object. keys:\n    //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n    //  results: array (ordered) or object (unordered) of current results\n    //    (aliased with this._docs!)\n    //  resultsSnapshot: snapshot of results. null if not paused.\n    //  cursor: Cursor object for the query.\n    //  selector, sorter, (callbacks): functions\n\n    this.queries = Object.create(null); // null if not saving originals; an IdMap from id to original document value\n    // if saving originals. See comments before saveOriginals().\n\n    this._savedOriginals = null; // True when observers are paused and we should not send callbacks.\n\n    this.paused = false;\n  } // options may include sort, skip, limit, reactive\n  // sort may be any of these forms:\n  //     {a: 1, b: -1}\n  //     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n  //     [\"a\", [\"b\", \"desc\"]]\n  //   (in the first form you're beholden to key enumeration order in\n  //   your javascript VM)\n  //\n  // reactive: if given, and false, don't register with Tracker (default\n  // is true)\n  //\n  // XXX possibly should support retrieving a subset of fields? and\n  // have it be a hint (ignored on the client, when not copying the\n  // doc?)\n  //\n  // XXX sort does not yet support subkeys ('a.b') .. fix that!\n  // XXX add one more sort form: \"key\"\n  // XXX tests\n\n\n  var _proto = LocalCollection.prototype;\n\n  _proto.find = function () {\n    function find(selector, options) {\n      // default syntax for everything is to omit the selector argument.\n      // but if selector is explicitly passed in as false or undefined, we\n      // want a selector that matches nothing.\n      if (arguments.length === 0) {\n        selector = {};\n      }\n\n      return new LocalCollection.Cursor(this, selector, options);\n    }\n\n    return find;\n  }();\n\n  _proto.findOne = function () {\n    function findOne(selector) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (arguments.length === 0) {\n        selector = {};\n      } // NOTE: by setting limit 1 here, we end up using very inefficient\n      // code that recomputes the whole query on each update. The upside is\n      // that when you reactively depend on a findOne you only get\n      // invalidated when the found object changes, not any object in the\n      // collection. Most findOne will be by id, which has a fast path, so\n      // this might not be a big deal. In most cases, invalidation causes\n      // the called to re-query anyway, so this should be a net performance\n      // improvement.\n\n\n      options.limit = 1;\n      return this.find(selector, options).fetch()[0];\n    }\n\n    return findOne;\n  }(); // XXX possibly enforce that 'undefined' does not appear (we assume\n  // this in our handling of null and $exists)\n\n\n  _proto.insert = function () {\n    function insert(doc, callback) {\n      var _this = this;\n\n      doc = EJSON.clone(doc);\n      assertHasValidFieldNames(doc); // if you really want to use ObjectIDs, set this global.\n      // Mongo.Collection specifies its own ids and does not use this code.\n\n      if (!hasOwn.call(doc, '_id')) {\n        doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n      }\n\n      var id = doc._id;\n\n      if (this._docs.has(id)) {\n        throw MinimongoError(\"Duplicate _id '\" + id + \"'\");\n      }\n\n      this._saveOriginal(id, undefined);\n\n      this._docs.set(id, doc);\n\n      var queriesToRecompute = []; // trigger live queries that match\n\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this.queries[qid];\n\n        if (query.dirty) {\n          return;\n        }\n\n        var matchResult = query.matcher.documentMatches(doc);\n\n        if (matchResult.result) {\n          if (query.distances && matchResult.distance !== undefined) {\n            query.distances.set(id, matchResult.distance);\n          }\n\n          if (query.cursor.skip || query.cursor.limit) {\n            queriesToRecompute.push(qid);\n          } else {\n            LocalCollection._insertInResults(query, doc);\n          }\n        }\n      });\n      queriesToRecompute.forEach(function (qid) {\n        if (_this.queries[qid]) {\n          _this._recomputeResults(_this.queries[qid]);\n        }\n      });\n\n      this._observeQueue.drain(); // Defer because the caller likely doesn't expect the callback to be run\n      // immediately.\n\n\n      if (callback) {\n        Meteor.defer(function () {\n          callback(null, id);\n        });\n      }\n\n      return id;\n    }\n\n    return insert;\n  }(); // Pause the observers. No callbacks from observers will fire until\n  // 'resumeObservers' is called.\n\n\n  _proto.pauseObservers = function () {\n    function pauseObservers() {\n      var _this2 = this;\n\n      // No-op if already paused.\n      if (this.paused) {\n        return;\n      } // Set the 'paused' flag such that new observer messages don't fire.\n\n\n      this.paused = true; // Take a snapshot of the query results for each query.\n\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this2.queries[qid];\n        query.resultsSnapshot = EJSON.clone(query.results);\n      });\n    }\n\n    return pauseObservers;\n  }();\n\n  _proto.remove = function () {\n    function remove(selector, callback) {\n      var _this3 = this;\n\n      // Easy special case: if we're not calling observeChanges callbacks and\n      // we're not saving originals and we got asked to remove everything, then\n      // just empty everything directly.\n      if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n        var _result = this._docs.size();\n\n        this._docs.clear();\n\n        Object.keys(this.queries).forEach(function (qid) {\n          var query = _this3.queries[qid];\n\n          if (query.ordered) {\n            query.results = [];\n          } else {\n            query.results.clear();\n          }\n        });\n\n        if (callback) {\n          Meteor.defer(function () {\n            callback(null, _result);\n          });\n        }\n\n        return _result;\n      }\n\n      var matcher = new Minimongo.Matcher(selector);\n      var remove = [];\n\n      this._eachPossiblyMatchingDoc(selector, function (doc, id) {\n        if (matcher.documentMatches(doc).result) {\n          remove.push(id);\n        }\n      });\n\n      var queriesToRecompute = [];\n      var queryRemove = [];\n\n      var _loop = function (i) {\n        var removeId = remove[i];\n\n        var removeDoc = _this3._docs.get(removeId);\n\n        Object.keys(_this3.queries).forEach(function (qid) {\n          var query = _this3.queries[qid];\n\n          if (query.dirty) {\n            return;\n          }\n\n          if (query.matcher.documentMatches(removeDoc).result) {\n            if (query.cursor.skip || query.cursor.limit) {\n              queriesToRecompute.push(qid);\n            } else {\n              queryRemove.push({\n                qid: qid,\n                doc: removeDoc\n              });\n            }\n          }\n        });\n\n        _this3._saveOriginal(removeId, removeDoc);\n\n        _this3._docs.remove(removeId);\n      };\n\n      for (var i = 0; i < remove.length; i++) {\n        _loop(i);\n      } // run live query callbacks _after_ we've removed the documents.\n\n\n      queryRemove.forEach(function (remove) {\n        var query = _this3.queries[remove.qid];\n\n        if (query) {\n          query.distances && query.distances.remove(remove.doc._id);\n\n          LocalCollection._removeFromResults(query, remove.doc);\n        }\n      });\n      queriesToRecompute.forEach(function (qid) {\n        var query = _this3.queries[qid];\n\n        if (query) {\n          _this3._recomputeResults(query);\n        }\n      });\n\n      this._observeQueue.drain();\n\n      var result = remove.length;\n\n      if (callback) {\n        Meteor.defer(function () {\n          callback(null, result);\n        });\n      }\n\n      return result;\n    }\n\n    return remove;\n  }(); // Resume the observers. Observers immediately receive change\n  // notifications to bring them to the current state of the\n  // database. Note that this is not just replaying all the changes that\n  // happened during the pause, it is a smarter 'coalesced' diff.\n\n\n  _proto.resumeObservers = function () {\n    function resumeObservers() {\n      var _this4 = this;\n\n      // No-op if not paused.\n      if (!this.paused) {\n        return;\n      } // Unset the 'paused' flag. Make sure to do this first, otherwise\n      // observer methods won't actually fire when we trigger them.\n\n\n      this.paused = false;\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this4.queries[qid];\n\n        if (query.dirty) {\n          query.dirty = false; // re-compute results will perform `LocalCollection._diffQueryChanges`\n          // automatically.\n\n          _this4._recomputeResults(query, query.resultsSnapshot);\n        } else {\n          // Diff the current results against the snapshot and send to observers.\n          // pass the query object for its observer callbacks.\n          LocalCollection._diffQueryChanges(query.ordered, query.resultsSnapshot, query.results, query, {\n            projectionFn: query.projectionFn\n          });\n        }\n\n        query.resultsSnapshot = null;\n      });\n\n      this._observeQueue.drain();\n    }\n\n    return resumeObservers;\n  }();\n\n  _proto.retrieveOriginals = function () {\n    function retrieveOriginals() {\n      if (!this._savedOriginals) {\n        throw new Error('Called retrieveOriginals without saveOriginals');\n      }\n\n      var originals = this._savedOriginals;\n      this._savedOriginals = null;\n      return originals;\n    }\n\n    return retrieveOriginals;\n  }(); // To track what documents are affected by a piece of code, call\n  // saveOriginals() before it and retrieveOriginals() after it.\n  // retrieveOriginals returns an object whose keys are the ids of the documents\n  // that were affected since the call to saveOriginals(), and the values are\n  // equal to the document's contents at the time of saveOriginals. (In the case\n  // of an inserted document, undefined is the value.) You must alternate\n  // between calls to saveOriginals() and retrieveOriginals().\n\n\n  _proto.saveOriginals = function () {\n    function saveOriginals() {\n      if (this._savedOriginals) {\n        throw new Error('Called saveOriginals twice without retrieveOriginals');\n      }\n\n      this._savedOriginals = new LocalCollection._IdMap();\n    }\n\n    return saveOriginals;\n  }(); // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n\n\n  _proto.update = function () {\n    function update(selector, mod, options, callback) {\n      var _this5 = this;\n\n      if (!callback && options instanceof Function) {\n        callback = options;\n        options = null;\n      }\n\n      if (!options) {\n        options = {};\n      }\n\n      var matcher = new Minimongo.Matcher(selector, true); // Save the original results of any query that we might need to\n      // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n      // it. (We don't need to save the original results of paused queries because\n      // they already have a resultsSnapshot and we won't be diffing in\n      // _recomputeResults.)\n\n      var qidToOriginalResults = {}; // We should only clone each document once, even if it appears in multiple\n      // queries\n\n      var docMap = new LocalCollection._IdMap();\n\n      var idsMatched = LocalCollection._idsMatchedBySelector(selector);\n\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this5.queries[qid];\n\n        if ((query.cursor.skip || query.cursor.limit) && !_this5.paused) {\n          // Catch the case of a reactive `count()` on a cursor with skip\n          // or limit, which registers an unordered observe. This is a\n          // pretty rare case, so we just clone the entire result set with\n          // no optimizations for documents that appear in these result\n          // sets and other queries.\n          if (query.results instanceof LocalCollection._IdMap) {\n            qidToOriginalResults[qid] = query.results.clone();\n            return;\n          }\n\n          if (!(query.results instanceof Array)) {\n            throw new Error('Assertion failed: query.results not an array');\n          } // Clones a document to be stored in `qidToOriginalResults`\n          // because it may be modified before the new and old result sets\n          // are diffed. But if we know exactly which document IDs we're\n          // going to modify, then we only need to clone those.\n\n\n          var memoizedCloneIfNeeded = function (doc) {\n            if (docMap.has(doc._id)) {\n              return docMap.get(doc._id);\n            }\n\n            var docToMemoize = idsMatched && !idsMatched.some(function (id) {\n              return EJSON.equals(id, doc._id);\n            }) ? doc : EJSON.clone(doc);\n            docMap.set(doc._id, docToMemoize);\n            return docToMemoize;\n          };\n\n          qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n        }\n      });\n      var recomputeQids = {};\n      var updateCount = 0;\n\n      this._eachPossiblyMatchingDoc(selector, function (doc, id) {\n        var queryResult = matcher.documentMatches(doc);\n\n        if (queryResult.result) {\n          // XXX Should we save the original even if mod ends up being a no-op?\n          _this5._saveOriginal(id, doc);\n\n          _this5._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);\n\n          ++updateCount;\n\n          if (!options.multi) {\n            return false; // break\n          }\n        }\n\n        return true;\n      });\n\n      Object.keys(recomputeQids).forEach(function (qid) {\n        var query = _this5.queries[qid];\n\n        if (query) {\n          _this5._recomputeResults(query, qidToOriginalResults[qid]);\n        }\n      });\n\n      this._observeQueue.drain(); // If we are doing an upsert, and we didn't modify any documents yet, then\n      // it's time to do an insert. Figure out what document we are inserting, and\n      // generate an id for it.\n\n\n      var insertedId;\n\n      if (updateCount === 0 && options.upsert) {\n        var doc = LocalCollection._createUpsertDocument(selector, mod);\n\n        if (!doc._id && options.insertedId) {\n          doc._id = options.insertedId;\n        }\n\n        insertedId = this.insert(doc);\n        updateCount = 1;\n      } // Return the number of affected documents, or in the upsert case, an object\n      // containing the number of affected docs and the id of the doc that was\n      // inserted, if any.\n\n\n      var result;\n\n      if (options._returnObject) {\n        result = {\n          numberAffected: updateCount\n        };\n\n        if (insertedId !== undefined) {\n          result.insertedId = insertedId;\n        }\n      } else {\n        result = updateCount;\n      }\n\n      if (callback) {\n        Meteor.defer(function () {\n          callback(null, result);\n        });\n      }\n\n      return result;\n    }\n\n    return update;\n  }(); // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n  // equivalent to LocalCollection.update(sel, mod, {upsert: true,\n  // _returnObject: true}).\n\n\n  _proto.upsert = function () {\n    function upsert(selector, mod, options, callback) {\n      if (!callback && typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      return this.update(selector, mod, Object.assign({}, options, {\n        upsert: true,\n        _returnObject: true\n      }), callback);\n    }\n\n    return upsert;\n  }(); // Iterates over a subset of documents that could match selector; calls\n  // fn(doc, id) on each of them.  Specifically, if selector specifies\n  // specific _id's, it only looks at those.  doc is *not* cloned: it is the\n  // same object that is in _docs.\n\n\n  _proto._eachPossiblyMatchingDoc = function () {\n    function _eachPossiblyMatchingDoc(selector, fn) {\n      var _this6 = this;\n\n      var specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n      if (specificIds) {\n        specificIds.some(function (id) {\n          var doc = _this6._docs.get(id);\n\n          if (doc) {\n            return fn(doc, id) === false;\n          }\n        });\n      } else {\n        this._docs.forEach(fn);\n      }\n    }\n\n    return _eachPossiblyMatchingDoc;\n  }();\n\n  _proto._modifyAndNotify = function () {\n    function _modifyAndNotify(doc, mod, recomputeQids, arrayIndices) {\n      var _this7 = this;\n\n      var matched_before = {};\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this7.queries[qid];\n\n        if (query.dirty) {\n          return;\n        }\n\n        if (query.ordered) {\n          matched_before[qid] = query.matcher.documentMatches(doc).result;\n        } else {\n          // Because we don't support skip or limit (yet) in unordered queries, we\n          // can just do a direct lookup.\n          matched_before[qid] = query.results.has(doc._id);\n        }\n      });\n      var old_doc = EJSON.clone(doc);\n\n      LocalCollection._modify(doc, mod, {\n        arrayIndices: arrayIndices\n      });\n\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this7.queries[qid];\n\n        if (query.dirty) {\n          return;\n        }\n\n        var afterMatch = query.matcher.documentMatches(doc);\n        var after = afterMatch.result;\n        var before = matched_before[qid];\n\n        if (after && query.distances && afterMatch.distance !== undefined) {\n          query.distances.set(doc._id, afterMatch.distance);\n        }\n\n        if (query.cursor.skip || query.cursor.limit) {\n          // We need to recompute any query where the doc may have been in the\n          // cursor's window either before or after the update. (Note that if skip\n          // or limit is set, \"before\" and \"after\" being true do not necessarily\n          // mean that the document is in the cursor's output after skip/limit is\n          // applied... but if they are false, then the document definitely is NOT\n          // in the output. So it's safe to skip recompute if neither before or\n          // after are true.)\n          if (before || after) {\n            recomputeQids[qid] = true;\n          }\n        } else if (before && !after) {\n          LocalCollection._removeFromResults(query, doc);\n        } else if (!before && after) {\n          LocalCollection._insertInResults(query, doc);\n        } else if (before && after) {\n          LocalCollection._updateInResults(query, doc, old_doc);\n        }\n      });\n    }\n\n    return _modifyAndNotify;\n  }(); // Recomputes the results of a query and runs observe callbacks for the\n  // difference between the previous results and the current results (unless\n  // paused). Used for skip/limit queries.\n  //\n  // When this is used by insert or remove, it can just use query.results for\n  // the old results (and there's no need to pass in oldResults), because these\n  // operations don't mutate the documents in the collection. Update needs to\n  // pass in an oldResults which was deep-copied before the modifier was\n  // applied.\n  //\n  // oldResults is guaranteed to be ignored if the query is not paused.\n\n\n  _proto._recomputeResults = function () {\n    function _recomputeResults(query, oldResults) {\n      if (this.paused) {\n        // There's no reason to recompute the results now as we're still paused.\n        // By flagging the query as \"dirty\", the recompute will be performed\n        // when resumeObservers is called.\n        query.dirty = true;\n        return;\n      }\n\n      if (!this.paused && !oldResults) {\n        oldResults = query.results;\n      }\n\n      if (query.distances) {\n        query.distances.clear();\n      }\n\n      query.results = query.cursor._getRawObjects({\n        distances: query.distances,\n        ordered: query.ordered\n      });\n\n      if (!this.paused) {\n        LocalCollection._diffQueryChanges(query.ordered, oldResults, query.results, query, {\n          projectionFn: query.projectionFn\n        });\n      }\n    }\n\n    return _recomputeResults;\n  }();\n\n  _proto._saveOriginal = function () {\n    function _saveOriginal(id, doc) {\n      // Are we even trying to save originals?\n      if (!this._savedOriginals) {\n        return;\n      } // Have we previously mutated the original (and so 'doc' is not actually\n      // original)?  (Note the 'has' check rather than truth: we store undefined\n      // here for inserted docs!)\n\n\n      if (this._savedOriginals.has(id)) {\n        return;\n      }\n\n      this._savedOriginals.set(id, EJSON.clone(doc));\n    }\n\n    return _saveOriginal;\n  }();\n\n  return LocalCollection;\n}();\n\nLocalCollection.Cursor = Cursor;\nLocalCollection.ObserveHandle = ObserveHandle; // XXX maybe move these into another ObserveHelpers package or something\n// _CachingChangeObserver is an object which receives observeChanges callbacks\n// and keeps a cache of the current cursor state up to date in this.docs. Users\n// of this class should read the docs field but not modify it. You should pass\n// the \"applyChange\" field as the callbacks to the underlying observeChanges\n// call. Optionally, you can specify your own observeChanges callbacks which are\n// invoked immediately before the docs field is updated; this object is made\n// available as `this` to those callbacks.\n\nLocalCollection._CachingChangeObserver = function () {\n  function _CachingChangeObserver() {\n    var _this8 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var orderedFromCallbacks = options.callbacks && LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);\n\n    if (hasOwn.call(options, 'ordered')) {\n      this.ordered = options.ordered;\n\n      if (options.callbacks && options.ordered !== orderedFromCallbacks) {\n        throw Error('ordered option doesn\\'t match callbacks');\n      }\n    } else if (options.callbacks) {\n      this.ordered = orderedFromCallbacks;\n    } else {\n      throw Error('must provide ordered or callbacks');\n    }\n\n    var callbacks = options.callbacks || {};\n\n    if (this.ordered) {\n      this.docs = new OrderedDict(MongoID.idStringify);\n      this.applyChange = {\n        addedBefore: function (id, fields, before) {\n          var doc = EJSON.clone(fields);\n          doc._id = id;\n\n          if (callbacks.addedBefore) {\n            callbacks.addedBefore.call(_this8, id, fields, before);\n          } // This line triggers if we provide added with movedBefore.\n\n\n          if (callbacks.added) {\n            callbacks.added.call(_this8, id, fields);\n          } // XXX could `before` be a falsy ID?  Technically\n          // idStringify seems to allow for them -- though\n          // OrderedDict won't call stringify on a falsy arg.\n\n\n          _this8.docs.putBefore(id, doc, before || null);\n        },\n        movedBefore: function (id, before) {\n          var doc = _this8.docs.get(id);\n\n          if (callbacks.movedBefore) {\n            callbacks.movedBefore.call(_this8, id, before);\n          }\n\n          _this8.docs.moveBefore(id, before || null);\n        }\n      };\n    } else {\n      this.docs = new LocalCollection._IdMap();\n      this.applyChange = {\n        added: function (id, fields) {\n          var doc = EJSON.clone(fields);\n\n          if (callbacks.added) {\n            callbacks.added.call(_this8, id, fields);\n          }\n\n          doc._id = id;\n\n          _this8.docs.set(id, doc);\n        }\n      };\n    } // The methods in _IdMap and OrderedDict used by these callbacks are\n    // identical.\n\n\n    this.applyChange.changed = function (id, fields) {\n      var doc = _this8.docs.get(id);\n\n      if (!doc) {\n        throw new Error(\"Unknown id for changed: \" + id);\n      }\n\n      if (callbacks.changed) {\n        callbacks.changed.call(_this8, id, EJSON.clone(fields));\n      }\n\n      DiffSequence.applyChanges(doc, fields);\n    };\n\n    this.applyChange.removed = function (id) {\n      if (callbacks.removed) {\n        callbacks.removed.call(_this8, id);\n      }\n\n      _this8.docs.remove(id);\n    };\n  }\n\n  return _CachingChangeObserver;\n}();\n\nLocalCollection._IdMap =\n/*#__PURE__*/\nfunction (_IdMap2) {\n  (0, _inheritsLoose2.default)(_IdMap, _IdMap2);\n\n  function _IdMap() {\n    return _IdMap2.call(this, MongoID.idStringify, MongoID.idParse) || this;\n  }\n\n  return _IdMap;\n}(IdMap); // Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\n\n\nLocalCollection.wrapTransform = function (transform) {\n  if (!transform) {\n    return null;\n  } // No need to doubly-wrap transforms.\n\n\n  if (transform.__wrappedTransform__) {\n    return transform;\n  }\n\n  var wrapped = function (doc) {\n    if (!hasOwn.call(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error('can only transform documents with _id');\n    }\n\n    var id = doc._id; // XXX consider making tracker a weak dependency and checking\n    // Package.tracker here\n\n    var transformed = Tracker.nonreactive(function () {\n      return transform(doc);\n    });\n\n    if (!LocalCollection._isPlainObject(transformed)) {\n      throw new Error('transform must return object');\n    }\n\n    if (hasOwn.call(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error('transformed document can\\'t have different _id');\n      }\n    } else {\n      transformed._id = id;\n    }\n\n    return transformed;\n  };\n\n  wrapped.__wrappedTransform__ = true;\n  return wrapped;\n}; // XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n// This binary search puts a value between any equal values, and the first\n// lesser value.\n\n\nLocalCollection._binarySearch = function (cmp, array, value) {\n  var first = 0;\n  var range = array.length;\n\n  while (range > 0) {\n    var halfRange = Math.floor(range / 2);\n\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      range -= halfRange + 1;\n    } else {\n      range = halfRange;\n    }\n  }\n\n  return first;\n};\n\nLocalCollection._checkSupportedProjection = function (fields) {\n  if (fields !== Object(fields) || Array.isArray(fields)) {\n    throw MinimongoError('fields option must be an object');\n  }\n\n  Object.keys(fields).forEach(function (keyPath) {\n    if (keyPath.split('.').includes('$')) {\n      throw MinimongoError('Minimongo doesn\\'t support $ operator in projections yet.');\n    }\n\n    var value = fields[keyPath];\n\n    if ((0, _typeof2.default)(value) === 'object' && ['$elemMatch', '$meta', '$slice'].some(function (key) {\n      return hasOwn.call(value, key);\n    })) {\n      throw MinimongoError('Minimongo doesn\\'t support operators in projections yet.');\n    }\n\n    if (![1, 0, true, false].includes(value)) {\n      throw MinimongoError('Projection values should be one of 1, 0, true, or false');\n    }\n  });\n}; // Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\n\n\nLocalCollection._compileProjection = function (fields) {\n  LocalCollection._checkSupportedProjection(fields);\n\n  var _idProjection = fields._id === undefined ? true : fields._id;\n\n  var details = projectionDetails(fields); // returns transformed doc according to ruleTree\n\n  var transform = function (doc, ruleTree) {\n    // Special case for \"sets\"\n    if (Array.isArray(doc)) {\n      return doc.map(function (subdoc) {\n        return transform(subdoc, ruleTree);\n      });\n    }\n\n    var result = details.including ? {} : EJSON.clone(doc);\n    Object.keys(ruleTree).forEach(function (key) {\n      if (!hasOwn.call(doc, key)) {\n        return;\n      }\n\n      var rule = ruleTree[key];\n\n      if (rule === Object(rule)) {\n        // For sub-objects/subsets we branch\n        if (doc[key] === Object(doc[key])) {\n          result[key] = transform(doc[key], rule);\n        }\n      } else if (details.including) {\n        // Otherwise we don't even touch this subfield\n        result[key] = EJSON.clone(doc[key]);\n      } else {\n        delete result[key];\n      }\n    });\n    return result;\n  };\n\n  return function (doc) {\n    var result = transform(doc, details.tree);\n\n    if (_idProjection && hasOwn.call(doc, '_id')) {\n      result._id = doc._id;\n    }\n\n    if (!_idProjection && hasOwn.call(result, '_id')) {\n      delete result._id;\n    }\n\n    return result;\n  };\n}; // Calculates the document to insert in case we're doing an upsert and the\n// selector does not match any elements\n\n\nLocalCollection._createUpsertDocument = function (selector, modifier) {\n  var selectorDocument = populateDocumentWithQueryFields(selector);\n\n  var isModify = LocalCollection._isModificationMod(modifier);\n\n  var newDoc = {};\n\n  if (selectorDocument._id) {\n    newDoc._id = selectorDocument._id;\n    delete selectorDocument._id;\n  } // This double _modify call is made to help with nested properties (see issue\n  // #8631). We do this even if it's a replacement for validation purposes (e.g.\n  // ambiguous id's)\n\n\n  LocalCollection._modify(newDoc, {\n    $set: selectorDocument\n  });\n\n  LocalCollection._modify(newDoc, modifier, {\n    isInsert: true\n  });\n\n  if (isModify) {\n    return newDoc;\n  } // Replacement can take _id from query document\n\n\n  var replacement = Object.assign({}, modifier);\n\n  if (newDoc._id) {\n    replacement._id = newDoc._id;\n  }\n\n  return replacement;\n};\n\nLocalCollection._diffObjects = function (left, right, callbacks) {\n  return DiffSequence.diffObjects(left, right, callbacks);\n}; // ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\n\n\nLocalCollection._diffQueryChanges = function (ordered, oldResults, newResults, observer, options) {\n  return DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options);\n};\n\nLocalCollection._diffQueryOrderedChanges = function (oldResults, newResults, observer, options) {\n  return DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);\n};\n\nLocalCollection._diffQueryUnorderedChanges = function (oldResults, newResults, observer, options) {\n  return DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);\n};\n\nLocalCollection._findInOrderedResults = function (query, doc) {\n  if (!query.ordered) {\n    throw new Error('Can\\'t call _findInOrderedResults on unordered query');\n  }\n\n  for (var i = 0; i < query.results.length; i++) {\n    if (query.results[i] === doc) {\n      return i;\n    }\n  }\n\n  throw Error('object missing from query');\n}; // If this is a selector which explicitly constrains the match by ID to a finite\n// number of documents, returns a list of their IDs.  Otherwise returns\n// null. Note that the selector may have other restrictions so it may not even\n// match those document!  We care about $in and $and since those are generated\n// access-controlled update and remove.\n\n\nLocalCollection._idsMatchedBySelector = function (selector) {\n  // Is the selector just an ID?\n  if (LocalCollection._selectorIsId(selector)) {\n    return [selector];\n  }\n\n  if (!selector) {\n    return null;\n  } // Do we have an _id clause?\n\n\n  if (hasOwn.call(selector, '_id')) {\n    // Is the _id clause just an ID?\n    if (LocalCollection._selectorIsId(selector._id)) {\n      return [selector._id];\n    } // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?\n\n\n    if (selector._id && Array.isArray(selector._id.$in) && selector._id.$in.length && selector._id.$in.every(LocalCollection._selectorIsId)) {\n      return selector._id.$in;\n    }\n\n    return null;\n  } // If this is a top-level $and, and any of the clauses constrain their\n  // documents, then the whole selector is constrained by any one clause's\n  // constraint. (Well, by their intersection, but that seems unlikely.)\n\n\n  if (Array.isArray(selector.$and)) {\n    for (var i = 0; i < selector.$and.length; ++i) {\n      var subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\n\n      if (subIds) {\n        return subIds;\n      }\n    }\n  }\n\n  return null;\n};\n\nLocalCollection._insertInResults = function (query, doc) {\n  var fields = EJSON.clone(doc);\n  delete fields._id;\n\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      var i = LocalCollection._insertInSortedList(query.sorter.getComparator({\n        distances: query.distances\n      }), query.results, doc);\n\n      var next = query.results[i + 1];\n\n      if (next) {\n        next = next._id;\n      } else {\n        next = null;\n      }\n\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._insertInSortedList = function (cmp, array, value) {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n\n  var i = LocalCollection._binarySearch(cmp, array, value);\n\n  array.splice(i, 0, value);\n  return i;\n};\n\nLocalCollection._isModificationMod = function (mod) {\n  var isModify = false;\n  var isReplace = false;\n  Object.keys(mod).forEach(function (key) {\n    if (key.substr(0, 1) === '$') {\n      isModify = true;\n    } else {\n      isReplace = true;\n    }\n  });\n\n  if (isModify && isReplace) {\n    throw new Error('Update parameter cannot have both modifier and non-modifier fields.');\n  }\n\n  return isModify;\n}; // XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\n// RegExp\n// XXX note that _type(undefined) === 3!!!!\n\n\nLocalCollection._isPlainObject = function (x) {\n  return x && LocalCollection._f._type(x) === 3;\n}; // XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\n\n\nLocalCollection._modify = function (doc, modifier) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!LocalCollection._isPlainObject(modifier)) {\n    throw MinimongoError('Modifier must be an object');\n  } // Make sure the caller can't mutate our data structures.\n\n\n  modifier = EJSON.clone(modifier);\n  var isModifier = isOperatorObject(modifier);\n  var newDoc = isModifier ? EJSON.clone(doc) : modifier;\n\n  if (isModifier) {\n    // apply modifiers to the doc.\n    Object.keys(modifier).forEach(function (operator) {\n      // Treat $setOnInsert as $set if this is an insert.\n      var setOnInsert = options.isInsert && operator === '$setOnInsert';\n      var modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\n      var operand = modifier[operator];\n\n      if (!modFunc) {\n        throw MinimongoError(\"Invalid modifier specified \" + operator);\n      }\n\n      Object.keys(operand).forEach(function (keypath) {\n        var arg = operand[keypath];\n\n        if (keypath === '') {\n          throw MinimongoError('An empty update path is not valid.');\n        }\n\n        var keyparts = keypath.split('.');\n\n        if (!keyparts.every(Boolean)) {\n          throw MinimongoError(\"The update path '\" + keypath + \"' contains an empty field name, \" + 'which is not allowed.');\n        }\n\n        var target = findModTarget(newDoc, keyparts, {\n          arrayIndices: options.arrayIndices,\n          forbidArray: operator === '$rename',\n          noCreate: NO_CREATE_MODIFIERS[operator]\n        });\n        modFunc(target, keyparts.pop(), arg, keypath, newDoc);\n      });\n    });\n\n    if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\n      throw MinimongoError(\"After applying the update to the document {_id: \\\"\" + doc._id + \"\\\", ...},\" + ' the (immutable) field \\'_id\\' was found to have been altered to ' + (\"_id: \\\"\" + newDoc._id + \"\\\"\"));\n    }\n  } else {\n    if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\n      throw MinimongoError(\"The _id field cannot be changed from {_id: \\\"\" + doc._id + \"\\\"} to \" + (\"{_id: \\\"\" + modifier._id + \"\\\"}\"));\n    } // replace the whole document\n\n\n    assertHasValidFieldNames(modifier);\n  } // move new document into place.\n\n\n  Object.keys(doc).forEach(function (key) {\n    // Note: this used to be for (var key in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (key !== '_id') {\n      delete doc[key];\n    }\n  });\n  Object.keys(newDoc).forEach(function (key) {\n    doc[key] = newDoc[key];\n  });\n};\n\nLocalCollection._observeFromObserveChanges = function (cursor, observeCallbacks) {\n  var transform = cursor.getTransform() || function (doc) {\n    return doc;\n  };\n\n  var suppressed = !!observeCallbacks._suppress_initial;\n  var observeChangesCallbacks;\n\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the\n    // linear scans required to generate them.  This lets observers that don't\n    // need absolute indices benefit from the other features of this API --\n    // relative order, transforms, and applyChanges -- without the speed hit.\n    var indices = !observeCallbacks._no_indices;\n    observeChangesCallbacks = {\n      addedBefore: function (id, fields, before) {\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)) {\n          return;\n        }\n\n        var doc = transform(Object.assign(fields, {\n          _id: id\n        }));\n\n        if (observeCallbacks.addedAt) {\n          observeCallbacks.addedAt(doc, indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1, before);\n        } else {\n          observeCallbacks.added(doc);\n        }\n      },\n      changed: function (id, fields) {\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\n          return;\n        }\n\n        var doc = EJSON.clone(this.docs.get(id));\n\n        if (!doc) {\n          throw new Error(\"Unknown id for changed: \" + id);\n        }\n\n        var oldDoc = transform(EJSON.clone(doc));\n        DiffSequence.applyChanges(doc, fields);\n\n        if (observeCallbacks.changedAt) {\n          observeCallbacks.changedAt(transform(doc), oldDoc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.changed(transform(doc), oldDoc);\n        }\n      },\n      movedBefore: function (id, before) {\n        if (!observeCallbacks.movedTo) {\n          return;\n        }\n\n        var from = indices ? this.docs.indexOf(id) : -1;\n        var to = indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1; // When not moving backwards, adjust for the fact that removing the\n        // document slides everything back one slot.\n\n        if (to > from) {\n          --to;\n        }\n\n        observeCallbacks.movedTo(transform(EJSON.clone(this.docs.get(id))), from, to, before || null);\n      },\n      removed: function (id) {\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\n          return;\n        } // technically maybe there should be an EJSON.clone here, but it's about\n        // to be removed from this.docs!\n\n\n        var doc = transform(this.docs.get(id));\n\n        if (observeCallbacks.removedAt) {\n          observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.removed(doc);\n        }\n      }\n    };\n  } else {\n    observeChangesCallbacks = {\n      added: function (id, fields) {\n        if (!suppressed && observeCallbacks.added) {\n          observeCallbacks.added(transform(Object.assign(fields, {\n            _id: id\n          })));\n        }\n      },\n      changed: function (id, fields) {\n        if (observeCallbacks.changed) {\n          var oldDoc = this.docs.get(id);\n          var doc = EJSON.clone(oldDoc);\n          DiffSequence.applyChanges(doc, fields);\n          observeCallbacks.changed(transform(doc), transform(EJSON.clone(oldDoc)));\n        }\n      },\n      removed: function (id) {\n        if (observeCallbacks.removed) {\n          observeCallbacks.removed(transform(this.docs.get(id)));\n        }\n      }\n    };\n  }\n\n  var changeObserver = new LocalCollection._CachingChangeObserver({\n    callbacks: observeChangesCallbacks\n  });\n  var handle = cursor.observeChanges(changeObserver.applyChange);\n  suppressed = false;\n  return handle;\n};\n\nLocalCollection._observeCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.added && callbacks.addedAt) {\n    throw new Error('Please specify only one of added() and addedAt()');\n  }\n\n  if (callbacks.changed && callbacks.changedAt) {\n    throw new Error('Please specify only one of changed() and changedAt()');\n  }\n\n  if (callbacks.removed && callbacks.removedAt) {\n    throw new Error('Please specify only one of removed() and removedAt()');\n  }\n\n  return !!(callbacks.addedAt || callbacks.changedAt || callbacks.movedTo || callbacks.removedAt);\n};\n\nLocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.added && callbacks.addedBefore) {\n    throw new Error('Please specify only one of added() and addedBefore()');\n  }\n\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\n\nLocalCollection._removeFromResults = function (query, doc) {\n  if (query.ordered) {\n    var i = LocalCollection._findInOrderedResults(query, doc);\n\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    var id = doc._id; // in case callback mutates doc\n\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n}; // Is this selector just shorthand for lookup by _id?\n\n\nLocalCollection._selectorIsId = function (selector) {\n  return typeof selector === 'number' || typeof selector === 'string' || selector instanceof MongoID.ObjectID;\n}; // Is the selector just lookup by _id (shorthand or not)?\n\n\nLocalCollection._selectorIsIdPerhapsAsObject = function (selector) {\n  return LocalCollection._selectorIsId(selector) || LocalCollection._selectorIsId(selector && selector._id) && Object.keys(selector).length === 1;\n};\n\nLocalCollection._updateInResults = function (query, doc, old_doc) {\n  if (!EJSON.equals(doc._id, old_doc._id)) {\n    throw new Error('Can\\'t change a doc\\'s _id while updating');\n  }\n\n  var projectionFn = query.projectionFn;\n  var changedFields = DiffSequence.makeChangedFields(projectionFn(doc), projectionFn(old_doc));\n\n  if (!query.ordered) {\n    if (Object.keys(changedFields).length) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n\n    return;\n  }\n\n  var old_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (Object.keys(changedFields).length) {\n    query.changed(doc._id, changedFields);\n  }\n\n  if (!query.sorter) {\n    return;\n  } // just take it out and put it back in again, and see if the index changes\n\n\n  query.results.splice(old_idx, 1);\n\n  var new_idx = LocalCollection._insertInSortedList(query.sorter.getComparator({\n    distances: query.distances\n  }), query.results, doc);\n\n  if (old_idx !== new_idx) {\n    var next = query.results[new_idx + 1];\n\n    if (next) {\n      next = next._id;\n    } else {\n      next = null;\n    }\n\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n};\n\nvar MODIFIERS = {\n  $currentDate: function (target, field, arg) {\n    if ((0, _typeof2.default)(arg) === 'object' && hasOwn.call(arg, '$type')) {\n      if (arg.$type !== 'date') {\n        throw MinimongoError('Minimongo does currently only support the date type in ' + '$currentDate modifiers', {\n          field: field\n        });\n      }\n    } else if (arg !== true) {\n      throw MinimongoError('Invalid $currentDate modifier', {\n        field: field\n      });\n    }\n\n    target[field] = new Date();\n  },\n  $min: function (target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $min allowed for numbers only', {\n        field: field\n      });\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $min modifier to non-number', {\n          field: field\n        });\n      }\n\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max: function (target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $max allowed for numbers only', {\n        field: field\n      });\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $max modifier to non-number', {\n          field: field\n        });\n      }\n\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $inc: function (target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $inc allowed for numbers only', {\n        field: field\n      });\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $inc modifier to non-number', {\n          field: field\n        });\n      }\n\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function (target, field, arg) {\n    if (target !== Object(target)) {\n      // not an array or an object\n      var error = MinimongoError('Cannot set property on non-object field', {\n        field: field\n      });\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (target === null) {\n      var _error = MinimongoError('Cannot set property on null', {\n        field: field\n      });\n\n      _error.setPropertyError = true;\n      throw _error;\n    }\n\n    assertHasValidFieldNames(arg);\n    target[field] = arg;\n  },\n  $setOnInsert: function (target, field, arg) {// converted to `$set` in `_modify`\n  },\n  $unset: function (target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) {\n          target[field] = null;\n        }\n      } else {\n        delete target[field];\n      }\n    }\n  },\n  $push: function (target, field, arg) {\n    if (target[field] === undefined) {\n      target[field] = [];\n    }\n\n    if (!(target[field] instanceof Array)) {\n      throw MinimongoError('Cannot apply $push modifier to non-array', {\n        field: field\n      });\n    }\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      assertHasValidFieldNames(arg);\n      target[field].push(arg);\n      return;\n    } // Fancy mode: $each (and maybe $slice and $sort and $position)\n\n\n    var toPush = arg.$each;\n\n    if (!(toPush instanceof Array)) {\n      throw MinimongoError('$each must be an array', {\n        field: field\n      });\n    }\n\n    assertHasValidFieldNames(toPush); // Parse $position\n\n    var position = undefined;\n\n    if ('$position' in arg) {\n      if (typeof arg.$position !== 'number') {\n        throw MinimongoError('$position must be a numeric value', {\n          field: field\n        });\n      } // XXX should check to make sure integer\n\n\n      if (arg.$position < 0) {\n        throw MinimongoError('$position in $push must be zero or positive', {\n          field: field\n        });\n      }\n\n      position = arg.$position;\n    } // Parse $slice.\n\n\n    var slice = undefined;\n\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== 'number') {\n        throw MinimongoError('$slice must be a numeric value', {\n          field: field\n        });\n      } // XXX should check to make sure integer\n\n\n      slice = arg.$slice;\n    } // Parse $sort.\n\n\n    var sortFunction = undefined;\n\n    if (arg.$sort) {\n      if (slice === undefined) {\n        throw MinimongoError('$sort requires $slice to be present', {\n          field: field\n        });\n      } // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n\n\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n      toPush.forEach(function (element) {\n        if (LocalCollection._f._type(element) !== 3) {\n          throw MinimongoError('$push like modifiers using $sort require all elements to be ' + 'objects', {\n            field: field\n          });\n        }\n      });\n    } // Actually push.\n\n\n    if (position === undefined) {\n      toPush.forEach(function (element) {\n        target[field].push(element);\n      });\n    } else {\n      var _target$field;\n\n      var spliceArguments = [position, 0];\n      toPush.forEach(function (element) {\n        spliceArguments.push(element);\n      });\n\n      (_target$field = target[field]).splice.apply(_target$field, spliceArguments);\n    } // Actually sort.\n\n\n    if (sortFunction) {\n      target[field].sort(sortFunction);\n    } // Actually slice.\n\n\n    if (slice !== undefined) {\n      if (slice === 0) {\n        target[field] = []; // differs from Array.slice!\n      } else if (slice < 0) {\n        target[field] = target[field].slice(slice);\n      } else {\n        target[field] = target[field].slice(0, slice);\n      }\n    }\n  },\n  $pushAll: function (target, field, arg) {\n    if (!((0, _typeof2.default)(arg) === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n\n    assertHasValidFieldNames(arg);\n    var toPush = target[field];\n\n    if (toPush === undefined) {\n      target[field] = arg;\n    } else if (!(toPush instanceof Array)) {\n      throw MinimongoError('Cannot apply $pushAll modifier to non-array', {\n        field: field\n      });\n    } else {\n      toPush.push.apply(toPush, (0, _toConsumableArray2.default)(arg));\n    }\n  },\n  $addToSet: function (target, field, arg) {\n    var isEach = false;\n\n    if ((0, _typeof2.default)(arg) === 'object') {\n      // check if first key is '$each'\n      var keys = Object.keys(arg);\n\n      if (keys[0] === '$each') {\n        isEach = true;\n      }\n    }\n\n    var values = isEach ? arg.$each : [arg];\n    assertHasValidFieldNames(values);\n    var toAdd = target[field];\n\n    if (toAdd === undefined) {\n      target[field] = values;\n    } else if (!(toAdd instanceof Array)) {\n      throw MinimongoError('Cannot apply $addToSet modifier to non-array', {\n        field: field\n      });\n    } else {\n      values.forEach(function (value) {\n        if (toAdd.some(function (element) {\n          return LocalCollection._f._equal(value, element);\n        })) {\n          return;\n        }\n\n        toAdd.push(value);\n      });\n    }\n  },\n  $pop: function (target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    var toPop = target[field];\n\n    if (toPop === undefined) {\n      return;\n    }\n\n    if (!(toPop instanceof Array)) {\n      throw MinimongoError('Cannot apply $pop modifier to non-array', {\n        field: field\n      });\n    }\n\n    if (typeof arg === 'number' && arg < 0) {\n      toPop.splice(0, 1);\n    } else {\n      toPop.pop();\n    }\n  },\n  $pull: function (target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    var toPull = target[field];\n\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n        field: field\n      });\n    }\n\n    var out;\n\n    if (arg != null && (0, _typeof2.default)(arg) === 'object' && !(arg instanceof Array)) {\n      // XXX would be much nicer to compile this once, rather than\n      // for each document we modify.. but usually we're not\n      // modifying that many documents, so we'll let it slide for\n      // now\n      // XXX Minimongo.Matcher isn't up for the job, because we need\n      // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      // like {$gt: 4} is not normally a complete selector.\n      // same issue as $elemMatch possibly?\n      var matcher = new Minimongo.Matcher(arg);\n      out = toPull.filter(function (element) {\n        return !matcher.documentMatches(element).result;\n      });\n    } else {\n      out = toPull.filter(function (element) {\n        return !LocalCollection._f._equal(element, arg);\n      });\n    }\n\n    target[field] = out;\n  },\n  $pullAll: function (target, field, arg) {\n    if (!((0, _typeof2.default)(arg) === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only', {\n        field: field\n      });\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    var toPull = target[field];\n\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n        field: field\n      });\n    }\n\n    target[field] = toPull.filter(function (object) {\n      return !arg.some(function (element) {\n        return LocalCollection._f._equal(object, element);\n      });\n    });\n  },\n  $rename: function (target, field, arg, keypath, doc) {\n    // no idea why mongo has this restriction..\n    if (keypath === arg) {\n      throw MinimongoError('$rename source must differ from target', {\n        field: field\n      });\n    }\n\n    if (target === null) {\n      throw MinimongoError('$rename source field invalid', {\n        field: field\n      });\n    }\n\n    if (typeof arg !== 'string') {\n      throw MinimongoError('$rename target must be a string', {\n        field: field\n      });\n    }\n\n    if (arg.includes('\\0')) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError('The \\'to\\' field for $rename cannot contain an embedded null byte', {\n        field: field\n      });\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    var object = target[field];\n    delete target[field];\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, {\n      forbidArray: true\n    });\n\n    if (target2 === null) {\n      throw MinimongoError('$rename target field invalid', {\n        field: field\n      });\n    }\n\n    target2[keyparts.pop()] = object;\n  },\n  $bit: function (target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError('$bit is not supported', {\n      field: field\n    });\n  },\n  $v: function () {// As discussed in https://github.com/meteor/meteor/issues/9623,\n    // the `$v` operator is not needed by Meteor, but problems can occur if\n    // it's not at least callable (as of Mongo >= 3.6). It's defined here as\n    // a no-op to work around these problems.\n  }\n};\nvar NO_CREATE_MODIFIERS = {\n  $pop: true,\n  $pull: true,\n  $pullAll: true,\n  $rename: true,\n  $unset: true\n}; // Make sure field names do not contain Mongo restricted\n// characters ('.', '$', '\\0').\n// https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n\nvar invalidCharMsg = {\n  $: 'start with \\'$\\'',\n  '.': 'contain \\'.\\'',\n  '\\0': 'contain null bytes'\n}; // checks if all field names in an object are valid\n\nfunction assertHasValidFieldNames(doc) {\n  if (doc && (0, _typeof2.default)(doc) === 'object') {\n    JSON.stringify(doc, function (key, value) {\n      assertIsValidFieldName(key);\n      return value;\n    });\n  }\n}\n\nfunction assertIsValidFieldName(key) {\n  var match;\n\n  if (typeof key === 'string' && (match = key.match(/^\\$|\\.|\\0/))) {\n    throw MinimongoError(\"Key \" + key + \" must not \" + invalidCharMsg[match[0]]);\n  }\n} // for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\n\n\nfunction findModTarget(doc, keyparts) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var usedArrayIndex = false;\n\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = i === keyparts.length - 1;\n    var keypart = keyparts[i];\n\n    if (!isIndexable(doc)) {\n      if (options.noCreate) {\n        return undefined;\n      }\n\n      var error = MinimongoError(\"cannot use the part '\" + keypart + \"' to traverse \" + doc);\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (doc instanceof Array) {\n      if (options.forbidArray) {\n        return null;\n      }\n\n      if (keypart === '$') {\n        if (usedArrayIndex) {\n          throw MinimongoError('Too many positional (i.e. \\'$\\') elements');\n        }\n\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError('The positional operator did not find the match needed from the ' + 'query');\n        }\n\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        throw MinimongoError(\"can't append to array using string field name [\" + keypart + \"]\");\n      }\n\n      if (last) {\n        keyparts[i] = keypart; // handle 'a.01'\n      }\n\n      if (options.noCreate && keypart >= doc.length) {\n        return undefined;\n      }\n\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n\n      if (!last) {\n        if (doc.length === keypart) {\n          doc.push({});\n        } else if ((0, _typeof2.default)(doc[keypart]) !== 'object') {\n          throw MinimongoError(\"can't modify field '\" + keyparts[i + 1] + \"' of list value \" + JSON.stringify(doc[keypart]));\n        }\n      }\n    } else {\n      assertIsValidFieldName(keypart);\n\n      if (!(keypart in doc)) {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        if (!last) {\n          doc[keypart] = {};\n        }\n      }\n    }\n\n    if (last) {\n      return doc;\n    }\n\n    doc = doc[keypart];\n  } // notreached\n\n}","map":{"version":3,"sources":["packages/minimongo/local_collection.js"],"names":["module","export","LocalCollection","Cursor","link","v","ObserveHandle","hasOwn","isIndexable","isNumericKey","isOperatorObject","populateDocumentWithQueryFields","projectionDetails","name","_docs","_IdMap","_observeQueue","Meteor","_SynchronousQueue","next_qid","queries","Object","create","_savedOriginals","paused","find","selector","options","arguments","length","findOne","limit","fetch","insert","doc","callback","EJSON","clone","assertHasValidFieldNames","call","_id","_useOID","MongoID","ObjectID","Random","id","has","MinimongoError","_saveOriginal","undefined","set","queriesToRecompute","keys","forEach","qid","query","dirty","matchResult","matcher","documentMatches","result","distances","distance","cursor","skip","push","_insertInResults","_recomputeResults","drain","defer","pauseObservers","resultsSnapshot","results","remove","equals","size","clear","ordered","Minimongo","Matcher","_eachPossiblyMatchingDoc","queryRemove","i","removeId","removeDoc","get","_removeFromResults","resumeObservers","_diffQueryChanges","projectionFn","retrieveOriginals","Error","originals","saveOriginals","update","mod","Function","qidToOriginalResults","docMap","idsMatched","_idsMatchedBySelector","Array","memoizedCloneIfNeeded","docToMemoize","some","map","recomputeQids","updateCount","queryResult","_modifyAndNotify","arrayIndices","multi","insertedId","upsert","_createUpsertDocument","_returnObject","numberAffected","assign","fn","specificIds","matched_before","old_doc","_modify","afterMatch","after","before","_updateInResults","oldResults","_getRawObjects","_CachingChangeObserver","orderedFromCallbacks","callbacks","_observeChangesCallbacksAreOrdered","docs","OrderedDict","idStringify","applyChange","addedBefore","fields","added","putBefore","movedBefore","moveBefore","changed","DiffSequence","applyChanges","removed","idParse","IdMap","wrapTransform","transform","__wrappedTransform__","wrapped","transformed","Tracker","nonreactive","_isPlainObject","_binarySearch","cmp","array","value","first","range","halfRange","Math","floor","_checkSupportedProjection","isArray","keyPath","split","includes","key","_compileProjection","_idProjection","details","ruleTree","subdoc","including","rule","tree","modifier","selectorDocument","isModify","_isModificationMod","newDoc","$set","isInsert","replacement","_diffObjects","left","right","diffObjects","newResults","observer","diffQueryChanges","_diffQueryOrderedChanges","diffQueryOrderedChanges","_diffQueryUnorderedChanges","diffQueryUnorderedChanges","_findInOrderedResults","_selectorIsId","$in","every","$and","subIds","sorter","_insertInSortedList","getComparator","next","splice","isReplace","substr","x","_f","_type","isModifier","operator","setOnInsert","modFunc","MODIFIERS","operand","keypath","arg","keyparts","Boolean","target","findModTarget","forbidArray","noCreate","NO_CREATE_MODIFIERS","pop","_observeFromObserveChanges","observeCallbacks","getTransform","suppressed","_suppress_initial","observeChangesCallbacks","_observeCallbacksAreOrdered","indices","_no_indices","addedAt","indexOf","changedAt","oldDoc","movedTo","from","to","removedAt","changeObserver","handle","observeChanges","_selectorIsIdPerhapsAsObject","changedFields","makeChangedFields","old_idx","new_idx","$currentDate","field","$type","Date","$min","$max","$inc","error","setPropertyError","$setOnInsert","$unset","$push","$each","toPush","position","$position","slice","$slice","sortFunction","$sort","Sorter","element","spliceArguments","sort","$pushAll","$addToSet","isEach","values","toAdd","_equal","$pop","toPop","$pull","toPull","out","filter","$pullAll","object","$rename","target2","$bit","$v","invalidCharMsg","$","JSON","stringify","assertIsValidFieldName","match","usedArrayIndex","last","keypart","parseInt"],"mappings":";;;;;;;;AAAAA,MAAM,CAACC,MAAP,CAAc;AAAC,aAAQ;AAAA,WAAIC,eAAJ;AAAA;AAAT,CAAd;AAA6C,IAAIC,MAAJ;AAAWH,MAAM,CAACI,IAAP,CAAY,aAAZ,EAA0B;AAAA,uBAASC,CAAT,EAAW;AAACF,IAAAA,MAAM,GAACE,CAAP;AAAS;AAArB,CAA1B,EAAiD,CAAjD;AAAoD,IAAIC,aAAJ;AAAkBN,MAAM,CAACI,IAAP,CAAY,qBAAZ,EAAkC;AAAA,uBAASC,CAAT,EAAW;AAACC,IAAAA,aAAa,GAACD,CAAd;AAAgB;AAA5B,CAAlC,EAAgE,CAAhE;AAAmE,IAAIE,MAAJ,EAAWC,WAAX,EAAuBC,YAAvB,EAAoCC,gBAApC,EAAqDC,+BAArD,EAAqFC,iBAArF;AAAuGZ,MAAM,CAACI,IAAP,CAAY,aAAZ,EAA0B;AAACG,EAAAA,MAAD,YAAQF,CAAR,EAAU;AAACE,IAAAA,MAAM,GAACF,CAAP;AAAS,GAApB;AAAqBG,EAAAA,WAArB,YAAiCH,CAAjC,EAAmC;AAACG,IAAAA,WAAW,GAACH,CAAZ;AAAc,GAAlD;AAAmDI,EAAAA,YAAnD,YAAgEJ,CAAhE,EAAkE;AAACI,IAAAA,YAAY,GAACJ,CAAb;AAAe,GAAlF;AAAmFK,EAAAA,gBAAnF,YAAoGL,CAApG,EAAsG;AAACK,IAAAA,gBAAgB,GAACL,CAAjB;AAAmB,GAA1H;AAA2HM,EAAAA,+BAA3H,YAA2JN,CAA3J,EAA6J;AAACM,IAAAA,+BAA+B,GAACN,CAAhC;AAAkC,GAAhM;AAAiMO,EAAAA,iBAAjM,YAAmNP,CAAnN,EAAqN;AAACO,IAAAA,iBAAiB,GAACP,CAAlB;AAAoB;AAA1O,CAA1B,EAAsQ,CAAtQ;;IAcnRH,e;;;AACnB,2BAAYW,IAAZ,EAAkB;AAChB,SAAKA,IAAL,GAAYA,IAAZ,CADgB,CAEhB;;AACA,SAAKC,KAAL,GAAa,IAAIZ,eAAe,CAACa,MAApB,EAAb;AAEA,SAAKC,aAAL,GAAqB,IAAIC,MAAM,CAACC,iBAAX,EAArB;AAEA,SAAKC,QAAL,GAAgB,CAAhB,CAPgB,CAOG;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAKC,OAAL,GAAeC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAf,CAhBgB,CAkBhB;AACA;;AACA,SAAKC,eAAL,GAAuB,IAAvB,CApBgB,CAsBhB;;AACA,SAAKC,MAAL,GAAc,KAAd;AACD,G,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;SACAC,I;kBAAKC,Q,EAAUC,O,EAAS;AACtB;AACA;AACA;AACA,UAAIC,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;AAC1BH,QAAAA,QAAQ,GAAG,EAAX;AACD;;AAED,aAAO,IAAIxB,eAAe,CAACC,MAApB,CAA2B,IAA3B,EAAiCuB,QAAjC,EAA2CC,OAA3C,CAAP;AACD;;;;;SAEDG,O;qBAAQJ,Q,EAAwB;AAAA,UAAdC,OAAc,uEAAJ,EAAI;;AAC9B,UAAIC,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;AAC1BH,QAAAA,QAAQ,GAAG,EAAX;AACD,OAH6B,CAK9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAAA,OAAO,CAACI,KAAR,GAAgB,CAAhB;AAEA,aAAO,KAAKN,IAAL,CAAUC,QAAV,EAAoBC,OAApB,EAA6BK,KAA7B,GAAqC,CAArC,CAAP;AACD;;;OAED;AACA;;;SACAC,M;oBAAOC,G,EAAKC,Q,EAAU;AAAA;;AACpBD,MAAAA,GAAG,GAAGE,KAAK,CAACC,KAAN,CAAYH,GAAZ,CAAN;AAEAI,MAAAA,wBAAwB,CAACJ,GAAD,CAAxB,CAHoB,CAKpB;AACA;;AACA,UAAI,CAAC3B,MAAM,CAACgC,IAAP,CAAYL,GAAZ,EAAiB,KAAjB,CAAL,EAA8B;AAC5BA,QAAAA,GAAG,CAACM,GAAJ,GAAUtC,eAAe,CAACuC,OAAhB,GAA0B,IAAIC,OAAO,CAACC,QAAZ,EAA1B,GAAmDC,MAAM,CAACC,EAAP,EAA7D;AACD;;AAED,UAAMA,EAAE,GAAGX,GAAG,CAACM,GAAf;;AAEA,UAAI,KAAK1B,KAAL,CAAWgC,GAAX,CAAeD,EAAf,CAAJ,EAAwB;AACtB,cAAME,cAAc,qBAAmBF,EAAnB,OAApB;AACD;;AAED,WAAKG,aAAL,CAAmBH,EAAnB,EAAuBI,SAAvB;;AACA,WAAKnC,KAAL,CAAWoC,GAAX,CAAeL,EAAf,EAAmBX,GAAnB;;AAEA,UAAMiB,kBAAkB,GAAG,EAA3B,CApBoB,CAsBpB;;AACA9B,MAAAA,MAAM,CAAC+B,IAAP,CAAY,KAAKhC,OAAjB,EAA0BiC,OAA1B,CAAkC,UAAAC,GAAG,EAAI;AACvC,YAAMC,KAAK,GAAG,KAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;;AAEA,YAAIC,KAAK,CAACC,KAAV,EAAiB;AACf;AACD;;AAED,YAAMC,WAAW,GAAGF,KAAK,CAACG,OAAN,CAAcC,eAAd,CAA8BzB,GAA9B,CAApB;;AAEA,YAAIuB,WAAW,CAACG,MAAhB,EAAwB;AACtB,cAAIL,KAAK,CAACM,SAAN,IAAmBJ,WAAW,CAACK,QAAZ,KAAyBb,SAAhD,EAA2D;AACzDM,YAAAA,KAAK,CAACM,SAAN,CAAgBX,GAAhB,CAAoBL,EAApB,EAAwBY,WAAW,CAACK,QAApC;AACD;;AAED,cAAIP,KAAK,CAACQ,MAAN,CAAaC,IAAb,IAAqBT,KAAK,CAACQ,MAAN,CAAahC,KAAtC,EAA6C;AAC3CoB,YAAAA,kBAAkB,CAACc,IAAnB,CAAwBX,GAAxB;AACD,WAFD,MAEO;AACLpD,YAAAA,eAAe,CAACgE,gBAAhB,CAAiCX,KAAjC,EAAwCrB,GAAxC;AACD;AACF;AACF,OApBD;AAsBAiB,MAAAA,kBAAkB,CAACE,OAAnB,CAA2B,UAAAC,GAAG,EAAI;AAChC,YAAI,KAAI,CAAClC,OAAL,CAAakC,GAAb,CAAJ,EAAuB;AACrB,UAAA,KAAI,CAACa,iBAAL,CAAuB,KAAI,CAAC/C,OAAL,CAAakC,GAAb,CAAvB;AACD;AACF,OAJD;;AAMA,WAAKtC,aAAL,CAAmBoD,KAAnB,GAnDoB,CAqDpB;AACA;;;AACA,UAAIjC,QAAJ,EAAc;AACZlB,QAAAA,MAAM,CAACoD,KAAP,CAAa,YAAM;AACjBlC,UAAAA,QAAQ,CAAC,IAAD,EAAOU,EAAP,CAAR;AACD,SAFD;AAGD;;AAED,aAAOA,EAAP;AACD;;;OAED;AACA;;;SACAyB,c;8BAAiB;AAAA;;AACf;AACA,UAAI,KAAK9C,MAAT,EAAiB;AACf;AACD,OAJc,CAMf;;;AACA,WAAKA,MAAL,GAAc,IAAd,CAPe,CASf;;AACAH,MAAAA,MAAM,CAAC+B,IAAP,CAAY,KAAKhC,OAAjB,EAA0BiC,OAA1B,CAAkC,UAAAC,GAAG,EAAI;AACvC,YAAMC,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;AACAC,QAAAA,KAAK,CAACgB,eAAN,GAAwBnC,KAAK,CAACC,KAAN,CAAYkB,KAAK,CAACiB,OAAlB,CAAxB;AACD,OAHD;AAID;;;;;SAEDC,M;oBAAO/C,Q,EAAUS,Q,EAAU;AAAA;;AACzB;AACA;AACA;AACA,UAAI,KAAKX,MAAL,IAAe,CAAC,KAAKD,eAArB,IAAwCa,KAAK,CAACsC,MAAN,CAAahD,QAAb,EAAuB,EAAvB,CAA5C,EAAwE;AACtE,YAAMkC,OAAM,GAAG,KAAK9C,KAAL,CAAW6D,IAAX,EAAf;;AAEA,aAAK7D,KAAL,CAAW8D,KAAX;;AAEAvD,QAAAA,MAAM,CAAC+B,IAAP,CAAY,KAAKhC,OAAjB,EAA0BiC,OAA1B,CAAkC,UAAAC,GAAG,EAAI;AACvC,cAAMC,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;;AAEA,cAAIC,KAAK,CAACsB,OAAV,EAAmB;AACjBtB,YAAAA,KAAK,CAACiB,OAAN,GAAgB,EAAhB;AACD,WAFD,MAEO;AACLjB,YAAAA,KAAK,CAACiB,OAAN,CAAcI,KAAd;AACD;AACF,SARD;;AAUA,YAAIzC,QAAJ,EAAc;AACZlB,UAAAA,MAAM,CAACoD,KAAP,CAAa,YAAM;AACjBlC,YAAAA,QAAQ,CAAC,IAAD,EAAOyB,OAAP,CAAR;AACD,WAFD;AAGD;;AAED,eAAOA,OAAP;AACD;;AAED,UAAMF,OAAO,GAAG,IAAIoB,SAAS,CAACC,OAAd,CAAsBrD,QAAtB,CAAhB;AACA,UAAM+C,MAAM,GAAG,EAAf;;AAEA,WAAKO,wBAAL,CAA8BtD,QAA9B,EAAwC,UAACQ,GAAD,EAAMW,EAAN,EAAa;AACnD,YAAIa,OAAO,CAACC,eAAR,CAAwBzB,GAAxB,EAA6B0B,MAAjC,EAAyC;AACvCa,UAAAA,MAAM,CAACR,IAAP,CAAYpB,EAAZ;AACD;AACF,OAJD;;AAMA,UAAMM,kBAAkB,GAAG,EAA3B;AACA,UAAM8B,WAAW,GAAG,EAApB;;AAtCyB,4BAwChBC,CAxCgB;AAyCvB,YAAMC,QAAQ,GAAGV,MAAM,CAACS,CAAD,CAAvB;;AACA,YAAME,SAAS,GAAG,MAAI,CAACtE,KAAL,CAAWuE,GAAX,CAAeF,QAAf,CAAlB;;AAEA9D,QAAAA,MAAM,CAAC+B,IAAP,CAAY,MAAI,CAAChC,OAAjB,EAA0BiC,OAA1B,CAAkC,UAAAC,GAAG,EAAI;AACvC,cAAMC,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;;AAEA,cAAIC,KAAK,CAACC,KAAV,EAAiB;AACf;AACD;;AAED,cAAID,KAAK,CAACG,OAAN,CAAcC,eAAd,CAA8ByB,SAA9B,EAAyCxB,MAA7C,EAAqD;AACnD,gBAAIL,KAAK,CAACQ,MAAN,CAAaC,IAAb,IAAqBT,KAAK,CAACQ,MAAN,CAAahC,KAAtC,EAA6C;AAC3CoB,cAAAA,kBAAkB,CAACc,IAAnB,CAAwBX,GAAxB;AACD,aAFD,MAEO;AACL2B,cAAAA,WAAW,CAAChB,IAAZ,CAAiB;AAACX,gBAAAA,GAAG,EAAHA,GAAD;AAAMpB,gBAAAA,GAAG,EAAEkD;AAAX,eAAjB;AACD;AACF;AACF,SAdD;;AAgBA,QAAA,MAAI,CAACpC,aAAL,CAAmBmC,QAAnB,EAA6BC,SAA7B;;AACA,QAAA,MAAI,CAACtE,KAAL,CAAW2D,MAAX,CAAkBU,QAAlB;AA7DuB;;AAwCzB,WAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,MAAM,CAAC5C,MAA3B,EAAmCqD,CAAC,EAApC,EAAwC;AAAA,cAA/BA,CAA+B;AAsBvC,OA9DwB,CAgEzB;;;AACAD,MAAAA,WAAW,CAAC5B,OAAZ,CAAoB,UAAAoB,MAAM,EAAI;AAC5B,YAAMlB,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAaqD,MAAM,CAACnB,GAApB,CAAd;;AAEA,YAAIC,KAAJ,EAAW;AACTA,UAAAA,KAAK,CAACM,SAAN,IAAmBN,KAAK,CAACM,SAAN,CAAgBY,MAAhB,CAAuBA,MAAM,CAACvC,GAAP,CAAWM,GAAlC,CAAnB;;AACAtC,UAAAA,eAAe,CAACoF,kBAAhB,CAAmC/B,KAAnC,EAA0CkB,MAAM,CAACvC,GAAjD;AACD;AACF,OAPD;AASAiB,MAAAA,kBAAkB,CAACE,OAAnB,CAA2B,UAAAC,GAAG,EAAI;AAChC,YAAMC,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;;AAEA,YAAIC,KAAJ,EAAW;AACT,UAAA,MAAI,CAACY,iBAAL,CAAuBZ,KAAvB;AACD;AACF,OAND;;AAQA,WAAKvC,aAAL,CAAmBoD,KAAnB;;AAEA,UAAMR,MAAM,GAAGa,MAAM,CAAC5C,MAAtB;;AAEA,UAAIM,QAAJ,EAAc;AACZlB,QAAAA,MAAM,CAACoD,KAAP,CAAa,YAAM;AACjBlC,UAAAA,QAAQ,CAAC,IAAD,EAAOyB,MAAP,CAAR;AACD,SAFD;AAGD;;AAED,aAAOA,MAAP;AACD;;;OAED;AACA;AACA;AACA;;;SACA2B,e;+BAAkB;AAAA;;AAChB;AACA,UAAI,CAAC,KAAK/D,MAAV,EAAkB;AAChB;AACD,OAJe,CAMhB;AACA;;;AACA,WAAKA,MAAL,GAAc,KAAd;AAEAH,MAAAA,MAAM,CAAC+B,IAAP,CAAY,KAAKhC,OAAjB,EAA0BiC,OAA1B,CAAkC,UAAAC,GAAG,EAAI;AACvC,YAAMC,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;;AAEA,YAAIC,KAAK,CAACC,KAAV,EAAiB;AACfD,UAAAA,KAAK,CAACC,KAAN,GAAc,KAAd,CADe,CAGf;AACA;;AACA,UAAA,MAAI,CAACW,iBAAL,CAAuBZ,KAAvB,EAA8BA,KAAK,CAACgB,eAApC;AACD,SAND,MAMO;AACL;AACA;AACArE,UAAAA,eAAe,CAACsF,iBAAhB,CACEjC,KAAK,CAACsB,OADR,EAEEtB,KAAK,CAACgB,eAFR,EAGEhB,KAAK,CAACiB,OAHR,EAIEjB,KAJF,EAKE;AAACkC,YAAAA,YAAY,EAAElC,KAAK,CAACkC;AAArB,WALF;AAOD;;AAEDlC,QAAAA,KAAK,CAACgB,eAAN,GAAwB,IAAxB;AACD,OAtBD;;AAwBA,WAAKvD,aAAL,CAAmBoD,KAAnB;AACD;;;;;SAEDsB,iB;iCAAoB;AAClB,UAAI,CAAC,KAAKnE,eAAV,EAA2B;AACzB,cAAM,IAAIoE,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED,UAAMC,SAAS,GAAG,KAAKrE,eAAvB;AAEA,WAAKA,eAAL,GAAuB,IAAvB;AAEA,aAAOqE,SAAP;AACD;;;OAED;AACA;AACA;AACA;AACA;AACA;AACA;;;SACAC,a;6BAAgB;AACd,UAAI,KAAKtE,eAAT,EAA0B;AACxB,cAAM,IAAIoE,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,WAAKpE,eAAL,GAAuB,IAAIrB,eAAe,CAACa,MAApB,EAAvB;AACD;;;OAED;AACA;;;SACA+E,M;oBAAOpE,Q,EAAUqE,G,EAAKpE,O,EAASQ,Q,EAAU;AAAA;;AACvC,UAAI,CAAEA,QAAF,IAAcR,OAAO,YAAYqE,QAArC,EAA+C;AAC7C7D,QAAAA,QAAQ,GAAGR,OAAX;AACAA,QAAAA,OAAO,GAAG,IAAV;AACD;;AAED,UAAI,CAACA,OAAL,EAAc;AACZA,QAAAA,OAAO,GAAG,EAAV;AACD;;AAED,UAAM+B,OAAO,GAAG,IAAIoB,SAAS,CAACC,OAAd,CAAsBrD,QAAtB,EAAgC,IAAhC,CAAhB,CAVuC,CAYvC;AACA;AACA;AACA;AACA;;AACA,UAAMuE,oBAAoB,GAAG,EAA7B,CAjBuC,CAmBvC;AACA;;AACA,UAAMC,MAAM,GAAG,IAAIhG,eAAe,CAACa,MAApB,EAAf;;AACA,UAAMoF,UAAU,GAAGjG,eAAe,CAACkG,qBAAhB,CAAsC1E,QAAtC,CAAnB;;AAEAL,MAAAA,MAAM,CAAC+B,IAAP,CAAY,KAAKhC,OAAjB,EAA0BiC,OAA1B,CAAkC,UAAAC,GAAG,EAAI;AACvC,YAAMC,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;;AAEA,YAAI,CAACC,KAAK,CAACQ,MAAN,CAAaC,IAAb,IAAqBT,KAAK,CAACQ,MAAN,CAAahC,KAAnC,KAA6C,CAAE,MAAI,CAACP,MAAxD,EAAgE;AAC9D;AACA;AACA;AACA;AACA;AACA,cAAI+B,KAAK,CAACiB,OAAN,YAAyBtE,eAAe,CAACa,MAA7C,EAAqD;AACnDkF,YAAAA,oBAAoB,CAAC3C,GAAD,CAApB,GAA4BC,KAAK,CAACiB,OAAN,CAAcnC,KAAd,EAA5B;AACA;AACD;;AAED,cAAI,EAAEkB,KAAK,CAACiB,OAAN,YAAyB6B,KAA3B,CAAJ,EAAuC;AACrC,kBAAM,IAAIV,KAAJ,CAAU,8CAAV,CAAN;AACD,WAb6D,CAe9D;AACA;AACA;AACA;;;AACA,cAAMW,qBAAqB,GAAG,UAAApE,GAAG,EAAI;AACnC,gBAAIgE,MAAM,CAACpD,GAAP,CAAWZ,GAAG,CAACM,GAAf,CAAJ,EAAyB;AACvB,qBAAO0D,MAAM,CAACb,GAAP,CAAWnD,GAAG,CAACM,GAAf,CAAP;AACD;;AAED,gBAAM+D,YAAY,GAChBJ,UAAU,IACV,CAACA,UAAU,CAACK,IAAX,CAAgB,UAAA3D,EAAE;AAAA,qBAAIT,KAAK,CAACsC,MAAN,CAAa7B,EAAb,EAAiBX,GAAG,CAACM,GAArB,CAAJ;AAAA,aAAlB,CAFkB,GAGjBN,GAHiB,GAGXE,KAAK,CAACC,KAAN,CAAYH,GAAZ,CAHV;AAKAgE,YAAAA,MAAM,CAAChD,GAAP,CAAWhB,GAAG,CAACM,GAAf,EAAoB+D,YAApB;AAEA,mBAAOA,YAAP;AACD,WAbD;;AAeAN,UAAAA,oBAAoB,CAAC3C,GAAD,CAApB,GAA4BC,KAAK,CAACiB,OAAN,CAAciC,GAAd,CAAkBH,qBAAlB,CAA5B;AACD;AACF,OAvCD;AAyCA,UAAMI,aAAa,GAAG,EAAtB;AAEA,UAAIC,WAAW,GAAG,CAAlB;;AAEA,WAAK3B,wBAAL,CAA8BtD,QAA9B,EAAwC,UAACQ,GAAD,EAAMW,EAAN,EAAa;AACnD,YAAM+D,WAAW,GAAGlD,OAAO,CAACC,eAAR,CAAwBzB,GAAxB,CAApB;;AAEA,YAAI0E,WAAW,CAAChD,MAAhB,EAAwB;AACtB;AACA,UAAA,MAAI,CAACZ,aAAL,CAAmBH,EAAnB,EAAuBX,GAAvB;;AACA,UAAA,MAAI,CAAC2E,gBAAL,CACE3E,GADF,EAEE6D,GAFF,EAGEW,aAHF,EAIEE,WAAW,CAACE,YAJd;;AAOA,YAAEH,WAAF;;AAEA,cAAI,CAAChF,OAAO,CAACoF,KAAb,EAAoB;AAClB,mBAAO,KAAP,CADkB,CACJ;AACf;AACF;;AAED,eAAO,IAAP;AACD,OArBD;;AAuBA1F,MAAAA,MAAM,CAAC+B,IAAP,CAAYsD,aAAZ,EAA2BrD,OAA3B,CAAmC,UAAAC,GAAG,EAAI;AACxC,YAAMC,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;;AAEA,YAAIC,KAAJ,EAAW;AACT,UAAA,MAAI,CAACY,iBAAL,CAAuBZ,KAAvB,EAA8B0C,oBAAoB,CAAC3C,GAAD,CAAlD;AACD;AACF,OAND;;AAQA,WAAKtC,aAAL,CAAmBoD,KAAnB,GApGuC,CAsGvC;AACA;AACA;;;AACA,UAAI4C,UAAJ;;AACA,UAAIL,WAAW,KAAK,CAAhB,IAAqBhF,OAAO,CAACsF,MAAjC,EAAyC;AACvC,YAAM/E,GAAG,GAAGhC,eAAe,CAACgH,qBAAhB,CAAsCxF,QAAtC,EAAgDqE,GAAhD,CAAZ;;AACA,YAAI,CAAE7D,GAAG,CAACM,GAAN,IAAab,OAAO,CAACqF,UAAzB,EAAqC;AACnC9E,UAAAA,GAAG,CAACM,GAAJ,GAAUb,OAAO,CAACqF,UAAlB;AACD;;AAEDA,QAAAA,UAAU,GAAG,KAAK/E,MAAL,CAAYC,GAAZ,CAAb;AACAyE,QAAAA,WAAW,GAAG,CAAd;AACD,OAlHsC,CAoHvC;AACA;AACA;;;AACA,UAAI/C,MAAJ;;AACA,UAAIjC,OAAO,CAACwF,aAAZ,EAA2B;AACzBvD,QAAAA,MAAM,GAAG;AAACwD,UAAAA,cAAc,EAAET;AAAjB,SAAT;;AAEA,YAAIK,UAAU,KAAK/D,SAAnB,EAA8B;AAC5BW,UAAAA,MAAM,CAACoD,UAAP,GAAoBA,UAApB;AACD;AACF,OAND,MAMO;AACLpD,QAAAA,MAAM,GAAG+C,WAAT;AACD;;AAED,UAAIxE,QAAJ,EAAc;AACZlB,QAAAA,MAAM,CAACoD,KAAP,CAAa,YAAM;AACjBlC,UAAAA,QAAQ,CAAC,IAAD,EAAOyB,MAAP,CAAR;AACD,SAFD;AAGD;;AAED,aAAOA,MAAP;AACD;;;OAED;AACA;AACA;;;SACAqD,M;oBAAOvF,Q,EAAUqE,G,EAAKpE,O,EAASQ,Q,EAAU;AACvC,UAAI,CAACA,QAAD,IAAa,OAAOR,OAAP,KAAmB,UAApC,EAAgD;AAC9CQ,QAAAA,QAAQ,GAAGR,OAAX;AACAA,QAAAA,OAAO,GAAG,EAAV;AACD;;AAED,aAAO,KAAKmE,MAAL,CACLpE,QADK,EAELqE,GAFK,EAGL1E,MAAM,CAACgG,MAAP,CAAc,EAAd,EAAkB1F,OAAlB,EAA2B;AAACsF,QAAAA,MAAM,EAAE,IAAT;AAAeE,QAAAA,aAAa,EAAE;AAA9B,OAA3B,CAHK,EAILhF,QAJK,CAAP;AAMD;;;OAED;AACA;AACA;AACA;;;SACA6C,wB;sCAAyBtD,Q,EAAU4F,E,EAAI;AAAA;;AACrC,UAAMC,WAAW,GAAGrH,eAAe,CAACkG,qBAAhB,CAAsC1E,QAAtC,CAApB;;AAEA,UAAI6F,WAAJ,EAAiB;AACfA,QAAAA,WAAW,CAACf,IAAZ,CAAiB,UAAA3D,EAAE,EAAI;AACrB,cAAMX,GAAG,GAAG,MAAI,CAACpB,KAAL,CAAWuE,GAAX,CAAexC,EAAf,CAAZ;;AAEA,cAAIX,GAAJ,EAAS;AACP,mBAAOoF,EAAE,CAACpF,GAAD,EAAMW,EAAN,CAAF,KAAgB,KAAvB;AACD;AACF,SAND;AAOD,OARD,MAQO;AACL,aAAK/B,KAAL,CAAWuC,OAAX,CAAmBiE,EAAnB;AACD;AACF;;;;;SAEDT,gB;8BAAiB3E,G,EAAK6D,G,EAAKW,a,EAAeI,Y,EAAc;AAAA;;AACtD,UAAMU,cAAc,GAAG,EAAvB;AAEAnG,MAAAA,MAAM,CAAC+B,IAAP,CAAY,KAAKhC,OAAjB,EAA0BiC,OAA1B,CAAkC,UAAAC,GAAG,EAAI;AACvC,YAAMC,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;;AAEA,YAAIC,KAAK,CAACC,KAAV,EAAiB;AACf;AACD;;AAED,YAAID,KAAK,CAACsB,OAAV,EAAmB;AACjB2C,UAAAA,cAAc,CAAClE,GAAD,CAAd,GAAsBC,KAAK,CAACG,OAAN,CAAcC,eAAd,CAA8BzB,GAA9B,EAAmC0B,MAAzD;AACD,SAFD,MAEO;AACL;AACA;AACA4D,UAAAA,cAAc,CAAClE,GAAD,CAAd,GAAsBC,KAAK,CAACiB,OAAN,CAAc1B,GAAd,CAAkBZ,GAAG,CAACM,GAAtB,CAAtB;AACD;AACF,OAdD;AAgBA,UAAMiF,OAAO,GAAGrF,KAAK,CAACC,KAAN,CAAYH,GAAZ,CAAhB;;AAEAhC,MAAAA,eAAe,CAACwH,OAAhB,CAAwBxF,GAAxB,EAA6B6D,GAA7B,EAAkC;AAACe,QAAAA,YAAY,EAAZA;AAAD,OAAlC;;AAEAzF,MAAAA,MAAM,CAAC+B,IAAP,CAAY,KAAKhC,OAAjB,EAA0BiC,OAA1B,CAAkC,UAAAC,GAAG,EAAI;AACvC,YAAMC,KAAK,GAAG,MAAI,CAACnC,OAAL,CAAakC,GAAb,CAAd;;AAEA,YAAIC,KAAK,CAACC,KAAV,EAAiB;AACf;AACD;;AAED,YAAMmE,UAAU,GAAGpE,KAAK,CAACG,OAAN,CAAcC,eAAd,CAA8BzB,GAA9B,CAAnB;AACA,YAAM0F,KAAK,GAAGD,UAAU,CAAC/D,MAAzB;AACA,YAAMiE,MAAM,GAAGL,cAAc,CAAClE,GAAD,CAA7B;;AAEA,YAAIsE,KAAK,IAAIrE,KAAK,CAACM,SAAf,IAA4B8D,UAAU,CAAC7D,QAAX,KAAwBb,SAAxD,EAAmE;AACjEM,UAAAA,KAAK,CAACM,SAAN,CAAgBX,GAAhB,CAAoBhB,GAAG,CAACM,GAAxB,EAA6BmF,UAAU,CAAC7D,QAAxC;AACD;;AAED,YAAIP,KAAK,CAACQ,MAAN,CAAaC,IAAb,IAAqBT,KAAK,CAACQ,MAAN,CAAahC,KAAtC,EAA6C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAI8F,MAAM,IAAID,KAAd,EAAqB;AACnBlB,YAAAA,aAAa,CAACpD,GAAD,CAAb,GAAqB,IAArB;AACD;AACF,SAXD,MAWO,IAAIuE,MAAM,IAAI,CAACD,KAAf,EAAsB;AAC3B1H,UAAAA,eAAe,CAACoF,kBAAhB,CAAmC/B,KAAnC,EAA0CrB,GAA1C;AACD,SAFM,MAEA,IAAI,CAAC2F,MAAD,IAAWD,KAAf,EAAsB;AAC3B1H,UAAAA,eAAe,CAACgE,gBAAhB,CAAiCX,KAAjC,EAAwCrB,GAAxC;AACD,SAFM,MAEA,IAAI2F,MAAM,IAAID,KAAd,EAAqB;AAC1B1H,UAAAA,eAAe,CAAC4H,gBAAhB,CAAiCvE,KAAjC,EAAwCrB,GAAxC,EAA6CuF,OAA7C;AACD;AACF,OAjCD;AAkCD;;;OAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACAtD,iB;+BAAkBZ,K,EAAOwE,U,EAAY;AACnC,UAAI,KAAKvG,MAAT,EAAiB;AACf;AACA;AACA;AACA+B,QAAAA,KAAK,CAACC,KAAN,GAAc,IAAd;AACA;AACD;;AAED,UAAI,CAAC,KAAKhC,MAAN,IAAgB,CAACuG,UAArB,EAAiC;AAC/BA,QAAAA,UAAU,GAAGxE,KAAK,CAACiB,OAAnB;AACD;;AAED,UAAIjB,KAAK,CAACM,SAAV,EAAqB;AACnBN,QAAAA,KAAK,CAACM,SAAN,CAAgBe,KAAhB;AACD;;AAEDrB,MAAAA,KAAK,CAACiB,OAAN,GAAgBjB,KAAK,CAACQ,MAAN,CAAaiE,cAAb,CAA4B;AAC1CnE,QAAAA,SAAS,EAAEN,KAAK,CAACM,SADyB;AAE1CgB,QAAAA,OAAO,EAAEtB,KAAK,CAACsB;AAF2B,OAA5B,CAAhB;;AAKA,UAAI,CAAC,KAAKrD,MAAV,EAAkB;AAChBtB,QAAAA,eAAe,CAACsF,iBAAhB,CACEjC,KAAK,CAACsB,OADR,EAEEkD,UAFF,EAGExE,KAAK,CAACiB,OAHR,EAIEjB,KAJF,EAKE;AAACkC,UAAAA,YAAY,EAAElC,KAAK,CAACkC;AAArB,SALF;AAOD;AACF;;;;;SAEDzC,a;2BAAcH,E,EAAIX,G,EAAK;AACrB;AACA,UAAI,CAAC,KAAKX,eAAV,EAA2B;AACzB;AACD,OAJoB,CAMrB;AACA;AACA;;;AACA,UAAI,KAAKA,eAAL,CAAqBuB,GAArB,CAAyBD,EAAzB,CAAJ,EAAkC;AAChC;AACD;;AAED,WAAKtB,eAAL,CAAqB2B,GAArB,CAAyBL,EAAzB,EAA6BT,KAAK,CAACC,KAAN,CAAYH,GAAZ,CAA7B;AACD;;;;;;;;AAGHhC,eAAe,CAACC,MAAhB,GAAyBA,MAAzB;AAEAD,eAAe,CAACI,aAAhB,GAAgCA,aAAhC,C,CAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAJ,eAAe,CAAC+H,sBAAhB;AACE,oCAA0B;AAAA;;AAAA,QAAdtG,OAAc,uEAAJ,EAAI;;AACxB,QAAMuG,oBAAoB,GACxBvG,OAAO,CAACwG,SAAR,IACAjI,eAAe,CAACkI,kCAAhB,CAAmDzG,OAAO,CAACwG,SAA3D,CAFF;;AAKA,QAAI5H,MAAM,CAACgC,IAAP,CAAYZ,OAAZ,EAAqB,SAArB,CAAJ,EAAqC;AACnC,WAAKkD,OAAL,GAAelD,OAAO,CAACkD,OAAvB;;AAEA,UAAIlD,OAAO,CAACwG,SAAR,IAAqBxG,OAAO,CAACkD,OAAR,KAAoBqD,oBAA7C,EAAmE;AACjE,cAAMvC,KAAK,CAAC,yCAAD,CAAX;AACD;AACF,KAND,MAMO,IAAIhE,OAAO,CAACwG,SAAZ,EAAuB;AAC5B,WAAKtD,OAAL,GAAeqD,oBAAf;AACD,KAFM,MAEA;AACL,YAAMvC,KAAK,CAAC,mCAAD,CAAX;AACD;;AAED,QAAMwC,SAAS,GAAGxG,OAAO,CAACwG,SAAR,IAAqB,EAAvC;;AAEA,QAAI,KAAKtD,OAAT,EAAkB;AAChB,WAAKwD,IAAL,GAAY,IAAIC,WAAJ,CAAgB5F,OAAO,CAAC6F,WAAxB,CAAZ;AACA,WAAKC,WAAL,GAAmB;AACjBC,QAAAA,WAAW,EAAE,UAAC5F,EAAD,EAAK6F,MAAL,EAAab,MAAb,EAAwB;AACnC,cAAM3F,GAAG,GAAGE,KAAK,CAACC,KAAN,CAAYqG,MAAZ,CAAZ;AAEAxG,UAAAA,GAAG,CAACM,GAAJ,GAAUK,EAAV;;AAEA,cAAIsF,SAAS,CAACM,WAAd,EAA2B;AACzBN,YAAAA,SAAS,CAACM,WAAV,CAAsBlG,IAAtB,CAA2B,MAA3B,EAAiCM,EAAjC,EAAqC6F,MAArC,EAA6Cb,MAA7C;AACD,WAPkC,CASnC;;;AACA,cAAIM,SAAS,CAACQ,KAAd,EAAqB;AACnBR,YAAAA,SAAS,CAACQ,KAAV,CAAgBpG,IAAhB,CAAqB,MAArB,EAA2BM,EAA3B,EAA+B6F,MAA/B;AACD,WAZkC,CAcnC;AACA;AACA;;;AACA,UAAA,MAAI,CAACL,IAAL,CAAUO,SAAV,CAAoB/F,EAApB,EAAwBX,GAAxB,EAA6B2F,MAAM,IAAI,IAAvC;AACD,SAnBgB;AAoBjBgB,QAAAA,WAAW,EAAE,UAAChG,EAAD,EAAKgF,MAAL,EAAgB;AAC3B,cAAM3F,GAAG,GAAG,MAAI,CAACmG,IAAL,CAAUhD,GAAV,CAAcxC,EAAd,CAAZ;;AAEA,cAAIsF,SAAS,CAACU,WAAd,EAA2B;AACzBV,YAAAA,SAAS,CAACU,WAAV,CAAsBtG,IAAtB,CAA2B,MAA3B,EAAiCM,EAAjC,EAAqCgF,MAArC;AACD;;AAED,UAAA,MAAI,CAACQ,IAAL,CAAUS,UAAV,CAAqBjG,EAArB,EAAyBgF,MAAM,IAAI,IAAnC;AACD;AA5BgB,OAAnB;AA8BD,KAhCD,MAgCO;AACL,WAAKQ,IAAL,GAAY,IAAInI,eAAe,CAACa,MAApB,EAAZ;AACA,WAAKyH,WAAL,GAAmB;AACjBG,QAAAA,KAAK,EAAE,UAAC9F,EAAD,EAAK6F,MAAL,EAAgB;AACrB,cAAMxG,GAAG,GAAGE,KAAK,CAACC,KAAN,CAAYqG,MAAZ,CAAZ;;AAEA,cAAIP,SAAS,CAACQ,KAAd,EAAqB;AACnBR,YAAAA,SAAS,CAACQ,KAAV,CAAgBpG,IAAhB,CAAqB,MAArB,EAA2BM,EAA3B,EAA+B6F,MAA/B;AACD;;AAEDxG,UAAAA,GAAG,CAACM,GAAJ,GAAUK,EAAV;;AAEA,UAAA,MAAI,CAACwF,IAAL,CAAUnF,GAAV,CAAcL,EAAd,EAAmBX,GAAnB;AACD;AAXgB,OAAnB;AAaD,KAnEuB,CAqExB;AACA;;;AACA,SAAKsG,WAAL,CAAiBO,OAAjB,GAA2B,UAAClG,EAAD,EAAK6F,MAAL,EAAgB;AACzC,UAAMxG,GAAG,GAAG,MAAI,CAACmG,IAAL,CAAUhD,GAAV,CAAcxC,EAAd,CAAZ;;AAEA,UAAI,CAACX,GAAL,EAAU;AACR,cAAM,IAAIyD,KAAJ,8BAAqC9C,EAArC,CAAN;AACD;;AAED,UAAIsF,SAAS,CAACY,OAAd,EAAuB;AACrBZ,QAAAA,SAAS,CAACY,OAAV,CAAkBxG,IAAlB,CAAuB,MAAvB,EAA6BM,EAA7B,EAAiCT,KAAK,CAACC,KAAN,CAAYqG,MAAZ,CAAjC;AACD;;AAEDM,MAAAA,YAAY,CAACC,YAAb,CAA0B/G,GAA1B,EAA+BwG,MAA/B;AACD,KAZD;;AAcA,SAAKF,WAAL,CAAiBU,OAAjB,GAA2B,UAAArG,EAAE,EAAI;AAC/B,UAAIsF,SAAS,CAACe,OAAd,EAAuB;AACrBf,QAAAA,SAAS,CAACe,OAAV,CAAkB3G,IAAlB,CAAuB,MAAvB,EAA6BM,EAA7B;AACD;;AAED,MAAA,MAAI,CAACwF,IAAL,CAAU5D,MAAV,CAAiB5B,EAAjB;AACD,KAND;AAOD;;AA7FH;AAAA;;AAgGA3C,eAAe,CAACa,MAAhB;AAAA;AAAA;AAAA;;AACE,oBAAc;AAAA,WACZ,mBAAM2B,OAAO,CAAC6F,WAAd,EAA2B7F,OAAO,CAACyG,OAAnC,CADY;AAEb;;AAHH;AAAA,EAA8CC,KAA9C,E,CAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlJ,eAAe,CAACmJ,aAAhB,GAAgC,UAAAC,SAAS,EAAI;AAC3C,MAAI,CAACA,SAAL,EAAgB;AACd,WAAO,IAAP;AACD,GAH0C,CAK3C;;;AACA,MAAIA,SAAS,CAACC,oBAAd,EAAoC;AAClC,WAAOD,SAAP;AACD;;AAED,MAAME,OAAO,GAAG,UAAAtH,GAAG,EAAI;AACrB,QAAI,CAAC3B,MAAM,CAACgC,IAAP,CAAYL,GAAZ,EAAiB,KAAjB,CAAL,EAA8B;AAC5B;AACA;AACA,YAAM,IAAIyD,KAAJ,CAAU,uCAAV,CAAN;AACD;;AAED,QAAM9C,EAAE,GAAGX,GAAG,CAACM,GAAf,CAPqB,CASrB;AACA;;AACA,QAAMiH,WAAW,GAAGC,OAAO,CAACC,WAAR,CAAoB;AAAA,aAAML,SAAS,CAACpH,GAAD,CAAf;AAAA,KAApB,CAApB;;AAEA,QAAI,CAAChC,eAAe,CAAC0J,cAAhB,CAA+BH,WAA/B,CAAL,EAAkD;AAChD,YAAM,IAAI9D,KAAJ,CAAU,8BAAV,CAAN;AACD;;AAED,QAAIpF,MAAM,CAACgC,IAAP,CAAYkH,WAAZ,EAAyB,KAAzB,CAAJ,EAAqC;AACnC,UAAI,CAACrH,KAAK,CAACsC,MAAN,CAAa+E,WAAW,CAACjH,GAAzB,EAA8BK,EAA9B,CAAL,EAAwC;AACtC,cAAM,IAAI8C,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF,KAJD,MAIO;AACL8D,MAAAA,WAAW,CAACjH,GAAZ,GAAkBK,EAAlB;AACD;;AAED,WAAO4G,WAAP;AACD,GA1BD;;AA4BAD,EAAAA,OAAO,CAACD,oBAAR,GAA+B,IAA/B;AAEA,SAAOC,OAAP;AACD,CAzCD,C,CA2CA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AACAtJ,eAAe,CAAC2J,aAAhB,GAAgC,UAACC,GAAD,EAAMC,KAAN,EAAaC,KAAb,EAAuB;AACrD,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,KAAK,GAAGH,KAAK,CAAClI,MAAlB;;AAEA,SAAOqI,KAAK,GAAG,CAAf,EAAkB;AAChB,QAAMC,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWH,KAAK,GAAG,CAAnB,CAAlB;;AAEA,QAAIJ,GAAG,CAACE,KAAD,EAAQD,KAAK,CAACE,KAAK,GAAGE,SAAT,CAAb,CAAH,IAAwC,CAA5C,EAA+C;AAC7CF,MAAAA,KAAK,IAAIE,SAAS,GAAG,CAArB;AACAD,MAAAA,KAAK,IAAIC,SAAS,GAAG,CAArB;AACD,KAHD,MAGO;AACLD,MAAAA,KAAK,GAAGC,SAAR;AACD;AACF;;AAED,SAAOF,KAAP;AACD,CAhBD;;AAkBA/J,eAAe,CAACoK,yBAAhB,GAA4C,UAAA5B,MAAM,EAAI;AACpD,MAAIA,MAAM,KAAKrH,MAAM,CAACqH,MAAD,CAAjB,IAA6BrC,KAAK,CAACkE,OAAN,CAAc7B,MAAd,CAAjC,EAAwD;AACtD,UAAM3F,cAAc,CAAC,iCAAD,CAApB;AACD;;AAED1B,EAAAA,MAAM,CAAC+B,IAAP,CAAYsF,MAAZ,EAAoBrF,OAApB,CAA4B,UAAAmH,OAAO,EAAI;AACrC,QAAIA,OAAO,CAACC,KAAR,CAAc,GAAd,EAAmBC,QAAnB,CAA4B,GAA5B,CAAJ,EAAsC;AACpC,YAAM3H,cAAc,CAClB,2DADkB,CAApB;AAGD;;AAED,QAAMiH,KAAK,GAAGtB,MAAM,CAAC8B,OAAD,CAApB;;AAEA,QAAI,sBAAOR,KAAP,MAAiB,QAAjB,IACA,CAAC,YAAD,EAAe,OAAf,EAAwB,QAAxB,EAAkCxD,IAAlC,CAAuC,UAAAmE,GAAG;AAAA,aACxCpK,MAAM,CAACgC,IAAP,CAAYyH,KAAZ,EAAmBW,GAAnB,CADwC;AAAA,KAA1C,CADJ,EAGO;AACL,YAAM5H,cAAc,CAClB,0DADkB,CAApB;AAGD;;AAED,QAAI,CAAC,CAAC,CAAD,EAAI,CAAJ,EAAO,IAAP,EAAa,KAAb,EAAoB2H,QAApB,CAA6BV,KAA7B,CAAL,EAA0C;AACxC,YAAMjH,cAAc,CAClB,yDADkB,CAApB;AAGD;AACF,GAvBD;AAwBD,CA7BD,C,CA+BA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA7C,eAAe,CAAC0K,kBAAhB,GAAqC,UAAAlC,MAAM,EAAI;AAC7CxI,EAAAA,eAAe,CAACoK,yBAAhB,CAA0C5B,MAA1C;;AAEA,MAAMmC,aAAa,GAAGnC,MAAM,CAAClG,GAAP,KAAeS,SAAf,GAA2B,IAA3B,GAAkCyF,MAAM,CAAClG,GAA/D;;AACA,MAAMsI,OAAO,GAAGlK,iBAAiB,CAAC8H,MAAD,CAAjC,CAJ6C,CAM7C;;AACA,MAAMY,SAAS,GAAG,UAACpH,GAAD,EAAM6I,QAAN,EAAmB;AACnC;AACA,QAAI1E,KAAK,CAACkE,OAAN,CAAcrI,GAAd,CAAJ,EAAwB;AACtB,aAAOA,GAAG,CAACuE,GAAJ,CAAQ,UAAAuE,MAAM;AAAA,eAAI1B,SAAS,CAAC0B,MAAD,EAASD,QAAT,CAAb;AAAA,OAAd,CAAP;AACD;;AAED,QAAMnH,MAAM,GAAGkH,OAAO,CAACG,SAAR,GAAoB,EAApB,GAAyB7I,KAAK,CAACC,KAAN,CAAYH,GAAZ,CAAxC;AAEAb,IAAAA,MAAM,CAAC+B,IAAP,CAAY2H,QAAZ,EAAsB1H,OAAtB,CAA8B,UAAAsH,GAAG,EAAI;AACnC,UAAI,CAACpK,MAAM,CAACgC,IAAP,CAAYL,GAAZ,EAAiByI,GAAjB,CAAL,EAA4B;AAC1B;AACD;;AAED,UAAMO,IAAI,GAAGH,QAAQ,CAACJ,GAAD,CAArB;;AAEA,UAAIO,IAAI,KAAK7J,MAAM,CAAC6J,IAAD,CAAnB,EAA2B;AACzB;AACA,YAAIhJ,GAAG,CAACyI,GAAD,CAAH,KAAatJ,MAAM,CAACa,GAAG,CAACyI,GAAD,CAAJ,CAAvB,EAAmC;AACjC/G,UAAAA,MAAM,CAAC+G,GAAD,CAAN,GAAcrB,SAAS,CAACpH,GAAG,CAACyI,GAAD,CAAJ,EAAWO,IAAX,CAAvB;AACD;AACF,OALD,MAKO,IAAIJ,OAAO,CAACG,SAAZ,EAAuB;AAC5B;AACArH,QAAAA,MAAM,CAAC+G,GAAD,CAAN,GAAcvI,KAAK,CAACC,KAAN,CAAYH,GAAG,CAACyI,GAAD,CAAf,CAAd;AACD,OAHM,MAGA;AACL,eAAO/G,MAAM,CAAC+G,GAAD,CAAb;AACD;AACF,KAlBD;AAoBA,WAAO/G,MAAP;AACD,GA7BD;;AA+BA,SAAO,UAAA1B,GAAG,EAAI;AACZ,QAAM0B,MAAM,GAAG0F,SAAS,CAACpH,GAAD,EAAM4I,OAAO,CAACK,IAAd,CAAxB;;AAEA,QAAIN,aAAa,IAAItK,MAAM,CAACgC,IAAP,CAAYL,GAAZ,EAAiB,KAAjB,CAArB,EAA8C;AAC5C0B,MAAAA,MAAM,CAACpB,GAAP,GAAaN,GAAG,CAACM,GAAjB;AACD;;AAED,QAAI,CAACqI,aAAD,IAAkBtK,MAAM,CAACgC,IAAP,CAAYqB,MAAZ,EAAoB,KAApB,CAAtB,EAAkD;AAChD,aAAOA,MAAM,CAACpB,GAAd;AACD;;AAED,WAAOoB,MAAP;AACD,GAZD;AAaD,CAnDD,C,CAqDA;AACA;;;AACA1D,eAAe,CAACgH,qBAAhB,GAAwC,UAACxF,QAAD,EAAW0J,QAAX,EAAwB;AAC9D,MAAMC,gBAAgB,GAAG1K,+BAA+B,CAACe,QAAD,CAAxD;;AACA,MAAM4J,QAAQ,GAAGpL,eAAe,CAACqL,kBAAhB,CAAmCH,QAAnC,CAAjB;;AAEA,MAAMI,MAAM,GAAG,EAAf;;AAEA,MAAIH,gBAAgB,CAAC7I,GAArB,EAA0B;AACxBgJ,IAAAA,MAAM,CAAChJ,GAAP,GAAa6I,gBAAgB,CAAC7I,GAA9B;AACA,WAAO6I,gBAAgB,CAAC7I,GAAxB;AACD,GAT6D,CAW9D;AACA;AACA;;;AACAtC,EAAAA,eAAe,CAACwH,OAAhB,CAAwB8D,MAAxB,EAAgC;AAACC,IAAAA,IAAI,EAAEJ;AAAP,GAAhC;;AACAnL,EAAAA,eAAe,CAACwH,OAAhB,CAAwB8D,MAAxB,EAAgCJ,QAAhC,EAA0C;AAACM,IAAAA,QAAQ,EAAE;AAAX,GAA1C;;AAEA,MAAIJ,QAAJ,EAAc;AACZ,WAAOE,MAAP;AACD,GAnB6D,CAqB9D;;;AACA,MAAMG,WAAW,GAAGtK,MAAM,CAACgG,MAAP,CAAc,EAAd,EAAkB+D,QAAlB,CAApB;;AACA,MAAII,MAAM,CAAChJ,GAAX,EAAgB;AACdmJ,IAAAA,WAAW,CAACnJ,GAAZ,GAAkBgJ,MAAM,CAAChJ,GAAzB;AACD;;AAED,SAAOmJ,WAAP;AACD,CA5BD;;AA8BAzL,eAAe,CAAC0L,YAAhB,GAA+B,UAACC,IAAD,EAAOC,KAAP,EAAc3D,SAAd,EAA4B;AACzD,SAAOa,YAAY,CAAC+C,WAAb,CAAyBF,IAAzB,EAA+BC,KAA/B,EAAsC3D,SAAtC,CAAP;AACD,CAFD,C,CAIA;AACA;AACA;AACA;;;AACAjI,eAAe,CAACsF,iBAAhB,GAAoC,UAACX,OAAD,EAAUkD,UAAV,EAAsBiE,UAAtB,EAAkCC,QAAlC,EAA4CtK,OAA5C;AAAA,SAClCqH,YAAY,CAACkD,gBAAb,CAA8BrH,OAA9B,EAAuCkD,UAAvC,EAAmDiE,UAAnD,EAA+DC,QAA/D,EAAyEtK,OAAzE,CADkC;AAAA,CAApC;;AAIAzB,eAAe,CAACiM,wBAAhB,GAA2C,UAACpE,UAAD,EAAaiE,UAAb,EAAyBC,QAAzB,EAAmCtK,OAAnC;AAAA,SACzCqH,YAAY,CAACoD,uBAAb,CAAqCrE,UAArC,EAAiDiE,UAAjD,EAA6DC,QAA7D,EAAuEtK,OAAvE,CADyC;AAAA,CAA3C;;AAIAzB,eAAe,CAACmM,0BAAhB,GAA6C,UAACtE,UAAD,EAAaiE,UAAb,EAAyBC,QAAzB,EAAmCtK,OAAnC;AAAA,SAC3CqH,YAAY,CAACsD,yBAAb,CAAuCvE,UAAvC,EAAmDiE,UAAnD,EAA+DC,QAA/D,EAAyEtK,OAAzE,CAD2C;AAAA,CAA7C;;AAIAzB,eAAe,CAACqM,qBAAhB,GAAwC,UAAChJ,KAAD,EAAQrB,GAAR,EAAgB;AACtD,MAAI,CAACqB,KAAK,CAACsB,OAAX,EAAoB;AAClB,UAAM,IAAIc,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,OAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3B,KAAK,CAACiB,OAAN,CAAc3C,MAAlC,EAA0CqD,CAAC,EAA3C,EAA+C;AAC7C,QAAI3B,KAAK,CAACiB,OAAN,CAAcU,CAAd,MAAqBhD,GAAzB,EAA8B;AAC5B,aAAOgD,CAAP;AACD;AACF;;AAED,QAAMS,KAAK,CAAC,2BAAD,CAAX;AACD,CAZD,C,CAcA;AACA;AACA;AACA;AACA;;;AACAzF,eAAe,CAACkG,qBAAhB,GAAwC,UAAA1E,QAAQ,EAAI;AAClD;AACA,MAAIxB,eAAe,CAACsM,aAAhB,CAA8B9K,QAA9B,CAAJ,EAA6C;AAC3C,WAAO,CAACA,QAAD,CAAP;AACD;;AAED,MAAI,CAACA,QAAL,EAAe;AACb,WAAO,IAAP;AACD,GARiD,CAUlD;;;AACA,MAAInB,MAAM,CAACgC,IAAP,CAAYb,QAAZ,EAAsB,KAAtB,CAAJ,EAAkC;AAChC;AACA,QAAIxB,eAAe,CAACsM,aAAhB,CAA8B9K,QAAQ,CAACc,GAAvC,CAAJ,EAAiD;AAC/C,aAAO,CAACd,QAAQ,CAACc,GAAV,CAAP;AACD,KAJ+B,CAMhC;;;AACA,QAAId,QAAQ,CAACc,GAAT,IACG6D,KAAK,CAACkE,OAAN,CAAc7I,QAAQ,CAACc,GAAT,CAAaiK,GAA3B,CADH,IAEG/K,QAAQ,CAACc,GAAT,CAAaiK,GAAb,CAAiB5K,MAFpB,IAGGH,QAAQ,CAACc,GAAT,CAAaiK,GAAb,CAAiBC,KAAjB,CAAuBxM,eAAe,CAACsM,aAAvC,CAHP,EAG8D;AAC5D,aAAO9K,QAAQ,CAACc,GAAT,CAAaiK,GAApB;AACD;;AAED,WAAO,IAAP;AACD,GA1BiD,CA4BlD;AACA;AACA;;;AACA,MAAIpG,KAAK,CAACkE,OAAN,CAAc7I,QAAQ,CAACiL,IAAvB,CAAJ,EAAkC;AAChC,SAAK,IAAIzH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxD,QAAQ,CAACiL,IAAT,CAAc9K,MAAlC,EAA0C,EAAEqD,CAA5C,EAA+C;AAC7C,UAAM0H,MAAM,GAAG1M,eAAe,CAACkG,qBAAhB,CAAsC1E,QAAQ,CAACiL,IAAT,CAAczH,CAAd,CAAtC,CAAf;;AAEA,UAAI0H,MAAJ,EAAY;AACV,eAAOA,MAAP;AACD;AACF;AACF;;AAED,SAAO,IAAP;AACD,CA1CD;;AA4CA1M,eAAe,CAACgE,gBAAhB,GAAmC,UAACX,KAAD,EAAQrB,GAAR,EAAgB;AACjD,MAAMwG,MAAM,GAAGtG,KAAK,CAACC,KAAN,CAAYH,GAAZ,CAAf;AAEA,SAAOwG,MAAM,CAAClG,GAAd;;AAEA,MAAIe,KAAK,CAACsB,OAAV,EAAmB;AACjB,QAAI,CAACtB,KAAK,CAACsJ,MAAX,EAAmB;AACjBtJ,MAAAA,KAAK,CAACkF,WAAN,CAAkBvG,GAAG,CAACM,GAAtB,EAA2Be,KAAK,CAACkC,YAAN,CAAmBiD,MAAnB,CAA3B,EAAuD,IAAvD;AACAnF,MAAAA,KAAK,CAACiB,OAAN,CAAcP,IAAd,CAAmB/B,GAAnB;AACD,KAHD,MAGO;AACL,UAAMgD,CAAC,GAAGhF,eAAe,CAAC4M,mBAAhB,CACRvJ,KAAK,CAACsJ,MAAN,CAAaE,aAAb,CAA2B;AAAClJ,QAAAA,SAAS,EAAEN,KAAK,CAACM;AAAlB,OAA3B,CADQ,EAERN,KAAK,CAACiB,OAFE,EAGRtC,GAHQ,CAAV;;AAMA,UAAI8K,IAAI,GAAGzJ,KAAK,CAACiB,OAAN,CAAcU,CAAC,GAAG,CAAlB,CAAX;;AACA,UAAI8H,IAAJ,EAAU;AACRA,QAAAA,IAAI,GAAGA,IAAI,CAACxK,GAAZ;AACD,OAFD,MAEO;AACLwK,QAAAA,IAAI,GAAG,IAAP;AACD;;AAEDzJ,MAAAA,KAAK,CAACkF,WAAN,CAAkBvG,GAAG,CAACM,GAAtB,EAA2Be,KAAK,CAACkC,YAAN,CAAmBiD,MAAnB,CAA3B,EAAuDsE,IAAvD;AACD;;AAEDzJ,IAAAA,KAAK,CAACoF,KAAN,CAAYzG,GAAG,CAACM,GAAhB,EAAqBe,KAAK,CAACkC,YAAN,CAAmBiD,MAAnB,CAArB;AACD,GAtBD,MAsBO;AACLnF,IAAAA,KAAK,CAACoF,KAAN,CAAYzG,GAAG,CAACM,GAAhB,EAAqBe,KAAK,CAACkC,YAAN,CAAmBiD,MAAnB,CAArB;AACAnF,IAAAA,KAAK,CAACiB,OAAN,CAActB,GAAd,CAAkBhB,GAAG,CAACM,GAAtB,EAA2BN,GAA3B;AACD;AACF,CA/BD;;AAiCAhC,eAAe,CAAC4M,mBAAhB,GAAsC,UAAChD,GAAD,EAAMC,KAAN,EAAaC,KAAb,EAAuB;AAC3D,MAAID,KAAK,CAAClI,MAAN,KAAiB,CAArB,EAAwB;AACtBkI,IAAAA,KAAK,CAAC9F,IAAN,CAAW+F,KAAX;AACA,WAAO,CAAP;AACD;;AAED,MAAM9E,CAAC,GAAGhF,eAAe,CAAC2J,aAAhB,CAA8BC,GAA9B,EAAmCC,KAAnC,EAA0CC,KAA1C,CAAV;;AAEAD,EAAAA,KAAK,CAACkD,MAAN,CAAa/H,CAAb,EAAgB,CAAhB,EAAmB8E,KAAnB;AAEA,SAAO9E,CAAP;AACD,CAXD;;AAaAhF,eAAe,CAACqL,kBAAhB,GAAqC,UAAAxF,GAAG,EAAI;AAC1C,MAAIuF,QAAQ,GAAG,KAAf;AACA,MAAI4B,SAAS,GAAG,KAAhB;AAEA7L,EAAAA,MAAM,CAAC+B,IAAP,CAAY2C,GAAZ,EAAiB1C,OAAjB,CAAyB,UAAAsH,GAAG,EAAI;AAC9B,QAAIA,GAAG,CAACwC,MAAJ,CAAW,CAAX,EAAc,CAAd,MAAqB,GAAzB,EAA8B;AAC5B7B,MAAAA,QAAQ,GAAG,IAAX;AACD,KAFD,MAEO;AACL4B,MAAAA,SAAS,GAAG,IAAZ;AACD;AACF,GAND;;AAQA,MAAI5B,QAAQ,IAAI4B,SAAhB,EAA2B;AACzB,UAAM,IAAIvH,KAAJ,CACJ,qEADI,CAAN;AAGD;;AAED,SAAO2F,QAAP;AACD,CAnBD,C,CAqBA;AACA;AACA;;;AACApL,eAAe,CAAC0J,cAAhB,GAAiC,UAAAwD,CAAC,EAAI;AACpC,SAAOA,CAAC,IAAIlN,eAAe,CAACmN,EAAhB,CAAmBC,KAAnB,CAAyBF,CAAzB,MAAgC,CAA5C;AACD,CAFD,C,CAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlN,eAAe,CAACwH,OAAhB,GAA0B,UAACxF,GAAD,EAAMkJ,QAAN,EAAiC;AAAA,MAAjBzJ,OAAiB,uEAAP,EAAO;;AACzD,MAAI,CAACzB,eAAe,CAAC0J,cAAhB,CAA+BwB,QAA/B,CAAL,EAA+C;AAC7C,UAAMrI,cAAc,CAAC,4BAAD,CAApB;AACD,GAHwD,CAKzD;;;AACAqI,EAAAA,QAAQ,GAAGhJ,KAAK,CAACC,KAAN,CAAY+I,QAAZ,CAAX;AAEA,MAAMmC,UAAU,GAAG7M,gBAAgB,CAAC0K,QAAD,CAAnC;AACA,MAAMI,MAAM,GAAG+B,UAAU,GAAGnL,KAAK,CAACC,KAAN,CAAYH,GAAZ,CAAH,GAAsBkJ,QAA/C;;AAEA,MAAImC,UAAJ,EAAgB;AACd;AACAlM,IAAAA,MAAM,CAAC+B,IAAP,CAAYgI,QAAZ,EAAsB/H,OAAtB,CAA8B,UAAAmK,QAAQ,EAAI;AACxC;AACA,UAAMC,WAAW,GAAG9L,OAAO,CAAC+J,QAAR,IAAoB8B,QAAQ,KAAK,cAArD;AACA,UAAME,OAAO,GAAGC,SAAS,CAACF,WAAW,GAAG,MAAH,GAAYD,QAAxB,CAAzB;AACA,UAAMI,OAAO,GAAGxC,QAAQ,CAACoC,QAAD,CAAxB;;AAEA,UAAI,CAACE,OAAL,EAAc;AACZ,cAAM3K,cAAc,iCAA+ByK,QAA/B,CAApB;AACD;;AAEDnM,MAAAA,MAAM,CAAC+B,IAAP,CAAYwK,OAAZ,EAAqBvK,OAArB,CAA6B,UAAAwK,OAAO,EAAI;AACtC,YAAMC,GAAG,GAAGF,OAAO,CAACC,OAAD,CAAnB;;AAEA,YAAIA,OAAO,KAAK,EAAhB,EAAoB;AAClB,gBAAM9K,cAAc,CAAC,oCAAD,CAApB;AACD;;AAED,YAAMgL,QAAQ,GAAGF,OAAO,CAACpD,KAAR,CAAc,GAAd,CAAjB;;AAEA,YAAI,CAACsD,QAAQ,CAACrB,KAAT,CAAesB,OAAf,CAAL,EAA8B;AAC5B,gBAAMjL,cAAc,CAClB,sBAAoB8K,OAApB,wCACA,uBAFkB,CAApB;AAID;;AAED,YAAMI,MAAM,GAAGC,aAAa,CAAC1C,MAAD,EAASuC,QAAT,EAAmB;AAC7CjH,UAAAA,YAAY,EAAEnF,OAAO,CAACmF,YADuB;AAE7CqH,UAAAA,WAAW,EAAEX,QAAQ,KAAK,SAFmB;AAG7CY,UAAAA,QAAQ,EAAEC,mBAAmB,CAACb,QAAD;AAHgB,SAAnB,CAA5B;AAMAE,QAAAA,OAAO,CAACO,MAAD,EAASF,QAAQ,CAACO,GAAT,EAAT,EAAyBR,GAAzB,EAA8BD,OAA9B,EAAuCrC,MAAvC,CAAP;AACD,OAvBD;AAwBD,KAlCD;;AAoCA,QAAItJ,GAAG,CAACM,GAAJ,IAAW,CAACJ,KAAK,CAACsC,MAAN,CAAaxC,GAAG,CAACM,GAAjB,EAAsBgJ,MAAM,CAAChJ,GAA7B,CAAhB,EAAmD;AACjD,YAAMO,cAAc,CAClB,uDAAoDb,GAAG,CAACM,GAAxD,iBACA,mEADA,gBAESgJ,MAAM,CAAChJ,GAFhB,QADkB,CAApB;AAKD;AACF,GA7CD,MA6CO;AACL,QAAIN,GAAG,CAACM,GAAJ,IAAW4I,QAAQ,CAAC5I,GAApB,IAA2B,CAACJ,KAAK,CAACsC,MAAN,CAAaxC,GAAG,CAACM,GAAjB,EAAsB4I,QAAQ,CAAC5I,GAA/B,CAAhC,EAAqE;AACnE,YAAMO,cAAc,CAClB,kDAA+Cb,GAAG,CAACM,GAAnD,6BACU4I,QAAQ,CAAC5I,GADnB,SADkB,CAApB;AAID,KANI,CAQL;;;AACAF,IAAAA,wBAAwB,CAAC8I,QAAD,CAAxB;AACD,GAlEwD,CAoEzD;;;AACA/J,EAAAA,MAAM,CAAC+B,IAAP,CAAYlB,GAAZ,EAAiBmB,OAAjB,CAAyB,UAAAsH,GAAG,EAAI;AAC9B;AACA;AACA;AACA,QAAIA,GAAG,KAAK,KAAZ,EAAmB;AACjB,aAAOzI,GAAG,CAACyI,GAAD,CAAV;AACD;AACF,GAPD;AASAtJ,EAAAA,MAAM,CAAC+B,IAAP,CAAYoI,MAAZ,EAAoBnI,OAApB,CAA4B,UAAAsH,GAAG,EAAI;AACjCzI,IAAAA,GAAG,CAACyI,GAAD,CAAH,GAAWa,MAAM,CAACb,GAAD,CAAjB;AACD,GAFD;AAGD,CAjFD;;AAmFAzK,eAAe,CAACqO,0BAAhB,GAA6C,UAACxK,MAAD,EAASyK,gBAAT,EAA8B;AACzE,MAAMlF,SAAS,GAAGvF,MAAM,CAAC0K,YAAP,MAA0B,UAAAvM,GAAG;AAAA,WAAIA,GAAJ;AAAA,GAA/C;;AACA,MAAIwM,UAAU,GAAG,CAAC,CAACF,gBAAgB,CAACG,iBAApC;AAEA,MAAIC,uBAAJ;;AACA,MAAI1O,eAAe,CAAC2O,2BAAhB,CAA4CL,gBAA5C,CAAJ,EAAmE;AACjE;AACA;AACA;AACA;AACA,QAAMM,OAAO,GAAG,CAACN,gBAAgB,CAACO,WAAlC;AAEAH,IAAAA,uBAAuB,GAAG;AACxBnG,MAAAA,WADwB,YACZ5F,EADY,EACR6F,MADQ,EACAb,MADA,EACQ;AAC9B,YAAI6G,UAAU,IAAI,EAAEF,gBAAgB,CAACQ,OAAjB,IAA4BR,gBAAgB,CAAC7F,KAA/C,CAAlB,EAAyE;AACvE;AACD;;AAED,YAAMzG,GAAG,GAAGoH,SAAS,CAACjI,MAAM,CAACgG,MAAP,CAAcqB,MAAd,EAAsB;AAAClG,UAAAA,GAAG,EAAEK;AAAN,SAAtB,CAAD,CAArB;;AAEA,YAAI2L,gBAAgB,CAACQ,OAArB,EAA8B;AAC5BR,UAAAA,gBAAgB,CAACQ,OAAjB,CACE9M,GADF,EAEE4M,OAAO,GACHjH,MAAM,GACJ,KAAKQ,IAAL,CAAU4G,OAAV,CAAkBpH,MAAlB,CADI,GAEJ,KAAKQ,IAAL,CAAU1D,IAAV,EAHC,GAIH,CAAC,CANP,EAOEkD,MAPF;AASD,SAVD,MAUO;AACL2G,UAAAA,gBAAgB,CAAC7F,KAAjB,CAAuBzG,GAAvB;AACD;AACF,OArBuB;AAsBxB6G,MAAAA,OAtBwB,YAsBhBlG,EAtBgB,EAsBZ6F,MAtBY,EAsBJ;AAClB,YAAI,EAAE8F,gBAAgB,CAACU,SAAjB,IAA8BV,gBAAgB,CAACzF,OAAjD,CAAJ,EAA+D;AAC7D;AACD;;AAED,YAAI7G,GAAG,GAAGE,KAAK,CAACC,KAAN,CAAY,KAAKgG,IAAL,CAAUhD,GAAV,CAAcxC,EAAd,CAAZ,CAAV;;AACA,YAAI,CAACX,GAAL,EAAU;AACR,gBAAM,IAAIyD,KAAJ,8BAAqC9C,EAArC,CAAN;AACD;;AAED,YAAMsM,MAAM,GAAG7F,SAAS,CAAClH,KAAK,CAACC,KAAN,CAAYH,GAAZ,CAAD,CAAxB;AAEA8G,QAAAA,YAAY,CAACC,YAAb,CAA0B/G,GAA1B,EAA+BwG,MAA/B;;AAEA,YAAI8F,gBAAgB,CAACU,SAArB,EAAgC;AAC9BV,UAAAA,gBAAgB,CAACU,SAAjB,CACE5F,SAAS,CAACpH,GAAD,CADX,EAEEiN,MAFF,EAGEL,OAAO,GAAG,KAAKzG,IAAL,CAAU4G,OAAV,CAAkBpM,EAAlB,CAAH,GAA2B,CAAC,CAHrC;AAKD,SAND,MAMO;AACL2L,UAAAA,gBAAgB,CAACzF,OAAjB,CAAyBO,SAAS,CAACpH,GAAD,CAAlC,EAAyCiN,MAAzC;AACD;AACF,OA7CuB;AA8CxBtG,MAAAA,WA9CwB,YA8CZhG,EA9CY,EA8CRgF,MA9CQ,EA8CA;AACtB,YAAI,CAAC2G,gBAAgB,CAACY,OAAtB,EAA+B;AAC7B;AACD;;AAED,YAAMC,IAAI,GAAGP,OAAO,GAAG,KAAKzG,IAAL,CAAU4G,OAAV,CAAkBpM,EAAlB,CAAH,GAA2B,CAAC,CAAhD;AACA,YAAIyM,EAAE,GAAGR,OAAO,GACZjH,MAAM,GACJ,KAAKQ,IAAL,CAAU4G,OAAV,CAAkBpH,MAAlB,CADI,GAEJ,KAAKQ,IAAL,CAAU1D,IAAV,EAHU,GAIZ,CAAC,CAJL,CANsB,CAYtB;AACA;;AACA,YAAI2K,EAAE,GAAGD,IAAT,EAAe;AACb,YAAEC,EAAF;AACD;;AAEDd,QAAAA,gBAAgB,CAACY,OAAjB,CACE9F,SAAS,CAAClH,KAAK,CAACC,KAAN,CAAY,KAAKgG,IAAL,CAAUhD,GAAV,CAAcxC,EAAd,CAAZ,CAAD,CADX,EAEEwM,IAFF,EAGEC,EAHF,EAIEzH,MAAM,IAAI,IAJZ;AAMD,OAtEuB;AAuExBqB,MAAAA,OAvEwB,YAuEhBrG,EAvEgB,EAuEZ;AACV,YAAI,EAAE2L,gBAAgB,CAACe,SAAjB,IAA8Bf,gBAAgB,CAACtF,OAAjD,CAAJ,EAA+D;AAC7D;AACD,SAHS,CAKV;AACA;;;AACA,YAAMhH,GAAG,GAAGoH,SAAS,CAAC,KAAKjB,IAAL,CAAUhD,GAAV,CAAcxC,EAAd,CAAD,CAArB;;AAEA,YAAI2L,gBAAgB,CAACe,SAArB,EAAgC;AAC9Bf,UAAAA,gBAAgB,CAACe,SAAjB,CAA2BrN,GAA3B,EAAgC4M,OAAO,GAAG,KAAKzG,IAAL,CAAU4G,OAAV,CAAkBpM,EAAlB,CAAH,GAA2B,CAAC,CAAnE;AACD,SAFD,MAEO;AACL2L,UAAAA,gBAAgB,CAACtF,OAAjB,CAAyBhH,GAAzB;AACD;AACF;AArFuB,KAA1B;AAuFD,GA9FD,MA8FO;AACL0M,IAAAA,uBAAuB,GAAG;AACxBjG,MAAAA,KADwB,YAClB9F,EADkB,EACd6F,MADc,EACN;AAChB,YAAI,CAACgG,UAAD,IAAeF,gBAAgB,CAAC7F,KAApC,EAA2C;AACzC6F,UAAAA,gBAAgB,CAAC7F,KAAjB,CAAuBW,SAAS,CAACjI,MAAM,CAACgG,MAAP,CAAcqB,MAAd,EAAsB;AAAClG,YAAAA,GAAG,EAAEK;AAAN,WAAtB,CAAD,CAAhC;AACD;AACF,OALuB;AAMxBkG,MAAAA,OANwB,YAMhBlG,EANgB,EAMZ6F,MANY,EAMJ;AAClB,YAAI8F,gBAAgB,CAACzF,OAArB,EAA8B;AAC5B,cAAMoG,MAAM,GAAG,KAAK9G,IAAL,CAAUhD,GAAV,CAAcxC,EAAd,CAAf;AACA,cAAMX,GAAG,GAAGE,KAAK,CAACC,KAAN,CAAY8M,MAAZ,CAAZ;AAEAnG,UAAAA,YAAY,CAACC,YAAb,CAA0B/G,GAA1B,EAA+BwG,MAA/B;AAEA8F,UAAAA,gBAAgB,CAACzF,OAAjB,CACEO,SAAS,CAACpH,GAAD,CADX,EAEEoH,SAAS,CAAClH,KAAK,CAACC,KAAN,CAAY8M,MAAZ,CAAD,CAFX;AAID;AACF,OAlBuB;AAmBxBjG,MAAAA,OAnBwB,YAmBhBrG,EAnBgB,EAmBZ;AACV,YAAI2L,gBAAgB,CAACtF,OAArB,EAA8B;AAC5BsF,UAAAA,gBAAgB,CAACtF,OAAjB,CAAyBI,SAAS,CAAC,KAAKjB,IAAL,CAAUhD,GAAV,CAAcxC,EAAd,CAAD,CAAlC;AACD;AACF;AAvBuB,KAA1B;AAyBD;;AAED,MAAM2M,cAAc,GAAG,IAAItP,eAAe,CAAC+H,sBAApB,CAA2C;AAChEE,IAAAA,SAAS,EAAEyG;AADqD,GAA3C,CAAvB;AAIA,MAAMa,MAAM,GAAG1L,MAAM,CAAC2L,cAAP,CAAsBF,cAAc,CAAChH,WAArC,CAAf;AAEAkG,EAAAA,UAAU,GAAG,KAAb;AAEA,SAAOe,MAAP;AACD,CAxID;;AA0IAvP,eAAe,CAAC2O,2BAAhB,GAA8C,UAAA1G,SAAS,EAAI;AACzD,MAAIA,SAAS,CAACQ,KAAV,IAAmBR,SAAS,CAAC6G,OAAjC,EAA0C;AACxC,UAAM,IAAIrJ,KAAJ,CAAU,kDAAV,CAAN;AACD;;AAED,MAAIwC,SAAS,CAACY,OAAV,IAAqBZ,SAAS,CAAC+G,SAAnC,EAA8C;AAC5C,UAAM,IAAIvJ,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,MAAIwC,SAAS,CAACe,OAAV,IAAqBf,SAAS,CAACoH,SAAnC,EAA8C;AAC5C,UAAM,IAAI5J,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,SAAO,CAAC,EACNwC,SAAS,CAAC6G,OAAV,IACA7G,SAAS,CAAC+G,SADV,IAEA/G,SAAS,CAACiH,OAFV,IAGAjH,SAAS,CAACoH,SAJJ,CAAR;AAMD,CAnBD;;AAqBArP,eAAe,CAACkI,kCAAhB,GAAqD,UAAAD,SAAS,EAAI;AAChE,MAAIA,SAAS,CAACQ,KAAV,IAAmBR,SAAS,CAACM,WAAjC,EAA8C;AAC5C,UAAM,IAAI9C,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,SAAO,CAAC,EAAEwC,SAAS,CAACM,WAAV,IAAyBN,SAAS,CAACU,WAArC,CAAR;AACD,CAND;;AAQA3I,eAAe,CAACoF,kBAAhB,GAAqC,UAAC/B,KAAD,EAAQrB,GAAR,EAAgB;AACnD,MAAIqB,KAAK,CAACsB,OAAV,EAAmB;AACjB,QAAMK,CAAC,GAAGhF,eAAe,CAACqM,qBAAhB,CAAsChJ,KAAtC,EAA6CrB,GAA7C,CAAV;;AAEAqB,IAAAA,KAAK,CAAC2F,OAAN,CAAchH,GAAG,CAACM,GAAlB;AACAe,IAAAA,KAAK,CAACiB,OAAN,CAAcyI,MAAd,CAAqB/H,CAArB,EAAwB,CAAxB;AACD,GALD,MAKO;AACL,QAAMrC,EAAE,GAAGX,GAAG,CAACM,GAAf,CADK,CACgB;;AAErBe,IAAAA,KAAK,CAAC2F,OAAN,CAAchH,GAAG,CAACM,GAAlB;AACAe,IAAAA,KAAK,CAACiB,OAAN,CAAcC,MAAd,CAAqB5B,EAArB;AACD;AACF,CAZD,C,CAcA;;;AACA3C,eAAe,CAACsM,aAAhB,GAAgC,UAAA9K,QAAQ;AAAA,SACtC,OAAOA,QAAP,KAAoB,QAApB,IACA,OAAOA,QAAP,KAAoB,QADpB,IAEAA,QAAQ,YAAYgB,OAAO,CAACC,QAHU;AAAA,CAAxC,C,CAMA;;;AACAzC,eAAe,CAACyP,4BAAhB,GAA+C,UAAAjO,QAAQ;AAAA,SACrDxB,eAAe,CAACsM,aAAhB,CAA8B9K,QAA9B,KACAxB,eAAe,CAACsM,aAAhB,CAA8B9K,QAAQ,IAAIA,QAAQ,CAACc,GAAnD,KACAnB,MAAM,CAAC+B,IAAP,CAAY1B,QAAZ,EAAsBG,MAAtB,KAAiC,CAHoB;AAAA,CAAvD;;AAMA3B,eAAe,CAAC4H,gBAAhB,GAAmC,UAACvE,KAAD,EAAQrB,GAAR,EAAauF,OAAb,EAAyB;AAC1D,MAAI,CAACrF,KAAK,CAACsC,MAAN,CAAaxC,GAAG,CAACM,GAAjB,EAAsBiF,OAAO,CAACjF,GAA9B,CAAL,EAAyC;AACvC,UAAM,IAAImD,KAAJ,CAAU,2CAAV,CAAN;AACD;;AAED,MAAMF,YAAY,GAAGlC,KAAK,CAACkC,YAA3B;AACA,MAAMmK,aAAa,GAAG5G,YAAY,CAAC6G,iBAAb,CACpBpK,YAAY,CAACvD,GAAD,CADQ,EAEpBuD,YAAY,CAACgC,OAAD,CAFQ,CAAtB;;AAKA,MAAI,CAAClE,KAAK,CAACsB,OAAX,EAAoB;AAClB,QAAIxD,MAAM,CAAC+B,IAAP,CAAYwM,aAAZ,EAA2B/N,MAA/B,EAAuC;AACrC0B,MAAAA,KAAK,CAACwF,OAAN,CAAc7G,GAAG,CAACM,GAAlB,EAAuBoN,aAAvB;AACArM,MAAAA,KAAK,CAACiB,OAAN,CAActB,GAAd,CAAkBhB,GAAG,CAACM,GAAtB,EAA2BN,GAA3B;AACD;;AAED;AACD;;AAED,MAAM4N,OAAO,GAAG5P,eAAe,CAACqM,qBAAhB,CAAsChJ,KAAtC,EAA6CrB,GAA7C,CAAhB;;AAEA,MAAIb,MAAM,CAAC+B,IAAP,CAAYwM,aAAZ,EAA2B/N,MAA/B,EAAuC;AACrC0B,IAAAA,KAAK,CAACwF,OAAN,CAAc7G,GAAG,CAACM,GAAlB,EAAuBoN,aAAvB;AACD;;AAED,MAAI,CAACrM,KAAK,CAACsJ,MAAX,EAAmB;AACjB;AACD,GA5ByD,CA8B1D;;;AACAtJ,EAAAA,KAAK,CAACiB,OAAN,CAAcyI,MAAd,CAAqB6C,OAArB,EAA8B,CAA9B;;AAEA,MAAMC,OAAO,GAAG7P,eAAe,CAAC4M,mBAAhB,CACdvJ,KAAK,CAACsJ,MAAN,CAAaE,aAAb,CAA2B;AAAClJ,IAAAA,SAAS,EAAEN,KAAK,CAACM;AAAlB,GAA3B,CADc,EAEdN,KAAK,CAACiB,OAFQ,EAGdtC,GAHc,CAAhB;;AAMA,MAAI4N,OAAO,KAAKC,OAAhB,EAAyB;AACvB,QAAI/C,IAAI,GAAGzJ,KAAK,CAACiB,OAAN,CAAcuL,OAAO,GAAG,CAAxB,CAAX;;AACA,QAAI/C,IAAJ,EAAU;AACRA,MAAAA,IAAI,GAAGA,IAAI,CAACxK,GAAZ;AACD,KAFD,MAEO;AACLwK,MAAAA,IAAI,GAAG,IAAP;AACD;;AAEDzJ,IAAAA,KAAK,CAACsF,WAAN,IAAqBtF,KAAK,CAACsF,WAAN,CAAkB3G,GAAG,CAACM,GAAtB,EAA2BwK,IAA3B,CAArB;AACD;AACF,CAjDD;;AAmDA,IAAMW,SAAS,GAAG;AAChBqC,EAAAA,YADgB,YACH/B,MADG,EACKgC,KADL,EACYnC,GADZ,EACiB;AAC/B,QAAI,sBAAOA,GAAP,MAAe,QAAf,IAA2BvN,MAAM,CAACgC,IAAP,CAAYuL,GAAZ,EAAiB,OAAjB,CAA/B,EAA0D;AACxD,UAAIA,GAAG,CAACoC,KAAJ,KAAc,MAAlB,EAA0B;AACxB,cAAMnN,cAAc,CAClB,4DACA,wBAFkB,EAGlB;AAACkN,UAAAA,KAAK,EAALA;AAAD,SAHkB,CAApB;AAKD;AACF,KARD,MAQO,IAAInC,GAAG,KAAK,IAAZ,EAAkB;AACvB,YAAM/K,cAAc,CAAC,+BAAD,EAAkC;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAAlC,CAApB;AACD;;AAEDhC,IAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgB,IAAIE,IAAJ,EAAhB;AACD,GAfe;AAgBhBC,EAAAA,IAhBgB,YAgBXnC,MAhBW,EAgBHgC,KAhBG,EAgBInC,GAhBJ,EAgBS;AACvB,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAM/K,cAAc,CAAC,wCAAD,EAA2C;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAA3C,CAApB;AACD;;AAED,QAAIA,KAAK,IAAIhC,MAAb,EAAqB;AACnB,UAAI,OAAOA,MAAM,CAACgC,KAAD,CAAb,KAAyB,QAA7B,EAAuC;AACrC,cAAMlN,cAAc,CAClB,0CADkB,EAElB;AAACkN,UAAAA,KAAK,EAALA;AAAD,SAFkB,CAApB;AAID;;AAED,UAAIhC,MAAM,CAACgC,KAAD,CAAN,GAAgBnC,GAApB,EAAyB;AACvBG,QAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBnC,GAAhB;AACD;AACF,KAXD,MAWO;AACLG,MAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBnC,GAAhB;AACD;AACF,GAnCe;AAoChBuC,EAAAA,IApCgB,YAoCXpC,MApCW,EAoCHgC,KApCG,EAoCInC,GApCJ,EAoCS;AACvB,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAM/K,cAAc,CAAC,wCAAD,EAA2C;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAA3C,CAApB;AACD;;AAED,QAAIA,KAAK,IAAIhC,MAAb,EAAqB;AACnB,UAAI,OAAOA,MAAM,CAACgC,KAAD,CAAb,KAAyB,QAA7B,EAAuC;AACrC,cAAMlN,cAAc,CAClB,0CADkB,EAElB;AAACkN,UAAAA,KAAK,EAALA;AAAD,SAFkB,CAApB;AAID;;AAED,UAAIhC,MAAM,CAACgC,KAAD,CAAN,GAAgBnC,GAApB,EAAyB;AACvBG,QAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBnC,GAAhB;AACD;AACF,KAXD,MAWO;AACLG,MAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBnC,GAAhB;AACD;AACF,GAvDe;AAwDhBwC,EAAAA,IAxDgB,YAwDXrC,MAxDW,EAwDHgC,KAxDG,EAwDInC,GAxDJ,EAwDS;AACvB,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAM/K,cAAc,CAAC,wCAAD,EAA2C;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAA3C,CAApB;AACD;;AAED,QAAIA,KAAK,IAAIhC,MAAb,EAAqB;AACnB,UAAI,OAAOA,MAAM,CAACgC,KAAD,CAAb,KAAyB,QAA7B,EAAuC;AACrC,cAAMlN,cAAc,CAClB,0CADkB,EAElB;AAACkN,UAAAA,KAAK,EAALA;AAAD,SAFkB,CAApB;AAID;;AAEDhC,MAAAA,MAAM,CAACgC,KAAD,CAAN,IAAiBnC,GAAjB;AACD,KATD,MASO;AACLG,MAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBnC,GAAhB;AACD;AACF,GAzEe;AA0EhBrC,EAAAA,IA1EgB,YA0EXwC,MA1EW,EA0EHgC,KA1EG,EA0EInC,GA1EJ,EA0ES;AACvB,QAAIG,MAAM,KAAK5M,MAAM,CAAC4M,MAAD,CAArB,EAA+B;AAAE;AAC/B,UAAMsC,KAAK,GAAGxN,cAAc,CAC1B,yCAD0B,EAE1B;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAF0B,CAA5B;AAIAM,MAAAA,KAAK,CAACC,gBAAN,GAAyB,IAAzB;AACA,YAAMD,KAAN;AACD;;AAED,QAAItC,MAAM,KAAK,IAAf,EAAqB;AACnB,UAAMsC,MAAK,GAAGxN,cAAc,CAAC,6BAAD,EAAgC;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAAhC,CAA5B;;AACAM,MAAAA,MAAK,CAACC,gBAAN,GAAyB,IAAzB;AACA,YAAMD,MAAN;AACD;;AAEDjO,IAAAA,wBAAwB,CAACwL,GAAD,CAAxB;AAEAG,IAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBnC,GAAhB;AACD,GA7Fe;AA8FhB2C,EAAAA,YA9FgB,YA8FHxC,MA9FG,EA8FKgC,KA9FL,EA8FYnC,GA9FZ,EA8FiB,CAC/B;AACD,GAhGe;AAiGhB4C,EAAAA,MAjGgB,YAiGTzC,MAjGS,EAiGDgC,KAjGC,EAiGMnC,GAjGN,EAiGW;AACzB,QAAIG,MAAM,KAAKhL,SAAf,EAA0B;AACxB,UAAIgL,MAAM,YAAY5H,KAAtB,EAA6B;AAC3B,YAAI4J,KAAK,IAAIhC,MAAb,EAAqB;AACnBA,UAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgB,IAAhB;AACD;AACF,OAJD,MAIO;AACL,eAAOhC,MAAM,CAACgC,KAAD,CAAb;AACD;AACF;AACF,GA3Ge;AA4GhBU,EAAAA,KA5GgB,YA4GV1C,MA5GU,EA4GFgC,KA5GE,EA4GKnC,GA5GL,EA4GU;AACxB,QAAIG,MAAM,CAACgC,KAAD,CAAN,KAAkBhN,SAAtB,EAAiC;AAC/BgL,MAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgB,EAAhB;AACD;;AAED,QAAI,EAAEhC,MAAM,CAACgC,KAAD,CAAN,YAAyB5J,KAA3B,CAAJ,EAAuC;AACrC,YAAMtD,cAAc,CAAC,0CAAD,EAA6C;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAA7C,CAApB;AACD;;AAED,QAAI,EAAEnC,GAAG,IAAIA,GAAG,CAAC8C,KAAb,CAAJ,EAAyB;AACvB;AACAtO,MAAAA,wBAAwB,CAACwL,GAAD,CAAxB;AAEAG,MAAAA,MAAM,CAACgC,KAAD,CAAN,CAAchM,IAAd,CAAmB6J,GAAnB;AAEA;AACD,KAhBuB,CAkBxB;;;AACA,QAAM+C,MAAM,GAAG/C,GAAG,CAAC8C,KAAnB;;AACA,QAAI,EAAEC,MAAM,YAAYxK,KAApB,CAAJ,EAAgC;AAC9B,YAAMtD,cAAc,CAAC,wBAAD,EAA2B;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAA3B,CAApB;AACD;;AAED3N,IAAAA,wBAAwB,CAACuO,MAAD,CAAxB,CAxBwB,CA0BxB;;AACA,QAAIC,QAAQ,GAAG7N,SAAf;;AACA,QAAI,eAAe6K,GAAnB,EAAwB;AACtB,UAAI,OAAOA,GAAG,CAACiD,SAAX,KAAyB,QAA7B,EAAuC;AACrC,cAAMhO,cAAc,CAAC,mCAAD,EAAsC;AAACkN,UAAAA,KAAK,EAALA;AAAD,SAAtC,CAApB;AACD,OAHqB,CAKtB;;;AACA,UAAInC,GAAG,CAACiD,SAAJ,GAAgB,CAApB,EAAuB;AACrB,cAAMhO,cAAc,CAClB,6CADkB,EAElB;AAACkN,UAAAA,KAAK,EAALA;AAAD,SAFkB,CAApB;AAID;;AAEDa,MAAAA,QAAQ,GAAGhD,GAAG,CAACiD,SAAf;AACD,KA1CuB,CA4CxB;;;AACA,QAAIC,KAAK,GAAG/N,SAAZ;;AACA,QAAI,YAAY6K,GAAhB,EAAqB;AACnB,UAAI,OAAOA,GAAG,CAACmD,MAAX,KAAsB,QAA1B,EAAoC;AAClC,cAAMlO,cAAc,CAAC,gCAAD,EAAmC;AAACkN,UAAAA,KAAK,EAALA;AAAD,SAAnC,CAApB;AACD,OAHkB,CAKnB;;;AACAe,MAAAA,KAAK,GAAGlD,GAAG,CAACmD,MAAZ;AACD,KArDuB,CAuDxB;;;AACA,QAAIC,YAAY,GAAGjO,SAAnB;;AACA,QAAI6K,GAAG,CAACqD,KAAR,EAAe;AACb,UAAIH,KAAK,KAAK/N,SAAd,EAAyB;AACvB,cAAMF,cAAc,CAAC,qCAAD,EAAwC;AAACkN,UAAAA,KAAK,EAALA;AAAD,SAAxC,CAApB;AACD,OAHY,CAKb;AACA;AACA;AACA;;;AACAiB,MAAAA,YAAY,GAAG,IAAIpM,SAAS,CAACsM,MAAd,CAAqBtD,GAAG,CAACqD,KAAzB,EAAgCpE,aAAhC,EAAf;AAEA8D,MAAAA,MAAM,CAACxN,OAAP,CAAe,UAAAgO,OAAO,EAAI;AACxB,YAAInR,eAAe,CAACmN,EAAhB,CAAmBC,KAAnB,CAAyB+D,OAAzB,MAAsC,CAA1C,EAA6C;AAC3C,gBAAMtO,cAAc,CAClB,iEACA,SAFkB,EAGlB;AAACkN,YAAAA,KAAK,EAALA;AAAD,WAHkB,CAApB;AAKD;AACF,OARD;AASD,KA7EuB,CA+ExB;;;AACA,QAAIa,QAAQ,KAAK7N,SAAjB,EAA4B;AAC1B4N,MAAAA,MAAM,CAACxN,OAAP,CAAe,UAAAgO,OAAO,EAAI;AACxBpD,QAAAA,MAAM,CAACgC,KAAD,CAAN,CAAchM,IAAd,CAAmBoN,OAAnB;AACD,OAFD;AAGD,KAJD,MAIO;AAAA;;AACL,UAAMC,eAAe,GAAG,CAACR,QAAD,EAAW,CAAX,CAAxB;AAEAD,MAAAA,MAAM,CAACxN,OAAP,CAAe,UAAAgO,OAAO,EAAI;AACxBC,QAAAA,eAAe,CAACrN,IAAhB,CAAqBoN,OAArB;AACD,OAFD;;AAIA,uBAAApD,MAAM,CAACgC,KAAD,CAAN,EAAchD,MAAd,sBAAwBqE,eAAxB;AACD,KA5FuB,CA8FxB;;;AACA,QAAIJ,YAAJ,EAAkB;AAChBjD,MAAAA,MAAM,CAACgC,KAAD,CAAN,CAAcsB,IAAd,CAAmBL,YAAnB;AACD,KAjGuB,CAmGxB;;;AACA,QAAIF,KAAK,KAAK/N,SAAd,EAAyB;AACvB,UAAI+N,KAAK,KAAK,CAAd,EAAiB;AACf/C,QAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgB,EAAhB,CADe,CACK;AACrB,OAFD,MAEO,IAAIe,KAAK,GAAG,CAAZ,EAAe;AACpB/C,QAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBhC,MAAM,CAACgC,KAAD,CAAN,CAAce,KAAd,CAAoBA,KAApB,CAAhB;AACD,OAFM,MAEA;AACL/C,QAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBhC,MAAM,CAACgC,KAAD,CAAN,CAAce,KAAd,CAAoB,CAApB,EAAuBA,KAAvB,CAAhB;AACD;AACF;AACF,GAzNe;AA0NhBQ,EAAAA,QA1NgB,YA0NPvD,MA1NO,EA0NCgC,KA1ND,EA0NQnC,GA1NR,EA0Na;AAC3B,QAAI,EAAE,sBAAOA,GAAP,MAAe,QAAf,IAA2BA,GAAG,YAAYzH,KAA5C,CAAJ,EAAwD;AACtD,YAAMtD,cAAc,CAAC,mDAAD,CAApB;AACD;;AAEDT,IAAAA,wBAAwB,CAACwL,GAAD,CAAxB;AAEA,QAAM+C,MAAM,GAAG5C,MAAM,CAACgC,KAAD,CAArB;;AAEA,QAAIY,MAAM,KAAK5N,SAAf,EAA0B;AACxBgL,MAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBnC,GAAhB;AACD,KAFD,MAEO,IAAI,EAAE+C,MAAM,YAAYxK,KAApB,CAAJ,EAAgC;AACrC,YAAMtD,cAAc,CAClB,6CADkB,EAElB;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAFkB,CAApB;AAID,KALM,MAKA;AACLY,MAAAA,MAAM,CAAC5M,IAAP,OAAA4M,MAAM,mCAAS/C,GAAT,EAAN;AACD;AACF,GA7Oe;AA8OhB2D,EAAAA,SA9OgB,YA8ONxD,MA9OM,EA8OEgC,KA9OF,EA8OSnC,GA9OT,EA8Oc;AAC5B,QAAI4D,MAAM,GAAG,KAAb;;AAEA,QAAI,sBAAO5D,GAAP,MAAe,QAAnB,EAA6B;AAC3B;AACA,UAAM1K,IAAI,GAAG/B,MAAM,CAAC+B,IAAP,CAAY0K,GAAZ,CAAb;;AACA,UAAI1K,IAAI,CAAC,CAAD,CAAJ,KAAY,OAAhB,EAAyB;AACvBsO,QAAAA,MAAM,GAAG,IAAT;AACD;AACF;;AAED,QAAMC,MAAM,GAAGD,MAAM,GAAG5D,GAAG,CAAC8C,KAAP,GAAe,CAAC9C,GAAD,CAApC;AAEAxL,IAAAA,wBAAwB,CAACqP,MAAD,CAAxB;AAEA,QAAMC,KAAK,GAAG3D,MAAM,CAACgC,KAAD,CAApB;;AACA,QAAI2B,KAAK,KAAK3O,SAAd,EAAyB;AACvBgL,MAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgB0B,MAAhB;AACD,KAFD,MAEO,IAAI,EAAEC,KAAK,YAAYvL,KAAnB,CAAJ,EAA+B;AACpC,YAAMtD,cAAc,CAClB,8CADkB,EAElB;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAFkB,CAApB;AAID,KALM,MAKA;AACL0B,MAAAA,MAAM,CAACtO,OAAP,CAAe,UAAA2G,KAAK,EAAI;AACtB,YAAI4H,KAAK,CAACpL,IAAN,CAAW,UAAA6K,OAAO;AAAA,iBAAInR,eAAe,CAACmN,EAAhB,CAAmBwE,MAAnB,CAA0B7H,KAA1B,EAAiCqH,OAAjC,CAAJ;AAAA,SAAlB,CAAJ,EAAsE;AACpE;AACD;;AAEDO,QAAAA,KAAK,CAAC3N,IAAN,CAAW+F,KAAX;AACD,OAND;AAOD;AACF,GA9Qe;AA+QhB8H,EAAAA,IA/QgB,YA+QX7D,MA/QW,EA+QHgC,KA/QG,EA+QInC,GA/QJ,EA+QS;AACvB,QAAIG,MAAM,KAAKhL,SAAf,EAA0B;AACxB;AACD;;AAED,QAAM8O,KAAK,GAAG9D,MAAM,CAACgC,KAAD,CAApB;;AAEA,QAAI8B,KAAK,KAAK9O,SAAd,EAAyB;AACvB;AACD;;AAED,QAAI,EAAE8O,KAAK,YAAY1L,KAAnB,CAAJ,EAA+B;AAC7B,YAAMtD,cAAc,CAAC,yCAAD,EAA4C;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAA5C,CAApB;AACD;;AAED,QAAI,OAAOnC,GAAP,KAAe,QAAf,IAA2BA,GAAG,GAAG,CAArC,EAAwC;AACtCiE,MAAAA,KAAK,CAAC9E,MAAN,CAAa,CAAb,EAAgB,CAAhB;AACD,KAFD,MAEO;AACL8E,MAAAA,KAAK,CAACzD,GAAN;AACD;AACF,GAnSe;AAoShB0D,EAAAA,KApSgB,YAoSV/D,MApSU,EAoSFgC,KApSE,EAoSKnC,GApSL,EAoSU;AACxB,QAAIG,MAAM,KAAKhL,SAAf,EAA0B;AACxB;AACD;;AAED,QAAMgP,MAAM,GAAGhE,MAAM,CAACgC,KAAD,CAArB;;AACA,QAAIgC,MAAM,KAAKhP,SAAf,EAA0B;AACxB;AACD;;AAED,QAAI,EAAEgP,MAAM,YAAY5L,KAApB,CAAJ,EAAgC;AAC9B,YAAMtD,cAAc,CAClB,kDADkB,EAElB;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAFkB,CAApB;AAID;;AAED,QAAIiC,GAAJ;;AACA,QAAIpE,GAAG,IAAI,IAAP,IAAe,sBAAOA,GAAP,MAAe,QAA9B,IAA0C,EAAEA,GAAG,YAAYzH,KAAjB,CAA9C,EAAuE;AACrE;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA,UAAM3C,OAAO,GAAG,IAAIoB,SAAS,CAACC,OAAd,CAAsB+I,GAAtB,CAAhB;AAEAoE,MAAAA,GAAG,GAAGD,MAAM,CAACE,MAAP,CAAc,UAAAd,OAAO;AAAA,eAAI,CAAC3N,OAAO,CAACC,eAAR,CAAwB0N,OAAxB,EAAiCzN,MAAtC;AAAA,OAArB,CAAN;AACD,KAbD,MAaO;AACLsO,MAAAA,GAAG,GAAGD,MAAM,CAACE,MAAP,CAAc,UAAAd,OAAO;AAAA,eAAI,CAACnR,eAAe,CAACmN,EAAhB,CAAmBwE,MAAnB,CAA0BR,OAA1B,EAAmCvD,GAAnC,CAAL;AAAA,OAArB,CAAN;AACD;;AAEDG,IAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBiC,GAAhB;AACD,GAxUe;AAyUhBE,EAAAA,QAzUgB,YAyUPnE,MAzUO,EAyUCgC,KAzUD,EAyUQnC,GAzUR,EAyUa;AAC3B,QAAI,EAAE,sBAAOA,GAAP,MAAe,QAAf,IAA2BA,GAAG,YAAYzH,KAA5C,CAAJ,EAAwD;AACtD,YAAMtD,cAAc,CAClB,mDADkB,EAElB;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAFkB,CAApB;AAID;;AAED,QAAIhC,MAAM,KAAKhL,SAAf,EAA0B;AACxB;AACD;;AAED,QAAMgP,MAAM,GAAGhE,MAAM,CAACgC,KAAD,CAArB;;AAEA,QAAIgC,MAAM,KAAKhP,SAAf,EAA0B;AACxB;AACD;;AAED,QAAI,EAAEgP,MAAM,YAAY5L,KAApB,CAAJ,EAAgC;AAC9B,YAAMtD,cAAc,CAClB,kDADkB,EAElB;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAFkB,CAApB;AAID;;AAEDhC,IAAAA,MAAM,CAACgC,KAAD,CAAN,GAAgBgC,MAAM,CAACE,MAAP,CAAc,UAAAE,MAAM;AAAA,aAClC,CAACvE,GAAG,CAACtH,IAAJ,CAAS,UAAA6K,OAAO;AAAA,eAAInR,eAAe,CAACmN,EAAhB,CAAmBwE,MAAnB,CAA0BQ,MAA1B,EAAkChB,OAAlC,CAAJ;AAAA,OAAhB,CADiC;AAAA,KAApB,CAAhB;AAGD,GArWe;AAsWhBiB,EAAAA,OAtWgB,YAsWRrE,MAtWQ,EAsWAgC,KAtWA,EAsWOnC,GAtWP,EAsWYD,OAtWZ,EAsWqB3L,GAtWrB,EAsW0B;AACxC;AACA,QAAI2L,OAAO,KAAKC,GAAhB,EAAqB;AACnB,YAAM/K,cAAc,CAAC,wCAAD,EAA2C;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAA3C,CAApB;AACD;;AAED,QAAIhC,MAAM,KAAK,IAAf,EAAqB;AACnB,YAAMlL,cAAc,CAAC,8BAAD,EAAiC;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAAjC,CAApB;AACD;;AAED,QAAI,OAAOnC,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAM/K,cAAc,CAAC,iCAAD,EAAoC;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAApC,CAApB;AACD;;AAED,QAAInC,GAAG,CAACpD,QAAJ,CAAa,IAAb,CAAJ,EAAwB;AACtB;AACA;AACA,YAAM3H,cAAc,CAClB,mEADkB,EAElB;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAFkB,CAApB;AAID;;AAED,QAAIhC,MAAM,KAAKhL,SAAf,EAA0B;AACxB;AACD;;AAED,QAAMoP,MAAM,GAAGpE,MAAM,CAACgC,KAAD,CAArB;AAEA,WAAOhC,MAAM,CAACgC,KAAD,CAAb;AAEA,QAAMlC,QAAQ,GAAGD,GAAG,CAACrD,KAAJ,CAAU,GAAV,CAAjB;AACA,QAAM8H,OAAO,GAAGrE,aAAa,CAAChM,GAAD,EAAM6L,QAAN,EAAgB;AAACI,MAAAA,WAAW,EAAE;AAAd,KAAhB,CAA7B;;AAEA,QAAIoE,OAAO,KAAK,IAAhB,EAAsB;AACpB,YAAMxP,cAAc,CAAC,8BAAD,EAAiC;AAACkN,QAAAA,KAAK,EAALA;AAAD,OAAjC,CAApB;AACD;;AAEDsC,IAAAA,OAAO,CAACxE,QAAQ,CAACO,GAAT,EAAD,CAAP,GAA0B+D,MAA1B;AACD,GA7Ye;AA8YhBG,EAAAA,IA9YgB,YA8YXvE,MA9YW,EA8YHgC,KA9YG,EA8YInC,GA9YJ,EA8YS;AACvB;AACA;AACA,UAAM/K,cAAc,CAAC,uBAAD,EAA0B;AAACkN,MAAAA,KAAK,EAALA;AAAD,KAA1B,CAApB;AACD,GAlZe;AAmZhBwC,EAAAA,EAnZgB,cAmZX,CACH;AACA;AACA;AACA;AACD;AAxZe,CAAlB;AA2ZA,IAAMpE,mBAAmB,GAAG;AAC1ByD,EAAAA,IAAI,EAAE,IADoB;AAE1BE,EAAAA,KAAK,EAAE,IAFmB;AAG1BI,EAAAA,QAAQ,EAAE,IAHgB;AAI1BE,EAAAA,OAAO,EAAE,IAJiB;AAK1B5B,EAAAA,MAAM,EAAE;AALkB,CAA5B,C,CAQA;AACA;AACA;;AACA,IAAMgC,cAAc,GAAG;AACrBC,EAAAA,CAAC,EAAE,kBADkB;AAErB,OAAK,eAFgB;AAGrB,QAAM;AAHe,CAAvB,C,CAMA;;AACA,SAASrQ,wBAAT,CAAkCJ,GAAlC,EAAuC;AACrC,MAAIA,GAAG,IAAI,sBAAOA,GAAP,MAAe,QAA1B,EAAoC;AAClC0Q,IAAAA,IAAI,CAACC,SAAL,CAAe3Q,GAAf,EAAoB,UAACyI,GAAD,EAAMX,KAAN,EAAgB;AAClC8I,MAAAA,sBAAsB,CAACnI,GAAD,CAAtB;AACA,aAAOX,KAAP;AACD,KAHD;AAID;AACF;;AAED,SAAS8I,sBAAT,CAAgCnI,GAAhC,EAAqC;AACnC,MAAIoI,KAAJ;;AACA,MAAI,OAAOpI,GAAP,KAAe,QAAf,KAA4BoI,KAAK,GAAGpI,GAAG,CAACoI,KAAJ,CAAU,WAAV,CAApC,CAAJ,EAAiE;AAC/D,UAAMhQ,cAAc,UAAQ4H,GAAR,kBAAwB+H,cAAc,CAACK,KAAK,CAAC,CAAD,CAAN,CAAtC,CAApB;AACD;AACF,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS7E,aAAT,CAAuBhM,GAAvB,EAA4B6L,QAA5B,EAAoD;AAAA,MAAdpM,OAAc,uEAAJ,EAAI;AAClD,MAAIqR,cAAc,GAAG,KAArB;;AAEA,OAAK,IAAI9N,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6I,QAAQ,CAAClM,MAA7B,EAAqCqD,CAAC,EAAtC,EAA0C;AACxC,QAAM+N,IAAI,GAAG/N,CAAC,KAAK6I,QAAQ,CAAClM,MAAT,GAAkB,CAArC;AACA,QAAIqR,OAAO,GAAGnF,QAAQ,CAAC7I,CAAD,CAAtB;;AAEA,QAAI,CAAC1E,WAAW,CAAC0B,GAAD,CAAhB,EAAuB;AACrB,UAAIP,OAAO,CAACyM,QAAZ,EAAsB;AACpB,eAAOnL,SAAP;AACD;;AAED,UAAMsN,KAAK,GAAGxN,cAAc,2BACFmQ,OADE,sBACsBhR,GADtB,CAA5B;AAGAqO,MAAAA,KAAK,CAACC,gBAAN,GAAyB,IAAzB;AACA,YAAMD,KAAN;AACD;;AAED,QAAIrO,GAAG,YAAYmE,KAAnB,EAA0B;AACxB,UAAI1E,OAAO,CAACwM,WAAZ,EAAyB;AACvB,eAAO,IAAP;AACD;;AAED,UAAI+E,OAAO,KAAK,GAAhB,EAAqB;AACnB,YAAIF,cAAJ,EAAoB;AAClB,gBAAMjQ,cAAc,CAAC,2CAAD,CAApB;AACD;;AAED,YAAI,CAACpB,OAAO,CAACmF,YAAT,IAAyB,CAACnF,OAAO,CAACmF,YAAR,CAAqBjF,MAAnD,EAA2D;AACzD,gBAAMkB,cAAc,CAClB,oEACA,OAFkB,CAApB;AAID;;AAEDmQ,QAAAA,OAAO,GAAGvR,OAAO,CAACmF,YAAR,CAAqB,CAArB,CAAV;AACAkM,QAAAA,cAAc,GAAG,IAAjB;AACD,OAdD,MAcO,IAAIvS,YAAY,CAACyS,OAAD,CAAhB,EAA2B;AAChCA,QAAAA,OAAO,GAAGC,QAAQ,CAACD,OAAD,CAAlB;AACD,OAFM,MAEA;AACL,YAAIvR,OAAO,CAACyM,QAAZ,EAAsB;AACpB,iBAAOnL,SAAP;AACD;;AAED,cAAMF,cAAc,qDACgCmQ,OADhC,OAApB;AAGD;;AAED,UAAID,IAAJ,EAAU;AACRlF,QAAAA,QAAQ,CAAC7I,CAAD,CAAR,GAAcgO,OAAd,CADQ,CACe;AACxB;;AAED,UAAIvR,OAAO,CAACyM,QAAR,IAAoB8E,OAAO,IAAIhR,GAAG,CAACL,MAAvC,EAA+C;AAC7C,eAAOoB,SAAP;AACD;;AAED,aAAOf,GAAG,CAACL,MAAJ,GAAaqR,OAApB,EAA6B;AAC3BhR,QAAAA,GAAG,CAAC+B,IAAJ,CAAS,IAAT;AACD;;AAED,UAAI,CAACgP,IAAL,EAAW;AACT,YAAI/Q,GAAG,CAACL,MAAJ,KAAeqR,OAAnB,EAA4B;AAC1BhR,UAAAA,GAAG,CAAC+B,IAAJ,CAAS,EAAT;AACD,SAFD,MAEO,IAAI,sBAAO/B,GAAG,CAACgR,OAAD,CAAV,MAAwB,QAA5B,EAAsC;AAC3C,gBAAMnQ,cAAc,CAClB,yBAAuBgL,QAAQ,CAAC7I,CAAC,GAAG,CAAL,CAA/B,wBACA0N,IAAI,CAACC,SAAL,CAAe3Q,GAAG,CAACgR,OAAD,CAAlB,CAFkB,CAApB;AAID;AACF;AACF,KArDD,MAqDO;AACLJ,MAAAA,sBAAsB,CAACI,OAAD,CAAtB;;AAEA,UAAI,EAAEA,OAAO,IAAIhR,GAAb,CAAJ,EAAuB;AACrB,YAAIP,OAAO,CAACyM,QAAZ,EAAsB;AACpB,iBAAOnL,SAAP;AACD;;AAED,YAAI,CAACgQ,IAAL,EAAW;AACT/Q,UAAAA,GAAG,CAACgR,OAAD,CAAH,GAAe,EAAf;AACD;AACF;AACF;;AAED,QAAID,IAAJ,EAAU;AACR,aAAO/Q,GAAP;AACD;;AAEDA,IAAAA,GAAG,GAAGA,GAAG,CAACgR,OAAD,CAAT;AACD,GA3FiD,CA6FlD;;AACD","sourcesContent":["import Cursor from './cursor.js';\nimport ObserveHandle from './observe_handle.js';\nimport {\n  hasOwn,\n  isIndexable,\n  isNumericKey,\n  isOperatorObject,\n  populateDocumentWithQueryFields,\n  projectionDetails,\n} from './common.js';\n\n// XXX type checking on selectors (graceful error if malformed)\n\n// LocalCollection: a set of documents that supports queries and modifiers.\nexport default class LocalCollection {\n  constructor(name) {\n    this.name = name;\n    // _id -> document (also containing id)\n    this._docs = new LocalCollection._IdMap;\n\n    this._observeQueue = new Meteor._SynchronousQueue();\n\n    this.next_qid = 1; // live query id generator\n\n    // qid -> live query object. keys:\n    //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n    //  results: array (ordered) or object (unordered) of current results\n    //    (aliased with this._docs!)\n    //  resultsSnapshot: snapshot of results. null if not paused.\n    //  cursor: Cursor object for the query.\n    //  selector, sorter, (callbacks): functions\n    this.queries = Object.create(null);\n\n    // null if not saving originals; an IdMap from id to original document value\n    // if saving originals. See comments before saveOriginals().\n    this._savedOriginals = null;\n\n    // True when observers are paused and we should not send callbacks.\n    this.paused = false;\n  }\n\n  // options may include sort, skip, limit, reactive\n  // sort may be any of these forms:\n  //     {a: 1, b: -1}\n  //     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n  //     [\"a\", [\"b\", \"desc\"]]\n  //   (in the first form you're beholden to key enumeration order in\n  //   your javascript VM)\n  //\n  // reactive: if given, and false, don't register with Tracker (default\n  // is true)\n  //\n  // XXX possibly should support retrieving a subset of fields? and\n  // have it be a hint (ignored on the client, when not copying the\n  // doc?)\n  //\n  // XXX sort does not yet support subkeys ('a.b') .. fix that!\n  // XXX add one more sort form: \"key\"\n  // XXX tests\n  find(selector, options) {\n    // default syntax for everything is to omit the selector argument.\n    // but if selector is explicitly passed in as false or undefined, we\n    // want a selector that matches nothing.\n    if (arguments.length === 0) {\n      selector = {};\n    }\n\n    return new LocalCollection.Cursor(this, selector, options);\n  }\n\n  findOne(selector, options = {}) {\n    if (arguments.length === 0) {\n      selector = {};\n    }\n\n    // NOTE: by setting limit 1 here, we end up using very inefficient\n    // code that recomputes the whole query on each update. The upside is\n    // that when you reactively depend on a findOne you only get\n    // invalidated when the found object changes, not any object in the\n    // collection. Most findOne will be by id, which has a fast path, so\n    // this might not be a big deal. In most cases, invalidation causes\n    // the called to re-query anyway, so this should be a net performance\n    // improvement.\n    options.limit = 1;\n\n    return this.find(selector, options).fetch()[0];\n  }\n\n  // XXX possibly enforce that 'undefined' does not appear (we assume\n  // this in our handling of null and $exists)\n  insert(doc, callback) {\n    doc = EJSON.clone(doc);\n\n    assertHasValidFieldNames(doc);\n\n    // if you really want to use ObjectIDs, set this global.\n    // Mongo.Collection specifies its own ids and does not use this code.\n    if (!hasOwn.call(doc, '_id')) {\n      doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n    }\n\n    const id = doc._id;\n\n    if (this._docs.has(id)) {\n      throw MinimongoError(`Duplicate _id '${id}'`);\n    }\n\n    this._saveOriginal(id, undefined);\n    this._docs.set(id, doc);\n\n    const queriesToRecompute = [];\n\n    // trigger live queries that match\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        return;\n      }\n\n      const matchResult = query.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (query.distances && matchResult.distance !== undefined) {\n          query.distances.set(id, matchResult.distance);\n        }\n\n        if (query.cursor.skip || query.cursor.limit) {\n          queriesToRecompute.push(qid);\n        } else {\n          LocalCollection._insertInResults(query, doc);\n        }\n      }\n    });\n\n    queriesToRecompute.forEach(qid => {\n      if (this.queries[qid]) {\n        this._recomputeResults(this.queries[qid]);\n      }\n    });\n\n    this._observeQueue.drain();\n\n    // Defer because the caller likely doesn't expect the callback to be run\n    // immediately.\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, id);\n      });\n    }\n\n    return id;\n  }\n\n  // Pause the observers. No callbacks from observers will fire until\n  // 'resumeObservers' is called.\n  pauseObservers() {\n    // No-op if already paused.\n    if (this.paused) {\n      return;\n    }\n\n    // Set the 'paused' flag such that new observer messages don't fire.\n    this.paused = true;\n\n    // Take a snapshot of the query results for each query.\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      query.resultsSnapshot = EJSON.clone(query.results);\n    });\n  }\n\n  remove(selector, callback) {\n    // Easy special case: if we're not calling observeChanges callbacks and\n    // we're not saving originals and we got asked to remove everything, then\n    // just empty everything directly.\n    if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n      const result = this._docs.size();\n\n      this._docs.clear();\n\n      Object.keys(this.queries).forEach(qid => {\n        const query = this.queries[qid];\n\n        if (query.ordered) {\n          query.results = [];\n        } else {\n          query.results.clear();\n        }\n      });\n\n      if (callback) {\n        Meteor.defer(() => {\n          callback(null, result);\n        });\n      }\n\n      return result;\n    }\n\n    const matcher = new Minimongo.Matcher(selector);\n    const remove = [];\n\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\n      if (matcher.documentMatches(doc).result) {\n        remove.push(id);\n      }\n    });\n\n    const queriesToRecompute = [];\n    const queryRemove = [];\n\n    for (let i = 0; i < remove.length; i++) {\n      const removeId = remove[i];\n      const removeDoc = this._docs.get(removeId);\n\n      Object.keys(this.queries).forEach(qid => {\n        const query = this.queries[qid];\n\n        if (query.dirty) {\n          return;\n        }\n\n        if (query.matcher.documentMatches(removeDoc).result) {\n          if (query.cursor.skip || query.cursor.limit) {\n            queriesToRecompute.push(qid);\n          } else {\n            queryRemove.push({qid, doc: removeDoc});\n          }\n        }\n      });\n\n      this._saveOriginal(removeId, removeDoc);\n      this._docs.remove(removeId);\n    }\n\n    // run live query callbacks _after_ we've removed the documents.\n    queryRemove.forEach(remove => {\n      const query = this.queries[remove.qid];\n\n      if (query) {\n        query.distances && query.distances.remove(remove.doc._id);\n        LocalCollection._removeFromResults(query, remove.doc);\n      }\n    });\n\n    queriesToRecompute.forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query);\n      }\n    });\n\n    this._observeQueue.drain();\n\n    const result = remove.length;\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  // Resume the observers. Observers immediately receive change\n  // notifications to bring them to the current state of the\n  // database. Note that this is not just replaying all the changes that\n  // happened during the pause, it is a smarter 'coalesced' diff.\n  resumeObservers() {\n    // No-op if not paused.\n    if (!this.paused) {\n      return;\n    }\n\n    // Unset the 'paused' flag. Make sure to do this first, otherwise\n    // observer methods won't actually fire when we trigger them.\n    this.paused = false;\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        query.dirty = false;\n\n        // re-compute results will perform `LocalCollection._diffQueryChanges`\n        // automatically.\n        this._recomputeResults(query, query.resultsSnapshot);\n      } else {\n        // Diff the current results against the snapshot and send to observers.\n        // pass the query object for its observer callbacks.\n        LocalCollection._diffQueryChanges(\n          query.ordered,\n          query.resultsSnapshot,\n          query.results,\n          query,\n          {projectionFn: query.projectionFn}\n        );\n      }\n\n      query.resultsSnapshot = null;\n    });\n\n    this._observeQueue.drain();\n  }\n\n  retrieveOriginals() {\n    if (!this._savedOriginals) {\n      throw new Error('Called retrieveOriginals without saveOriginals');\n    }\n\n    const originals = this._savedOriginals;\n\n    this._savedOriginals = null;\n\n    return originals;\n  }\n\n  // To track what documents are affected by a piece of code, call\n  // saveOriginals() before it and retrieveOriginals() after it.\n  // retrieveOriginals returns an object whose keys are the ids of the documents\n  // that were affected since the call to saveOriginals(), and the values are\n  // equal to the document's contents at the time of saveOriginals. (In the case\n  // of an inserted document, undefined is the value.) You must alternate\n  // between calls to saveOriginals() and retrieveOriginals().\n  saveOriginals() {\n    if (this._savedOriginals) {\n      throw new Error('Called saveOriginals twice without retrieveOriginals');\n    }\n\n    this._savedOriginals = new LocalCollection._IdMap;\n  }\n\n  // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n  update(selector, mod, options, callback) {\n    if (! callback && options instanceof Function) {\n      callback = options;\n      options = null;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const matcher = new Minimongo.Matcher(selector, true);\n\n    // Save the original results of any query that we might need to\n    // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n    // it. (We don't need to save the original results of paused queries because\n    // they already have a resultsSnapshot and we won't be diffing in\n    // _recomputeResults.)\n    const qidToOriginalResults = {};\n\n    // We should only clone each document once, even if it appears in multiple\n    // queries\n    const docMap = new LocalCollection._IdMap;\n    const idsMatched = LocalCollection._idsMatchedBySelector(selector);\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if ((query.cursor.skip || query.cursor.limit) && ! this.paused) {\n        // Catch the case of a reactive `count()` on a cursor with skip\n        // or limit, which registers an unordered observe. This is a\n        // pretty rare case, so we just clone the entire result set with\n        // no optimizations for documents that appear in these result\n        // sets and other queries.\n        if (query.results instanceof LocalCollection._IdMap) {\n          qidToOriginalResults[qid] = query.results.clone();\n          return;\n        }\n\n        if (!(query.results instanceof Array)) {\n          throw new Error('Assertion failed: query.results not an array');\n        }\n\n        // Clones a document to be stored in `qidToOriginalResults`\n        // because it may be modified before the new and old result sets\n        // are diffed. But if we know exactly which document IDs we're\n        // going to modify, then we only need to clone those.\n        const memoizedCloneIfNeeded = doc => {\n          if (docMap.has(doc._id)) {\n            return docMap.get(doc._id);\n          }\n\n          const docToMemoize = (\n            idsMatched &&\n            !idsMatched.some(id => EJSON.equals(id, doc._id))\n          ) ? doc : EJSON.clone(doc);\n\n          docMap.set(doc._id, docToMemoize);\n\n          return docToMemoize;\n        };\n\n        qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n      }\n    });\n\n    const recomputeQids = {};\n\n    let updateCount = 0;\n\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\n      const queryResult = matcher.documentMatches(doc);\n\n      if (queryResult.result) {\n        // XXX Should we save the original even if mod ends up being a no-op?\n        this._saveOriginal(id, doc);\n        this._modifyAndNotify(\n          doc,\n          mod,\n          recomputeQids,\n          queryResult.arrayIndices\n        );\n\n        ++updateCount;\n\n        if (!options.multi) {\n          return false; // break\n        }\n      }\n\n      return true;\n    });\n\n    Object.keys(recomputeQids).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query, qidToOriginalResults[qid]);\n      }\n    });\n\n    this._observeQueue.drain();\n\n    // If we are doing an upsert, and we didn't modify any documents yet, then\n    // it's time to do an insert. Figure out what document we are inserting, and\n    // generate an id for it.\n    let insertedId;\n    if (updateCount === 0 && options.upsert) {\n      const doc = LocalCollection._createUpsertDocument(selector, mod);\n      if (! doc._id && options.insertedId) {\n        doc._id = options.insertedId;\n      }\n\n      insertedId = this.insert(doc);\n      updateCount = 1;\n    }\n\n    // Return the number of affected documents, or in the upsert case, an object\n    // containing the number of affected docs and the id of the doc that was\n    // inserted, if any.\n    let result;\n    if (options._returnObject) {\n      result = {numberAffected: updateCount};\n\n      if (insertedId !== undefined) {\n        result.insertedId = insertedId;\n      }\n    } else {\n      result = updateCount;\n    }\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n  // equivalent to LocalCollection.update(sel, mod, {upsert: true,\n  // _returnObject: true}).\n  upsert(selector, mod, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return this.update(\n      selector,\n      mod,\n      Object.assign({}, options, {upsert: true, _returnObject: true}),\n      callback\n    );\n  }\n\n  // Iterates over a subset of documents that could match selector; calls\n  // fn(doc, id) on each of them.  Specifically, if selector specifies\n  // specific _id's, it only looks at those.  doc is *not* cloned: it is the\n  // same object that is in _docs.\n  _eachPossiblyMatchingDoc(selector, fn) {\n    const specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n    if (specificIds) {\n      specificIds.some(id => {\n        const doc = this._docs.get(id);\n\n        if (doc) {\n          return fn(doc, id) === false;\n        }\n      });\n    } else {\n      this._docs.forEach(fn);\n    }\n  }\n\n  _modifyAndNotify(doc, mod, recomputeQids, arrayIndices) {\n    const matched_before = {};\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        return;\n      }\n\n      if (query.ordered) {\n        matched_before[qid] = query.matcher.documentMatches(doc).result;\n      } else {\n        // Because we don't support skip or limit (yet) in unordered queries, we\n        // can just do a direct lookup.\n        matched_before[qid] = query.results.has(doc._id);\n      }\n    });\n\n    const old_doc = EJSON.clone(doc);\n\n    LocalCollection._modify(doc, mod, {arrayIndices});\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        return;\n      }\n\n      const afterMatch = query.matcher.documentMatches(doc);\n      const after = afterMatch.result;\n      const before = matched_before[qid];\n\n      if (after && query.distances && afterMatch.distance !== undefined) {\n        query.distances.set(doc._id, afterMatch.distance);\n      }\n\n      if (query.cursor.skip || query.cursor.limit) {\n        // We need to recompute any query where the doc may have been in the\n        // cursor's window either before or after the update. (Note that if skip\n        // or limit is set, \"before\" and \"after\" being true do not necessarily\n        // mean that the document is in the cursor's output after skip/limit is\n        // applied... but if they are false, then the document definitely is NOT\n        // in the output. So it's safe to skip recompute if neither before or\n        // after are true.)\n        if (before || after) {\n          recomputeQids[qid] = true;\n        }\n      } else if (before && !after) {\n        LocalCollection._removeFromResults(query, doc);\n      } else if (!before && after) {\n        LocalCollection._insertInResults(query, doc);\n      } else if (before && after) {\n        LocalCollection._updateInResults(query, doc, old_doc);\n      }\n    });\n  }\n\n  // Recomputes the results of a query and runs observe callbacks for the\n  // difference between the previous results and the current results (unless\n  // paused). Used for skip/limit queries.\n  //\n  // When this is used by insert or remove, it can just use query.results for\n  // the old results (and there's no need to pass in oldResults), because these\n  // operations don't mutate the documents in the collection. Update needs to\n  // pass in an oldResults which was deep-copied before the modifier was\n  // applied.\n  //\n  // oldResults is guaranteed to be ignored if the query is not paused.\n  _recomputeResults(query, oldResults) {\n    if (this.paused) {\n      // There's no reason to recompute the results now as we're still paused.\n      // By flagging the query as \"dirty\", the recompute will be performed\n      // when resumeObservers is called.\n      query.dirty = true;\n      return;\n    }\n\n    if (!this.paused && !oldResults) {\n      oldResults = query.results;\n    }\n\n    if (query.distances) {\n      query.distances.clear();\n    }\n\n    query.results = query.cursor._getRawObjects({\n      distances: query.distances,\n      ordered: query.ordered\n    });\n\n    if (!this.paused) {\n      LocalCollection._diffQueryChanges(\n        query.ordered,\n        oldResults,\n        query.results,\n        query,\n        {projectionFn: query.projectionFn}\n      );\n    }\n  }\n\n  _saveOriginal(id, doc) {\n    // Are we even trying to save originals?\n    if (!this._savedOriginals) {\n      return;\n    }\n\n    // Have we previously mutated the original (and so 'doc' is not actually\n    // original)?  (Note the 'has' check rather than truth: we store undefined\n    // here for inserted docs!)\n    if (this._savedOriginals.has(id)) {\n      return;\n    }\n\n    this._savedOriginals.set(id, EJSON.clone(doc));\n  }\n}\n\nLocalCollection.Cursor = Cursor;\n\nLocalCollection.ObserveHandle = ObserveHandle;\n\n// XXX maybe move these into another ObserveHelpers package or something\n\n// _CachingChangeObserver is an object which receives observeChanges callbacks\n// and keeps a cache of the current cursor state up to date in this.docs. Users\n// of this class should read the docs field but not modify it. You should pass\n// the \"applyChange\" field as the callbacks to the underlying observeChanges\n// call. Optionally, you can specify your own observeChanges callbacks which are\n// invoked immediately before the docs field is updated; this object is made\n// available as `this` to those callbacks.\nLocalCollection._CachingChangeObserver = class _CachingChangeObserver {\n  constructor(options = {}) {\n    const orderedFromCallbacks = (\n      options.callbacks &&\n      LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks)\n    );\n\n    if (hasOwn.call(options, 'ordered')) {\n      this.ordered = options.ordered;\n\n      if (options.callbacks && options.ordered !== orderedFromCallbacks) {\n        throw Error('ordered option doesn\\'t match callbacks');\n      }\n    } else if (options.callbacks) {\n      this.ordered = orderedFromCallbacks;\n    } else {\n      throw Error('must provide ordered or callbacks');\n    }\n\n    const callbacks = options.callbacks || {};\n\n    if (this.ordered) {\n      this.docs = new OrderedDict(MongoID.idStringify);\n      this.applyChange = {\n        addedBefore: (id, fields, before) => {\n          const doc = EJSON.clone(fields);\n\n          doc._id = id;\n\n          if (callbacks.addedBefore) {\n            callbacks.addedBefore.call(this, id, fields, before);\n          }\n\n          // This line triggers if we provide added with movedBefore.\n          if (callbacks.added) {\n            callbacks.added.call(this, id, fields);\n          }\n\n          // XXX could `before` be a falsy ID?  Technically\n          // idStringify seems to allow for them -- though\n          // OrderedDict won't call stringify on a falsy arg.\n          this.docs.putBefore(id, doc, before || null);\n        },\n        movedBefore: (id, before) => {\n          const doc = this.docs.get(id);\n\n          if (callbacks.movedBefore) {\n            callbacks.movedBefore.call(this, id, before);\n          }\n\n          this.docs.moveBefore(id, before || null);\n        },\n      };\n    } else {\n      this.docs = new LocalCollection._IdMap;\n      this.applyChange = {\n        added: (id, fields) => {\n          const doc = EJSON.clone(fields);\n\n          if (callbacks.added) {\n            callbacks.added.call(this, id, fields);\n          }\n\n          doc._id = id;\n\n          this.docs.set(id,  doc);\n        },\n      };\n    }\n\n    // The methods in _IdMap and OrderedDict used by these callbacks are\n    // identical.\n    this.applyChange.changed = (id, fields) => {\n      const doc = this.docs.get(id);\n\n      if (!doc) {\n        throw new Error(`Unknown id for changed: ${id}`);\n      }\n\n      if (callbacks.changed) {\n        callbacks.changed.call(this, id, EJSON.clone(fields));\n      }\n\n      DiffSequence.applyChanges(doc, fields);\n    };\n\n    this.applyChange.removed = id => {\n      if (callbacks.removed) {\n        callbacks.removed.call(this, id);\n      }\n\n      this.docs.remove(id);\n    };\n  }\n};\n\nLocalCollection._IdMap = class _IdMap extends IdMap {\n  constructor() {\n    super(MongoID.idStringify, MongoID.idParse);\n  }\n};\n\n// Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\nLocalCollection.wrapTransform = transform => {\n  if (!transform) {\n    return null;\n  }\n\n  // No need to doubly-wrap transforms.\n  if (transform.__wrappedTransform__) {\n    return transform;\n  }\n\n  const wrapped = doc => {\n    if (!hasOwn.call(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error('can only transform documents with _id');\n    }\n\n    const id = doc._id;\n\n    // XXX consider making tracker a weak dependency and checking\n    // Package.tracker here\n    const transformed = Tracker.nonreactive(() => transform(doc));\n\n    if (!LocalCollection._isPlainObject(transformed)) {\n      throw new Error('transform must return object');\n    }\n\n    if (hasOwn.call(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error('transformed document can\\'t have different _id');\n      }\n    } else {\n      transformed._id = id;\n    }\n\n    return transformed;\n  };\n\n  wrapped.__wrappedTransform__ = true;\n\n  return wrapped;\n};\n\n// XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\n// This binary search puts a value between any equal values, and the first\n// lesser value.\nLocalCollection._binarySearch = (cmp, array, value) => {\n  let first = 0;\n  let range = array.length;\n\n  while (range > 0) {\n    const halfRange = Math.floor(range / 2);\n\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      range -= halfRange + 1;\n    } else {\n      range = halfRange;\n    }\n  }\n\n  return first;\n};\n\nLocalCollection._checkSupportedProjection = fields => {\n  if (fields !== Object(fields) || Array.isArray(fields)) {\n    throw MinimongoError('fields option must be an object');\n  }\n\n  Object.keys(fields).forEach(keyPath => {\n    if (keyPath.split('.').includes('$')) {\n      throw MinimongoError(\n        'Minimongo doesn\\'t support $ operator in projections yet.'\n      );\n    }\n\n    const value = fields[keyPath];\n\n    if (typeof value === 'object' &&\n        ['$elemMatch', '$meta', '$slice'].some(key =>\n          hasOwn.call(value, key)\n        )) {\n      throw MinimongoError(\n        'Minimongo doesn\\'t support operators in projections yet.'\n      );\n    }\n\n    if (![1, 0, true, false].includes(value)) {\n      throw MinimongoError(\n        'Projection values should be one of 1, 0, true, or false'\n      );\n    }\n  });\n};\n\n// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\nLocalCollection._compileProjection = fields => {\n  LocalCollection._checkSupportedProjection(fields);\n\n  const _idProjection = fields._id === undefined ? true : fields._id;\n  const details = projectionDetails(fields);\n\n  // returns transformed doc according to ruleTree\n  const transform = (doc, ruleTree) => {\n    // Special case for \"sets\"\n    if (Array.isArray(doc)) {\n      return doc.map(subdoc => transform(subdoc, ruleTree));\n    }\n\n    const result = details.including ? {} : EJSON.clone(doc);\n\n    Object.keys(ruleTree).forEach(key => {\n      if (!hasOwn.call(doc, key)) {\n        return;\n      }\n\n      const rule = ruleTree[key];\n\n      if (rule === Object(rule)) {\n        // For sub-objects/subsets we branch\n        if (doc[key] === Object(doc[key])) {\n          result[key] = transform(doc[key], rule);\n        }\n      } else if (details.including) {\n        // Otherwise we don't even touch this subfield\n        result[key] = EJSON.clone(doc[key]);\n      } else {\n        delete result[key];\n      }\n    });\n\n    return result;\n  };\n\n  return doc => {\n    const result = transform(doc, details.tree);\n\n    if (_idProjection && hasOwn.call(doc, '_id')) {\n      result._id = doc._id;\n    }\n\n    if (!_idProjection && hasOwn.call(result, '_id')) {\n      delete result._id;\n    }\n\n    return result;\n  };\n};\n\n// Calculates the document to insert in case we're doing an upsert and the\n// selector does not match any elements\nLocalCollection._createUpsertDocument = (selector, modifier) => {\n  const selectorDocument = populateDocumentWithQueryFields(selector);\n  const isModify = LocalCollection._isModificationMod(modifier);\n\n  const newDoc = {};\n\n  if (selectorDocument._id) {\n    newDoc._id = selectorDocument._id;\n    delete selectorDocument._id;\n  }\n\n  // This double _modify call is made to help with nested properties (see issue\n  // #8631). We do this even if it's a replacement for validation purposes (e.g.\n  // ambiguous id's)\n  LocalCollection._modify(newDoc, {$set: selectorDocument});\n  LocalCollection._modify(newDoc, modifier, {isInsert: true});\n\n  if (isModify) {\n    return newDoc;\n  }\n\n  // Replacement can take _id from query document\n  const replacement = Object.assign({}, modifier);\n  if (newDoc._id) {\n    replacement._id = newDoc._id;\n  }\n\n  return replacement;\n};\n\nLocalCollection._diffObjects = (left, right, callbacks) => {\n  return DiffSequence.diffObjects(left, right, callbacks);\n};\n\n// ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\nLocalCollection._diffQueryChanges = (ordered, oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options)\n;\n\nLocalCollection._diffQueryOrderedChanges = (oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options)\n;\n\nLocalCollection._diffQueryUnorderedChanges = (oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options)\n;\n\nLocalCollection._findInOrderedResults = (query, doc) => {\n  if (!query.ordered) {\n    throw new Error('Can\\'t call _findInOrderedResults on unordered query');\n  }\n\n  for (let i = 0; i < query.results.length; i++) {\n    if (query.results[i] === doc) {\n      return i;\n    }\n  }\n\n  throw Error('object missing from query');\n};\n\n// If this is a selector which explicitly constrains the match by ID to a finite\n// number of documents, returns a list of their IDs.  Otherwise returns\n// null. Note that the selector may have other restrictions so it may not even\n// match those document!  We care about $in and $and since those are generated\n// access-controlled update and remove.\nLocalCollection._idsMatchedBySelector = selector => {\n  // Is the selector just an ID?\n  if (LocalCollection._selectorIsId(selector)) {\n    return [selector];\n  }\n\n  if (!selector) {\n    return null;\n  }\n\n  // Do we have an _id clause?\n  if (hasOwn.call(selector, '_id')) {\n    // Is the _id clause just an ID?\n    if (LocalCollection._selectorIsId(selector._id)) {\n      return [selector._id];\n    }\n\n    // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?\n    if (selector._id\n        && Array.isArray(selector._id.$in)\n        && selector._id.$in.length\n        && selector._id.$in.every(LocalCollection._selectorIsId)) {\n      return selector._id.$in;\n    }\n\n    return null;\n  }\n\n  // If this is a top-level $and, and any of the clauses constrain their\n  // documents, then the whole selector is constrained by any one clause's\n  // constraint. (Well, by their intersection, but that seems unlikely.)\n  if (Array.isArray(selector.$and)) {\n    for (let i = 0; i < selector.$and.length; ++i) {\n      const subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\n\n      if (subIds) {\n        return subIds;\n      }\n    }\n  }\n\n  return null;\n};\n\nLocalCollection._insertInResults = (query, doc) => {\n  const fields = EJSON.clone(doc);\n\n  delete fields._id;\n\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      const i = LocalCollection._insertInSortedList(\n        query.sorter.getComparator({distances: query.distances}),\n        query.results,\n        doc\n      );\n\n      let next = query.results[i + 1];\n      if (next) {\n        next = next._id;\n      } else {\n        next = null;\n      }\n\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._insertInSortedList = (cmp, array, value) => {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n\n  const i = LocalCollection._binarySearch(cmp, array, value);\n\n  array.splice(i, 0, value);\n\n  return i;\n};\n\nLocalCollection._isModificationMod = mod => {\n  let isModify = false;\n  let isReplace = false;\n\n  Object.keys(mod).forEach(key => {\n    if (key.substr(0, 1) === '$') {\n      isModify = true;\n    } else {\n      isReplace = true;\n    }\n  });\n\n  if (isModify && isReplace) {\n    throw new Error(\n      'Update parameter cannot have both modifier and non-modifier fields.'\n    );\n  }\n\n  return isModify;\n};\n\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\n// RegExp\n// XXX note that _type(undefined) === 3!!!!\nLocalCollection._isPlainObject = x => {\n  return x && LocalCollection._f._type(x) === 3;\n};\n\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = (doc, modifier, options = {}) => {\n  if (!LocalCollection._isPlainObject(modifier)) {\n    throw MinimongoError('Modifier must be an object');\n  }\n\n  // Make sure the caller can't mutate our data structures.\n  modifier = EJSON.clone(modifier);\n\n  const isModifier = isOperatorObject(modifier);\n  const newDoc = isModifier ? EJSON.clone(doc) : modifier;\n\n  if (isModifier) {\n    // apply modifiers to the doc.\n    Object.keys(modifier).forEach(operator => {\n      // Treat $setOnInsert as $set if this is an insert.\n      const setOnInsert = options.isInsert && operator === '$setOnInsert';\n      const modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\n      const operand = modifier[operator];\n\n      if (!modFunc) {\n        throw MinimongoError(`Invalid modifier specified ${operator}`);\n      }\n\n      Object.keys(operand).forEach(keypath => {\n        const arg = operand[keypath];\n\n        if (keypath === '') {\n          throw MinimongoError('An empty update path is not valid.');\n        }\n\n        const keyparts = keypath.split('.');\n\n        if (!keyparts.every(Boolean)) {\n          throw MinimongoError(\n            `The update path '${keypath}' contains an empty field name, ` +\n            'which is not allowed.'\n          );\n        }\n\n        const target = findModTarget(newDoc, keyparts, {\n          arrayIndices: options.arrayIndices,\n          forbidArray: operator === '$rename',\n          noCreate: NO_CREATE_MODIFIERS[operator]\n        });\n\n        modFunc(target, keyparts.pop(), arg, keypath, newDoc);\n      });\n    });\n\n    if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\n      throw MinimongoError(\n        `After applying the update to the document {_id: \"${doc._id}\", ...},` +\n        ' the (immutable) field \\'_id\\' was found to have been altered to ' +\n        `_id: \"${newDoc._id}\"`\n      );\n    }\n  } else {\n    if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\n      throw MinimongoError(\n        `The _id field cannot be changed from {_id: \"${doc._id}\"} to ` +\n        `{_id: \"${modifier._id}\"}`\n      );\n    }\n\n    // replace the whole document\n    assertHasValidFieldNames(modifier);\n  }\n\n  // move new document into place.\n  Object.keys(doc).forEach(key => {\n    // Note: this used to be for (var key in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (key !== '_id') {\n      delete doc[key];\n    }\n  });\n\n  Object.keys(newDoc).forEach(key => {\n    doc[key] = newDoc[key];\n  });\n};\n\nLocalCollection._observeFromObserveChanges = (cursor, observeCallbacks) => {\n  const transform = cursor.getTransform() || (doc => doc);\n  let suppressed = !!observeCallbacks._suppress_initial;\n\n  let observeChangesCallbacks;\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the\n    // linear scans required to generate them.  This lets observers that don't\n    // need absolute indices benefit from the other features of this API --\n    // relative order, transforms, and applyChanges -- without the speed hit.\n    const indices = !observeCallbacks._no_indices;\n\n    observeChangesCallbacks = {\n      addedBefore(id, fields, before) {\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)) {\n          return;\n        }\n\n        const doc = transform(Object.assign(fields, {_id: id}));\n\n        if (observeCallbacks.addedAt) {\n          observeCallbacks.addedAt(\n            doc,\n            indices\n              ? before\n                ? this.docs.indexOf(before)\n                : this.docs.size()\n              : -1,\n            before\n          );\n        } else {\n          observeCallbacks.added(doc);\n        }\n      },\n      changed(id, fields) {\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\n          return;\n        }\n\n        let doc = EJSON.clone(this.docs.get(id));\n        if (!doc) {\n          throw new Error(`Unknown id for changed: ${id}`);\n        }\n\n        const oldDoc = transform(EJSON.clone(doc));\n\n        DiffSequence.applyChanges(doc, fields);\n\n        if (observeCallbacks.changedAt) {\n          observeCallbacks.changedAt(\n            transform(doc),\n            oldDoc,\n            indices ? this.docs.indexOf(id) : -1\n          );\n        } else {\n          observeCallbacks.changed(transform(doc), oldDoc);\n        }\n      },\n      movedBefore(id, before) {\n        if (!observeCallbacks.movedTo) {\n          return;\n        }\n\n        const from = indices ? this.docs.indexOf(id) : -1;\n        let to = indices\n          ? before\n            ? this.docs.indexOf(before)\n            : this.docs.size()\n          : -1;\n\n        // When not moving backwards, adjust for the fact that removing the\n        // document slides everything back one slot.\n        if (to > from) {\n          --to;\n        }\n\n        observeCallbacks.movedTo(\n          transform(EJSON.clone(this.docs.get(id))),\n          from,\n          to,\n          before || null\n        );\n      },\n      removed(id) {\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\n          return;\n        }\n\n        // technically maybe there should be an EJSON.clone here, but it's about\n        // to be removed from this.docs!\n        const doc = transform(this.docs.get(id));\n\n        if (observeCallbacks.removedAt) {\n          observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.removed(doc);\n        }\n      },\n    };\n  } else {\n    observeChangesCallbacks = {\n      added(id, fields) {\n        if (!suppressed && observeCallbacks.added) {\n          observeCallbacks.added(transform(Object.assign(fields, {_id: id})));\n        }\n      },\n      changed(id, fields) {\n        if (observeCallbacks.changed) {\n          const oldDoc = this.docs.get(id);\n          const doc = EJSON.clone(oldDoc);\n\n          DiffSequence.applyChanges(doc, fields);\n\n          observeCallbacks.changed(\n            transform(doc),\n            transform(EJSON.clone(oldDoc))\n          );\n        }\n      },\n      removed(id) {\n        if (observeCallbacks.removed) {\n          observeCallbacks.removed(transform(this.docs.get(id)));\n        }\n      },\n    };\n  }\n\n  const changeObserver = new LocalCollection._CachingChangeObserver({\n    callbacks: observeChangesCallbacks\n  });\n\n  const handle = cursor.observeChanges(changeObserver.applyChange);\n\n  suppressed = false;\n\n  return handle;\n};\n\nLocalCollection._observeCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedAt) {\n    throw new Error('Please specify only one of added() and addedAt()');\n  }\n\n  if (callbacks.changed && callbacks.changedAt) {\n    throw new Error('Please specify only one of changed() and changedAt()');\n  }\n\n  if (callbacks.removed && callbacks.removedAt) {\n    throw new Error('Please specify only one of removed() and removedAt()');\n  }\n\n  return !!(\n    callbacks.addedAt ||\n    callbacks.changedAt ||\n    callbacks.movedTo ||\n    callbacks.removedAt\n  );\n};\n\nLocalCollection._observeChangesCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedBefore) {\n    throw new Error('Please specify only one of added() and addedBefore()');\n  }\n\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\n\nLocalCollection._removeFromResults = (query, doc) => {\n  if (query.ordered) {\n    const i = LocalCollection._findInOrderedResults(query, doc);\n\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    const id = doc._id;  // in case callback mutates doc\n\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\n// Is this selector just shorthand for lookup by _id?\nLocalCollection._selectorIsId = selector =>\n  typeof selector === 'number' ||\n  typeof selector === 'string' ||\n  selector instanceof MongoID.ObjectID\n;\n\n// Is the selector just lookup by _id (shorthand or not)?\nLocalCollection._selectorIsIdPerhapsAsObject = selector =>\n  LocalCollection._selectorIsId(selector) ||\n  LocalCollection._selectorIsId(selector && selector._id) &&\n  Object.keys(selector).length === 1\n;\n\nLocalCollection._updateInResults = (query, doc, old_doc) => {\n  if (!EJSON.equals(doc._id, old_doc._id)) {\n    throw new Error('Can\\'t change a doc\\'s _id while updating');\n  }\n\n  const projectionFn = query.projectionFn;\n  const changedFields = DiffSequence.makeChangedFields(\n    projectionFn(doc),\n    projectionFn(old_doc)\n  );\n\n  if (!query.ordered) {\n    if (Object.keys(changedFields).length) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n\n    return;\n  }\n\n  const old_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (Object.keys(changedFields).length) {\n    query.changed(doc._id, changedFields);\n  }\n\n  if (!query.sorter) {\n    return;\n  }\n\n  // just take it out and put it back in again, and see if the index changes\n  query.results.splice(old_idx, 1);\n\n  const new_idx = LocalCollection._insertInSortedList(\n    query.sorter.getComparator({distances: query.distances}),\n    query.results,\n    doc\n  );\n\n  if (old_idx !== new_idx) {\n    let next = query.results[new_idx + 1];\n    if (next) {\n      next = next._id;\n    } else {\n      next = null;\n    }\n\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n};\n\nconst MODIFIERS = {\n  $currentDate(target, field, arg) {\n    if (typeof arg === 'object' && hasOwn.call(arg, '$type')) {\n      if (arg.$type !== 'date') {\n        throw MinimongoError(\n          'Minimongo does currently only support the date type in ' +\n          '$currentDate modifiers',\n          {field}\n        );\n      }\n    } else if (arg !== true) {\n      throw MinimongoError('Invalid $currentDate modifier', {field});\n    }\n\n    target[field] = new Date();\n  },\n  $min(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $min allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $min modifier to non-number',\n          {field}\n        );\n      }\n\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $max allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $max modifier to non-number',\n          {field}\n        );\n      }\n\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $inc(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $inc allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $inc modifier to non-number',\n          {field}\n        );\n      }\n\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set(target, field, arg) {\n    if (target !== Object(target)) { // not an array or an object\n      const error = MinimongoError(\n        'Cannot set property on non-object field',\n        {field}\n      );\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (target === null) {\n      const error = MinimongoError('Cannot set property on null', {field});\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    assertHasValidFieldNames(arg);\n\n    target[field] = arg;\n  },\n  $setOnInsert(target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) {\n          target[field] = null;\n        }\n      } else {\n        delete target[field];\n      }\n    }\n  },\n  $push(target, field, arg) {\n    if (target[field] === undefined) {\n      target[field] = [];\n    }\n\n    if (!(target[field] instanceof Array)) {\n      throw MinimongoError('Cannot apply $push modifier to non-array', {field});\n    }\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      assertHasValidFieldNames(arg);\n\n      target[field].push(arg);\n\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    const toPush = arg.$each;\n    if (!(toPush instanceof Array)) {\n      throw MinimongoError('$each must be an array', {field});\n    }\n\n    assertHasValidFieldNames(toPush);\n\n    // Parse $position\n    let position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== 'number') {\n        throw MinimongoError('$position must be a numeric value', {field});\n      }\n\n      // XXX should check to make sure integer\n      if (arg.$position < 0) {\n        throw MinimongoError(\n          '$position in $push must be zero or positive',\n          {field}\n        );\n      }\n\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    let slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== 'number') {\n        throw MinimongoError('$slice must be a numeric value', {field});\n      }\n\n      // XXX should check to make sure integer\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    let sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined) {\n        throw MinimongoError('$sort requires $slice to be present', {field});\n      }\n\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n\n      toPush.forEach(element => {\n        if (LocalCollection._f._type(element) !== 3) {\n          throw MinimongoError(\n            '$push like modifiers using $sort require all elements to be ' +\n            'objects',\n            {field}\n          );\n        }\n      });\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      toPush.forEach(element => {\n        target[field].push(element);\n      });\n    } else {\n      const spliceArguments = [position, 0];\n\n      toPush.forEach(element => {\n        spliceArguments.push(element);\n      });\n\n      target[field].splice(...spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction) {\n      target[field].sort(sortFunction);\n    }\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0) {\n        target[field] = []; // differs from Array.slice!\n      } else if (slice < 0) {\n        target[field] = target[field].slice(slice);\n      } else {\n        target[field] = target[field].slice(0, slice);\n      }\n    }\n  },\n  $pushAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n\n    assertHasValidFieldNames(arg);\n\n    const toPush = target[field];\n\n    if (toPush === undefined) {\n      target[field] = arg;\n    } else if (!(toPush instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pushAll modifier to non-array',\n        {field}\n      );\n    } else {\n      toPush.push(...arg);\n    }\n  },\n  $addToSet(target, field, arg) {\n    let isEach = false;\n\n    if (typeof arg === 'object') {\n      // check if first key is '$each'\n      const keys = Object.keys(arg);\n      if (keys[0] === '$each') {\n        isEach = true;\n      }\n    }\n\n    const values = isEach ? arg.$each : [arg];\n\n    assertHasValidFieldNames(values);\n\n    const toAdd = target[field];\n    if (toAdd === undefined) {\n      target[field] = values;\n    } else if (!(toAdd instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $addToSet modifier to non-array',\n        {field}\n      );\n    } else {\n      values.forEach(value => {\n        if (toAdd.some(element => LocalCollection._f._equal(value, element))) {\n          return;\n        }\n\n        toAdd.push(value);\n      });\n    }\n  },\n  $pop(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    const toPop = target[field];\n\n    if (toPop === undefined) {\n      return;\n    }\n\n    if (!(toPop instanceof Array)) {\n      throw MinimongoError('Cannot apply $pop modifier to non-array', {field});\n    }\n\n    if (typeof arg === 'number' && arg < 0) {\n      toPop.splice(0, 1);\n    } else {\n      toPop.pop();\n    }\n  },\n  $pull(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    const toPull = target[field];\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pull/pullAll modifier to non-array',\n        {field}\n      );\n    }\n\n    let out;\n    if (arg != null && typeof arg === 'object' && !(arg instanceof Array)) {\n      // XXX would be much nicer to compile this once, rather than\n      // for each document we modify.. but usually we're not\n      // modifying that many documents, so we'll let it slide for\n      // now\n\n      // XXX Minimongo.Matcher isn't up for the job, because we need\n      // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      // like {$gt: 4} is not normally a complete selector.\n      // same issue as $elemMatch possibly?\n      const matcher = new Minimongo.Matcher(arg);\n\n      out = toPull.filter(element => !matcher.documentMatches(element).result);\n    } else {\n      out = toPull.filter(element => !LocalCollection._f._equal(element, arg));\n    }\n\n    target[field] = out;\n  },\n  $pullAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError(\n        'Modifier $pushAll/pullAll allowed for arrays only',\n        {field}\n      );\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    const toPull = target[field];\n\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pull/pullAll modifier to non-array',\n        {field}\n      );\n    }\n\n    target[field] = toPull.filter(object =>\n      !arg.some(element => LocalCollection._f._equal(object, element))\n    );\n  },\n  $rename(target, field, arg, keypath, doc) {\n    // no idea why mongo has this restriction..\n    if (keypath === arg) {\n      throw MinimongoError('$rename source must differ from target', {field});\n    }\n\n    if (target === null) {\n      throw MinimongoError('$rename source field invalid', {field});\n    }\n\n    if (typeof arg !== 'string') {\n      throw MinimongoError('$rename target must be a string', {field});\n    }\n\n    if (arg.includes('\\0')) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(\n        'The \\'to\\' field for $rename cannot contain an embedded null byte',\n        {field}\n      );\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    const object = target[field];\n\n    delete target[field];\n\n    const keyparts = arg.split('.');\n    const target2 = findModTarget(doc, keyparts, {forbidArray: true});\n\n    if (target2 === null) {\n      throw MinimongoError('$rename target field invalid', {field});\n    }\n\n    target2[keyparts.pop()] = object;\n  },\n  $bit(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError('$bit is not supported', {field});\n  },\n  $v() {\n    // As discussed in https://github.com/meteor/meteor/issues/9623,\n    // the `$v` operator is not needed by Meteor, but problems can occur if\n    // it's not at least callable (as of Mongo >= 3.6). It's defined here as\n    // a no-op to work around these problems.\n  }\n};\n\nconst NO_CREATE_MODIFIERS = {\n  $pop: true,\n  $pull: true,\n  $pullAll: true,\n  $rename: true,\n  $unset: true\n};\n\n// Make sure field names do not contain Mongo restricted\n// characters ('.', '$', '\\0').\n// https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\nconst invalidCharMsg = {\n  $: 'start with \\'$\\'',\n  '.': 'contain \\'.\\'',\n  '\\0': 'contain null bytes'\n};\n\n// checks if all field names in an object are valid\nfunction assertHasValidFieldNames(doc) {\n  if (doc && typeof doc === 'object') {\n    JSON.stringify(doc, (key, value) => {\n      assertIsValidFieldName(key);\n      return value;\n    });\n  }\n}\n\nfunction assertIsValidFieldName(key) {\n  let match;\n  if (typeof key === 'string' && (match = key.match(/^\\$|\\.|\\0/))) {\n    throw MinimongoError(`Key ${key} must not ${invalidCharMsg[match[0]]}`);\n  }\n}\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nfunction findModTarget(doc, keyparts, options = {}) {\n  let usedArrayIndex = false;\n\n  for (let i = 0; i < keyparts.length; i++) {\n    const last = i === keyparts.length - 1;\n    let keypart = keyparts[i];\n\n    if (!isIndexable(doc)) {\n      if (options.noCreate) {\n        return undefined;\n      }\n\n      const error = MinimongoError(\n        `cannot use the part '${keypart}' to traverse ${doc}`\n      );\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (doc instanceof Array) {\n      if (options.forbidArray) {\n        return null;\n      }\n\n      if (keypart === '$') {\n        if (usedArrayIndex) {\n          throw MinimongoError('Too many positional (i.e. \\'$\\') elements');\n        }\n\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError(\n            'The positional operator did not find the match needed from the ' +\n            'query'\n          );\n        }\n\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        throw MinimongoError(\n          `can't append to array using string field name [${keypart}]`\n        );\n      }\n\n      if (last) {\n        keyparts[i] = keypart; // handle 'a.01'\n      }\n\n      if (options.noCreate && keypart >= doc.length) {\n        return undefined;\n      }\n\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n\n      if (!last) {\n        if (doc.length === keypart) {\n          doc.push({});\n        } else if (typeof doc[keypart] !== 'object') {\n          throw MinimongoError(\n            `can't modify field '${keyparts[i + 1]}' of list value ` +\n            JSON.stringify(doc[keypart])\n          );\n        }\n      }\n    } else {\n      assertIsValidFieldName(keypart);\n\n      if (!(keypart in doc)) {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        if (!last) {\n          doc[keypart] = {};\n        }\n      }\n    }\n\n    if (last) {\n      return doc;\n    }\n\n    doc = doc[keypart];\n  }\n\n  // notreached\n}\n"]},"sourceType":"script","hash":"4b396d8a08accd0feb3caede080aa1557b92e3db"}
