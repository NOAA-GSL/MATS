{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_match_util.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_match_util.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_match_util.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/imports/startup/server/data_match_util.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/randyp:mats-common/imports/startup/server/data_match_util.js"}},"code":"let matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\n\n// function for removing unmatched data from a dataset containing multiple curves *without* levels\nconst getMatchedDataSet = function (dataset, curvesLength) {\n  var subSecs = [];\n  var subValues = [];\n  var newSubSecs = [];\n  var newSubValues = [];\n  var independentVarGroups = [];\n  var independentVarHasPoint = [];\n  var currIndependentVar;\n  var curveIndex;\n  var data;\n  var di;\n  var fi;\n  var si; // matching in this function is based on a curve's independent variable. For a timeseries, the independentVar is epoch,\n  // for a profile, it's level, for a dieoff, it's forecast hour, for a threshold plot, it's threshold, and for a\n  // valid time plot, it's hour of day. This function identifies the the independentVar values common across all of\n  // the curves, and then the common sub times/levels/values for those independentVar values.\n  // find the matching independentVars shared across all curves\n\n  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // every curve\n    independentVarGroups[curveIndex] = []; // store the independentVars for each curve that are not null\n\n    independentVarHasPoint[curveIndex] = []; // store the *all* of the independentVars for each curve\n\n    subSecs[curveIndex] = {}; // store the individual record times (subSecs) going into each independentVar for each curve\n\n    data = dataset[curveIndex];\n\n    for (di = 0; di < data.x.length; di++) {\n      // loop over every independentVar value in this curve\n      currIndependentVar = data.x[di];\n\n      if (data.y[di] !== null) {\n        subSecs[curveIndex][currIndependentVar] = data.subSecs[di]; // store raw secs for this independentVar value, since it's not a null point\n\n        independentVarGroups[curveIndex].push(currIndependentVar); // store this independentVar value, since it's not a null point\n      }\n\n      independentVarHasPoint[curveIndex].push(currIndependentVar); // store all the independentVar values, regardless of whether they're null\n    }\n  }\n\n  var matchingIndependentVars = _.intersection.apply(_, independentVarGroups); // find all of the non-null independentVar values common across all the curves\n\n\n  var matchingIndependentHasPoint = _.intersection.apply(_, independentVarHasPoint); // find all of the independentVar values common across all the curves, regardless of whether or not they're null\n\n\n  var subSecIntersection = {}; // eventually find the intersecting subSecs for each common non-null independentVar value\n\n  for (fi = 0; fi < matchingIndependentVars.length; fi++) {\n    // loop over each common non-null independentVar value\n    currIndependentVar = matchingIndependentVars[fi];\n    var currSubSecIntersection = subSecs[0][currIndependentVar]; // fill current subSecs intersection array with subSecs from the first curve\n\n    for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {\n      // loop over every curve\n      currSubSecIntersection = _.intersection(currSubSecIntersection, subSecs[curveIndex][currIndependentVar]); // keep taking the intersection of the current subSecs intersection array with each curve's subSecs array for this independentVar value\n    }\n\n    subSecIntersection[currIndependentVar] = currSubSecIntersection; // store the final intersecting subSecs array for this common non-null independentVar value\n  } // remove non-matching independentVars and subSecs\n\n\n  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // loop over every curve\n    data = dataset[curveIndex]; // need to loop backwards through the data array so that we can splice non-matching indices\n    // while still having the remaining indices in the correct order\n\n    var dataLength = data.x.length;\n\n    for (di = dataLength - 1; di >= 0; di--) {\n      if (matchingIndependentVars.indexOf(data.x[di]) === -1) {\n        // if this is not a common non-null independentVar value, we'll have to remove some data\n        if (matchingIndependentHasPoint.indexOf(data.x[di]) === -1) {\n          // if at least one curve doesn't even have a null here, much less a matching value (beacause of the cadence), just drop this independentVar\n          data.x.splice(di, 1);\n          data.y.splice(di, 1);\n          data.error_y.array.splice(di, 1);\n          data.subVals.splice(di, 1);\n          data.subSecs.splice(di, 1);\n          data.stats.splice(di, 1);\n          data.text.splice(di, 1);\n        } else {\n          // if all of the curves have either data or nulls at this independentVar, and there is at least one null, ensure all of the curves are null\n          data.y[di] = null;\n          data.subVals[di] = NaN;\n          data.subSecs[di] = NaN;\n        }\n\n        continue; // then move on to the next independentVar. There's no need to mess with the subSecs\n      }\n\n      subSecs = data.subSecs[di];\n      subValues = data.subVals[di];\n\n      if (subSecs.length > 0) {\n        currIndependentVar = data.x[di];\n        newSubValues = [];\n        newSubSecs = [];\n\n        for (si = 0; si < subSecs.length; si++) {\n          // loop over all subSecs for this independentVar\n          if (subSecIntersection[currIndependentVar].indexOf(subSecs[si]) !== -1) {\n            // keep the subValue only if its associated subSec is common to all curves for this independentVar\n            var newVal = subValues[si];\n            var newSec = subSecs[si];\n\n            if (newVal !== undefined) {\n              newSubValues.push(newVal);\n              newSubSecs.push(newSec);\n            }\n          }\n        } // store the filtered data\n\n\n        data.subVals[di] = newSubValues;\n        data.subSecs[di] = newSubSecs;\n      }\n    }\n\n    dataset[curveIndex] = data;\n  }\n\n  return dataset;\n}; // function for removing unmatched data from a dataset containing multiple curves *with* levels\n\n\nconst getMatchedDataSetWithLevels = function (dataset, curvesLength, plotType) {\n  var subSecs = [];\n  var subLevs = [];\n  var subValues = [];\n  var newSubSecs = [];\n  var newSubLevs = [];\n  var newSubValues = [];\n  var independentVarGroups = [];\n  var independentVarHasPoint = [];\n  var currIndependentVar;\n  var curveIndex;\n  var data;\n  var di;\n  var fi;\n  var si; // matching in this function is based on a curve's independent variable. For a timeseries, the independentVar is epoch,\n  // for a profile, it's level, for a dieoff, it's forecast hour, for a threshold plot, it's threshold, and for a\n  // valid time plot, it's hour of day. This function identifies the the independentVar values common across all of\n  // the curves, and then the common sub times/levels/values for those independentVar values.\n  //determine whether data.x or data.y is the independent variable, and which is the stat value\n\n  var independentVarName;\n  var statVarName;\n\n  if (plotType !== matsTypes.PlotTypes.profile) {\n    independentVarName = 'x';\n    statVarName = 'y';\n  } else {\n    independentVarName = 'y';\n    statVarName = 'x';\n  }\n\n  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // every curve\n    independentVarGroups[curveIndex] = []; // store the independentVars for each curve that are not null\n\n    independentVarHasPoint[curveIndex] = []; // store the *all* of the independentVars for each curve\n\n    subSecs[curveIndex] = {}; // store the individual record times (subSecs) going into each independentVar for each curve\n\n    subLevs[curveIndex] = {}; // store the individual record levels (subLevs) going into each independentVar for each curve\n\n    data = dataset[curveIndex];\n\n    for (di = 0; di < data[independentVarName].length; di++) {\n      // loop over every independentVar value in this curve\n      currIndependentVar = data[independentVarName][di];\n\n      if (data[statVarName][di] !== null) {\n        subSecs[curveIndex][currIndependentVar] = data.subSecs[di]; // store raw secs for this independentVar value, since it's not a null point\n\n        subLevs[curveIndex][currIndependentVar] = data.subLevs[di]; // store raw levs for this independentVar value, since it's not a null point\n\n        independentVarGroups[curveIndex].push(currIndependentVar); // store this independentVar value, since it's not a null point\n      }\n\n      independentVarHasPoint[curveIndex].push(currIndependentVar); // store all the independentVar values, regardless of whether they're null\n    }\n  }\n\n  var matchingIndependentVars = _.intersection.apply(_, independentVarGroups); // find all of the non-null independentVar values common across all the curves\n\n\n  var matchingIndependentHasPoint = _.intersection.apply(_, independentVarHasPoint); // find all of the independentVar values common across all the curves, regardless of whether or not they're null\n\n\n  var subIntersections = []; // eventually find the intersecting subSecs and subLevs for each common non-null independentVar value\n\n  for (fi = 0; fi < matchingIndependentVars.length; fi++) {\n    // loop over each common non-null independentVar value\n    currIndependentVar = matchingIndependentVars[fi];\n    subIntersections[currIndependentVar] = [];\n    var currSubIntersections = [];\n\n    for (si = 0; si < subSecs[0][currIndependentVar].length; si++) {\n      // fill current intersection array with sec-lev pairs from the first curve\n      currSubIntersections.push([subSecs[0][currIndependentVar][si], subLevs[0][currIndependentVar][si]]);\n    }\n\n    for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {\n      // loop over every curve after the first\n      var tempSubIntersections = [];\n      var tempPair;\n\n      for (si = 0; si < subSecs[curveIndex][currIndependentVar].length; si++) {\n        // loop over every subSecs value\n        tempPair = [subSecs[curveIndex][currIndependentVar][si], subLevs[curveIndex][currIndependentVar][si]]; // create an individual sec-lev pair for each index in the subSecs and subLevs arrays\n\n        if (matsDataUtils.arrayContainsSubArray(currSubIntersections, tempPair)) {\n          // see if the individual sec-lev pair matches a pair from the current intersection array\n          tempSubIntersections.push(tempPair); // store matching pairs\n        }\n      }\n\n      currSubIntersections = tempSubIntersections; //replace current intersection array with array of only pairs that matched from this loop through.\n    }\n\n    subIntersections[currIndependentVar] = currSubIntersections; // store the final intersecting subSecs array for this common non-null independentVar value\n  } // remove non-matching independentVars and subSecs\n\n\n  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // loop over every curve\n    data = dataset[curveIndex]; // need to loop backwards through the data array so that we can splice non-matching indices\n    // while still having the remaining indices in the correct order\n\n    var dataLength = data[independentVarName].length;\n\n    for (di = dataLength - 1; di >= 0; di--) {\n      if (matchingIndependentVars.indexOf(data[independentVarName][di]) === -1) {\n        // if this is not a common non-null independentVar value, we'll have to remove some data\n        if (matchingIndependentHasPoint.indexOf(data[independentVarName][di]) === -1) {\n          // if at least one curve doesn't even have a null here, much less a matching value (beacause of the cadence), just drop this independentVar\n          data.x.splice(di, 1);\n          data.y.splice(di, 1);\n          data['error_' + statVarName].array.splice(di, 1);\n          data.subVals.splice(di, 1);\n          data.subSecs.splice(di, 1);\n          data.subLevs.splice(di, 1);\n          data.stats.splice(di, 1);\n          data.text.splice(di, 1);\n        } else {\n          // if all of the curves have either data or nulls at this independentVar, and there is at least one null, ensure all of the curves are null\n          data[statVarName][di] = null;\n          data.subVals[di] = NaN;\n          data.subSecs[di] = NaN;\n          data.subLevs[di] = NaN;\n        }\n\n        continue; // then move on to the next independentVar. There's no need to mess with the subSecs or subLevs\n      }\n\n      subSecs = data.subSecs[di];\n      subLevs = data.subLevs[di];\n      subValues = data.subVals[di];\n\n      if (subSecs.length > 0 && subLevs.length > 0) {\n        currIndependentVar = data[independentVarName][di];\n        newSubValues = [];\n        newSubSecs = [];\n        newSubLevs = [];\n\n        for (si = 0; si < subSecs.length; si++) {\n          // loop over all subSecs for this independentVar\n          tempPair = [subSecs[si], subLevs[si]]; //create sec-lev pair for each sub value\n\n          if (matsDataUtils.arrayContainsSubArray(subIntersections[currIndependentVar], tempPair)) {\n            // keep the subValue only if its sec-lev pair is common to all curves for this independentVar\n            var newVal = subValues[si];\n            var newSec = subSecs[si];\n            var newLev = subLevs[si];\n\n            if (newVal !== undefined) {\n              newSubValues.push(newVal);\n              newSubSecs.push(newSec);\n              newSubLevs.push(newLev);\n            }\n          }\n        } // store the filtered data\n\n\n        data.subVals[di] = newSubValues;\n        data.subSecs[di] = newSubSecs;\n        data.subLevs[di] = newSubLevs;\n      }\n    }\n\n    dataset[curveIndex] = data;\n  }\n\n  return dataset;\n}; // function for removing unmatched data from a dataset containing multiple curves for a histogram *without* levels.\n// separate matching functions are needed for histograms because you have to take all of the data out of the bins, then\n// match it, then recalculate the bins. For other plot types, you can just leave the data in its already-sorted fhr, level, etc.\n\n\nconst getMatchedDataSetHistogram = function (dataset, curvesLength, binStats) {\n  var subStatsRaw = {};\n  var subSecsRaw = {};\n  var subStats = {};\n  var subSecs = {};\n  var newSubStats = {};\n  var newSubSecs = {};\n  var newCurveData;\n  var curveIndex;\n  var di;\n  var si; // pull all subSecs and subStats out of their bins, and back into one master array\n\n  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    data = dataset[curveIndex];\n    subStatsRaw[curveIndex] = [];\n    subSecsRaw[curveIndex] = [];\n    subStats[curveIndex] = [];\n    subSecs[curveIndex] = [];\n\n    for (di = 0; di < data.x.length; di++) {\n      subStatsRaw[curveIndex].push(data.subVals[di]);\n      subSecsRaw[curveIndex].push(data.subSecs[di]);\n    }\n\n    subStats[curveIndex] = [].concat.apply([], subStatsRaw[curveIndex]);\n    subSecs[curveIndex] = [].concat.apply([], subSecsRaw[curveIndex]);\n  } // determine which seconds are present in all curves\n\n\n  var subSecIntersection = subSecs[0]; // fill current subSecs intersection array with subSecs from the first curve\n\n  for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {\n    // loop over every curve\n    subSecIntersection = _.intersection(subSecIntersection, subSecs[curveIndex]); // keep taking the intersection of the current subSecs intersection array with each curve's subSecs array\n  } // remove non-matching subSecs and subStats\n\n\n  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // loop over every curve\n    data = dataset[curveIndex];\n\n    if (subSecIntersection.length > 0) {\n      newSubStats[curveIndex] = [];\n      newSubSecs[curveIndex] = [];\n\n      for (si = 0; si < subSecs[curveIndex].length; si++) {\n        // loop over all subSecs for this curve\n        if (subSecIntersection.indexOf(subSecs[curveIndex][si]) !== -1) {\n          // keep the subStat only if its associated subSec is common to all curves\n          var newStat = subStats[curveIndex][si];\n          var newSec = subSecs[curveIndex][si];\n\n          if (newStat !== undefined) {\n            newSubStats[curveIndex].push(newStat);\n            newSubSecs[curveIndex].push(newSec);\n          }\n        }\n      } // re-sort all of the data into histogram bins\n\n\n      var d = {\n        // d will contain the curve data\n        x: [],\n        //placeholder\n        y: [],\n        //placeholder\n        error_x: [],\n        // unused\n        error_y: [],\n        // unused\n        subVals: [],\n        subSecs: [],\n        subLevs: [],\n        glob_stats: {},\n        // placeholder\n        bin_stats: [],\n        // placeholder\n        text: [],\n        //placeholder\n        xmin: Number.MAX_VALUE,\n        xmax: Number.MIN_VALUE,\n        ymin: Number.MAX_VALUE,\n        ymax: Number.MIN_VALUE\n      };\n      newCurveData = matsDataUtils.sortHistogramBins(newSubStats[curveIndex], newSubSecs[curveIndex], [], data.x.length, binStats, false, d);\n      var newCurveDataKeys = Object.keys(newCurveData.d);\n\n      for (var didx = 0; didx < newCurveDataKeys.length; didx++) {\n        dataset[curveIndex][newCurveDataKeys[didx]] = newCurveData.d[newCurveDataKeys[didx]];\n      }\n    } else {\n      // if there are no matching values, set data to an empty array\n      dataset[curveIndex] = {\n        x: [],\n        y: [],\n        error_x: [],\n        error_y: [],\n        subVals: [],\n        subSecs: [],\n        subLevs: [],\n        glob_stats: {},\n        bin_stats: [],\n        text: [],\n        xmin: Number.MAX_VALUE,\n        xmax: Number.MIN_VALUE,\n        ymin: Number.MAX_VALUE,\n        ymax: Number.MIN_VALUE\n      };\n    }\n  }\n\n  return dataset;\n}; // function for removing unmatched data from a dataset containing multiple curves for a histogram *with* levels.\n// separate matching functions are needed for histograms because you have to take all of the data out of the bins, then\n// match it, then recalculate the bins. For other plot types, you can just leave the data in its already-sorted fhr, level, etc.\n\n\nconst getMatchedDataSetHistogramWithLevels = function (dataset, curvesLength, binStats) {\n  var subStatsRaw = {};\n  var subSecsRaw = {};\n  var subLevsRaw = {};\n  var subStats = {};\n  var subSecs = {};\n  var subLevs = {};\n  var newSubStats = {};\n  var newSubSecs = {};\n  var newSubLevs = {};\n  var newCurveData;\n  var curveIndex;\n  var di;\n  var si; // pull all subSecs and subStats out of their bins, and back into one master array\n\n  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    data = dataset[curveIndex];\n    subStatsRaw[curveIndex] = [];\n    subSecsRaw[curveIndex] = [];\n    subLevsRaw[curveIndex] = [];\n    subStats[curveIndex] = [];\n    subSecs[curveIndex] = [];\n    subLevs[curveIndex] = [];\n\n    for (di = 0; di < data.x.length; di++) {\n      subStatsRaw[curveIndex].push(data.subVals[di]);\n      subSecsRaw[curveIndex].push(data.subSecs[di]);\n      subLevsRaw[curveIndex].push(data.subLevs[di]);\n    }\n\n    subStats[curveIndex] = [].concat.apply([], subStatsRaw[curveIndex]);\n    subSecs[curveIndex] = [].concat.apply([], subSecsRaw[curveIndex]);\n    subLevs[curveIndex] = [].concat.apply([], subLevsRaw[curveIndex]);\n  } // determine which seconds and levels are present in all curves\n\n\n  var subIntersections = []; // eventually find the intersecting subSecs and subLevs across all curves\n\n  for (si = 0; si < subSecs[0].length; si++) {\n    // fill current intersection array with sec-lev pairs from the first curve\n    subIntersections.push([subSecs[0][si], subLevs[0][si]]);\n  }\n\n  for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) {\n    // loop over every curve after the first\n    var tempSubIntersections = [];\n    var tempPair;\n\n    for (si = 0; si < subSecs[curveIndex].length; si++) {\n      // loop over every subSecs value\n      tempPair = [subSecs[curveIndex][si], subLevs[curveIndex][si]]; // create an individual sec-lev pair for each index in the subSecs and subLevs arrays\n\n      if (matsDataUtils.arrayContainsSubArray(subIntersections, tempPair)) {\n        // see if the individual sec-lev pair matches a pair from the current intersection array\n        tempSubIntersections.push(tempPair); // store matching pairs\n      }\n    }\n\n    subIntersections = tempSubIntersections; //replace current intersection array with array of only pairs that matched from this loop through.\n  } // remove non-matching subSecs, subLevs, and subStats\n\n\n  for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // loop over every curve\n    data = dataset[curveIndex];\n\n    if (subIntersections.length > 0) {\n      newSubStats[curveIndex] = [];\n      newSubSecs[curveIndex] = [];\n      newSubLevs[curveIndex] = [];\n\n      for (si = 0; si < subSecs[curveIndex].length; si++) {\n        // loop over all subSecs for this curve\n        tempPair = [subSecs[curveIndex][si], subLevs[curveIndex][si]]; //create sec-lev pair for each subStat\n\n        if (matsDataUtils.arrayContainsSubArray(subIntersections, tempPair)) {\n          // keep the subStat only if its sec-lev pair is common to all curves\n          var newStat = subStats[curveIndex][si];\n          var newSec = subSecs[curveIndex][si];\n          var newLev = subLevs[curveIndex][si];\n\n          if (newStat !== undefined) {\n            newSubStats[curveIndex].push(newStat);\n            newSubSecs[curveIndex].push(newSec);\n            newSubLevs[curveIndex].push(newLev);\n          }\n        }\n      } // re-sort all of the data into histogram bins\n\n\n      var d = {\n        // d will contain the curve data\n        x: [],\n        //placeholder\n        y: [],\n        //placeholder\n        error_x: [],\n        // unused\n        error_y: [],\n        // unused\n        subVals: [],\n        subSecs: [],\n        subLevs: [],\n        glob_stats: {},\n        // placeholder\n        bin_stats: [],\n        // placeholder\n        text: [],\n        //placeholder\n        xmin: Number.MAX_VALUE,\n        xmax: Number.MIN_VALUE,\n        ymin: Number.MAX_VALUE,\n        ymax: Number.MIN_VALUE\n      };\n      newCurveData = matsDataUtils.sortHistogramBins(newSubStats[curveIndex], newSubSecs[curveIndex], newSubLevs[curveIndex], data.x.length, binStats, true, d);\n      var newCurveDataKeys = Object.keys(newCurveData.d);\n\n      for (var didx = 0; didx < newCurveDataKeys.length; didx++) {\n        dataset[curveIndex][newCurveDataKeys[didx]] = newCurveData.d[newCurveDataKeys[didx]];\n      }\n    } else {\n      // if there are no matching values, set data to an empty dataset\n      dataset[curveIndex] = {\n        x: [],\n        y: [],\n        error_x: [],\n        error_y: [],\n        subVals: [],\n        subSecs: [],\n        subLevs: [],\n        glob_stats: {},\n        bin_stats: [],\n        text: [],\n        xmin: Number.MAX_VALUE,\n        xmax: Number.MIN_VALUE,\n        ymin: Number.MAX_VALUE,\n        ymax: Number.MIN_VALUE\n      };\n    }\n  }\n\n  return dataset;\n};\n\nmodule.exportDefault(matsDataMatchUtils = {\n  getMatchedDataSet: getMatchedDataSet,\n  getMatchedDataSetWithLevels: getMatchedDataSetWithLevels,\n  getMatchedDataSetHistogram: getMatchedDataSetHistogram,\n  getMatchedDataSetHistogramWithLevels: getMatchedDataSetHistogramWithLevels\n});","map":{"version":3,"sources":["packages/randyp:mats-common/imports/startup/server/data_match_util.js"],"names":["matsDataUtils","module","link","v","matsTypes","getMatchedDataSet","dataset","curvesLength","subSecs","subValues","newSubSecs","newSubValues","independentVarGroups","independentVarHasPoint","currIndependentVar","curveIndex","data","di","fi","si","x","length","y","push","matchingIndependentVars","_","intersection","apply","matchingIndependentHasPoint","subSecIntersection","currSubSecIntersection","dataLength","indexOf","splice","error_y","array","subVals","stats","text","NaN","newVal","newSec","undefined","getMatchedDataSetWithLevels","plotType","subLevs","newSubLevs","independentVarName","statVarName","PlotTypes","profile","subIntersections","currSubIntersections","tempSubIntersections","tempPair","arrayContainsSubArray","newLev","getMatchedDataSetHistogram","binStats","subStatsRaw","subSecsRaw","subStats","newSubStats","newCurveData","concat","newStat","d","error_x","glob_stats","bin_stats","xmin","Number","MAX_VALUE","xmax","MIN_VALUE","ymin","ymax","sortHistogramBins","newCurveDataKeys","Object","keys","didx","getMatchedDataSetHistogramWithLevels","subLevsRaw","exportDefault","matsDataMatchUtils"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\n\n// function for removing unmatched data from a dataset containing multiple curves *without* levels\nconst getMatchedDataSet = function (dataset, curvesLength) {\n\n    var subSecs = [];\n    var subValues = [];\n    var newSubSecs = [];\n    var newSubValues = [];\n    var independentVarGroups = [];\n    var independentVarHasPoint = [];\n    var currIndependentVar;\n    var curveIndex;\n    var data;\n    var di;\n    var fi;\n    var si;\n\n    // matching in this function is based on a curve's independent variable. For a timeseries, the independentVar is epoch,\n    // for a profile, it's level, for a dieoff, it's forecast hour, for a threshold plot, it's threshold, and for a\n    // valid time plot, it's hour of day. This function identifies the the independentVar values common across all of\n    // the curves, and then the common sub times/levels/values for those independentVar values.\n\n    // find the matching independentVars shared across all curves\n    for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) { // every curve\n        independentVarGroups[curveIndex] = [];  // store the independentVars for each curve that are not null\n        independentVarHasPoint[curveIndex] = [];   // store the *all* of the independentVars for each curve\n        subSecs[curveIndex] = {};  // store the individual record times (subSecs) going into each independentVar for each curve\n        data = dataset[curveIndex];\n        for (di = 0; di < data.x.length; di++) { // loop over every independentVar value in this curve\n            currIndependentVar = data.x[di];\n            if (data.y[di] !== null) {\n                subSecs[curveIndex][currIndependentVar] = data.subSecs[di];   // store raw secs for this independentVar value, since it's not a null point\n                independentVarGroups[curveIndex].push(currIndependentVar);   // store this independentVar value, since it's not a null point\n            }\n            independentVarHasPoint[curveIndex].push(currIndependentVar);    // store all the independentVar values, regardless of whether they're null\n        }\n    }\n\n    var matchingIndependentVars = _.intersection.apply(_, independentVarGroups);    // find all of the non-null independentVar values common across all the curves\n    var matchingIndependentHasPoint = _.intersection.apply(_, independentVarHasPoint);    // find all of the independentVar values common across all the curves, regardless of whether or not they're null\n    var subSecIntersection = {};       // eventually find the intersecting subSecs for each common non-null independentVar value\n\n    for (fi = 0; fi < matchingIndependentVars.length; fi++) { // loop over each common non-null independentVar value\n        currIndependentVar = matchingIndependentVars[fi];\n        var currSubSecIntersection = subSecs[0][currIndependentVar];   // fill current subSecs intersection array with subSecs from the first curve\n        for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) { // loop over every curve\n            currSubSecIntersection = _.intersection(currSubSecIntersection, subSecs[curveIndex][currIndependentVar]);   // keep taking the intersection of the current subSecs intersection array with each curve's subSecs array for this independentVar value\n        }\n        subSecIntersection[currIndependentVar] = currSubSecIntersection;   // store the final intersecting subSecs array for this common non-null independentVar value\n    }\n\n    // remove non-matching independentVars and subSecs\n    for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) { // loop over every curve\n        data = dataset[curveIndex];\n\n        // need to loop backwards through the data array so that we can splice non-matching indices\n        // while still having the remaining indices in the correct order\n        var dataLength = data.x.length;\n        for (di = dataLength - 1; di >= 0; di--) {\n\n            if (matchingIndependentVars.indexOf(data.x[di]) === -1) {  // if this is not a common non-null independentVar value, we'll have to remove some data\n                if (matchingIndependentHasPoint.indexOf(data.x[di]) === -1) {   // if at least one curve doesn't even have a null here, much less a matching value (beacause of the cadence), just drop this independentVar\n                    data.x.splice(di, 1);\n                    data.y.splice(di, 1);\n                    data.error_y.array.splice(di, 1);\n                    data.subVals.splice(di, 1);\n                    data.subSecs.splice(di, 1);\n                    data.stats.splice(di, 1);\n                    data.text.splice(di, 1);\n                } else {    // if all of the curves have either data or nulls at this independentVar, and there is at least one null, ensure all of the curves are null\n                    data.y[di] = null;\n                    data.subVals[di] = NaN;\n                    data.subSecs[di] = NaN;\n                }\n                continue;   // then move on to the next independentVar. There's no need to mess with the subSecs\n            }\n            subSecs = data.subSecs[di];\n            subValues = data.subVals[di];\n\n            if (subSecs.length > 0) {\n                currIndependentVar = data.x[di];\n                newSubValues = [];\n                newSubSecs = [];\n                for (si = 0; si < subSecs.length; si++) {  // loop over all subSecs for this independentVar\n                    if (subSecIntersection[currIndependentVar].indexOf(subSecs[si]) !== -1) { // keep the subValue only if its associated subSec is common to all curves for this independentVar\n                        var newVal = subValues[si];\n                        var newSec = subSecs[si];\n                        if (newVal !== undefined) {\n                            newSubValues.push(newVal);\n                            newSubSecs.push(newSec);\n                        }\n                    }\n                }\n                // store the filtered data\n                data.subVals[di] = newSubValues;\n                data.subSecs[di] = newSubSecs;\n            }\n        }\n        dataset[curveIndex] = data;\n    }\n\n    return dataset;\n};\n\n// function for removing unmatched data from a dataset containing multiple curves *with* levels\nconst getMatchedDataSetWithLevels = function (dataset, curvesLength, plotType) {\n\n    var subSecs = [];\n    var subLevs = [];\n    var subValues = [];\n    var newSubSecs = [];\n    var newSubLevs = [];\n    var newSubValues = [];\n    var independentVarGroups = [];\n    var independentVarHasPoint = [];\n    var currIndependentVar;\n    var curveIndex;\n    var data;\n    var di;\n    var fi;\n    var si;\n\n    // matching in this function is based on a curve's independent variable. For a timeseries, the independentVar is epoch,\n    // for a profile, it's level, for a dieoff, it's forecast hour, for a threshold plot, it's threshold, and for a\n    // valid time plot, it's hour of day. This function identifies the the independentVar values common across all of\n    // the curves, and then the common sub times/levels/values for those independentVar values.\n\n    //determine whether data.x or data.y is the independent variable, and which is the stat value\n    var independentVarName;\n    var statVarName;\n    if (plotType !== matsTypes.PlotTypes.profile) {\n        independentVarName = 'x';\n        statVarName = 'y';\n    } else {\n        independentVarName = 'y';\n        statVarName = 'x';\n    }\n\n    for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) { // every curve\n        independentVarGroups[curveIndex] = [];  // store the independentVars for each curve that are not null\n        independentVarHasPoint[curveIndex] = [];   // store the *all* of the independentVars for each curve\n        subSecs[curveIndex] = {};  // store the individual record times (subSecs) going into each independentVar for each curve\n        subLevs[curveIndex] = {};  // store the individual record levels (subLevs) going into each independentVar for each curve\n        data = dataset[curveIndex];\n        for (di = 0; di < data[independentVarName].length; di++) { // loop over every independentVar value in this curve\n            currIndependentVar = data[independentVarName][di];\n            if (data[statVarName][di] !== null) {\n                subSecs[curveIndex][currIndependentVar] = data.subSecs[di];   // store raw secs for this independentVar value, since it's not a null point\n                subLevs[curveIndex][currIndependentVar] = data.subLevs[di];   // store raw levs for this independentVar value, since it's not a null point\n                independentVarGroups[curveIndex].push(currIndependentVar);   // store this independentVar value, since it's not a null point\n            }\n            independentVarHasPoint[curveIndex].push(currIndependentVar);    // store all the independentVar values, regardless of whether they're null\n        }\n    }\n\n    var matchingIndependentVars = _.intersection.apply(_, independentVarGroups);    // find all of the non-null independentVar values common across all the curves\n    var matchingIndependentHasPoint = _.intersection.apply(_, independentVarHasPoint);    // find all of the independentVar values common across all the curves, regardless of whether or not they're null\n    var subIntersections = [];       // eventually find the intersecting subSecs and subLevs for each common non-null independentVar value\n\n    for (fi = 0; fi < matchingIndependentVars.length; fi++) { // loop over each common non-null independentVar value\n        currIndependentVar = matchingIndependentVars[fi];\n        subIntersections[currIndependentVar] = [];\n        var currSubIntersections = [];\n        for (si = 0; si < subSecs[0][currIndependentVar].length; si++) {   // fill current intersection array with sec-lev pairs from the first curve\n            currSubIntersections.push([subSecs[0][currIndependentVar][si], subLevs[0][currIndependentVar][si]]);\n        }\n        for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) { // loop over every curve after the first\n            var tempSubIntersections = [];\n            var tempPair;\n            for (si = 0; si < subSecs[curveIndex][currIndependentVar].length; si++) { // loop over every subSecs value\n                tempPair = [subSecs[curveIndex][currIndependentVar][si], subLevs[curveIndex][currIndependentVar][si]];    // create an individual sec-lev pair for each index in the subSecs and subLevs arrays\n                if (matsDataUtils.arrayContainsSubArray(currSubIntersections, tempPair)) {   // see if the individual sec-lev pair matches a pair from the current intersection array\n                    tempSubIntersections.push(tempPair);    // store matching pairs\n                }\n            }\n            currSubIntersections = tempSubIntersections;    //replace current intersection array with array of only pairs that matched from this loop through.\n        }\n        subIntersections[currIndependentVar] = currSubIntersections;   // store the final intersecting subSecs array for this common non-null independentVar value\n    }\n\n    // remove non-matching independentVars and subSecs\n    for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) { // loop over every curve\n        data = dataset[curveIndex];\n\n        // need to loop backwards through the data array so that we can splice non-matching indices\n        // while still having the remaining indices in the correct order\n        var dataLength = data[independentVarName].length;\n        for (di = dataLength - 1; di >= 0; di--) {\n\n            if (matchingIndependentVars.indexOf(data[independentVarName][di]) === -1) {  // if this is not a common non-null independentVar value, we'll have to remove some data\n                if (matchingIndependentHasPoint.indexOf(data[independentVarName][di]) === -1) {   // if at least one curve doesn't even have a null here, much less a matching value (beacause of the cadence), just drop this independentVar\n                    data.x.splice(di, 1);\n                    data.y.splice(di, 1);\n                    data[('error_' + statVarName)].array.splice(di, 1);\n                    data.subVals.splice(di, 1);\n                    data.subSecs.splice(di, 1);\n                    data.subLevs.splice(di, 1);\n                    data.stats.splice(di, 1);\n                    data.text.splice(di, 1);\n                } else {    // if all of the curves have either data or nulls at this independentVar, and there is at least one null, ensure all of the curves are null\n                    data[statVarName][di] = null;\n                    data.subVals[di] = NaN;\n                    data.subSecs[di] = NaN;\n                    data.subLevs[di] = NaN;\n                }\n                continue;   // then move on to the next independentVar. There's no need to mess with the subSecs or subLevs\n            }\n            subSecs = data.subSecs[di];\n            subLevs = data.subLevs[di];\n            subValues = data.subVals[di];\n\n            if (subSecs.length > 0 && subLevs.length > 0) {\n                currIndependentVar = data[independentVarName][di];\n                newSubValues = [];\n                newSubSecs = [];\n                newSubLevs = [];\n                for (si = 0; si < subSecs.length; si++) {  // loop over all subSecs for this independentVar\n                    tempPair = [subSecs[si], subLevs[si]]; //create sec-lev pair for each sub value\n                    if (matsDataUtils.arrayContainsSubArray(subIntersections[currIndependentVar], tempPair)) {  // keep the subValue only if its sec-lev pair is common to all curves for this independentVar\n                        var newVal = subValues[si];\n                        var newSec = subSecs[si];\n                        var newLev = subLevs[si];\n                        if (newVal !== undefined) {\n                            newSubValues.push(newVal);\n                            newSubSecs.push(newSec);\n                            newSubLevs.push(newLev);\n                        }\n                    }\n                }\n                // store the filtered data\n                data.subVals[di] = newSubValues;\n                data.subSecs[di] = newSubSecs;\n                data.subLevs[di] = newSubLevs;\n            }\n        }\n        dataset[curveIndex] = data;\n    }\n\n    return dataset;\n};\n\n// function for removing unmatched data from a dataset containing multiple curves for a histogram *without* levels.\n// separate matching functions are needed for histograms because you have to take all of the data out of the bins, then\n// match it, then recalculate the bins. For other plot types, you can just leave the data in its already-sorted fhr, level, etc.\nconst getMatchedDataSetHistogram = function (dataset, curvesLength, binStats) {\n\n    var subStatsRaw = {};\n    var subSecsRaw = {};\n    var subStats = {};\n    var subSecs = {};\n    var newSubStats = {};\n    var newSubSecs = {};\n    var newCurveData;\n    var curveIndex;\n    var di;\n    var si;\n\n    // pull all subSecs and subStats out of their bins, and back into one master array\n    for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        data = dataset[curveIndex];\n        subStatsRaw[curveIndex] = [];\n        subSecsRaw[curveIndex] = [];\n        subStats[curveIndex] = [];\n        subSecs[curveIndex] = [];\n        for (di = 0; di < data.x.length; di++) {\n            subStatsRaw[curveIndex].push(data.subVals[di]);\n            subSecsRaw[curveIndex].push(data.subSecs[di]);\n        }\n        subStats[curveIndex] = [].concat.apply([], subStatsRaw[curveIndex]);\n        subSecs[curveIndex] = [].concat.apply([], subSecsRaw[curveIndex]);\n    }\n\n    // determine which seconds are present in all curves\n    var subSecIntersection = subSecs[0];   // fill current subSecs intersection array with subSecs from the first curve\n    for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) { // loop over every curve\n        subSecIntersection = _.intersection(subSecIntersection, subSecs[curveIndex]);   // keep taking the intersection of the current subSecs intersection array with each curve's subSecs array\n    }\n\n    // remove non-matching subSecs and subStats\n    for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) { // loop over every curve\n        data = dataset[curveIndex];\n        if (subSecIntersection.length > 0) {\n            newSubStats[curveIndex] = [];\n            newSubSecs[curveIndex] = [];\n\n            for (si = 0; si < subSecs[curveIndex].length; si++) {  // loop over all subSecs for this curve\n                if (subSecIntersection.indexOf(subSecs[curveIndex][si]) !== -1) { // keep the subStat only if its associated subSec is common to all curves\n                    var newStat = subStats[curveIndex][si];\n                    var newSec = subSecs[curveIndex][si];\n                    if (newStat !== undefined) {\n                        newSubStats[curveIndex].push(newStat);\n                        newSubSecs[curveIndex].push(newSec);\n                    }\n                }\n            }\n            // re-sort all of the data into histogram bins\n            var d = {// d will contain the curve data\n                x: [], //placeholder\n                y: [], //placeholder\n                error_x: [], // unused\n                error_y: [], // unused\n                subVals: [],\n                subSecs: [],\n                subLevs: [],\n                glob_stats: {}, // placeholder\n                bin_stats: [], // placeholder\n                text: [], //placeholder\n                xmin: Number.MAX_VALUE,\n                xmax: Number.MIN_VALUE,\n                ymin: Number.MAX_VALUE,\n                ymax: Number.MIN_VALUE,\n            };\n            newCurveData = matsDataUtils.sortHistogramBins(newSubStats[curveIndex], newSubSecs[curveIndex], [], data.x.length, binStats, false, d);\n            var newCurveDataKeys = Object.keys(newCurveData.d);\n            for (var didx = 0; didx < newCurveDataKeys.length; didx++) {\n                dataset[curveIndex][newCurveDataKeys[didx]] = newCurveData.d[newCurveDataKeys[didx]];\n            }\n        } else {\n            // if there are no matching values, set data to an empty array\n            dataset[curveIndex] = {\n                x: [],\n                y: [],\n                error_x: [],\n                error_y: [],\n                subVals: [],\n                subSecs: [],\n                subLevs: [],\n                glob_stats: {},\n                bin_stats: [],\n                text: [],\n                xmin: Number.MAX_VALUE,\n                xmax: Number.MIN_VALUE,\n                ymin: Number.MAX_VALUE,\n                ymax: Number.MIN_VALUE,\n            };\n        }\n    }\n    return dataset;\n};\n\n// function for removing unmatched data from a dataset containing multiple curves for a histogram *with* levels.\n// separate matching functions are needed for histograms because you have to take all of the data out of the bins, then\n// match it, then recalculate the bins. For other plot types, you can just leave the data in its already-sorted fhr, level, etc.\nconst getMatchedDataSetHistogramWithLevels = function (dataset, curvesLength, binStats) {\n\n    var subStatsRaw = {};\n    var subSecsRaw = {};\n    var subLevsRaw = {};\n    var subStats = {};\n    var subSecs = {};\n    var subLevs = {};\n    var newSubStats = {};\n    var newSubSecs = {};\n    var newSubLevs = {};\n    var newCurveData;\n    var curveIndex;\n    var di;\n    var si;\n\n    // pull all subSecs and subStats out of their bins, and back into one master array\n    for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        data = dataset[curveIndex];\n        subStatsRaw[curveIndex] = [];\n        subSecsRaw[curveIndex] = [];\n        subLevsRaw[curveIndex] = [];\n        subStats[curveIndex] = [];\n        subSecs[curveIndex] = [];\n        subLevs[curveIndex] = [];\n        for (di = 0; di < data.x.length; di++) {\n            subStatsRaw[curveIndex].push(data.subVals[di]);\n            subSecsRaw[curveIndex].push(data.subSecs[di]);\n            subLevsRaw[curveIndex].push(data.subLevs[di]);\n        }\n        subStats[curveIndex] = [].concat.apply([], subStatsRaw[curveIndex]);\n        subSecs[curveIndex] = [].concat.apply([], subSecsRaw[curveIndex]);\n        subLevs[curveIndex] = [].concat.apply([], subLevsRaw[curveIndex]);\n    }\n\n    // determine which seconds and levels are present in all curves\n    var subIntersections = [];       // eventually find the intersecting subSecs and subLevs across all curves\n    for (si = 0; si < subSecs[0].length; si++) {   // fill current intersection array with sec-lev pairs from the first curve\n        subIntersections.push([subSecs[0][si], subLevs[0][si]]);\n    }\n    for (curveIndex = 1; curveIndex < curvesLength; curveIndex++) { // loop over every curve after the first\n        var tempSubIntersections = [];\n        var tempPair;\n        for (si = 0; si < subSecs[curveIndex].length; si++) { // loop over every subSecs value\n            tempPair = [subSecs[curveIndex][si], subLevs[curveIndex][si]];    // create an individual sec-lev pair for each index in the subSecs and subLevs arrays\n            if (matsDataUtils.arrayContainsSubArray(subIntersections, tempPair)) {   // see if the individual sec-lev pair matches a pair from the current intersection array\n                tempSubIntersections.push(tempPair);    // store matching pairs\n            }\n        }\n        subIntersections = tempSubIntersections;    //replace current intersection array with array of only pairs that matched from this loop through.\n    }\n\n    // remove non-matching subSecs, subLevs, and subStats\n    for (curveIndex = 0; curveIndex < curvesLength; curveIndex++) { // loop over every curve\n        data = dataset[curveIndex];\n        if (subIntersections.length > 0) {\n            newSubStats[curveIndex] = [];\n            newSubSecs[curveIndex] = [];\n            newSubLevs[curveIndex] = [];\n\n            for (si = 0; si < subSecs[curveIndex].length; si++) {  // loop over all subSecs for this curve\n                tempPair = [subSecs[curveIndex][si], subLevs[curveIndex][si]]; //create sec-lev pair for each subStat\n                if (matsDataUtils.arrayContainsSubArray(subIntersections, tempPair)) {  // keep the subStat only if its sec-lev pair is common to all curves\n                    var newStat = subStats[curveIndex][si];\n                    var newSec = subSecs[curveIndex][si];\n                    var newLev = subLevs[curveIndex][si];\n                    if (newStat !== undefined) {\n                        newSubStats[curveIndex].push(newStat);\n                        newSubSecs[curveIndex].push(newSec);\n                        newSubLevs[curveIndex].push(newLev);\n                    }\n                }\n            }\n            // re-sort all of the data into histogram bins\n            var d = {// d will contain the curve data\n                x: [], //placeholder\n                y: [], //placeholder\n                error_x: [], // unused\n                error_y: [], // unused\n                subVals: [],\n                subSecs: [],\n                subLevs: [],\n                glob_stats: {}, // placeholder\n                bin_stats: [], // placeholder\n                text: [], //placeholder\n                xmin: Number.MAX_VALUE,\n                xmax: Number.MIN_VALUE,\n                ymin: Number.MAX_VALUE,\n                ymax: Number.MIN_VALUE,\n            };\n            newCurveData = matsDataUtils.sortHistogramBins(newSubStats[curveIndex], newSubSecs[curveIndex], newSubLevs[curveIndex], data.x.length, binStats, true, d);\n            var newCurveDataKeys = Object.keys(newCurveData.d);\n            for (var didx = 0; didx < newCurveDataKeys.length; didx++) {\n                dataset[curveIndex][newCurveDataKeys[didx]] = newCurveData.d[newCurveDataKeys[didx]];\n            }\n        } else {\n            // if there are no matching values, set data to an empty dataset\n            dataset[curveIndex] = {\n                x: [],\n                y: [],\n                error_x: [],\n                error_y: [],\n                subVals: [],\n                subSecs: [],\n                subLevs: [],\n                glob_stats: {},\n                bin_stats: [],\n                text: [],\n                xmin: Number.MAX_VALUE,\n                xmax: Number.MIN_VALUE,\n                ymin: Number.MAX_VALUE,\n                ymax: Number.MIN_VALUE,\n            };\n        }\n    }\n    return dataset;\n};\n\nexport default matsDataMatchUtils = {\n\n    getMatchedDataSet: getMatchedDataSet,\n    getMatchedDataSetWithLevels: getMatchedDataSetWithLevels,\n    getMatchedDataSetHistogram: getMatchedDataSetHistogram,\n    getMatchedDataSetHistogramWithLevels: getMatchedDataSetHistogramWithLevels\n\n}"]},"sourceType":"script","hash":"8e10498a06719eba5cbf839bf3d95c43476d3f85"}
