{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_series.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"server/dataFunctions/data_series.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_series.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_series.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/dataFunctions/data_series.js"}},"code":"let matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataSeries = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.timeSeries;\n  const hasLevels = false;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n  var dataset = [];\n  var utcCycleStarts = [];\n  var axisMap = Object.create(null);\n  var xmax = -1 * Number.MAX_VALUE;\n  var ymax = -1 * Number.MAX_VALUE;\n  var xmin = Number.MAX_VALUE;\n  var ymin = Number.MAX_VALUE;\n  var idealValues = [];\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var diffFrom = curve.diffFrom;\n    var label = curve['label'];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var thresholdStr = curve['threshold'];\n    var threshold = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'threshold'\n    }).valuesMap[key] === thresholdStr);\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n    var averageStr = curve['average'];\n    var averageOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'average'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var average = averageOptionsMap[averageStr][0];\n    var scaleStr = curve['scale'];\n    var scale = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'scale'\n    }).valuesMap[key] === scaleStr);\n    var forecastLength = curve['forecast-length']; // axisKey is used to determine which axis a curve should use.\n    // This axisKeySet object is used like a set and if a curve has the same\n    // units (axisKey) it will use the same axis.\n    // The axis number is assigned to the axisKeySet value, which is the axisKey.\n\n    var axisKey = statisticOptionsMap[statisticSelect][1];\n    curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n\n    var idealVal = statisticOptionsMap[statisticSelect][2];\n\n    if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n      idealValues.push(idealVal);\n    }\n\n    var d;\n\n    if (diffFrom == null) {\n      // this is a database driven curve, not a difference curve\n      // prepare the query from the above parameters\n      var statement = \"select {{average}} as avtime, \" + \"count(distinct m0.time) as N_times, \" + \"min(m0.time) as min_secs, \" + \"max(m0.time) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0 \" + \"where 1=1 \" + \"and m0.time >= '{{fromSecs}}' \" + \"and m0.time <= '{{toSecs}}' \" + \"{{validTimeClause}} \" + \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" + \"and m0.trsh = '{{threshold}}' \" + \"and m0.fcst_len = '{{forecastLength}}' \" + \"group by avtime \" + \"order by avtime\" + \";\";\n      statement = statement.replace('{{average}}', average);\n      statement = statement.replace('{{fromSecs}}', fromSecs);\n      statement = statement.replace('{{toSecs}}', toSecs);\n      statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n      statement = statement.replace('{{statistic}}', statistic);\n      statement = statement.replace('{{threshold}}', threshold);\n      statement = statement.replace('{{forecastLength}}', forecastLength);\n      var validTimeClause = \" \";\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\";\n      }\n\n      statement = statement.replace('{{validTimeClause}}', validTimeClause);\n      dataRequests[curve.label] = statement; // math is done on forecastLength later on -- set all analyses to 0\n\n      if (forecastLength === \"-99\") {\n        forecastLength = \"0\";\n      }\n\n      var queryResult;\n      var startMoment = moment();\n      var finishMoment;\n\n      try {\n        // send the query statement to the query function\n        queryResult = matsDataQueryUtils.queryDBTimeSeries(sumPool, statement, data_source, forecastLength, fromSecs, toSecs, averageStr, validTimes, hasLevels, false);\n        finishMoment = moment();\n        dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n          begin: startMoment.format(),\n          finish: finishMoment.format(),\n          duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n          recordCount: queryResult.data.x.length\n        }; // get the data back from the query\n\n        d = queryResult.data;\n      } catch (e) {\n        // this is an error produced by a bug in the query function, not an error returned by the mysql database\n        e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n        throw new Error(e.message);\n      }\n\n      if (queryResult.error !== undefined && queryResult.error !== \"\") {\n        if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n          // this is NOT an error just a no data condition\n          dataFoundForCurve = false;\n        } else {\n          // this is an error returned by the mysql database\n          error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n          throw new Error(error);\n        }\n      } // set axis limits based on returned data\n\n\n      var postQueryStartMoment = moment();\n\n      if (dataFoundForCurve) {\n        xmin = xmin < d.xmin ? xmin : d.xmin;\n        xmax = xmax > d.xmax ? xmax : d.xmax;\n        ymin = ymin < d.ymin ? ymin : d.ymin;\n        ymax = ymax > d.ymax ? ymax : d.ymax;\n      }\n    } else {\n      // this is a difference curve\n      const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n      d = diffResult.dataset;\n      xmin = xmin < d.xmin ? xmin : d.xmin;\n      xmax = xmax > d.xmax ? xmax : d.xmax;\n      ymin = ymin < d.ymin ? ymin : d.ymin;\n      ymax = ymax > d.ymax ? ymax : d.ymax;\n    } // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n\n    const mean = d.sum / d.x.length;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['axisKey'] = axisKey;\n    const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // end for curves\n  // process the data returned by the query\n\n\n  const appParams = {\n    \"plotType\": plotType,\n    \"hasLevels\": hasLevels,\n    \"matching\": matching\n  };\n  const curveInfoParams = {\n    \"curves\": curves,\n    \"curvesLength\": curvesLength,\n    \"idealValues\": idealValues,\n    \"utcCycleStarts\": utcCycleStarts,\n    \"axisMap\": axisMap,\n    \"xmax\": xmax,\n    \"xmin\": xmin\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};","map":{"version":3,"sources":["server/dataFunctions/data_series.js"],"names":["matsCollections","module","link","v","matsTypes","matsDataUtils","matsDataQueryUtils","matsDataDiffUtils","matsDataCurveOpsUtils","matsDataProcessUtils","moment","dataSeries","plotParams","plotFunction","matching","PlotActions","matched","plotType","PlotTypes","timeSeries","hasLevels","dataRequests","dataFoundForCurve","totalProcessingStart","dateRange","getDateRange","dates","fromSecs","fromSeconds","toSecs","toSeconds","error","curves","JSON","parse","stringify","curvesLength","length","dataset","utcCycleStarts","axisMap","Object","create","xmax","Number","MAX_VALUE","ymax","xmin","ymin","idealValues","curveIndex","curve","diffFrom","label","dataSourceStr","data_source","CurveParams","findOne","name","optionsMap","regionStr","region","keys","valuesMap","find","key","source","sourceStr","thresholdStr","threshold","statisticSelect","statisticOptionsMap","statistic","validTimes","undefined","averageStr","averageOptionsMap","average","scaleStr","scale","forecastLength","axisKey","idealVal","indexOf","push","d","statement","replace","validTimeClause","InputTypes","unused","queryResult","startMoment","finishMoment","queryDBTimeSeries","sumPool","begin","format","finish","duration","diff","asSeconds","recordCount","data","x","e","message","Error","Messages","NO_DATA_FOUND","postQueryStartMoment","diffResult","getDataForDiffCurve","mean","sum","annotation","toPrecision","cOptions","generateSeriesCurveOptions","postQueryFinishMoment","appParams","curveInfoParams","bookkeepingParams","result","processDataXYCurve"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataSeries = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.timeSeries;\n    const hasLevels = false;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    var dataset = [];\n    var utcCycleStarts = [];\n    var axisMap = Object.create(null);\n    var xmax = -1 * Number.MAX_VALUE;\n    var ymax = -1 * Number.MAX_VALUE;\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var idealValues = [];\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var diffFrom = curve.diffFrom;\n        var label = curve['label'];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var thresholdStr = curve['threshold'];\n        var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n        var averageStr = curve['average'];\n        var averageOptionsMap = matsCollections.CurveParams.findOne({name: 'average'}, {optionsMap: 1})['optionsMap'];\n        var average = averageOptionsMap[averageStr][0];\n        var scaleStr = curve['scale'];\n        var scale = Object.keys(matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'scale'}).valuesMap[key] === scaleStr);\n        var forecastLength = curve['forecast-length'];\n        // axisKey is used to determine which axis a curve should use.\n        // This axisKeySet object is used like a set and if a curve has the same\n        // units (axisKey) it will use the same axis.\n        // The axis number is assigned to the axisKeySet value, which is the axisKey.\n        var axisKey = statisticOptionsMap[statisticSelect][1];\n        curves[curveIndex].axisKey = axisKey; // stash the axisKey to use it later for axis options\n        var idealVal = statisticOptionsMap[statisticSelect][2];\n        if (idealVal !== null && idealValues.indexOf(idealVal) === -1) {\n            idealValues.push(idealVal);\n        }\n\n        var d;\n        if (diffFrom == null) {\n            // this is a database driven curve, not a difference curve\n            // prepare the query from the above parameters\n            var statement = \"select {{average}} as avtime, \" +\n                \"count(distinct m0.time) as N_times, \" +\n                \"min(m0.time) as min_secs, \" +\n                \"max(m0.time) as max_secs, \" +\n                \"{{statistic}} \" +\n                \"from {{data_source}} as m0 \" +\n                \"where 1=1 \" +\n                \"and m0.time >= '{{fromSecs}}' \" +\n                \"and m0.time <= '{{toSecs}}' \" +\n                \"{{validTimeClause}} \" +\n                \"and m0.hit+m0.fa+m0.miss+m0.cn > 0 \" +\n                \"and m0.trsh = '{{threshold}}' \" +\n                \"and m0.fcst_len = '{{forecastLength}}' \" +\n                \"group by avtime \" +\n                \"order by avtime\" +\n                \";\";\n\n            statement = statement.replace('{{average}}', average);\n            statement = statement.replace('{{fromSecs}}', fromSecs);\n            statement = statement.replace('{{toSecs}}', toSecs);\n            statement = statement.replace('{{data_source}}', data_source + '_' + scale + sourceStr + '_' + region);\n            statement = statement.replace('{{statistic}}', statistic);\n            statement = statement.replace('{{threshold}}', threshold);\n            statement = statement.replace('{{forecastLength}}', forecastLength);\n            var validTimeClause = \" \";\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and floor((m0.time)%(24*3600)/3600) IN(\" + validTimes + \")\"\n            }\n            statement = statement.replace('{{validTimeClause}}', validTimeClause);\n\n            dataRequests[curve.label] = statement;\n\n            // math is done on forecastLength later on -- set all analyses to 0\n            if (forecastLength === \"-99\") {\n                forecastLength = \"0\";\n            }\n\n            var queryResult;\n            var startMoment = moment();\n            var finishMoment;\n            try {\n                // send the query statement to the query function\n                queryResult = matsDataQueryUtils.queryDBTimeSeries(sumPool, statement, data_source, forecastLength, fromSecs, toSecs, averageStr, validTimes, hasLevels, false);\n                finishMoment = moment();\n                dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                    begin: startMoment.format(),\n                    finish: finishMoment.format(),\n                    duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                    recordCount: queryResult.data.x.length\n                };\n                // get the data back from the query\n                d = queryResult.data;\n            } catch (e) {\n                // this is an error produced by a bug in the query function, not an error returned by the mysql database\n                e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n                throw new Error(e.message);\n            }\n            if (queryResult.error !== undefined && queryResult.error !== \"\") {\n                if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                    // this is NOT an error just a no data condition\n                    dataFoundForCurve = false;\n                } else {\n                    // this is an error returned by the mysql database\n                    error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                    throw (new Error(error));\n                }\n            }\n\n            // set axis limits based on returned data\n            var postQueryStartMoment = moment();\n            if (dataFoundForCurve) {\n                xmin = xmin < d.xmin ? xmin : d.xmin;\n                xmax = xmax > d.xmax ? xmax : d.xmax;\n                ymin = ymin < d.ymin ? ymin : d.ymin;\n                ymax = ymax > d.ymax ? ymax : d.ymax;\n            }\n        } else {\n            // this is a difference curve\n            const diffResult = matsDataDiffUtils.getDataForDiffCurve(dataset, diffFrom, plotType, hasLevels);\n            d = diffResult.dataset;\n            xmin = xmin < d.xmin ? xmin : d.xmin;\n            xmax = xmax > d.xmax ? xmax : d.xmax;\n            ymin = ymin < d.ymin ? ymin : d.ymin;\n            ymax = ymax > d.ymax ? ymax : d.ymax;\n        }\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.sum / d.x.length;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['axisKey'] = axisKey;\n        const cOptions = matsDataCurveOpsUtils.generateSeriesCurveOptions(curve, curveIndex, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        }\n    }  // end for curves\n\n    // process the data returned by the query\n    const appParams = {\"plotType\": plotType, \"hasLevels\": hasLevels, \"matching\": matching};\n    const curveInfoParams = {\n        \"curves\": curves,\n        \"curvesLength\": curvesLength,\n        \"idealValues\": idealValues,\n        \"utcCycleStarts\": utcCycleStarts,\n        \"axisMap\": axisMap,\n        \"xmax\": xmax,\n        \"xmin\": xmin\n    };\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataXYCurve(dataset, appParams, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};"]},"sourceType":"script","hash":"f9b6fb32004a38de25615a3cc215eb1958a8b487"}
