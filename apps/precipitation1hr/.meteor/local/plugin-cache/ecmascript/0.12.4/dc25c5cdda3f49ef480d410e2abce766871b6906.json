{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_contour_diff.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"server/dataFunctions/data_contour_diff.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_contour_diff.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/server/dataFunctions/data_contour_diff.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/dataFunctions/data_contour_diff.js"}},"code":"let matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 0);\nlet matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 1);\nlet matsDataUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataUtils(v) {\n    matsDataUtils = v;\n  }\n\n}, 2);\nlet matsDataQueryUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataQueryUtils(v) {\n    matsDataQueryUtils = v;\n  }\n\n}, 3);\nlet matsDataDiffUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataDiffUtils(v) {\n    matsDataDiffUtils = v;\n  }\n\n}, 4);\nlet matsDataCurveOpsUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataCurveOpsUtils(v) {\n    matsDataCurveOpsUtils = v;\n  }\n\n}, 5);\nlet matsDataProcessUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsDataProcessUtils(v) {\n    matsDataProcessUtils = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"meteor/momentjs:moment\", {\n  moment(v) {\n    moment = v;\n  }\n\n}, 7);\n\ndataContourDiff = function (plotParams, plotFunction) {\n  // initialize variables common to all curves\n  const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n  const plotType = matsTypes.PlotTypes.contourDiff;\n  var dataRequests = {}; // used to store data queries\n\n  var dataFoundForCurve = true;\n  var totalProcessingStart = moment();\n  var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n  var fromSecs = dateRange.fromSeconds;\n  var toSecs = dateRange.toSeconds;\n  var error = \"\";\n  var curves = JSON.parse(JSON.stringify(plotParams.curves));\n  var curvesLength = curves.length;\n\n  if (curvesLength !== 2) {\n    throw new Error(\"INFO:  There must be two added curves.\");\n  }\n\n  if (curves[0]['x-axis-parameter'] !== curves[1]['x-axis-parameter'] || curves[0]['y-axis-parameter'] !== curves[1]['y-axis-parameter']) {\n    throw new Error(\"INFO:  The x-axis-parameter and y-axis-parameter must be consistent across both curves.\");\n  }\n\n  var dataset = [];\n  var axisMap = Object.create(null);\n\n  for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n    // initialize variables specific to each curve\n    var curve = curves[curveIndex];\n    var label = curve['label'];\n    var xAxisParam = curve['x-axis-parameter'];\n    var yAxisParam = curve['y-axis-parameter'];\n    var xValClause = matsCollections.CurveParams.findOne({\n      name: 'x-axis-parameter'\n    }).optionsMap[xAxisParam];\n    var yValClause = matsCollections.CurveParams.findOne({\n      name: 'y-axis-parameter'\n    }).optionsMap[yAxisParam];\n    var dataSourceStr = curve['data-source'];\n    var data_source = matsCollections.CurveParams.findOne({\n      name: 'data-source'\n    }).optionsMap[curve['data-source']][0];\n    var regionStr = curve['region'];\n    var region = Object.keys(matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n      name: 'region'\n    }).valuesMap[key] === regionStr);\n    var source = curve['truth'];\n    var sourceStr = \"\";\n\n    if (source !== \"All\") {\n      sourceStr = \"_\" + source;\n    }\n\n    var statisticSelect = curve['statistic'];\n    var statisticOptionsMap = matsCollections.CurveParams.findOne({\n      name: 'statistic'\n    }, {\n      optionsMap: 1\n    })['optionsMap'];\n    var statistic = statisticOptionsMap[statisticSelect][0];\n    var validTimeClause = \"\";\n    var thresholdClause = \"\";\n    var forecastLengthClause = \"\";\n    var dateClause = \"\";\n\n    if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n      var forecastLength = curve['forecast-length'];\n      forecastLengthClause = \"and m0.fcst_len = \" + forecastLength;\n    }\n\n    if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n      var thresholdStr = curve['threshold'];\n      var threshold = Object.keys(matsCollections.CurveParams.findOne({\n        name: 'threshold'\n      }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n        name: 'threshold'\n      }).valuesMap[key] === thresholdStr);\n      thresholdClause = \"and m0.thresh = \" + threshold;\n    }\n\n    if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n      var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n\n      if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n        validTimeClause = \" and  m0.valid_time%(24*3600)/3600 IN(\" + validTimes + \")\";\n      }\n    }\n\n    if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date') {\n      dateClause = \"m0.valid_time-m0.fcst_len*3600\";\n    } else {\n      dateClause = \"m0.valid_time\";\n    } // for two contours it's faster to just take care of matching in the query\n\n\n    var matchModel = \"\";\n    var matchDates = \"\";\n    var matchThresholdClause = \"\";\n    var matchValidTimeClause = \"\";\n    var matchForecastLengthClause = \"\";\n    var matchClause = \"\";\n\n    if (matching) {\n      const otherCurveIndex = curveIndex === 0 ? 1 : 0;\n      const otherModel = matsCollections.CurveParams.findOne({\n        name: 'data-source'\n      }).optionsMap[curves[otherCurveIndex]['data-source']][0];\n      const otherRegion = Object.keys(matsCollections.CurveParams.findOne({\n        name: 'region'\n      }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n        name: 'region'\n      }).valuesMap[key] === curves[otherCurveIndex]['region']);\n      matchModel = \", \" + otherModel + \"_\" + otherRegion + \" as a0\";\n      const matchDateClause = dateClause.split('m0').join('a0');\n      matchDates = \"and \" + matchDateClause + \" >= '\" + fromSecs + \"' and \" + matchDateClause + \" <= '\" + toSecs + \"'\";\n      matchClause = \"and m0.valid_time = a0.valid_time\";\n\n      if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n        var matchForecastLength = curves[otherCurveIndex]['forecast-length'];\n        matchForecastLengthClause = \"and a0.fcst_len = \" + matchForecastLength;\n      } else {\n        matchForecastLengthClause = \"and m0.fcst_len = a0.fcst_len\";\n      }\n\n      if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n        var matchThreshold = Object.keys(matsCollections.CurveParams.findOne({\n          name: 'threshold'\n        }).valuesMap).find(key => matsCollections.CurveParams.findOne({\n          name: 'threshold'\n        }).valuesMap[key] === curves[otherCurveIndex]['threshold']);\n        matchThresholdClause = \"and a0.thresh = \" + matchThreshold;\n      } else {\n        matchThresholdClause = \"and m0.thresh = a0.thresh\";\n      }\n\n      if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n        var matchValidTimes = curves[otherCurveIndex]['valid-time'] === undefined ? [] : curves[otherCurveIndex]['valid-time'];\n\n        if (matchValidTimes.length > 0 && matchValidTimes !== matsTypes.InputTypes.unused) {\n          matchValidTimeClause = \" and a0.valid_time%(24*3600)/3600 IN(\" + matchValidTimes + \")\";\n        }\n      }\n    } // For contours, this functions as the colorbar label.\n\n\n    curves[curveIndex]['unitKey'] = statisticOptionsMap[statisticSelect][1];\n    var d; // this is a database driven curve, not a difference curve\n    // prepare the query from the above parameters\n\n    var statement = \"{{xValClause}} \" + \"{{yValClause}} \" + \"count(distinct {{dateClause}}) as N_times, \" + \"min({{dateClause}}) as min_secs, \" + \"max({{dateClause}}) as max_secs, \" + \"{{statistic}} \" + \"from {{data_source}} as m0{{matchModel}} \" + \"where 1=1 \" + \"{{matchClause}} \" + \"and {{dateClause}} >= '{{fromSecs}}' \" + \"and {{dateClause}} <= '{{toSecs}}' \" + \"{{matchDates}} \" + \"and m0.yy+m0.ny+m0.yn+m0.nn > 0 \" + \"{{thresholdClause}} \" + \"{{matchThresholdClause}} \" + \"{{validTimeClause}} \" + \"{{matchValidTimeClause}} \" + \"{{forecastLengthClause}} \" + \"{{matchForecastLengthClause}} \" + \"group by xVal,yVal \" + \"order by xVal,yVal\" + \";\";\n    statement = statement.replace('{{xValClause}}', xValClause);\n    statement = statement.replace('{{yValClause}}', yValClause);\n    statement = statement.replace('{{data_source}}', data_source + '_' + region + sourceStr);\n    statement = statement.replace('{{matchModel}}', matchModel);\n    statement = statement.replace('{{statistic}}', statistic);\n    statement = statement.replace('{{threshold}}', threshold);\n    statement = statement.replace('{{fromSecs}}', fromSecs);\n    statement = statement.replace('{{toSecs}}', toSecs);\n    statement = statement.replace('{{matchDates}}', matchDates);\n    statement = statement.replace('{{matchClause}}', matchClause);\n    statement = statement.replace('{{thresholdClause}}', thresholdClause);\n    statement = statement.replace('{{matchThresholdClause}}', matchThresholdClause);\n    statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n    statement = statement.replace('{{matchForecastLengthClause}}', matchForecastLengthClause);\n    statement = statement.replace('{{validTimeClause}}', validTimeClause);\n    statement = statement.replace('{{matchValidTimeClause}}', matchValidTimeClause);\n    statement = statement.split('{{dateClause}}').join(dateClause);\n    dataRequests[curve.label] = statement; // math is done on forecastLength later on -- set all analyses to 0\n\n    if (forecastLength === \"-99\") {\n      forecastLength = \"0\";\n    }\n\n    var queryResult;\n    var startMoment = moment();\n    var finishMoment;\n\n    try {\n      // send the query statement to the query function\n      queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n      finishMoment = moment();\n      dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n        begin: startMoment.format(),\n        finish: finishMoment.format(),\n        duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n        recordCount: queryResult.data.xTextOutput.length\n      }; // get the data back from the query\n\n      d = queryResult.data;\n    } catch (e) {\n      // this is an error produced by a bug in the query function, not an error returned by the mysql database\n      e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n      throw new Error(e.message);\n    }\n\n    if (queryResult.error !== undefined && queryResult.error !== \"\") {\n      if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n        // this is NOT an error just a no data condition\n        dataFoundForCurve = false;\n      } else {\n        // this is an error returned by the mysql database\n        error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n        throw new Error(error);\n      }\n    }\n\n    var postQueryStartMoment = moment(); // set curve annotation to be the curve mean -- may be recalculated later\n    // also pass previously calculated axis stats to curve options\n\n    const mean = d.glob_stats.mean;\n    const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n    curve['annotation'] = annotation;\n    curve['xmin'] = d.xmin;\n    curve['xmax'] = d.xmax;\n    curve['ymin'] = d.ymin;\n    curve['ymax'] = d.ymax;\n    curve['zmin'] = d.zmin;\n    curve['zmax'] = d.zmax;\n    curve['xAxisKey'] = xAxisParam;\n    curve['yAxisKey'] = yAxisParam;\n    const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d); // generate plot with data, curve annotation, axis labels, etc.\n\n    dataset.push(cOptions);\n    var postQueryFinishMoment = moment();\n    dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n      begin: postQueryStartMoment.format(),\n      finish: postQueryFinishMoment.format(),\n      duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n    };\n  } // turn the two contours into one difference contour\n\n\n  dataset = matsDataDiffUtils.getDataForDiffContour(dataset);\n  plotParams.curves = matsDataUtils.getDiffContourCurveParams(plotParams.curves);\n  curves = plotParams.curves; // process the data returned by the query\n\n  const curveInfoParams = {\n    \"curve\": curves,\n    \"axisMap\": axisMap\n  };\n  const bookkeepingParams = {\n    \"dataRequests\": dataRequests,\n    \"totalProcessingStart\": totalProcessingStart\n  };\n  var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n  plotFunction(result);\n};","map":{"version":3,"sources":["server/dataFunctions/data_contour_diff.js"],"names":["matsCollections","module","link","v","matsTypes","matsDataUtils","matsDataQueryUtils","matsDataDiffUtils","matsDataCurveOpsUtils","matsDataProcessUtils","moment","dataContourDiff","plotParams","plotFunction","matching","PlotActions","matched","plotType","PlotTypes","contourDiff","dataRequests","dataFoundForCurve","totalProcessingStart","dateRange","getDateRange","dates","fromSecs","fromSeconds","toSecs","toSeconds","error","curves","JSON","parse","stringify","curvesLength","length","Error","dataset","axisMap","Object","create","curveIndex","curve","label","xAxisParam","yAxisParam","xValClause","CurveParams","findOne","name","optionsMap","yValClause","dataSourceStr","data_source","regionStr","region","keys","valuesMap","find","key","source","sourceStr","statisticSelect","statisticOptionsMap","statistic","validTimeClause","thresholdClause","forecastLengthClause","dateClause","forecastLength","thresholdStr","threshold","validTimes","undefined","InputTypes","unused","matchModel","matchDates","matchThresholdClause","matchValidTimeClause","matchForecastLengthClause","matchClause","otherCurveIndex","otherModel","otherRegion","matchDateClause","split","join","matchForecastLength","matchThreshold","matchValidTimes","d","statement","replace","queryResult","startMoment","finishMoment","queryDBContour","sumPool","begin","format","finish","duration","diff","asSeconds","recordCount","data","xTextOutput","e","message","Messages","NO_DATA_FOUND","postQueryStartMoment","mean","glob_stats","annotation","toPrecision","xmin","xmax","ymin","ymax","zmin","zmax","cOptions","generateContourCurveOptions","push","postQueryFinishMoment","getDataForDiffContour","getDiffContourCurveParams","curveInfoParams","bookkeepingParams","result","processDataContour"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport {matsCollections} from 'meteor/randyp:mats-common';\nimport {matsTypes} from 'meteor/randyp:mats-common';\nimport {matsDataUtils} from 'meteor/randyp:mats-common';\nimport {matsDataQueryUtils} from 'meteor/randyp:mats-common';\nimport {matsDataDiffUtils} from 'meteor/randyp:mats-common';\nimport {matsDataCurveOpsUtils} from 'meteor/randyp:mats-common';\nimport {matsDataProcessUtils} from 'meteor/randyp:mats-common';\nimport {moment} from 'meteor/momentjs:moment'\n\ndataContourDiff = function (plotParams, plotFunction) {\n    // initialize variables common to all curves\n    const matching = plotParams['plotAction'] === matsTypes.PlotActions.matched;\n    const plotType = matsTypes.PlotTypes.contourDiff;\n    var dataRequests = {}; // used to store data queries\n    var dataFoundForCurve = true;\n    var totalProcessingStart = moment();\n    var dateRange = matsDataUtils.getDateRange(plotParams.dates);\n    var fromSecs = dateRange.fromSeconds;\n    var toSecs = dateRange.toSeconds;\n    var error = \"\";\n    var curves = JSON.parse(JSON.stringify(plotParams.curves));\n    var curvesLength = curves.length;\n    if (curvesLength !== 2) {\n        throw new Error(\"INFO:  There must be two added curves.\");\n    }\n    if (curves[0]['x-axis-parameter'] !== curves[1]['x-axis-parameter'] || curves[0]['y-axis-parameter'] !== curves[1]['y-axis-parameter']) {\n        throw new Error(\"INFO:  The x-axis-parameter and y-axis-parameter must be consistent across both curves.\");\n    }\n    var dataset = [];\n    var axisMap = Object.create(null);\n\n    for (var curveIndex = 0; curveIndex < curvesLength; curveIndex++) {\n        // initialize variables specific to each curve\n        var curve = curves[curveIndex];\n        var label = curve['label'];\n        var xAxisParam = curve['x-axis-parameter'];\n        var yAxisParam = curve['y-axis-parameter'];\n        var xValClause = matsCollections.CurveParams.findOne({name: 'x-axis-parameter'}).optionsMap[xAxisParam];\n        var yValClause = matsCollections.CurveParams.findOne({name: 'y-axis-parameter'}).optionsMap[yAxisParam];\n        var dataSourceStr = curve['data-source'];\n        var data_source = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curve['data-source']][0];\n        var regionStr = curve['region'];\n        var region = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === regionStr);\n        var source = curve['truth'];\n        var sourceStr = \"\";\n        if (source !== \"All\") {\n            sourceStr = \"_\" + source;\n        }\n        var statisticSelect = curve['statistic'];\n        var statisticOptionsMap = matsCollections.CurveParams.findOne({name: 'statistic'}, {optionsMap: 1})['optionsMap'];\n        var statistic = statisticOptionsMap[statisticSelect][0];\n        var validTimeClause = \"\";\n        var thresholdClause = \"\";\n        var forecastLengthClause = \"\";\n        var dateClause = \"\";\n        if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n            var forecastLength = curve['forecast-length'];\n            forecastLengthClause = \"and m0.fcst_len = \" + forecastLength;\n        }\n        if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n            var thresholdStr = curve['threshold'];\n            var threshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === thresholdStr);\n            thresholdClause = \"and m0.thresh = \" + threshold;\n        }\n        if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n            var validTimes = curve['valid-time'] === undefined ? [] : curve['valid-time'];\n            if (validTimes.length > 0 && validTimes !== matsTypes.InputTypes.unused) {\n                validTimeClause = \" and  m0.valid_time%(24*3600)/3600 IN(\" + validTimes + \")\";\n            }\n        }\n        if ((xAxisParam === 'Init Date' || yAxisParam === 'Init Date') && (xAxisParam !== 'Valid Date' && yAxisParam !== 'Valid Date')) {\n            dateClause = \"m0.valid_time-m0.fcst_len*3600\";\n        } else {\n            dateClause = \"m0.valid_time\";\n        }\n\n        // for two contours it's faster to just take care of matching in the query\n        var matchModel = \"\";\n        var matchDates = \"\";\n        var matchThresholdClause = \"\";\n        var matchValidTimeClause = \"\";\n        var matchForecastLengthClause = \"\";\n        var matchClause = \"\";\n        if (matching) {\n            const otherCurveIndex = curveIndex === 0 ? 1 : 0;\n            const otherModel = matsCollections.CurveParams.findOne({name: 'data-source'}).optionsMap[curves[otherCurveIndex]['data-source']][0];\n            const otherRegion = Object.keys(matsCollections.CurveParams.findOne({name: 'region'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'region'}).valuesMap[key] === curves[otherCurveIndex]['region']);\n\n            matchModel = \", \" + otherModel + \"_\" + otherRegion + \" as a0\";\n            const matchDateClause = dateClause.split('m0').join('a0');\n            matchDates = \"and \" + matchDateClause + \" >= '\" + fromSecs + \"' and \" + matchDateClause + \" <= '\" + toSecs + \"'\";\n            matchClause = \"and m0.valid_time = a0.valid_time\";\n\n            if (xAxisParam !== 'Fcst lead time' && yAxisParam !== 'Fcst lead time') {\n                var matchForecastLength = curves[otherCurveIndex]['forecast-length'];\n                matchForecastLengthClause = \"and a0.fcst_len = \" + matchForecastLength;\n            } else {\n                matchForecastLengthClause = \"and m0.fcst_len = a0.fcst_len\";\n            }\n            if (xAxisParam !== 'Threshold' && yAxisParam !== 'Threshold') {\n                var matchThreshold = Object.keys(matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap).find(key => matsCollections.CurveParams.findOne({name: 'threshold'}).valuesMap[key] === curves[otherCurveIndex]['threshold']);\n                matchThresholdClause = \"and a0.thresh = \" + matchThreshold;\n            } else {\n                matchThresholdClause = \"and m0.thresh = a0.thresh\";\n            }\n            if (xAxisParam !== 'Valid UTC hour' && yAxisParam !== 'Valid UTC hour') {\n                var matchValidTimes = curves[otherCurveIndex]['valid-time'] === undefined ? [] : curves[otherCurveIndex]['valid-time'];\n                if (matchValidTimes.length > 0 && matchValidTimes !== matsTypes.InputTypes.unused) {\n                    matchValidTimeClause = \" and a0.valid_time%(24*3600)/3600 IN(\" + matchValidTimes + \")\";\n                }\n            }\n        }\n\n        // For contours, this functions as the colorbar label.\n        curves[curveIndex]['unitKey'] = statisticOptionsMap[statisticSelect][1];\n\n        var d;\n        // this is a database driven curve, not a difference curve\n        // prepare the query from the above parameters\n        var statement = \"{{xValClause}} \" +\n            \"{{yValClause}} \" +\n            \"count(distinct {{dateClause}}) as N_times, \" +\n            \"min({{dateClause}}) as min_secs, \" +\n            \"max({{dateClause}}) as max_secs, \" +\n            \"{{statistic}} \" +\n            \"from {{data_source}} as m0{{matchModel}} \" +\n            \"where 1=1 \" +\n            \"{{matchClause}} \" +\n            \"and {{dateClause}} >= '{{fromSecs}}' \" +\n            \"and {{dateClause}} <= '{{toSecs}}' \" +\n            \"{{matchDates}} \" +\n            \"and m0.yy+m0.ny+m0.yn+m0.nn > 0 \" +\n            \"{{thresholdClause}} \" +\n            \"{{matchThresholdClause}} \" +\n            \"{{validTimeClause}} \" +\n            \"{{matchValidTimeClause}} \" +\n            \"{{forecastLengthClause}} \" +\n            \"{{matchForecastLengthClause}} \" +\n            \"group by xVal,yVal \" +\n            \"order by xVal,yVal\" +\n            \";\";\n\n        statement = statement.replace('{{xValClause}}', xValClause);\n        statement = statement.replace('{{yValClause}}', yValClause);\n        statement = statement.replace('{{data_source}}', data_source + '_' + region + sourceStr);\n        statement = statement.replace('{{matchModel}}', matchModel);\n        statement = statement.replace('{{statistic}}', statistic);\n        statement = statement.replace('{{threshold}}', threshold);\n        statement = statement.replace('{{fromSecs}}', fromSecs);\n        statement = statement.replace('{{toSecs}}', toSecs);\n        statement = statement.replace('{{matchDates}}', matchDates);\n        statement = statement.replace('{{matchClause}}', matchClause);\n        statement = statement.replace('{{thresholdClause}}', thresholdClause);\n        statement = statement.replace('{{matchThresholdClause}}', matchThresholdClause);\n        statement = statement.replace('{{forecastLengthClause}}', forecastLengthClause);\n        statement = statement.replace('{{matchForecastLengthClause}}', matchForecastLengthClause);\n        statement = statement.replace('{{validTimeClause}}', validTimeClause);\n        statement = statement.replace('{{matchValidTimeClause}}', matchValidTimeClause);\n        statement = statement.split('{{dateClause}}').join(dateClause);\n        dataRequests[curve.label] = statement;\n\n        // math is done on forecastLength later on -- set all analyses to 0\n        if (forecastLength === \"-99\") {\n            forecastLength = \"0\";\n        }\n\n        var queryResult;\n        var startMoment = moment();\n        var finishMoment;\n        try {\n            // send the query statement to the query function\n            queryResult = matsDataQueryUtils.queryDBContour(sumPool, statement);\n            finishMoment = moment();\n            dataRequests[\"data retrieval (query) time - \" + curve.label] = {\n                begin: startMoment.format(),\n                finish: finishMoment.format(),\n                duration: moment.duration(finishMoment.diff(startMoment)).asSeconds() + \" seconds\",\n                recordCount: queryResult.data.xTextOutput.length\n            };\n            // get the data back from the query\n            d = queryResult.data;\n        } catch (e) {\n            // this is an error produced by a bug in the query function, not an error returned by the mysql database\n            e.message = \"Error in queryDB: \" + e.message + \" for statement: \" + statement;\n            throw new Error(e.message);\n        }\n        if (queryResult.error !== undefined && queryResult.error !== \"\") {\n            if (queryResult.error === matsTypes.Messages.NO_DATA_FOUND) {\n                // this is NOT an error just a no data condition\n                dataFoundForCurve = false;\n            } else {\n                // this is an error returned by the mysql database\n                error += \"Error from verification query: <br>\" + queryResult.error + \"<br> query: <br>\" + statement + \"<br>\";\n                throw (new Error(error));\n            }\n        }\n\n        var postQueryStartMoment = moment();\n\n        // set curve annotation to be the curve mean -- may be recalculated later\n        // also pass previously calculated axis stats to curve options\n        const mean = d.glob_stats.mean;\n        const annotation = mean === undefined ? label + \"- mean = NaN\" : label + \"- mean = \" + mean.toPrecision(4);\n        curve['annotation'] = annotation;\n        curve['xmin'] = d.xmin;\n        curve['xmax'] = d.xmax;\n        curve['ymin'] = d.ymin;\n        curve['ymax'] = d.ymax;\n        curve['zmin'] = d.zmin;\n        curve['zmax'] = d.zmax;\n        curve['xAxisKey'] = xAxisParam;\n        curve['yAxisKey'] = yAxisParam;\n        const cOptions = matsDataCurveOpsUtils.generateContourCurveOptions(curve, axisMap, d);  // generate plot with data, curve annotation, axis labels, etc.\n        dataset.push(cOptions);\n        var postQueryFinishMoment = moment();\n        dataRequests[\"post data retrieval (query) process time - \" + curve.label] = {\n            begin: postQueryStartMoment.format(),\n            finish: postQueryFinishMoment.format(),\n            duration: moment.duration(postQueryFinishMoment.diff(postQueryStartMoment)).asSeconds() + ' seconds'\n        };\n    }\n\n    // turn the two contours into one difference contour\n    dataset = matsDataDiffUtils.getDataForDiffContour(dataset);\n    plotParams.curves = matsDataUtils.getDiffContourCurveParams(plotParams.curves);\n    curves = plotParams.curves;\n\n    // process the data returned by the query\n    const curveInfoParams = {\"curve\": curves, \"axisMap\": axisMap};\n    const bookkeepingParams = {\"dataRequests\": dataRequests, \"totalProcessingStart\": totalProcessingStart};\n    var result = matsDataProcessUtils.processDataContour(dataset, curveInfoParams, plotParams, bookkeepingParams);\n    plotFunction(result);\n};"]},"sourceType":"script","hash":"dc25c5cdda3f49ef480d410e2abce766871b6906"}
