{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/templates/curves/curve_param_item_group.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/randyp:mats-common/templates/curves/curve_param_item_group.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/templates/curves/curve_param_item_group.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/randyp:mats-common/templates/curves/curve_param_item_group.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/randyp:mats-common/templates/curves/curve_param_item_group.js"}},"code":"let matsTypes;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsTypes(v) {\n    matsTypes = v;\n  }\n\n}, 0);\nlet matsCollections;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsCollections(v) {\n    matsCollections = v;\n  }\n\n}, 1);\nlet matsPlotUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsPlotUtils(v) {\n    matsPlotUtils = v;\n  }\n\n}, 2);\nlet matsParamUtils;\nmodule.link(\"meteor/randyp:mats-common\", {\n  matsParamUtils(v) {\n    matsParamUtils = v;\n  }\n\n}, 3);\nvar allGroups = {};\nTemplate.curveParamItemGroup.helpers({\n  curveParamGroups: function (c) {\n    const label = c.label;\n    const curves = Session.get(\"Curves\");\n    const index = curves.findIndex(function (obj) {\n      return obj.label === label;\n    }); // create a set of groups each with an array of 6 params for display\n\n    const lastUpdate = Session.get('lastUpdate');\n    const plotType = matsPlotUtils.getPlotType();\n    var elmementValues = matsParamUtils.getElementValues().curveParams; // derive the sorted pValues, xpValues, and ypValues from the sorted params and the elementValues\n\n    var pValues = [];\n    var pattern;\n\n    switch (plotType) {\n      case matsTypes.PlotTypes.profile:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.profile\n        });\n        break;\n\n      case matsTypes.PlotTypes.dieoff:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.dieoff\n        });\n        break;\n\n      case matsTypes.PlotTypes.threshold:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.threshold\n        });\n        break;\n\n      case matsTypes.PlotTypes.validtime:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.validtime\n        });\n        break;\n\n      case matsTypes.PlotTypes.dailyModelCycle:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.dailyModelCycle\n        });\n        break;\n\n      case matsTypes.PlotTypes.reliability:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.reliability\n        });\n        break;\n\n      case matsTypes.PlotTypes.map:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.map\n        });\n        break;\n\n      case matsTypes.PlotTypes.histogram:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.histogram\n        });\n        break;\n\n      case matsTypes.PlotTypes.contour:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.contour\n        });\n        break;\n\n      case matsTypes.PlotTypes.contourDiff:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.contourDiff\n        });\n        break;\n\n      case matsTypes.PlotTypes.scatter2d:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.scatter2d\n        });\n        break;\n\n      case matsTypes.PlotTypes.timeSeries:\n      default:\n        pattern = matsCollections.CurveTextPatterns.findOne({\n          plotType: matsTypes.PlotTypes.timeSeries\n        });\n        break;\n    }\n\n    const groupSize = pattern.groupSize;\n    const displayParams = pattern.displayParams;\n\n    for (var di = 0; di < displayParams.length; di++) {\n      pValues.push({\n        name: displayParams[di],\n        value: c[displayParams[di]],\n        color: c.color,\n        curve: c.label,\n        index: index\n      });\n    } // create array of parameter value display groups each of groupSize\n\n\n    var pGroups = [];\n    var groupParams = [];\n    var pvi = 0;\n\n    while (pvi < pValues.length) {\n      if (pValues[pvi] && (pValues[pvi].name == 'xaxis' || pValues[pvi].name == 'yaxis')) {\n        if (groupParams.length > 0) {\n          // finish the old group and make a new group for 'xaxis' or 'yaxis'\n          pGroups.push(groupParams);\n        }\n\n        groupParams = [];\n      }\n\n      pValues[pvi] && groupParams.push(pValues[pvi]);\n\n      if (groupParams.length >= groupSize) {\n        pGroups.push(groupParams);\n        groupParams = [];\n      }\n\n      pvi++;\n    } // check for a partial last group\n\n\n    if (groupParams.length > 0) {\n      pGroups.push(groupParams);\n    }\n\n    allGroups[c.label] = pGroups;\n    return pGroups;\n  },\n  curveNumber: function (elem) {\n    return elem.index;\n  },\n  curveParams: function (paramGroup) {\n    return paramGroup;\n  },\n  label: function (elem) {\n    if (matsPlotUtils.getPlotType() === matsTypes.PlotTypes.scatter2d) {\n      const pNameArr = elem.name.match(/([xy]axis-)(.*)/);\n\n      if (pNameArr === null) {\n        return elem.name.toUpperCase();\n      }\n\n      const prefix = pNameArr[1];\n      const pName = pNameArr[2];\n      const p = matsCollections.CurveParams.findOne({\n        name: pName\n      });\n\n      if (p.controlButtonText) {\n        return (prefix + p.controlButtonText).toUpperCase();\n      } else {\n        return elem.name.toUpperCase();\n      }\n    } else {\n      const p = matsCollections.CurveParams.findOne({\n        name: elem.name\n      });\n\n      if (p.controlButtonText) {\n        return p.controlButtonText.toUpperCase();\n      } else {\n        return elem.name.toUpperCase();\n      }\n    } // should never get here\n\n\n    return elem.name.toUpperCase();\n  },\n  name: function (elem) {\n    return elem.name;\n  },\n  id: function (elem) {\n    return elem.name;\n  },\n  buttonId: function (elem) {\n    const name = new String(elem.name);\n    const upperName = name.toUpperCase();\n    const curveNumber = elem.index;\n    const spanId = upperName + \"-curve-\" + curveNumber + \"-Button\";\n    return spanId;\n  },\n  spanId: function (elem) {\n    const name = new String(elem.name);\n    const upperName = name.toUpperCase();\n    const curveNumber = elem.index;\n    const spanId = upperName + \"-curve-\" + curveNumber + \"-Item\";\n    return spanId;\n  },\n  value: function (elem) {\n    // have to get this from the session\n    const curve = Session.get(\"Curves\")[elem.index];\n\n    if (curve === undefined) {\n      return \"\";\n    }\n\n    var value = curve[elem.name];\n    var text = \"\";\n\n    if (Object.prototype.toString.call(value) === '[object Array]') {\n      if (value.length === 1) {\n        text = value[0];\n      } else if (value.length > 1) {\n        text = value[0] + \" .. \" + value[value.length - 1];\n      }\n    } else {\n      text = value;\n    }\n\n    return text;\n  },\n  defaultColor: function (elem) {\n    return elem.color;\n  },\n  border: function (elem) {\n    var elementChanged = Session.get(\"elementChanged\");\n    const name = elem.name; // for xaxis params\n\n    const curve = elem.curve;\n    const adb = name === Session.get(\"activeDisplayButton\");\n    const isEditMode = curve === Session.get(\"editMode\");\n    const inputElemIsVisible = matsParamUtils.isInputElementVisible(name);\n\n    if (adb && isEditMode && inputElemIsVisible) {\n      return \"solid\";\n    }\n\n    return \"\";\n  },\n  editCurve: function () {\n    return Session.get('editMode');\n  },\n  editTarget: function () {\n    return Session.get(\"eventTargetCurve\");\n  },\n  displayParam: function (elem) {\n    if (elem.name === \"label\") {\n      return \"none\";\n    } // it isn't good enough to just check the item control button. Need to evaluate the hideOtherFor functionality with\n    // respect to this particular curve item\n    // First - determine if my visibility is controlled by another\n\n\n    const visibilityControllingParam = matsParamUtils.visibilityControllerForParam(elem.name); // Second - Check the hide/show state based on the parameter hideOtherFor map in the parameter nad the state of this particular curve\n\n    if (visibilityControllingParam !== undefined) {\n      const curve = Session.get(\"Curves\")[elem.index];\n      const hideOtherFor = visibilityControllingParam.hideOtherFor[elem.name][0];\n\n      if (curve !== undefined && visibilityControllingParam !== undefined && curve[visibilityControllingParam.name] !== undefined && curve[visibilityControllingParam.name] === hideOtherFor) {\n        return \"none\";\n      }\n    }\n\n    return \"block\";\n  }\n});","map":{"version":3,"sources":["packages/randyp:mats-common/templates/curves/curve_param_item_group.js"],"names":["matsTypes","module","link","v","matsCollections","matsPlotUtils","matsParamUtils","allGroups","Template","curveParamItemGroup","helpers","curveParamGroups","c","label","curves","Session","get","index","findIndex","obj","lastUpdate","plotType","getPlotType","elmementValues","getElementValues","curveParams","pValues","pattern","PlotTypes","profile","CurveTextPatterns","findOne","dieoff","threshold","validtime","dailyModelCycle","reliability","map","histogram","contour","contourDiff","scatter2d","timeSeries","groupSize","displayParams","di","length","push","name","value","color","curve","pGroups","groupParams","pvi","curveNumber","elem","paramGroup","pNameArr","match","toUpperCase","prefix","pName","p","CurveParams","controlButtonText","id","buttonId","String","upperName","spanId","undefined","text","Object","prototype","toString","call","defaultColor","border","elementChanged","adb","isEditMode","inputElemIsVisible","isInputElementVisible","editCurve","editTarget","displayParam","visibilityControllingParam","visibilityControllerForParam","hideOtherFor"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 Colorado State University and Regents of the University of Colorado. All rights reserved.\n */\n\nimport { matsTypes } from 'meteor/randyp:mats-common';\n import { matsCollections } from 'meteor/randyp:mats-common';\nimport { matsPlotUtils } from 'meteor/randyp:mats-common';\nimport { matsParamUtils } from 'meteor/randyp:mats-common';\nvar allGroups = {};\nTemplate.curveParamItemGroup.helpers({\n    curveParamGroups: function (c) {\n        const label = c.label;\n        const curves = Session.get(\"Curves\");\n        const index = curves.findIndex(\n           function(obj){\n               return obj.label === label;\n           }\n        );\n\n        // create a set of groups each with an array of 6 params for display\n        const lastUpdate = Session.get('lastUpdate');\n        const plotType = matsPlotUtils.getPlotType();\n        var elmementValues = matsParamUtils.getElementValues().curveParams;\n        // derive the sorted pValues, xpValues, and ypValues from the sorted params and the elementValues\n        var pValues = [];\n        var pattern;\n        switch (plotType) {\n            case matsTypes.PlotTypes.profile:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.profile});\n                break;\n            case matsTypes.PlotTypes.dieoff:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.dieoff});\n                break;\n            case matsTypes.PlotTypes.threshold:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.threshold});\n                break;\n            case matsTypes.PlotTypes.validtime:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.validtime});\n                break;\n            case matsTypes.PlotTypes.dailyModelCycle:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.dailyModelCycle});\n                break;\n            case matsTypes.PlotTypes.reliability:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.reliability});\n                break;\n            case matsTypes.PlotTypes.map:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.map});\n                break;\n            case matsTypes.PlotTypes.histogram:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.histogram});\n                break;\n            case matsTypes.PlotTypes.contour:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.contour});\n                break;\n            case matsTypes.PlotTypes.contourDiff:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.contourDiff});\n                break;\n            case matsTypes.PlotTypes.scatter2d:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.scatter2d});\n                break;\n            case matsTypes.PlotTypes.timeSeries:\n            default:\n                pattern = matsCollections.CurveTextPatterns.findOne({plotType: matsTypes.PlotTypes.timeSeries});\n                break;\n        }\n        const groupSize = pattern.groupSize;\n        const displayParams = pattern.displayParams;\n        for (var di=0; di < displayParams.length;di++) {\n            pValues.push({name: displayParams[di], value: c[displayParams[di]], color:c.color, curve:c.label, index:index});\n        }\n\n        // create array of parameter value display groups each of groupSize\n        var pGroups = [];\n        var groupParams = [];\n        var pvi = 0;\n        while (pvi < pValues.length) {\n            if (pValues[pvi] && (pValues[pvi].name == 'xaxis' || pValues[pvi].name == 'yaxis')) {\n                if (groupParams.length > 0) {\n                    // finish the old group and make a new group for 'xaxis' or 'yaxis'\n                    pGroups.push(groupParams);\n                }\n                groupParams = [];\n            }\n            pValues[pvi] && groupParams.push(pValues[pvi]);\n            if (groupParams.length >= groupSize) {\n                pGroups.push(groupParams);\n                groupParams = [];\n            }\n            pvi++;\n        }\n        // check for a partial last group\n        if (groupParams.length > 0) {\n            pGroups.push(groupParams);\n        }\n        allGroups[c.label] = pGroups;\n        return pGroups;\n    },\n    curveNumber: function(elem) {\n        return elem.index;\n    },\n    curveParams: function(paramGroup) {\n      return paramGroup;\n    },\n    label: function(elem) {\n        if (matsPlotUtils.getPlotType() === matsTypes.PlotTypes.scatter2d) {\n            const pNameArr = elem.name.match(/([xy]axis-)(.*)/);\n            if (pNameArr === null) {\n                return elem.name.toUpperCase();\n            }\n            const prefix = pNameArr[1];\n            const pName = pNameArr[2];\n            const p = matsCollections.CurveParams.findOne({name:pName});\n            if (p.controlButtonText) {\n                return (prefix + p.controlButtonText).toUpperCase();\n            } else {\n                return elem.name.toUpperCase();\n            }\n        } else {\n            const p = matsCollections.CurveParams.findOne({name:elem.name});\n            if (p.controlButtonText) {\n                return p.controlButtonText.toUpperCase();\n            } else {\n                return elem.name.toUpperCase();\n            }\n        }\n        // should never get here\n        return elem.name.toUpperCase();\n    },\n    name: function(elem){\n        return elem.name;\n    },\n    id: function(elem){\n        return elem.name;\n    },\n    buttonId: function(elem) {\n        const name = new String(elem.name);\n        const upperName = name.toUpperCase();\n        const curveNumber = elem.index;\n        const spanId = upperName + \"-curve-\" + curveNumber + \"-Button\";\n        return spanId;\n    },\n    spanId: function(elem) {\n        const name = new String(elem.name);\n        const upperName = name.toUpperCase();\n        const curveNumber = elem.index;\n        const spanId = upperName + \"-curve-\" + curveNumber + \"-Item\";\n        return spanId;\n    },\n    value: function(elem){\n        // have to get this from the session\n        const curve = Session.get(\"Curves\")[elem.index];\n        if (curve === undefined) {\n            return \"\";\n        }\n        var value = curve[elem.name];\n        var text = \"\";\n        if ( Object.prototype.toString.call( value ) === '[object Array]' ) {\n            if (value.length === 1) {\n                text = value[0];\n            } else if (value.length > 1){\n                text = value[0] + \" .. \" + value[value.length -1];\n            }\n        } else {\n            text = value;\n        }\n        return text;\n    },\n    defaultColor: function(elem){\n        return elem.color;\n    },\n    border: function(elem) {\n        var elementChanged = Session.get(\"elementChanged\");\n        const name = elem.name; // for xaxis params\n        const curve = elem.curve;\n        const adb = (name === Session.get(\"activeDisplayButton\"));\n        const isEditMode = (curve === Session.get(\"editMode\"));\n        const inputElemIsVisible = matsParamUtils.isInputElementVisible(name);\n        if (adb && isEditMode &&  inputElemIsVisible) {\n            return \"solid\";\n        }\n        return \"\";\n    },\n    editCurve: function() {\n        return Session.get('editMode');\n    },\n    editTarget: function() {\n        return Session.get(\"eventTargetCurve\");\n    },\n    displayParam: function(elem) {\n        if (elem.name === \"label\") {\n            return \"none\";\n        }\n        // it isn't good enough to just check the item control button. Need to evaluate the hideOtherFor functionality with\n        // respect to this particular curve item\n        // First - determine if my visibility is controlled by another\n        const visibilityControllingParam = matsParamUtils.visibilityControllerForParam(elem.name);\n        // Second - Check the hide/show state based on the parameter hideOtherFor map in the parameter nad the state of this particular curve\n        if (visibilityControllingParam !== undefined) {\n            const curve = Session.get(\"Curves\")[elem.index];\n            const hideOtherFor = visibilityControllingParam.hideOtherFor[elem.name][0];\n            if (curve!== undefined && visibilityControllingParam !== undefined && curve[visibilityControllingParam.name] !== undefined && curve[visibilityControllingParam.name] === hideOtherFor) {\n                return \"none\";\n            }\n        }\n        return \"block\";\n    }\n});\n\n"]},"sourceType":"script","hash":"09d7b90def6ccae17282b7bb1bc5aea7cc5a7c12"}
