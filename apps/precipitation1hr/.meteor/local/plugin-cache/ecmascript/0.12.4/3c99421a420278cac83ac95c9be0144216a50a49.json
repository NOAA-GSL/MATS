{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/mongo/oplog_tailing.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/mongo/oplog_tailing.js","filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/mongo/oplog_tailing.js","passPerPreset":false,"envName":"development","cwd":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","root":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/jeffrey.a.hamilton/WebstormProjects/MATS_for_EMB/apps/precipitation1hr/packages/mongo/oplog_tailing.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/oplog_tailing.js"}},"code":"var Future = Npm.require('fibers/future');\n\nOPLOG_COLLECTION = 'oplog.rs';\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\nvar TAIL_TIMEOUT = +process.env.METEOR_OPLOG_TAIL_TIMEOUT || 30000;\n\nvar showTS = function (ts) {\n  return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\";\n};\n\nidForOp = function (op) {\n  if (op.op === 'd') return op.o._id;else if (op.op === 'i') return op.o._id;else if (op.op === 'u') return op.o2._id;else if (op.op === 'c') throw Error(\"Operator 'c' doesn't supply an object with id: \" + EJSON.stringify(op));else throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};\n\nOplogHandle = function (oplogUrl, dbName) {\n  var self = this;\n  self._oplogUrl = oplogUrl;\n  self._dbName = dbName;\n  self._oplogLastEntryConnection = null;\n  self._oplogTailConnection = null;\n  self._stopped = false;\n  self._tailHandle = null;\n  self._readyFuture = new Future();\n  self._crossbar = new DDPServer._Crossbar({\n    factPackage: \"mongo-livedata\",\n    factName: \"oplog-watchers\"\n  });\n  self._baseOplogSelector = {\n    ns: new RegExp(\"^(?:\" + [Meteor._escapeRegExp(self._dbName + \".\"), Meteor._escapeRegExp(\"admin.$cmd\")].join(\"|\") + \")\"),\n    $or: [{\n      op: {\n        $in: ['i', 'u', 'd']\n      }\n    }, // drop collection\n    {\n      op: 'c',\n      'o.drop': {\n        $exists: true\n      }\n    }, {\n      op: 'c',\n      'o.dropDatabase': 1\n    }, {\n      op: 'c',\n      'o.applyOps': {\n        $exists: true\n      }\n    }]\n  }; // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a\n  // combination of time and an incrementing counter; see\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the\n  // MongoTimestamp of the last oplog entry we've processed.\n  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n  // entry in the db.  If we've already processed it (ie, it is not greater than\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n  // then waits on that future, which is resolved once _lastProcessedTS is\n  // incremented to be past its timestamp by the worker fiber.\n  //\n  // XXX use a priority queue or something else that's faster than an array\n\n  self._catchingUpFutures = [];\n  self._lastProcessedTS = null;\n  self._onSkippedEntriesHook = new Hook({\n    debugPrintExceptions: \"onSkippedEntries callback\"\n  });\n  self._entryQueue = new Meteor._DoubleEndedQueue();\n  self._workerActive = false;\n\n  self._startTailing();\n};\n\n_.extend(OplogHandle.prototype, {\n  stop: function () {\n    var self = this;\n    if (self._stopped) return;\n    self._stopped = true;\n    if (self._tailHandle) self._tailHandle.stop(); // XXX should close connections too\n  },\n  onOplogEntry: function (trigger, callback) {\n    var self = this;\n    if (self._stopped) throw new Error(\"Called onOplogEntry on stopped handle!\"); // Calling onOplogEntry requires us to wait for the tailing to be ready.\n\n    self._readyFuture.wait();\n\n    var originalCallback = callback;\n    callback = Meteor.bindEnvironment(function (notification) {\n      originalCallback(notification);\n    }, function (err) {\n      Meteor._debug(\"Error in oplog callback\", err);\n    });\n\n    var listenHandle = self._crossbar.listen(trigger, callback);\n\n    return {\n      stop: function () {\n        listenHandle.stop();\n      }\n    };\n  },\n  // Register a callback to be invoked any time we skip oplog entries (eg,\n  // because we are too far behind).\n  onSkippedEntries: function (callback) {\n    var self = this;\n    if (self._stopped) throw new Error(\"Called onSkippedEntries on stopped handle!\");\n    return self._onSkippedEntriesHook.register(callback);\n  },\n  // Calls `callback` once the oplog has been processed up to a point that is\n  // roughly \"now\": specifically, once we've processed all ops that are\n  // currently visible.\n  // XXX become convinced that this is actually safe even if oplogConnection\n  // is some kind of pool\n  waitUntilCaughtUp: function () {\n    var self = this;\n    if (self._stopped) throw new Error(\"Called waitUntilCaughtUp on stopped handle!\"); // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n    // be ready.\n\n    self._readyFuture.wait();\n\n    var lastEntry;\n\n    while (!self._stopped) {\n      // We need to make the selector at least as restrictive as the actual\n      // tailing selector (ie, we need to specify the DB name) or else we might\n      // find a TS that won't show up in the actual tail stream.\n      try {\n        lastEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, self._baseOplogSelector, {\n          fields: {\n            ts: 1\n          },\n          sort: {\n            $natural: -1\n          }\n        });\n        break;\n      } catch (e) {\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while reading last entry\", e);\n\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped) return;\n\n    if (!lastEntry) {\n      // Really, nothing in the oplog? Well, we've processed everything.\n      return;\n    }\n\n    var ts = lastEntry.ts;\n    if (!ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n\n    if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n      // We've already caught up to here.\n      return;\n    } // Insert the future into our list. Almost always, this will be at the end,\n    // but it's conceivable that if we fail over from one primary to another,\n    // the oplog entries we see will go backwards.\n\n\n    var insertAfter = self._catchingUpFutures.length;\n\n    while (insertAfter - 1 > 0 && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {\n      insertAfter--;\n    }\n\n    var f = new Future();\n\n    self._catchingUpFutures.splice(insertAfter, 0, {\n      ts: ts,\n      future: f\n    });\n\n    f.wait();\n  },\n  _startTailing: function () {\n    var self = this; // First, make sure that we're talking to the local database.\n\n    var mongodbUri = Npm.require('mongodb-uri');\n\n    if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n    } // We make two separate connections to Mongo. The Node Mongo driver\n    // implements a naive round-robin connection pool: each \"connection\" is a\n    // pool of several (5 by default) TCP connections, and each request is\n    // rotated through the pools. Tailable cursor queries block on the server\n    // until there is some data to return (or until a few seconds have\n    // passed). So if the connection pool used for tailing cursors is the same\n    // pool used for other queries, the other queries will be delayed by seconds\n    // 1/5 of the time.\n    //\n    // The tail connection will only ever be running a single tail command, so\n    // it only needs to make one underlying TCP connection.\n\n\n    self._oplogTailConnection = new MongoConnection(self._oplogUrl, {\n      poolSize: 1\n    }); // XXX better docs, but: it's to get monotonic results\n    // XXX is it safe to say \"if there's an in flight query, just use its\n    //     results\"? I don't think so but should consider that\n\n    self._oplogLastEntryConnection = new MongoConnection(self._oplogUrl, {\n      poolSize: 1\n    }); // Now, make sure that there actually is a repl set here. If not, oplog\n    // tailing won't ever find anything!\n    // More on the isMasterDoc\n    // https://docs.mongodb.com/manual/reference/command/isMaster/\n\n    var f = new Future();\n\n    self._oplogLastEntryConnection.db.admin().command({\n      ismaster: 1\n    }, f.resolver());\n\n    var isMasterDoc = f.wait();\n\n    if (!(isMasterDoc && isMasterDoc.setName)) {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n    } // Find the last oplog entry.\n\n\n    var lastOplogEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, {}, {\n      sort: {\n        $natural: -1\n      },\n      fields: {\n        ts: 1\n      }\n    });\n\n    var oplogSelector = _.clone(self._baseOplogSelector);\n\n    if (lastOplogEntry) {\n      // Start after the last entry that currently exists.\n      oplogSelector.ts = {\n        $gt: lastOplogEntry.ts\n      }; // If there are any calls to callWhenProcessedLatest before any other\n      // oplog entries show up, allow callWhenProcessedLatest to call its\n      // callback immediately.\n\n      self._lastProcessedTS = lastOplogEntry.ts;\n    }\n\n    var cursorDescription = new CursorDescription(OPLOG_COLLECTION, oplogSelector, {\n      tailable: true\n    }); // Start tailing the oplog.\n    //\n    // We restart the low-level oplog query every 30 seconds if we didn't get a\n    // doc. This is a workaround for #8598: the Node Mongo driver has at least\n    // one bug that can lead to query callbacks never getting called (even with\n    // an error) when leadership failover occur.\n\n    self._tailHandle = self._oplogTailConnection.tail(cursorDescription, function (doc) {\n      self._entryQueue.push(doc);\n\n      self._maybeStartWorker();\n    }, TAIL_TIMEOUT);\n\n    self._readyFuture.return();\n  },\n  _maybeStartWorker: function () {\n    var self = this;\n    if (self._workerActive) return;\n    self._workerActive = true;\n    Meteor.defer(function () {\n      // May be called recursively in case of transactions.\n      function handleDoc(doc) {\n        if (doc.ns === \"admin.$cmd\") {\n          if (doc.o.applyOps) {\n            // This was a successful transaction, so we need to apply the\n            // operations that were involved.\n            doc.o.applyOps.forEach(handleDoc);\n            return;\n          }\n\n          throw new Error(\"Unknown command \" + EJSON.stringify(doc));\n        }\n\n        const trigger = {\n          dropCollection: false,\n          dropDatabase: false,\n          op: doc\n        };\n\n        if (typeof doc.ns === \"string\" && doc.ns.startsWith(self._dbName + \".\")) {\n          trigger.collection = doc.ns.slice(self._dbName.length + 1);\n        } else {\n          throw new Error(\"Unexpected ns\");\n        } // Is it a special command and the collection name is hidden\n        // somewhere in operator?\n\n\n        if (trigger.collection === \"$cmd\") {\n          if (doc.o.dropDatabase) {\n            delete trigger.collection;\n            trigger.dropDatabase = true;\n          } else if (_.has(doc.o, \"drop\")) {\n            trigger.collection = doc.o.drop;\n            trigger.dropCollection = true;\n            trigger.id = null;\n          } else {\n            throw Error(\"Unknown command \" + EJSON.stringify(doc));\n          }\n        } else {\n          // All other ops have an id.\n          trigger.id = idForOp(doc);\n        }\n\n        self._crossbar.fire(trigger);\n      }\n\n      try {\n        while (!self._stopped && !self._entryQueue.isEmpty()) {\n          // Are we too far behind? Just tell our observers that they need to\n          // repoll, and drop our queue.\n          if (self._entryQueue.length > TOO_FAR_BEHIND) {\n            var lastEntry = self._entryQueue.pop();\n\n            self._entryQueue.clear();\n\n            self._onSkippedEntriesHook.each(function (callback) {\n              callback();\n              return true;\n            }); // Free any waitUntilCaughtUp() calls that were waiting for us to\n            // pass something that we just skipped.\n\n\n            self._setLastProcessedTS(lastEntry.ts);\n\n            continue;\n          }\n\n          const doc = self._entryQueue.shift(); // Fire trigger(s) for this doc.\n\n\n          handleDoc(doc); // Now that we've processed this operation, process pending\n          // sequencers.\n\n          if (doc.ts) {\n            self._setLastProcessedTS(doc.ts);\n          } else {\n            throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n          }\n        }\n      } finally {\n        self._workerActive = false;\n      }\n    });\n  },\n  _setLastProcessedTS: function (ts) {\n    var self = this;\n    self._lastProcessedTS = ts;\n\n    while (!_.isEmpty(self._catchingUpFutures) && self._catchingUpFutures[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n      var sequencer = self._catchingUpFutures.shift();\n\n      sequencer.future.return();\n    }\n  },\n  //Methods used on tests to dinamically change TOO_FAR_BEHIND\n  _defineTooFarBehind: function (value) {\n    TOO_FAR_BEHIND = value;\n  },\n  _resetTooFarBehind: function () {\n    TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n  }\n});","map":{"version":3,"sources":["packages/mongo/oplog_tailing.js"],"names":["Future","Npm","require","OPLOG_COLLECTION","TOO_FAR_BEHIND","process","env","METEOR_OPLOG_TOO_FAR_BEHIND","TAIL_TIMEOUT","METEOR_OPLOG_TAIL_TIMEOUT","showTS","ts","getHighBits","getLowBits","idForOp","op","o","_id","o2","Error","EJSON","stringify","OplogHandle","oplogUrl","dbName","self","_oplogUrl","_dbName","_oplogLastEntryConnection","_oplogTailConnection","_stopped","_tailHandle","_readyFuture","_crossbar","DDPServer","_Crossbar","factPackage","factName","_baseOplogSelector","ns","RegExp","Meteor","_escapeRegExp","join","$or","$in","$exists","_catchingUpFutures","_lastProcessedTS","_onSkippedEntriesHook","Hook","debugPrintExceptions","_entryQueue","_DoubleEndedQueue","_workerActive","_startTailing","_","extend","prototype","stop","onOplogEntry","trigger","callback","wait","originalCallback","bindEnvironment","notification","err","_debug","listenHandle","listen","onSkippedEntries","register","waitUntilCaughtUp","lastEntry","findOne","fields","sort","$natural","e","_sleepForMs","lessThanOrEqual","insertAfter","length","greaterThan","f","splice","future","mongodbUri","parse","database","MongoConnection","poolSize","db","admin","command","ismaster","resolver","isMasterDoc","setName","lastOplogEntry","oplogSelector","clone","$gt","cursorDescription","CursorDescription","tailable","tail","doc","push","_maybeStartWorker","return","defer","handleDoc","applyOps","forEach","dropCollection","dropDatabase","startsWith","collection","slice","has","drop","id","fire","isEmpty","pop","clear","each","_setLastProcessedTS","shift","sequencer","_defineTooFarBehind","value","_resetTooFarBehind"],"mappings":"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","sourcesContent":["var Future = Npm.require('fibers/future');\n\nOPLOG_COLLECTION = 'oplog.rs';\n\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\nvar TAIL_TIMEOUT = +process.env.METEOR_OPLOG_TAIL_TIMEOUT || 30000;\n\nvar showTS = function (ts) {\n  return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\";\n};\n\nidForOp = function (op) {\n  if (op.op === 'd')\n    return op.o._id;\n  else if (op.op === 'i')\n    return op.o._id;\n  else if (op.op === 'u')\n    return op.o2._id;\n  else if (op.op === 'c')\n    throw Error(\"Operator 'c' doesn't supply an object with id: \" +\n                EJSON.stringify(op));\n  else\n    throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};\n\nOplogHandle = function (oplogUrl, dbName) {\n  var self = this;\n  self._oplogUrl = oplogUrl;\n  self._dbName = dbName;\n\n  self._oplogLastEntryConnection = null;\n  self._oplogTailConnection = null;\n  self._stopped = false;\n  self._tailHandle = null;\n  self._readyFuture = new Future();\n  self._crossbar = new DDPServer._Crossbar({\n    factPackage: \"mongo-livedata\", factName: \"oplog-watchers\"\n  });\n  self._baseOplogSelector = {\n    ns: new RegExp(\"^(?:\" + [\n      Meteor._escapeRegExp(self._dbName + \".\"),\n      Meteor._escapeRegExp(\"admin.$cmd\"),\n    ].join(\"|\") + \")\"),\n\n    $or: [\n      { op: { $in: ['i', 'u', 'd'] } },\n      // drop collection\n      { op: 'c', 'o.drop': { $exists: true } },\n      { op: 'c', 'o.dropDatabase': 1 },\n      { op: 'c', 'o.applyOps': { $exists: true } },\n    ]\n  };\n\n  // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a\n  // combination of time and an incrementing counter; see\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the\n  // MongoTimestamp of the last oplog entry we've processed.\n  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n  // entry in the db.  If we've already processed it (ie, it is not greater than\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n  // then waits on that future, which is resolved once _lastProcessedTS is\n  // incremented to be past its timestamp by the worker fiber.\n  //\n  // XXX use a priority queue or something else that's faster than an array\n  self._catchingUpFutures = [];\n  self._lastProcessedTS = null;\n\n  self._onSkippedEntriesHook = new Hook({\n    debugPrintExceptions: \"onSkippedEntries callback\"\n  });\n\n  self._entryQueue = new Meteor._DoubleEndedQueue();\n  self._workerActive = false;\n\n  self._startTailing();\n};\n\n_.extend(OplogHandle.prototype, {\n  stop: function () {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n    if (self._tailHandle)\n      self._tailHandle.stop();\n    // XXX should close connections too\n  },\n  onOplogEntry: function (trigger, callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onOplogEntry on stopped handle!\");\n\n    // Calling onOplogEntry requires us to wait for the tailing to be ready.\n    self._readyFuture.wait();\n\n    var originalCallback = callback;\n    callback = Meteor.bindEnvironment(function (notification) {\n      originalCallback(notification);\n    }, function (err) {\n      Meteor._debug(\"Error in oplog callback\", err);\n    });\n    var listenHandle = self._crossbar.listen(trigger, callback);\n    return {\n      stop: function () {\n        listenHandle.stop();\n      }\n    };\n  },\n  // Register a callback to be invoked any time we skip oplog entries (eg,\n  // because we are too far behind).\n  onSkippedEntries: function (callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onSkippedEntries on stopped handle!\");\n    return self._onSkippedEntriesHook.register(callback);\n  },\n  // Calls `callback` once the oplog has been processed up to a point that is\n  // roughly \"now\": specifically, once we've processed all ops that are\n  // currently visible.\n  // XXX become convinced that this is actually safe even if oplogConnection\n  // is some kind of pool\n  waitUntilCaughtUp: function () {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n\n    // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n    // be ready.\n    self._readyFuture.wait();\n    var lastEntry;\n\n    while (!self._stopped) {\n      // We need to make the selector at least as restrictive as the actual\n      // tailing selector (ie, we need to specify the DB name) or else we might\n      // find a TS that won't show up in the actual tail stream.\n      try {\n        lastEntry = self._oplogLastEntryConnection.findOne(\n          OPLOG_COLLECTION, self._baseOplogSelector,\n          {fields: {ts: 1}, sort: {$natural: -1}});\n        break;\n      } catch (e) {\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while reading last entry\", e);\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    if (!lastEntry) {\n      // Really, nothing in the oplog? Well, we've processed everything.\n      return;\n    }\n\n    var ts = lastEntry.ts;\n    if (!ts)\n      throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n\n    if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n      // We've already caught up to here.\n      return;\n    }\n\n\n    // Insert the future into our list. Almost always, this will be at the end,\n    // but it's conceivable that if we fail over from one primary to another,\n    // the oplog entries we see will go backwards.\n    var insertAfter = self._catchingUpFutures.length;\n    while (insertAfter - 1 > 0 && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {\n      insertAfter--;\n    }\n    var f = new Future;\n    self._catchingUpFutures.splice(insertAfter, 0, {ts: ts, future: f});\n    f.wait();\n  },\n  _startTailing: function () {\n    var self = this;\n    // First, make sure that we're talking to the local database.\n    var mongodbUri = Npm.require('mongodb-uri');\n    if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n                  \"a Mongo replica set\");\n    }\n\n    // We make two separate connections to Mongo. The Node Mongo driver\n    // implements a naive round-robin connection pool: each \"connection\" is a\n    // pool of several (5 by default) TCP connections, and each request is\n    // rotated through the pools. Tailable cursor queries block on the server\n    // until there is some data to return (or until a few seconds have\n    // passed). So if the connection pool used for tailing cursors is the same\n    // pool used for other queries, the other queries will be delayed by seconds\n    // 1/5 of the time.\n    //\n    // The tail connection will only ever be running a single tail command, so\n    // it only needs to make one underlying TCP connection.\n    self._oplogTailConnection = new MongoConnection(\n      self._oplogUrl, {poolSize: 1});\n    // XXX better docs, but: it's to get monotonic results\n    // XXX is it safe to say \"if there's an in flight query, just use its\n    //     results\"? I don't think so but should consider that\n    self._oplogLastEntryConnection = new MongoConnection(\n      self._oplogUrl, {poolSize: 1});\n\n    // Now, make sure that there actually is a repl set here. If not, oplog\n    // tailing won't ever find anything!\n    // More on the isMasterDoc\n    // https://docs.mongodb.com/manual/reference/command/isMaster/\n    var f = new Future;\n    self._oplogLastEntryConnection.db.admin().command(\n      { ismaster: 1 }, f.resolver());\n    var isMasterDoc = f.wait();\n\n    if (!(isMasterDoc && isMasterDoc.setName)) {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n                  \"a Mongo replica set\");\n    }\n\n    // Find the last oplog entry.\n    var lastOplogEntry = self._oplogLastEntryConnection.findOne(\n      OPLOG_COLLECTION, {}, {sort: {$natural: -1}, fields: {ts: 1}});\n\n    var oplogSelector = _.clone(self._baseOplogSelector);\n    if (lastOplogEntry) {\n      // Start after the last entry that currently exists.\n      oplogSelector.ts = {$gt: lastOplogEntry.ts};\n      // If there are any calls to callWhenProcessedLatest before any other\n      // oplog entries show up, allow callWhenProcessedLatest to call its\n      // callback immediately.\n      self._lastProcessedTS = lastOplogEntry.ts;\n    }\n\n    var cursorDescription = new CursorDescription(\n      OPLOG_COLLECTION, oplogSelector, {tailable: true});\n\n    // Start tailing the oplog.\n    //\n    // We restart the low-level oplog query every 30 seconds if we didn't get a\n    // doc. This is a workaround for #8598: the Node Mongo driver has at least\n    // one bug that can lead to query callbacks never getting called (even with\n    // an error) when leadership failover occur.\n    self._tailHandle = self._oplogTailConnection.tail(\n      cursorDescription,\n      function (doc) {\n        self._entryQueue.push(doc);\n        self._maybeStartWorker();\n      },\n      TAIL_TIMEOUT\n    );\n    self._readyFuture.return();\n  },\n\n  _maybeStartWorker: function () {\n    var self = this;\n    if (self._workerActive) return;\n    self._workerActive = true;\n\n    Meteor.defer(function () {\n      // May be called recursively in case of transactions.\n      function handleDoc(doc) {\n        if (doc.ns === \"admin.$cmd\") {\n          if (doc.o.applyOps) {\n            // This was a successful transaction, so we need to apply the\n            // operations that were involved.\n            doc.o.applyOps.forEach(handleDoc);\n            return;\n          }\n          throw new Error(\"Unknown command \" + EJSON.stringify(doc));\n        }\n\n        const trigger = {\n          dropCollection: false,\n          dropDatabase: false,\n          op: doc,\n        };\n\n        if (typeof doc.ns === \"string\" &&\n            doc.ns.startsWith(self._dbName + \".\")) {\n          trigger.collection = doc.ns.slice(self._dbName.length + 1);\n        } else {\n          throw new Error(\"Unexpected ns\");\n        }\n\n        // Is it a special command and the collection name is hidden\n        // somewhere in operator?\n        if (trigger.collection === \"$cmd\") {\n          if (doc.o.dropDatabase) {\n            delete trigger.collection;\n            trigger.dropDatabase = true;\n          } else if (_.has(doc.o, \"drop\")) {\n            trigger.collection = doc.o.drop;\n            trigger.dropCollection = true;\n            trigger.id = null;\n          } else {\n            throw Error(\"Unknown command \" + EJSON.stringify(doc));\n          }\n\n        } else {\n          // All other ops have an id.\n          trigger.id = idForOp(doc);\n        }\n\n        self._crossbar.fire(trigger);\n      }\n\n      try {\n        while (! self._stopped &&\n               ! self._entryQueue.isEmpty()) {\n          // Are we too far behind? Just tell our observers that they need to\n          // repoll, and drop our queue.\n          if (self._entryQueue.length > TOO_FAR_BEHIND) {\n            var lastEntry = self._entryQueue.pop();\n            self._entryQueue.clear();\n\n            self._onSkippedEntriesHook.each(function (callback) {\n              callback();\n              return true;\n            });\n\n            // Free any waitUntilCaughtUp() calls that were waiting for us to\n            // pass something that we just skipped.\n            self._setLastProcessedTS(lastEntry.ts);\n            continue;\n          }\n\n          const doc = self._entryQueue.shift();\n\n          // Fire trigger(s) for this doc.\n          handleDoc(doc);\n\n          // Now that we've processed this operation, process pending\n          // sequencers.\n          if (doc.ts) {\n            self._setLastProcessedTS(doc.ts);\n          } else {\n            throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n          }\n        }\n      } finally {\n        self._workerActive = false;\n      }\n    });\n  },\n\n  _setLastProcessedTS: function (ts) {\n    var self = this;\n    self._lastProcessedTS = ts;\n    while (!_.isEmpty(self._catchingUpFutures) && self._catchingUpFutures[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n      var sequencer = self._catchingUpFutures.shift();\n      sequencer.future.return();\n    }\n  },\n\n  //Methods used on tests to dinamically change TOO_FAR_BEHIND\n  _defineTooFarBehind: function(value) {\n    TOO_FAR_BEHIND = value;\n  },\n  _resetTooFarBehind: function() {\n    TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n  }\n});\n"]},"sourceType":"script","hash":"3c99421a420278cac83ac95c9be0144216a50a49"}
