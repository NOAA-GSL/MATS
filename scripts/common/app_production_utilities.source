#!/bin/sh
# app_production_utilities.source
# bash function source file with utilities for retrieving and setting the mongo appProductionStatus databse on mats.gsd.esrl.noaa.gov
# Each function will create a temporary tunnel to mats.gsd.esrl.noaa.gov for the mongo client to use, then close it when finished.



# NOTES on appProductionStatus database....

# The appProductionStatus database has two collections, buildConfiguration, and deployment. The test routine at the end of this file
# creates a temporary copy of the deployment database for use during testing, and deletes it ehen the tests complete.
# The buildConfiguration collection is not modified by these routines. That collection defines the build, integration, and
# production servers (one for each environment), and  specifies things like source code control, build and test directories,
# build and test commands, results directories, and an app_list. The app_list specifies each app reference, displayName,
# displayOrder, build status, and deployment status.
# If build status is enabled then that app be built for that environment. If the build status is disabled the app will be not be built
# when the build script runs for the given environment.
# If the deploymentStatus is enabled then the app can be deployed in the given environment, if disabled the app will not be deployed,
# even if it is built. This is how an app can progress from version to version from development, to integration, to production.


# By modifyinfg the data in that collection, the build and deployment operations can be controlled independently of the build script.

# The deployment collection is dynamic and is modified by the build, deploy, and publish routines.
# There is a document for production servers, integration servers, and development servers.
# The servers field in each document is a list because there may be more than one such server in each environment.
# Each server entry is itself a list because a server may be known by different names or domains. Think internal verses DMZ.
# Each environment document also contains an app list. Each app entry identifies the app reference, the version, the build date
# (which is the date that app was last built for that environment), the last test run (which is the date that the automated
# tests were last run, and the last test status (which is the result of the last test run).



# For non-test usages the deploy collectios is named deployment.
# for test usage the deployment collection is duplicated and the duplicate "deployment-test" is used.
export DEPLOYMENTCOLLECTION="deployment"

export GRN='\033[0;32m'
export RED='\033[0;31m'
export NC='\033[0m'
export passed='\033[0;32m passed \033[0m'
export success='\033[0;32m success \033[0m'
export failed='\033[0;31m failed \033[0m'

# This function can tell you if the docker daemon is a swarm manager
function isSwarmNode(){
     if [ "$(docker info 2> /dev/null | grep Swarm | sed 's/Swarm: //g')" == "inactive" ]; then
              echo false
     else
              echo true;
     fi
}

# close the ssh tunnel to the server where the mongo db lives ...
#PARAMETERS: none
#RETURNS: none
#TRANSFORMATION: opens ssh tunnel
function closeTunnel() {
	# kill tunnels
	kill -TERM `ps -Awf | grep '27020:localhost:27017' | grep -v grep | tr -s ' ' | cut -f2 -d' '` > /dev/null 2>&1
}

# establish the ssh tunnel to the server where the mongo db lives .e. mats.gsd.esrl.noaa.gov...
# This routine assumes that the user www-data is configured and the ssh key for www-data on this machine has been shared in the mats.gsd.esrl.noaa.gov authorized keys
#PARAMETERS: none
#RETURNS: none
#TRANSFORMATION: closses any open ssh tunnels like 27020:localhost:27017 
function openTunnel() {
	#open tunnel
	#-N do not execute a remote command
	#-f requests SSH to go to background
	#-L port:host:hostport (port = local port, host and hostport are where you want the tunnel to point to. This does not have to be the box you are ssh-ing to!)
	#-C compression â€“ optional
	#local client connects to port 27020
	#if a tunnel exists this returns 1 else 0
	pids=`ps -Awf | grep '27020:localhost:27017' | grep -v grep | tr -s ' ' | cut -f2 -d' '` > /dev/null 2>&1
	if [[ "X$pids" == "X" ]]; then
		ssh www-data@mats.gsd.esrl.noaa.gov -C -Nf -L 27020:localhost:27017  > /dev/null 2>&1
	fi
}

# this routine will populate shell variables to represent the values for
# server, deployment_environment,deployment_status,build_git_repo,build_code_branch,build_directory,and build_cmd
# which are values that are defined in the buildConfiguration collection of the appProductionStatus mongo database on mats.gsd.esrl.noaa.gov
# and are indexed by the server keyword. There are a different set of variables for each of the servers, i.e. mats-dev.gsd.esrl.noaa.gov differ from mats.gsd.esrl.noaa.gov.
# The variables will be defined as local shell variables like this....
# SERVER='mats-int.gsd.esrl.noaa.gov'
# DEPLOYMENT_ENVIRONMENT='production'
# DEPLOYMENT_STATUS='active'
# BUILD_GIT_REPO='gerrit:MATS_for_EMB'
# BUILD_CODE_BRANCH='master'
# BUILD_DIRECTORY='/builds/buildArea/'
# BUILD_CMD='sh ./MATS_for_EMB/scripts/common/build-int.sh'

#PARAMETERS: server
#RETURNS: none
#TRANSFORMATION: sets shell variables
setBuildConfigVarsForDevelopmentServer() {
	if [ $# -ne 0 ]; then
		echo $0 - wrong number of params - usage: $0
		return 1
	fi
	openTunnel
	unset data
    local data=$(mongo localhost:27020/appProductionStatus --quiet --eval "db.getCollection('buildConfiguration').find({deployment_environment:'development'},{_id:0}).shellPrint()")
    eval $(echo $data |  jq -r '. as $in  | del(.app_list) | del(.groupOrder) | to_entries[] | "\(.key | ascii_upcase)=\(.value | @sh)"')
	closeTunnel
}

setBuildConfigVarsForIntegrationServer() {
    if [ $# -ne 0 ]; then
        echo $0 - wrong number of params - usage: $0
        return 1
    fi
    openTunnel
    unset data
    local data=$(mongo localhost:27020/appProductionStatus --quiet --eval "db.getCollection('buildConfiguration').find({deployment_environment:'integration'},{_id:0}).shellPrint()")
    eval $(echo $data |  jq -r '. as $in  | del(.app_list) | del(.groupOrder) | to_entries[] | "\(.key | ascii_upcase)=\(.value | @sh)"')
    closeTunnel
}

setBuildConfigVarsForProductionServer() {
    if [ $# -ne 0 ]; then
        echo $0 - wrong number of params - usage: $0
        return 1
    fi
    openTunnel
    unset data
    local data=$(mongo localhost:27020/appProductionStatus --quiet --eval "db.getCollection('buildConfiguration').find({deployment_environment:'production'},{_id:0}).shellPrint()")
    eval $(echo $data |  jq -r '. as $in  | del(.app_list) | del(.groupOrder) | to_entries[] | "\(.key | ascii_upcase)=\(.value | @sh)"')
    closeTunnel
}

# this routine will populate shell ARRAYS to represent the VERSIONS and APPS values in the
# deployment collection of the appProductionStatus mongo database on mats.gsd.esrl.noaa.gov
# and are indexed by the servers keyword. There are a different set of variables for each of the servers entries, i.e. mats-dev.gsd.esrl.noaa.gov differ from mats.gsd.esrl.noaa.gov.
# the servers entry is actually a list of servers for which these values are configured.
#PARAMETERS: server
#RETURNS: none
#TRANSFORMATION: sets shell variables
setAppDeploymentVarsForServer() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 server
		return 1
	fi
	local server=$1
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODsetAppDeploymentVarsForServer
		db.getCollection("${DEPLOYMENTCOLLECTION}").find({servers:{\$in:["${server}"]}},{apps:1,_id: 0}).pretty();
	%EODsetAppDeploymentVarsForServer
	)
	readarray -t VERSIONS <<< "$(echo $data | jq -r '.apps[]  | [.version] | @csv' | sed s/\"//g)"
	readarray -t APPS <<< "$(echo $data | jq -r '.apps[]  | [.app] | @csv'  | sed s/\"//g)"
	closeTunnel
}

# This routine will output the list of ALL apps (app references not names) that are currently defined in the deployment collection of the 
# appProductionStatus mongo database on mats.gsd.esrl.noaa.gov for the server in the first parameter
#PARAMETERS: server
#RETURNS: list of app references
#TRANSFORMATION: none
getDeployedAppsForServer() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 server
		return 1
	fi
	local server=$1
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetDeployedAppsForServer
		db.getCollection("${DEPLOYMENTCOLLECTION}").find({servers:{\$in:["${server}"]}},{apps:1,_id: 0});
	%EODgetDeployedAppsForServer
	)
	closeTunnel
	readarray -t APPS <<< "$(echo $data | jq -r '.apps[]  | [.app] | @csv'  | sed s/\"//g)"
	echo ${APPS[@]}
}


# This routine will output the list of apps (app references not names) that are currently defined in the buildConfiguration collection of the 
# appProductionStatus mongo database on mats.gsd.esrl.noaa.gov and that have the buildStatus field set to enabled.
#PARAMETERS: server
#RETURNS: list of app references with buildStatus enabled
#TRANSFORMATION: none

getBuildableAppsForServer() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 server
		return 1
	fi
	local server=$1
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetBuildableAppsForServer
		db.getCollection('buildConfiguration').aggregate([
		{\$match:{server:"${server}"}},
		{\$unwind: '\$app_list'},
		{\$match: {'app_list.buildStatus': 'enabled'}},
		{\$group:{_id:null, app:{\$addToSet:"\$app_list.app"}}},
		{\$project: {_id:0,app: 1}}
		])
	%EODgetBuildableAppsForServer
	)
	closeTunnel
    APPS=($(echo $data | jq -r '.app[]'))
	echo ${APPS[@]}
}

# This routine will output the list of apps (app references not names) that are currently defined in the buildConfiguration collection of the
# appProductionStatus mongo database on mats.gsd.esrl.noaa.gov and that have the production server defined and the deploymentStatus field set to enabled.
#RETURNS: list of app references with buildStatus enabled
#TRANSFORMATION: none

getPublishableApps() {
	if [ $# -ne 0 ]; then
		echo $0 - wrong number of params - usage: $0
		return 1
	fi
	local server=$(getProductionServer)
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetBuildableAppsForServer
		db.getCollection('buildConfiguration').aggregate([
		{\$match:{server:"${server}"}},
		{\$unwind: '\$app_list'},
		{\$match: {'app_list.deploymentStatus': 'enabled'}},
		{\$group:{_id:null, app:{\$addToSet:"\$app_list.app"}}},
		{\$project: {_id:0,app: 1}}
		])
%EODgetBuildableAppsForServer
	)
	closeTunnel
	APPS=($(echo $data | jq -r '.app[]'))
	echo ${APPS[@]}
}


# This routine will update the app in the apps list of the deployment collection production deployment_environment document of the
# appProductionStatus mongo database on mats.gsd.esrl.noaa.gov to match the corresponding version and build date from the integration server app
promoteApp() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 appReference
		return 1
	fi
	local app=$1
	local intServer=$(getIntegrationServer)
    local prodServer=$(getProductionServer)
	# make the version and build date for the production environment the same as the integration
	local intVersion=$(getVersionForAppForServer ${app} ${intServer})
	local intBuildDate=$(getBuildDateForAppForServer ${app} ${intServer})
	updateVersionForAppForServer ${intVersion} ${app} ${prodServer}
	updateBuildDateForAppForServer ${intBuildDate}  ${app} ${prodServer}
	# get the deployed production servers
    local deployedProductionServers=$(getDeployedProductionServers)
    # remove the prodServer from this list
    deployedProductionServers=( "${deployedProductionServers[@]/${prodServer}}" )
    for s in ${deployedProductionServers[@]}
        do
            updateVersionForAppForServer ${intVersion} ${app} ${s}
            updateBuildDateForAppForServer ${intBuildDate}  ${app} ${s}
        done
}


# This routine will output apps (app references and displayNames) that are currently defined in the buildConfiguration collection of the
# appProductionStatus mongo database on mats.gsd.esrl.noaa.gov and that have the buildStatus field set to enabled, in the correct order
# according to how they are stored in the database. The data is output as a valid JSON array.... i.e.
# [
#   {
#       "app": "upperair",
#       "displayName": "Upper Air"
#   },
#   {
#       "app": "anomalycor",
#       "displayName": "Anomaly Correlation"
#   },
#   ......
#PARAMETERS: server
#RETURNS: list of app references with buildStatus enabled
#TRANSFORMATION: none
getApplistJSONForServer() {
    if [ $# -ne 1 ]; then
        echo $0 - wrong number of params - usage: $0 server
        return 1
    fi
    local server=$1
    openTunnel
    unset data
    local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetBuildableAppsForServer
		db.getCollection('buildConfiguration').find( {\$and: [ {server:"${server}"},{'app_list.buildStatus':'enabled'} ]}, {"app_list.app":1,"app_list.displayName":1,"app_list.group":1,_id:0});
	%EODgetBuildableAppsForServer
    )
    closeTunnel
    APPS=($(echo $data | jq -r '.[]'))
    echo ${APPS[@]}
}




# This routine will set or update the version field in the app element identified by the app reference and server params in the deployment collection of the appProductionStatus
# mongo database on mats.gsd.esrl.noaa.gov, setting the version to be what is supplied in the parameter.
#PARAMETERS: new version, app reference, server
#RETURNS: mongo update message
#TRANSFORMATION: sets or updates corresponding version field in the deployment collection of the appProductionStatus database
updateVersionForAppForServer() {
	if [ $# -ne 3 ]; then
		echo $0 - wrong number of params - usage: $0 version app server
		return 1
	fi
	local newVersion=$1
	local app=$2
	local server=$3
	# we need the ordinal position of the app in the apps array to be updated to provide to the set operator
	local appList=$(getDeployedAppsForServer ${server})
	local appPosition=-1
	for theApp in ${appList[@]}; do
		((appPosition++))	
		if [ "${theApp}" == "${app}" ]; then
			break
		fi
	done
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODupdateVersionForAppForServer
		db.getCollection("${DEPLOYMENTCOLLECTION}").update(
            { 
                \$and: [
                    { servers: {
                        \$in:["${server}"]
                    } },
                    {"apps.app":"${app}"}
                ],
            },
            {\$set: {"apps.${appPosition}.version":"${newVersion}"}}
        );
	%EODupdateVersionForAppForServer
	)
	echo $data
	closeTunnel
}

# This routine will set or update the buildDate field in the app element identified by the app reference and server params in the deployment collection of the appProductionStatus
# mongo database on mats.gsd.esrl.noaa.gov, setting the version to be what is supplied in the parameter.
#PARAMETERS: new build date, app reference, server
#RETURNS: mongo update message
#TRANSFORMATION: sets or updates corresponding version field in the deployment collection of the appProductionStatus database
updateBuildDateForAppForServer() {
	if [ $# -ne 3 ]; then
		echo $0 - wrong number of params - usage: $0 buildDate app server
		return 1
	fi
	local newBuildDate=$1
	local app=$2
	local server=$3
	# we need the ordinal position of the app in the apps array to be updated to provide to the set operator
	local appList=$(getDeployedAppsForServer ${server})
	local appPosition=-1
	for theApp in ${appList[@]}; do
		((appPosition++))	
		if [ "${theApp}" == "${app}" ]; then
			break
		fi
	done
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODupdateVersionForAppForServer
		db.getCollection("${DEPLOYMENTCOLLECTION}").update(
            { 
                \$and: [
                    { servers: {
                        \$in:["${server}"]
                    } },
                    {"apps.app":"${app}"}
                ],
            },
            {\$set: {"apps.${appPosition}.buildDate":"${newBuildDate}"}}
        );
	%EODupdateVersionForAppForServer
	)
	echo $data
	closeTunnel
}

# This routine will set the deploymentStatus field in the app element identified by the app reference and server params in the deployment collection of the production document
# of the appProductionStatus mongo database on mats.gsd.esrl.noaa.gov, setting the deploymentStaus to disabled.
#PARAMETERS: new build date, app reference, server
#RETURNS: mongo update message
#TRANSFORMATION: sets or updates corresponding version field in the deployment collection of the appProductionStatus database
disablePublicationStatusForApp() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 app
		return 1
	fi
	local app=$1
	local server=$(getProductionServer)
	# we need the ordinal position of the app in the apps array to be updated to provide to the set operator
	local appList=$(getDeployedAppsForServer ${server})
	local appPosition=-1
	for theApp in ${appList[@]}; do
		((appPosition++))
		if [ "${theApp}" == "${app}" ]; then
			break
		fi
	done
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODdisablePublicationStatusForApp
		db.getCollection('buildConfiguration').update(
            {
                \$and: [
                    { servers: {
                        \$in:["${server}"]
                    } },
                    {"apps.app":"${app}"}
                ],
            },
            {\$set: {"apps.${appPosition}.deploymentStatus":"disabled"}}
        );
	%EODdisablePublicationStatusForApp
	)
	echo $data
	closeTunnel
}

# This routine will set the deploymentStatus field in the app element identified by the app reference and server params in the deployment collection of the production document
# of the appProductionStatus mongo database on mats.gsd.esrl.noaa.gov, setting the deploymentStaus to ensabled.
#PARAMETERS: new build date, app reference, server
#RETURNS: mongo update message
#TRANSFORMATION: sets or updates corresponding version field in the deployment collection of the appProductionStatus database
enablePublicationStatusForApp() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 app
		return 1
	fi
	local app=$1
	local server=$(getProductionServer)
	# we need the ordinal position of the app in the apps array to be updated to provide to the set operator
	local appList=$(getDeployedAppsForServer ${server})
	local appPosition=-1
	for theApp in ${appList[@]}; do
		((appPosition++))
		if [ "${theApp}" == "${app}" ]; then
			break
		fi
	done
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODdisablePublicationStatusForApp
		db.getCollection('buildConfiguration').update(
            {
                \$and: [
                    { servers: {
                        \$in:["${server}"]
                    } },
                    {"apps.app":"${app}"}
                ],
            },
            {\$set: {"apps.${appPosition}.deploymentStatus":"enabled"}}
        );
	%EODdisablePublicationStatusForApp
	)
	echo $data
	closeTunnel
}

# This routine outputs the deployment_environment field for the server in the deployment collection of the appProductionStatus
# mongo database on mats.gsd.esrl.noaa.gov
#PARAMETERS: server
#RETURNS: deployment_environment
#TRANSFORMATION: none
getDeploymentEnvironmentForServer() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 server
		return 1
	fi
	local server=$1
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetDeploymentEnvironmentForServer
		db.getCollection("${DEPLOYMENTCOLLECTION}").find(
		{ servers: {
		      \$in:["${server}"]
		}}, 
		{
			_id:0, 
			deployment_environment:1
	   	});
	%EODgetDeploymentEnvironmentForServer
	)
	closeTunnel
	echo $data | jq -r '.deployment_environment'
	
}


# This routine outputs the apps list for the given deployment_environment field for the deployment collection of the appProductionStatus
# mongo database on mats.gsd.esrl.noaa.gov
#PARAMETERS: deployment_environment
#RETURNS: apps
#TRANSFORMATION: none
getAppsVersionsForDeploymentEnvironment() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 server
		return 1
	fi
	local deployment_environment=$1
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetAppsVersionsForDeploymentEnvironment
		db.getCollection("${DEPLOYMENTCOLLECTION}").find(
		{ deployment_environment: {
		      \$in:["${deployment_environment}"]
		}},
		{
			_id:0,
			apps:1
	   	});
	%EODgetAppsVersionsForDeploymentEnvironment
	)
	closeTunnel
	echo $data | jq -r '.apps | map({(.app):(.version)})| add | keys[] as $k | "\($k), \(.[$k])"'
}


getDeployedProductionServers() {
    if [ $# -ne 0 ]; then
        echo $0 - wrong number of params - usage: $0
        return 1
    fi
    openTunnel
    unset data
    data=$(mongo  localhost:27020/appProductionStatus --quiet --eval "db.getCollection('deployment').find({run_environment:'production'},{_id:0,servers:1}).shellPrint()" | jq -r '.servers[]')
    closeTunnel
    echo $data
}

getProductionServer() {
    if [ $# -ne 0 ]; then
        echo $0 - wrong number of params - usage: $0
        return 1
    fi
    openTunnel
    unset data
	local data=$(mongo  localhost:27020/appProductionStatus --quiet --eval "db.getCollection('buildConfiguration').find({ \$and: [{deployment_environment:'production'},{deployment_status:'active'}]},{_id:0,server:1}).shellPrint()" | jq -r '.server')
    closeTunnel
    echo $data
}

getIntegrationServer() {
    if [ $# -ne 0 ]; then
        echo $0 - wrong number of params - usage: $0
        return 1
    fi
    openTunnel
    unset data
	local data=$(mongo  localhost:27020/appProductionStatus --quiet --eval "db.getCollection('buildConfiguration').find({ \$and: [{deployment_environment:'integration'},{deployment_status:'active'}]},{_id:0,server:1}).shellPrint()" | jq -r '.server')
    closeTunnel
    echo $data
}

getDevelopmentServer() {
	if [ $# -ne 0 ]; then
		echo $0 - wrong number of params - usage: $0
		return 1
	fi
	openTunnel
	unset data
	local data=$(mongo  localhost:27020/appProductionStatus --quiet --eval "db.getCollection('buildConfiguration').find({ \$and: [{deployment_environment:'development'},{deployment_status:'active'}]},{_id:0,server:1}).shellPrint()" | jq -r '.server')
	closeTunnel
	echo $data
}

# This routine outputs the version field in the app element identified by the app reference and server params in the deployment collection of the appProductionStatus
# mongo database on mats.gsd.esrl.noaa.gov
#PARAMETERS: app reference, server
#RETURNS: version
#TRANSFORMATION: none
getVersionForAppForServer() {
	if [ $# -ne 2 ]; then
		echo $0 - wrong number of params - usage: $0 app server
		return 1
	fi
	local app=$1
	local server=$2
	#retrieve current version
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetVersionForAppForServer
		db.getCollection("${DEPLOYMENTCOLLECTION}").find(
			{ \$and: [
				{ servers: {
				      \$in:["${server}"]
				} },
				{
				    'apps.app':"$app"
				}
			] },
		     	{
			_id:0, 
			apps: {
			    \$elemMatch: {
				'app':"$app"
			    }
			}
	   	});
	%EODgetVersionForAppForServer
	)
	closeTunnel
	echo $data | jq -r '.apps[] | .version'
}

# This routine outputs the buildDate field in the app element identified by the app reference and server params in the deployment collection of the appProductionStatus
# mongo database on mats.gsd.esrl.noaa.gov
#PARAMETERS: app reference, server
#RETURNS: buildDate
#TRANSFORMATION: none
getBuildDateForAppForServer() {
	if [ $# -ne 2 ]; then
		echo $0 - wrong number of params - usage: $0 app server
		return 1
	fi
	local app=$1
	local server=$2
	#retrieve current buildDate
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetVersionForAppForServer
		db.getCollection("${DEPLOYMENTCOLLECTION}").find(
			{ \$and: [
				{ servers: {
				      \$in:["${server}"]
				} },
				{
				    'apps.app':"$app"
				}
			] },
		     	{
			_id:0, 
			apps: {
			    \$elemMatch: {
				'app':"$app"
			    }
			}
	   	});
	%EODgetVersionForAppForServer
	)
	closeTunnel
	echo $data | jq -r '.apps[] | .buildDate'
}

# This routine will output apps (app references, titles, and versions) that are currently defined in the production deployment collection of the
# appProductionStatus mongo database on mats.gsd.esrl.noaa.gov for the given server, in the correct order
# according to how they are stored in the database. The data is output as a valid JSON array.... i.e.
# [
#   {
#       "app": "upperair",
#       "title": "Upper Air (RAOBS)",
#       "version": "2.1.6"
#   },
#   {
#       "app": "anomalycor",
#       "title": "Anomaly Correlation"
#       "version": "2.1.6"
#   },
#   ......
# ]
#PARAMETERS: server
#RETURNS: list of app references with buildStatus enabled
#TRANSFORMATION: none
getProductionDeploymentAppsForServer() {
    if [ $# -ne 1 ]; then
        echo $0 - wrong number of params - usage: $0 server
        return 1
    fi
    local server=$1
    openTunnel
    unset data
    local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetBuildableAppsForServer
		db.getCollection('deployment').find( {servers: {\$in:["${server}"]}}, {"apps.app":1,"apps.title":1,"apps.version":1,_id:0});
	%EODgetBuildableAppsForServer
    )
    closeTunnel
    APPS=($(echo $data | jq -r '.[]'))
    echo ${APPS[@]}
}

getDeploymentAppsForServer() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 server
		return 1
	fi
	local server=$1
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODgetDeploymentEnvironmentForServer
		db.getCollection("${DEPLOYMENTCOLLECTION}").find(
		{ servers: {
		      \$in:["${server}"]
		}},
		{
			_id:0,
			deployment_environment:1
	   	});
	%EODgetDeploymentEnvironmentForServer
	)
	closeTunnel
	echo $data | jq -r '.deployment_environment'
}

# NOTE ABOUT ROLLING VERSIONS:
# When the nightly build (development branch) happens the version must acquire a higher patch number than the integration version. This is
# because the code gets tagged with a combination of the app and the version number. We want to be able to roll the code back to either an integration version or
# a development version. Therefore when the development version rolls we make sure that the patch number is one higher than the corresponding integration
# patch number and we add the date postfix.
# When the integration build happens, all that is necessary is to take the major, minor, patch part of the corresponding
# development version i.e. drop the date postfix. When the nightly build next runs it will roll the patch number and the date.

# This routine will update the version and buildDate fields in the app element identified by the app reference and server params
# in the deployment collection of the appProductionStatus mongo database on mats.gsd.esrl.noaa.gov,
# according to the deployment_environment settings for the given server.
# if deployment_environment is development, the date portion of the semver is modified and it is set to the current time stamp.
# If the current patch number is not greater than the corresponding integration version then the patch number is also incremented.
#PARAMETERS: app reference, server
#RETURNS: modified versions
#TRANSFORMATION: new versions for one or more servers for specified app
rollDevelopmentVersionAndDateForAppForServer() {
	if [ $# -ne 2 ]; then
		echo $0 - wrong number of params - usage: $0 app server
		return 1
	fi
	local app=$1
	local server=$2
	# double check that the environment for this server really is development
	local deployment_environment=$(getDeploymentEnvironmentForServer ${server})
	if [ "${deployment_environment}" != "development" ]; then
		echo "wrong environment - should be development, is  ${deployment_environment}"
		return 1
	fi
	# get the current build version 
	local currentVersion=$(getVersionForAppForServer ${app} ${server})
	local currentVersionPart=$(echo $currentVersion | cut -f1 -d'-')
	local major=$(echo "${currentVersionPart}" | cut -d'.' -f1)
	local minor=$(echo "${currentVersionPart}" | cut -d'.' -f2)
	local patch=$(echo "${currentVersionPart}" | cut -d'.' -f3)

	# get the corresponding integration version...
	local integrationServer=$(getIntegrationServer)
	local currentIntVersion=$(getVersionForAppForServer ${app} ${integrationServer})
        local intPatch=$(echo "${currentIntVersion}" | cut -d'.' -f3)
	if [ ${intPatch} -ge ${patch} ]; then
		patch=$((intPatch + 1))
	fi
	# build versions roll date... change the date portion to be current
	local vdate=`date +%Y.%m.%d.%H.%M`
	local newVersion="${major}.${minor}.${patch}-${vdate}"
	#update the new version
	updateVersionForAppForServer ${newVersion} ${app} ${server}
	updateBuildDateForAppForServer ${vdate} ${app} ${server}
}

# This routine updates the version and buildDate fields in the app element identified by the app reference and server params in the deployment collection of the appProductionStatus
# mongo database on mats.gsd.esrl.noaa.gov according to the deployment_environment settings for the given server.
# When the integration build happens, all that is necessary is to take the major, minor, patch part of the corresponding
# development version i.e. drop the date postfix. When the nightly build next runs it will roll the minor number.
#PARAMETERS: app reference, server
#RETURNS: modified versions
#TRANSFORMATION: new versions for one or more servers for specified app
rollIntegrationVersionAndDateForAppForServer() {
	if [ $# -ne 2 ]; then
		echo $0 - wrong number of params - usage: $0 app server
		return 1
	fi
	local app=$1
	local server=$2
	# double check that the environment for this server really is integration
	local deployment_environment=$(getDeploymentEnvironmentForServer ${server})
	if [ "${deployment_environment}" != "integration" ]; then
		echo "wrong environment - should be integration, is  ${deployment_environment}"
		return 1
	fi
	local developmentServer=$(getDevelopmentServer)
        local currentDevVersion=$(getVersionForAppForServer ${app} ${developmentServer})
        local currentDevVersionPart=$(echo ${currentDevVersion} | cut -f1 -d'-')
	local intDate=$(date +%Y.%m.%d.%H.%M)
	local newIntegrationVersion="${currentDevVersionPart}"
	updateVersionForAppForServer ${newIntegrationVersion} ${app} ${server}
	updateBuildDateForAppForServer ${intDate} ${app} ${server}
}

#This routine exports each collection to a set of files that are named after each collection, with a .json suffix.
# e.g.   "buildConfiguration.json", "deployment.json",
#PARAMETERS: output directory - optional (if not supplied the root of the git repo/appProductionStatusCollections directory is used)
#RETURNS: success or error message
#TRANSFORMATION: records the mongo export of the collections to a set of files in a given directory.
exportCollections() {
	local directory
	if [ $# -eq 1 ]; then
	    directory=$1
	else
	    directory=$(git rev-parse --show-toplevel)/appProductionStatusCollections
	fi

    mkdir -p ${directory}
    openTunnel
    unset data
    local data=$(mongo  localhost:27020/appProductionStatus --quiet --eval "db.getCollectionNames()" | sed 's/[]["]//g' )
	IFS=', ' read -r -a collections <<< "$data"
    for collection in "${collections[@]}"; do
		mongoexport --port 27020 -d appProductionStatus -c ${collection}  | jq -r -M '.' > "${directory}/${collection}.json"
    done
    closeTunnel
}

# This routine duplicates a collection of the appProductionStatus
# mongo database on mats.gsd.esrl.noaa.gov
#PARAMETERS: existing collection, new collection name
#RETURNS: success or an error message
#TRANSFORMATION: makes a copy of the specified collection to the new name.
duplicateCollection() {
	if [ $# -ne 2 ]; then
		echo $0 - wrong number of params - usage: $0 collection copyName
		return 1
	fi
	local collection=$1
	local newCollection=$2
	openTunnel
	unset data
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODduplicateCollection
		db.getCollection("${collection}").copyTo("${newCollection}");
	%EODduplicateCollection
	)
	closeTunnel
}

# This routine deletes a collection of the appProductionStatus
# mongo database on mats.gsd.esrl.noaa.gov
#PARAMETERS: existing collection
#RETURNS: success or an error message
#TRANSFORMATION: deletes (drops) a collection
dropCollection() {
	if [ $# -ne 1 ]; then
		echo $0 - wrong number of params - usage: $0 collection
		return 1
	fi
	local collection=$1
	openTunnel
	local data=$(mongo  --port 27020 --quiet appProductionStatus <<-%EODdropCollection
		db.getCollection("${collection}").drop();
	%EODdropCollection
	)
	closeTunnel
}

test () {
	DEPLOYMENTCOLLECTION="deployment-test"
	duplicateCollection deployment ${DEPLOYMENTCOLLECTION}
	host=$1
	echo ---------
	unset SERVER
	unset DEPLOYMENT_ENVIRONMENT
	declare pattern
	declare prodEnv
	case "$host" in
        mats.gsd.esrl.noaa.gov)
		pattern="^[0-9]+\.[0-9]+\.[0-9]+$"
		prodEnv="production"
            ;;
        mats-int.gsd.esrl.noaa.gov)
		pattern="^[0-9]+\.[0-9]+\.[0-9]+$"
		prodEnv="integration"
           ;;
        *)
		pattern="^[0-9]+\.[0-9]+\.[0-9]+-[0-9]{4}\.[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]{2}$"
		prodEnv="development"
	   ;;
	esac

	echo setBuildConfigVarsForDevelopmentServer
	setBuildConfigVarsForDevelopmentServer
	if [ "$SERVER" == "mats-dev.gsd.esrl.noaa.gov" ]; then
		echo -e setBuildConfigVarsDevelopmentForServer ${passed}
	else
		echo -e setBuildConfigVarsForServer ${failed}
		echo -e $SERVER does not equal ${host}
	fi
	
	if [ "$DEPLOYMENT_ENVIRONMENT" == "development" ]; then
		echo -e setBuildConfigVarsForDevelopmentServer ${passed}
	else
		echo -e setBuildConfigVarsForDevelopmentServer ${failed}
		echo -e $DEPLOYMENT_ENVIRONMENT does not equal "development"
	fi


    echo setBuildConfigVarsForIntegrationServer
    setBuildConfigVarsForIntegrationServer
    if [ "$SERVER" == "mats-int.gsd.esrl.noaa.gov" ]; then
        echo -e setBuildConfigVarsForIntegrationServer ${passed}
    else
        echo -e setBuildConfigVarsForServer ${failed}
        echo $SERVER does not equal ${host}
    fi

    if [ "$DEPLOYMENT_ENVIRONMENT" == "integration" ]; then
        echo -e setBuildConfigVarsForIntegrationServer ${passed}
    else
        echo -e setBuildConfigVarsForIntegrationServer ${failed}
        echo -e $DEPLOYMENT_ENVIRONMENT does not equal "integration"
    fi


    echo setBuildConfigVarsForProductionServer
    setBuildConfigVarsForProductionServer
    if [ "$SERVER" == "mats.gsd.esrl.noaa.gov" ]; then
        echo -e setBuildConfigVarsForProductionServer ${passed}
    else
        echo -e setBuildConfigVarsForProductionServer ${failed}
        echo -e $SERVER does not equal ${host}
    fi

    if [ "$DEPLOYMENT_ENVIRONMENT" == "production" ]; then
        echo -e setBuildConfigVarsForProductionServer ${passed}
    else
        echo -e setBuildConfigVarsForProductionServer ${failed}
        echo -e $DEPLOYMENT_ENVIRONMENT does not equal "production"
    fi


	echo -e ---------
	echo -e setAppDeploymentVarsForServer
	unset APPS
	unset VERSIONS
	setAppDeploymentVarsForServer ${host}
	if [ "${APPS[0]}" == "upperair" ]; then
		echo -e setAppDeploymentVarsForServer ${passed}
	else
		echo -e setAppDeploymentVarsForServer ${failed}
		echo -e "${APPS[0]}" does not equal "upperair"
        fi
		
	if [ "${APPS[1]}" == "anomalycor" ]; then
		echo -e setAppDeploymentVarsForServer ${passed}
	else
		echo -e setAppDeploymentVarsForServer ${failed}
		echo -e "${APPS[1]}" does not equal "anomalycor"
        fi
	
	if [[ "${VERSIONS[0]}" =~ ${pattern} ]]; then
		echo -e setAppDeploymentVarsForServer ${passed}
	else
		echo -e setAppDeploymentVarsForServer ${failed}
		echo -e "${VERSIONS[0]}" does not match "digit.digit.digit"
        fi
	
	echo -e ---------
	echo -e getBuildableAppsForServer
	unset appList
	appList=($(getBuildableAppsForServer mats-dev.gsd.esrl.noaa.gov))
	diff=()
	declare -a expectedApps='([0]="upperair" [1]="anomalycor" [2]="ceiling" [3]="visibility" [4]="surface" [5]="precipitation" [6]="radarReflectivity" [7]="wfip2")'
	for i in "${appList[@]}"; do
	    skip=
	    for j in "${expectedApps[@]}"; do
		[[ $i == $j ]] && { skip=1; break; }
	    done
	    [[ -n $skip ]] || diff+=("$i")
	done
	if [ ${#diff[@]} -eq 0 ]; then
		echo -e getBuildableAppsForServer ${passed}
	else
		echo -e getBuildableAppsForServer ${failed}
		echo -e found ${appList[@]} 
		echo -e expec ${expectedApps[@]} 
	fi

	echo -e -----
	unset appList
	appList=($(getBuildableAppsForServer mats-int.gsd.esrl.noaa.gov))
	diff=()
	declare -a expectedApps='([0]="upperair" [1]="anomalycor" [2]="ceiling" [3]="visibility" [4]="surface" [5]="precipitation" [6]="radarReflectivity" [7]="wfip2")'
	for i in "${appList[@]}"; do
	    skip=
	    for j in "${expectedApps[@]}"; do
		[[ $i == $j ]] && { skip=1; break; }
	    done
	    [[ -n $skip ]] || diff+=("$i")
	done
	if [ ${#diff[@]} -eq 0 ]; then
		echo -e getBuildableAppsForServer ${passed}
	else
		echo -e getBuildableAppsForServer ${failed}
		echo -e found ${appList[@]} 
		echo -e expec ${expectedApps[@]} 
	fi

	echo -e -----
	unset appList
	appList=($(getBuildableAppsForServer mats.gsd.esrl.noaa.gov))
	diff=()
	declare -a expectedApps='([0]="upperair" [1]="anomalycor" [2]="ceiling" [3]="visibility" [4]="surface" [5]="precipitation" [6]="radarReflectivity" [7]="wfip2")'
	for i in "${appList[@]}"; do
	    skip=
	    for j in "${expectedApps[@]}"; do
		[[ $i == $j ]] && { skip=1; break; }
	    done
	    [[ -n $skip ]] || diff+=("$i")
	done
	if [ ${#diff[@]} -eq 0 ]; then
		echo -e getBuildableAppsForServer mats.gsd.esrl.noaa.gov ${passed}
	else
		echo -e getBuildableAppsForServer mats.gsd.esrl.noaa.gov ${failed}
		echo -e found ${appList[@]} 
		echo -e expec ${expectedApps[@]} 
	fi

	echo -e ---------
	local ceilingCurrentVersion=$(getVersionForAppForServer ceiling mats.gsd.esrl.noaa.gov)
	updateVersionForAppForServer "1.5.20-2017.09.26.16.16-test" ceiling mats.gsd.esrl.noaa.gov
	local ceilingNewVersion=$(getVersionForAppForServer ceiling mats.gsd.esrl.noaa.gov)
	if [ "1.5.20-2017.09.26.16.16-test" == "$ceilingNewVersion" ]; then
		echo -e updateVersionForAppForServer mats.gsd.esrl.noaa.gov ${passed}
	else
		echo -e updateVersionForAppForServer mats.gsd.esrl.noaa.gov ${failed}
		echo -e old version is ${ceilingCurrentVersion}
		echo -e new version is ${ceilingNewVersion}
		echo -e new version should be "1.5.20-2017.09.26.16.16-test"
	fi

	updateVersionForAppForServer $ceilingCurrentVersion ceiling mats.gsd.esrl.noaa.gov
	local ceilingNewNewVersion=$(getVersionForAppForServer ceiling mats.gsd.esrl.noaa.gov)
	if [ "$ceilingCurrentVersion" == "$ceilingNewNewVersion" ]; then
		echo -e updateVersionForAppForServer version_reset mats.gsd.esrl.noaa.gov ${passed}
	else
		echo -e updatupdatupdatupdateeeesetVersionForAppForServer version_reset mats.gsd.esrl.noaa.gov ${failed}
		echo -e old version is ${ceilingNewVersion}
		echo -e new version is ${ceilingNewNewVersion}
		echo -e new version should be "$ceilingCurrentVersion"
	fi

	echo -e ---------
	local ceilingCurrentBuildDate=$(getBuildDateForAppForServer ceiling mats.gsd.esrl.noaa.gov)
	updateBuildDateForAppForServer "at the moment" ceiling mats.gsd.esrl.noaa.gov
	local ceilingNewBuildDate=$(getBuildDateForAppForServer ceiling mats.gsd.esrl.noaa.gov)
	if [ "at the moment" == "$ceilingNewBuildDate" ]; then
		echo -e updateBuildDateForAppForServer mats.gsd.esrl.noaa.gov ${passed}
	else
		echo -e updateBuildDateForAppForServer mats.gsd.esrl.noaa.gov ${failed}
		echo -e old buildDate is ${ceilingCurrentBuildDate}
		echo -e new buildDate is ${ceilingNewBuildDate}
		echo -e new buildDate should be "at the moment"
	fi

    echo -e ---------
	updateBuildDateForAppForServer $ceilingCurrentBuildDate ceiling mats.gsd.esrl.noaa.gov
	local ceilingNewNewBuildDate=$(getBuildDateForAppForServer ceiling mats.gsd.esrl.noaa.gov)
	if [ "$ceilingCurrentBuildDate" == "$ceilingNewNewBuildDate" ]; then
		echo -e updateBuildDateForAppForServer buildDate reset mats.gsd.esrl.noaa.gov ${passed}
	else
		echo -e updateBuildDateForAppForServer buildDate reset mats.gsd.esrl.noaa.gov ${failed}
		echo -e old buildDate is ${ceilingNewBuildDate}
		echo -e new buildDate is ${ceilingNewNewBuildDate}
		echo -e new buildDate should be "$ceilingCurrentBuildDate"
	fi

	echo -e ---------
    local productionServer=$(getProductionServer)
    if [ ${productionServer} == "mats.gsd.esrl.noaa.gov" ]; then
        echo -e getProductionServer ${passed}
    else
        echo -e getProductionServer ${failed} ${productionServer} is not "mats.gsd.esrl.noaa.gov"
    fi

    echo ---------
    local integrationServer=$(getIntegrationServer)
    if [ ${integrationServer} == "mats-int.gsd.esrl.noaa.gov" ]; then
        echo -e getIntegrationServer ${passed}
    else
        echo -e getIntegrationServer ${failed} ${integrationServer} is not "mats-int.gsd.esrl.noaa.gov"
    fi

    echo ---------
    local developmentServer=$(getDevelopmentServer)
    if [ ${developmentServer} == "mats-dev.gsd.esrl.noaa.gov" ]; then
        echo -e getDevelopmentServer ${passed}
    else
        echo -e getDevelopmentServer ${failed} ${developmentServer} is not "mats-dev.gsd.esrl.noaa.gov"
    fi

    echo ---------
    # With this test the first instance will be a copy of the deployment collection
    # so we will see a difference in the build dates between dev and int
    # but the build dates resolution is one minute so subsequent rolling operations actually
    # end up with the same build date.
    echo rollDevelopmentVersionAndDateForAppForServer
    local currentDevVersion=$(getVersionForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    local currentDevVersionPart=$(echo -e ${currentDevVersion} | cut -f1 -d'-')
    local currentDevBuildDate=$(getBuildDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    local currentIntVersion=$(getVersionForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    local currentIntBuildDate=$(getBuildDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    rollDevelopmentVersionAndDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov
    local buildVer=$(getVersionForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    local buildVersionPart=$(echo ${buildVer} | cut -f1 -d'-')
    local buildDate=$(getBuildDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    local intVer=$(getVersionForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    local intDate=$(getBuildDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    echo -e "dev cur ${currentDevVersion}\t\t${currentDevBuildDate}\t\t\t\tnew ${buildVer}\t\t${buildDate}"
    echo -e "int cur ${currentIntVersion}\t\t\t\t${currentIntBuildDate}\t\t\t\tnew ${intVer}\t\t\t\t${intDate}"
    if [ "${currentIntBuildDate}" != "${intDate}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial IntBuildDate ${currentIntBuildDate} and new intDate ${intDate} should be the same
    fi
    if [ "${currentDevBuildDate}" == "${buildDate}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial DevBuildDate ${currentDevBuildDate} and new buildDate ${buildDate} should NOT be the same
    fi
    if [ "${buildVersionPart}" == "${intVer}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} final build version part ${currentDevVersionPart} and int version ${intVer} should NOT be the SAME
    fi
    if [ "${currentIntVersion}" != "${intVer}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial int version ${currentIntVersion}  and new int version ${intVer} should be the SAME
    fi


    echo ---------
    echo rollIntegrationVersionAndDateForAppForServer
    currentDevVersion=$(getVersionForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    currentDevVersionPart=$(echo ${currentDevVersion} | cut -f1 -d'-')
    currentDevBuildDate=$(getBuildDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    currentIntVersion=$(getVersionForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    currentIntBuildDate=$(getBuildDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    rollIntegrationVersionAndDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov
    buildVer=$(getVersionForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    buildVersionPart=$(echo ${buildVer} | cut -f1 -d'-')
    buildDate=$(getBuildDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    intVer=$(getVersionForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    intDate=$(getBuildDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    echo -e "dev cur ${currentDevVersion}\t\t${currentDevBuildDate}\t\t\t\tnew ${buildVer}\t\t${buildDate}"
    echo -e "int cur ${currentIntVersion}\t\t\t\t${currentIntBuildDate}\t\t\t\tnew ${intVer}\t\t\t\t${intDate}"
    if [ "${currentDevVersion}" != "${buildVer}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial dev version ${currentDevVersion} and new build version ${buildVer} should be the same
    fi
    if [ "${currentDevBuildDate}" != "${buildDate}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial build date ${currentDevBuildDate} and new build date ${buildDate} should be the same
    fi
    if [ "${currentIntVersion}" == "${intVer}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial int version ${currentIntVersion}  and new int version ${intVer} should NOT be the SAME
    fi
    if [ "${currentIntBuildDate}" == "${intDate}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial int date ${currentIntBuildDate} and new int date ${intDate} should be the SAME
    fi



    echo ------------
    echo rollDevelopmentVersionAndDateForAppForServer again
    currentDevVersion=$(getVersionForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    currentDevBuildDate=$(getBuildDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    currentIntVersion=$(getVersionForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    currentIntBuildDate=$(getBuildDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    currentDevVersionPart=$(echo ${currentDevVersion} | cut -f1 -d'-')
    rollDevelopmentVersionAndDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov
    buildVer=$(getVersionForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    buildVersionPart=$(echo ${buildVer} | cut -f1 -d'-')
    buildDate=$(getBuildDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    intVer=$(getVersionForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    intDate=$(getBuildDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    echo -e "dev cur ${currentDevVersion}\t\t${currentDevBuildDate}\t\t\t\tnew ${buildVer}\t\t${buildDate}"
    echo -e "int cur ${currentIntVersion}\t\t\t\t${currentIntBuildDate}\t\t\t\tnew ${intVer}\t\t\t\t${intDate}"
    if [ "${currentDevVersionPart}" != "${intVer}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial build version part ${currentDevVersionPart} and new int version ${intVer} should be the SAME
    fi
    if [ "${currentIntVersion}" != "${intVer}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial int version ${currentIntVersion}  and new int version ${intVer} should be the SAME
    fi

    echo -e ------------
    echo rollIntegrationVersionAndDateForAppForServer again
    currentDevVersion=$(getVersionForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    currentDevBuildDate=$(getBuildDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    currentIntVersion=$(getVersionForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    currentIntBuildDate=$(getBuildDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    currentDevVersionPart=$(echo ${currentDevVersion} | cut -f1 -d'-')
    rollIntegrationVersionAndDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov
    buildVer=$(getVersionForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    buildVersionPart=$(echo ${buildVer} | cut -f1 -d'-')
    buildDate=$(getBuildDateForAppForServer ceiling mats-dev.gsd.esrl.noaa.gov)
    intVer=$(getVersionForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    intDate=$(getBuildDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    intVer=$(getVersionForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    intDate=$(getBuildDateForAppForServer ceiling mats-int.gsd.esrl.noaa.gov)
    echo -e "dev cur ${currentDevVersion}\t\t${currentDevBuildDate}\t\t\t\tnew ${buildVer}\t\t${buildDate}"
    echo -e "int cur ${currentIntVersion}\t\t\t\t${currentIntBuildDate}\t\t\t\tnew ${intVer}\t\t\t\t${intDate}"
    if [ "${currentIntVersion}" == "${intVer}" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial int version ${currentIntVersion}  and new int version ${intVer} should NOT be the SAME
    fi
    local initialIntVersionPatch=$(echo ${currentIntVersion} | cut -f3 -d'.')
    local newIntVersionPatch=$(echo ${intVer} | cut -f3 -d'.')
    if [ "${initialIntVersionPatch}" != "$((${newIntVersionPatch} - 1))" ]; then
        echo -e rollDevelopmentVersionAndDateForAppForServer ${failed} initial int version patch ${initialIntVersionPatch}  SHOULD be new intVersionPatch less 1, it is ${newIntVersionPatch}
    fi

	echo ---------
	echo getPublishableApps enable/disable
	firstPublishableApps=($(getPublishableApps))
    firstLength=${#firstPublishableApps[@]}
    firstApp=${firstPublishableApps[0]}
	disablePublicationStatusForApp ${firstApp}
	secondPublishableApps=($(getPublishableApps))
	if [ ${firstLength} -eq 0 ]; then
		echo -e getPublishableApps ${failed} no publishable apps
	fi
	secondLength=${#firstPublishableApps[@]}
	secondApp=${firstPublishableApps[0]}
    if [ "${firstApp}" == "${secondApp}" ]; then
		echo -e getPublishableApps ${failed} first app is still ${firstApp} after being disabled
	fi
	if [ ${firstLength} -ne ${secondLength} -1 ]; then
		echo -e getPublishableApps ${failed} number of apps should be one less after diabling one
	fi
	enablePublicationStatusForApp ${firstApp}
	secondPublishableApps=($(getPublishableApps))
	secondLength=${#firstPublishableApps[@]}
	secondApp=${firstPublishableApps[0]}
	if [ ${firstLength} -ne ${secondLength} ]; then
		echo -e getPublishableApps ${failed} number of apps should be the same after re-enabling the disabled one
	fi

	if [ "${firstApp}" != "${secondApp}" ]; then
		echo -e getPublishableApps ${failed} first app is not ${firstApp} after being re-enabled
	fi

    echo ---------

    echo exportCollections /tmp/tmpCollections
    rm -rf /tmp/exportCollections
    mkdir /tmp/exportCollections
    exportCollections /tmp/tmpCollections
    ls -ltr /tmp/tmpCollections
    echo ---------

	# drop test collection and repoint the deploymentcollection
	dropCollection ${DEPLOYMENTCOLLECTION}
	DEPLOYMENTCOLLECTION="deployment"

}

if [[ "$1" == "test" ]];then
	if [ $# -ne 2 ]; then
		echo $0 - wrong number of params - usage: $0 test host
		return 1
	fi

	host=$2
	test ${host}
fi

